<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">


    <link rel="icon" type="image/png" sizes="32x32" href="./images/icon-32x32.png">
    <link rel="icon" type="image/png" sizes="192x192" href="./images/icon-192x192.png">
    <link rel="apple-touch-icon" sizes="180x180" href="./images/apple-touch-icon.png">
    <link rel="shortcut icon" href="./images/favicon.ico">


    <link rel="manifest" href="./manifest.json">


    <script src="./uPlot.iife.min.js"></script> <!-- Add uPlot JavaScript -->
    <link rel="stylesheet" href="./uPlot.min.css"> <!-- Add uPlot CSS for styling -->

    <!-- Add XLSX (MS Excel) JavaScript -->
    <script src="./xlsx.full.min.js"></script>


    <title>Moira Control - Thymos</title>
    <style>
        :root {
            --blue-color: #007bff;
            --blue-light-color: #4CA2FF;
            --green-color: #28a745;
            --green-light-color: #68C17C;
            --red-color: #dc3545;
            --red-light-color: #E6717C;
            --orange-color: #ffc107;
            --cyan-color: #17a2b8;
            --light-color: #f8f9fa;
            --gray-color: #6c757d;
            --dark-color: #343a40;
        }

        /* General styling for the body */
        body {
            font-family: Arial, sans-serif;
            height: 100%;
            width: 98%;
        }

        /* Button styling for spacing and cursor behavior */
        button {
            padding: 5px;
            cursor: pointer;
            border-radius: 10px;
            border: 1px solid darkgray;
            font-size: 14px;
        }

        /* Styling for textAreas used for user input */
        textarea {
            resize: none; /* Disables resizing */
            overflow: auto;
            font-size: 16px;
            font-family: monospace;
        }

        /* Disabled elements styling */
        .disabled {
            cursor: not-allowed;
            opacity: 0.5;
            user-select: none; /* Disables text selection */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            pointer-events: none; /* Prevents interaction */
        }

        #settingContainer {
            display: grid;
            grid-template-columns: 1fr; /* One column */
            width: 95%;
            padding: 0 15px 15px;
            justify-self: center;
            justify-content: center;
            overflow: hidden;
            max-height: 0;
            opacity: 0;
            transition: max-height 0.5s ease, opacity 0.45s; /* Animation */
        }

        #experimentSettingsContainer {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(470px, 1fr)); /* Dynamic grid */
            gap: 10px; /* Space between inputs */
            /*justify-self: center;*/
            overflow: hidden;
            width: 100%;
        }


        #machineSettingsContainer {
            display: flex;
            gap: 10px; /* Space between inputs */
            justify-self: center;
            justify-content: center;
            overflow: hidden;
            width: 100%;
        }

        #appSettingsContainer {
            display: flex;
            gap: 10px; /* Space between inputs */
            justify-self: center;
            justify-content: center;
            overflow: hidden;
            width: 100%;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 10px; /* Space between inputs and labels */
            white-space: nowrap; /* Prevents wrapping */

        }

        .input-group label {
            flex-shrink: 0; /* Prevents shrinking */
            text-align: right;
            width: max-content; /* Label width */
            min-width: 250px;
        }

        .input-group input {
            height: 25px;
        }

        .input-group input[type="number"] {
            flex-grow: 1; /* Input will grow if there is space */
            justify-self: left;
            max-width: 220px;
        }

        input[type="checkbox"] {
            transform: scale(1.5); /* Scale the checkbox to 1.5 */
            margin: 5px; /* Space around the checkbox */
        }

        h3 {
            margin-top: 20px;
            margin-bottom: 5px;
            align-self: flex-start;
        }

        h4 {
            margin-top: 5px;
            margin-bottom: 5px;
        }


        hr {
            width: 100%;
            margin: 20px auto;
            border: 1px solid gray;
        }

    </style>
</head>

<body>

<div style="display: flex; flex-direction: row; align-items: center; gap: 10px; margin-top: 20px; margin-left: 20px;">
    <img src="./images/icon-192x192.png" alt="thymos" style="width: 50px; height: 50px;">
    <h2>THYMOS - Moira controller</h2>
</div>

<div style="gap: 5px; display: flex; justify-content: center; align-items: center; flex-direction: column;">
    <!-- USB Connection Section -->
    <div id="usbContainer"
         style="display: flex; flex-direction: row; align-items: center; justify-content: center; gap: 10px; ">

        <button id="connectBtnUSB" style=" padding: 5px; height: 45px; width: 160px;">üîå Connect via USB</button>
        <label for="inputNumBaudRate" class="disabled">Baud-Rate:</label>
        <input data-inputType="intInput" type="number" id="inputNumBaudRate" placeholder="Baud-Rate"
               value="921600" min="1" data-type="int" class="disabled"
               style="width: 148px; height: 33px;  border-radius: 10px; padding: 5px; border: 1px solid darkgray; background: #f0f0f0; text-align: center;">

    </div>
    <div id="connectionStatus" style="font-weight: bold; color: gray;">
        üî¥ Disconnected
    </div>
</div>

<!-- Graph Display Section -->

<div style="display: flex; flex-direction: column; margin-top: 50px; align-items: center; width: 95%; justify-self: center;">
    <h3>üìà Graphs:</h3>
    <div style="display: flex; gap: 10px;">
        <button id="toggleLive"
                style="display: flex; min-width: 100px; height: 50px; padding: 20px; align-items: center; justify-content: center;">
            ‚ñ∂Ô∏è Activate Charts
        </button>
        <button style="display: flex; height: 50px; min-width: 100px; padding: 20px;align-items: center; justify-content: center;"
                onclick="clearCharts()">üßπ Clear Charts
        </button>
        <button style="display: flex; height: 50px; min-width: 100px; padding: 20px;align-items: center; justify-content: center;"
                onclick="refreshCharts()">üîÑ Refresh Charts
        </button>
    </div>
    <div style="display: flex; justify-content: space-between; width: 100%; height: 400px; margin-top: 10px; background: #f5f5f5; border-radius: 10px; border: 1px solid lightgrey;"
         id="chartsContainer">
        <div id="timeChart" style="width: 49%; height: 400px;"></div>
        <div id="distanceChart" style="width: 49%;height: 400px;"></div>

    </div>
</div>

<!-- Progress Bar -->
<div style="display: flex; flex-direction: column; width: 100%; gap: 10px; align-items: center; justify-content: center; margin-top: 20px;">
    <div style="display: flex; flex-direction: row; width: 100%; gap: 10px; align-items: center; justify-content: center;">
        <!-- Start Experiment Button -->
        <button id="startExperiment"
                style="display: flex; height: 50px; min-width: 100px; width: 170px; max-width: 200px; padding: 20px; align-items: center; justify-content: center; background: lightblue;">
            ‚ö° Start Experiment
        </button>

        <!-- Stop Experiment Button -->
        <button id="stopExperiment"
                style="display: flex; height: 50px; min-width: 100px; width: 170px; max-width: 200px; padding: 20px; align-items: center; justify-content: center; background: lightpink;">
            üõë Stop Experiment
        </button>

        <!-- Return to original position Button -->
        <button id="returnPositionExperimentBtn" onclick="moveToOriginalPosition()"
                style="display: flex; height: 50px; min-width: 100px; width: 170px; max-width: 200px; padding: 20px; align-items: center; justify-content: center; background: lightgrey;">
            ‚Ü©Ô∏è Return to original position
        </button>

        <!-- Automatic returning to original position Checnkmark -->
        <label for="autoReturnPositionExperiment">‚ÜïÔ∏è Auto-return to original position:</label>
        <input type="checkbox" id="autoReturnPositionExperiment"
               style="display: flex; height: 50px; padding: 20px; align-items: center; justify-content: center;">
    </div>

    <!-- Experiment Progress -->
    <div style="display: flex; align-items: center; gap: 10px; flex-grow: 1;  width: 100%; max-width: 650px; min-width: 50px; ">
        <label for="experimentProgress">Experiment Progress:</label>
        <progress id="experimentProgress" value="0" max="100"
                  style="flex-grow: 1; max-width: 450px; min-width: 50px; height: 20px;"></progress>
    </div>
</div>


<div style="display: flex; flex-direction: column; padding: 5px; gap: 10px; left: 0; justify-self: center;align-items: center;">
    <h3 style="position: relative;">üìù Experiment options:</h3>
    <div style="display: flex; flex-direction: row; gap: 10px;">
        <div style="display: grid; grid-template-columns: auto 1fr; max-width: 1220px; min-width: 300px; width: calc(100vw - 200px); gap: 10px; justify-items: left;">

            <label for="experimentType" style="">üß™ Experiment Name: </label>
            <input type="text" id="experimentType" placeholder="Experiment name (mandatory) ..."
                   style="width: calc(100% - 20px); height: 24px; padding: 10px; border: none; background: lightgray; border-radius: 10px;">
            <label for="experimentDesc">üìÑ Experiment description: </label>
            <input id="experimentDesc" placeholder="Short description of the experiment (optional)..."
                   style="width: calc(100% - 20px); height: 32px; padding: 10px; border: none; background: lightgray; border-radius: 10px;">
            <label for="storagePath">üìÅ Handpick the folder: </label>
            <div><input type="checkbox" id="storagePath" onchange="toggleDirectorySelector()"> (Default folder:
                Downloads)
            </div>
        </div>


        <div style="display: flex; flex-direction: column; gap: 10px;">

            <button id="saveData" style="width: 150px; height: 44px;">üíæ Save single CSV</button>
            <button id="convertCSV" onclick="convertCSVtoXLSX()" style="width: 150px; height: 52px;">
                üìä Convert CSV files to XLSX (MATTES)
            </button>

        </div>
    </div>

    <!-- Experiment Parameter Inputs -->
    <h3 style="position: relative;">‚öôÔ∏è Settings:</h3>
    <div style="position: relative; display: flex; align-items: flex-start; width: 100%; background: lightgray; border-radius: 10px; border: 1px solid darkgray">
        <button id="openSettingsContainer" style="padding: 10px;">üîΩ</button>
        <div id="settingContainer">


            <h4 style="position: relative;">üõ†Ô∏è Loading settings:</h4>
            <div style="position: relative; display: flex; align-items: flex-start; gap: 10px;">
                <div id="experimentSettingsContainer">
                    <div class="input-group">
                        <label for="inputDistance">Distance (mm): </label>
                        <input data-inputType="floatInput" type="number" id="inputDistance" value="20" min="0.00001"
                               step="any"
                               max="100000000">
                    </div>

                    <div class="input-group">
                        <label for="experimentDirectionDropdown" class="disabled">Direction: </label>
                        <select id="experimentDirectionDropdown" class="disabled"
                                style="width: 227.2px; height: 30.2px;">
                            <option value="Option-DOWN">‚ÄáDOWN‚Äá‚è¨‚Äá</option>
                            <option value="Option-UP">‚ÄáUP‚Äá‚Äá‚Äá‚Äá‚è´‚Äá</option>
                        </select>
                    </div>


                    <div class="input-group">
                        <label for="inputLoadLimitDropPercent">Force drop limit (%): </label>
                        <input data-inputType="floatInput" type="number" id="inputLoadLimitDropPercent" value="30"
                               min="0"
                               max="100">
                    </div>


                    <div class="input-group">
                        <label for="inputTakePhotos">Take photos: </label>
                        <input type="checkbox" id="inputTakePhotos">
                        <label for="inputPhotoInterval" style="min-width: max-content;">Photo Interval (s): </label>
                        <input class="disabled" data-inputType="floatInput" type="number" id="inputPhotoInterval"
                               style="max-width: 50px;"
                               value="1"
                               min="0.00001" step="any"
                               max="100000000">
                    </div>


                    <div class="input-group">
                        <label for="inputLoadLimitDropValue">Force drop limit (N): </label>
                        <input data-inputType="floatInput" type="number" id="inputLoadLimitDropValue" value="5" min="0"
                               step="any"
                               max="100000000">
                    </div>


                    <div class="input-group">
                        <label for="inputSpeedForward">Speed Forward (mm/s): </label>
                        <input data-inputType="floatInput" type="number" id="inputSpeedForward" value="1" min="0.00001"
                               step="any"
                               max="100000000">
                    </div>

                    <div class="input-group">
                        <label for="inputDataInterval">Data Interval (¬µs): </label>
                        <input data-inputType="floatInput" type="number" id="inputDataInterval" value="20000"
                               min="15000"
                               step="any"
                               max="100000000">
                    </div>

                    <div class="input-group">
                        <label for="inputSpeedBackward" class="disabled">Speed Backward (mm/s): </label>
                        <input data-inputType="floatInput" type="number" id="inputSpeedBackward" class="disabled"
                               value="25"
                               min="0.00001"
                               step="any"
                               max="100000000">
                    </div>

                </div>
            </div>

            <hr>

            <h4 style="position: relative;">üìü Machine settings:</h4>
            <div style="position: relative; display: flex; align-items: flex-start; gap: 10px;">
                <div id="machineSettingsContainer">

                    <div class="input-group">
                        <label for="inputLoadcellCapacity">Loadcell Capacity (kg): </label>
                        <input data-inputType="floatInput" type="number" id="inputLoadcellCapacity" value="1000"
                               step="any"
                               min="0.00001" max="100000000">
                    </div>

                    <div class="input-group">
                        <label for="inputLoadcellOutput">Loadcell Rated Output (mV/V): </label>
                        <input data-inputType="floatInput" type="number" id="inputLoadcellOutput" value="2.0" step="any"
                               min="0.00001"
                               max="100000000">
                    </div>

                </div>
            </div>

            <hr>

            <h4 style="position: relative;">üïπÔ∏è App settings:</h4>
            <div style="position: relative; display: flex; align-items: flex-start; gap: 10px;">
                <div id="appSettingsContainer">

                    <button id="clearStorageButton" onclick="clearLocalStorage()" style="padding: 20px;">üîÅ Restart app
                    </button>

                </div>
            </div>
        </div>
    </div>


    <!-- Device Output Section -->
    <h3>üìë Device Output:</h3>
    <div style="display: flex; flex-direction: row; gap: 10px;">
        <div style="display: flex; flex-direction: column; gap: 10px;">
        <pre id="regularLog"
             style="max-width: 1200px; min-width: 300px; width: calc(100vw - 200px); height: 200px; background: darkgray; margin: 0; border-radius: 10px; overflow-y: auto; padding: 10px;">
        </pre>

            <pre id="loadingLog"
                 style="max-width: 1200px; min-width: 300px; width: calc(100vw - 200px); height: 80px; background: #323232; border-radius: 10px; padding: 10px;">

            </pre>


        </div>
        <!-- Log Control Buttons -->
        <div style="display: grid; flex-direction: column; justify-content: center; gap: 10px;">
            <button id="toggleScrollBtn" style="width: 150px">üìå Auto-scroll: ON</button>
            <button id="toggleLineLockBtn" onclick="lineLock()" style="width: 150px">üîí Fix Scroll: ON</button>
            <button onclick="clearLog()" style="width: 150px">üóëÔ∏è Clear Log</button>

        </div>
    </div>

    <div style="display: flex; flex-direction: row; gap: 10px; height: 40px;">
        <div>
            <label for="commandInput" style="margin-top: -5px"></label>
            <textarea id="commandInput" placeholder="Enter command..."
                      style="max-width: 1200px; min-width: 300px; width: calc(100vw - 200px); padding: 10px; height: calc(100% - 20px); border: none; background: lightgray; border-radius: 10px; margin-bottom: 50px;"></textarea>
        </div>
        <button id="sendButton" style="width: 150px">üì° Send Command</button>
    </div>

</div>


<script>
    if ('serviceWorker' in navigator) {
        console.log('Service Worker is supported.');
        navigator.serviceWorker.register('service-worker.js').then(function (registration) {
            console.log('Service Worker was registered', registration);
        }).catch(function (error) {
            console.log('Registration failed.', error);
        });
    } else {
        console.log('Service Worker is not supported.');
    }

    self.addEventListener("activate", (event) => {
        console.log("New service worker activated");
        event.waitUntil(self.clients.claim());
    });


    const storageKey = "formData"; // Key in localStorage

    // /////// Log Settings /////////

    isMeasuring = false;// Tracks whether the device is currently measuring
    let isAutoScroll = true;// Enables automatic scrolling of log output
    let isLineLimit = true;// Limits the number of stored log lines
    let isLineLocker = true;// Locks the view at a fixed position when scrolling is disabled
    let logContentMaxLines = 10000;// Maximum number of log lines to keep in memory
    let isScrolledToBottom = true;// Tracks whether the user has scrolled to the bottom of the log
    let logCount = 0; // Counter for received messages
    const logContentLines = []; // Array storing the log content
    let parsedData = {time: NaN, distance: NaN, value: NaN, load: [NaN, NaN, NaN], photoIndex: NaN}; // Last data log


    // /////// Live Data Update and Chart Configuration /////////

    // Live update flag (disabled by default)
    let liveUpdate = false;
    let liveUpdatePaused = false;

    // Maximum number of data points displayed in the charts
    // let maxDataPoints = 1e10000000000000;

    let isReadingSerial = false;


    let dataFormat = null; // Data format for parsing incoming data
    let waitingForDataFormat = false; // Flag for waiting for data format response
    let onDataMatch = null; // Callback function for data matching


    // /////// Experiment Configuration /////////
    let loadLimitDropPercent = 0;
    let loadLimitDropValue = 0;
    let zero_speed_counter = 0;
    let startPosition = 0;
    let experimentEndPosition = 0;

    const cpuDelay = 50; // Delay (ms) to prevent excessive CPU usage

    let isExperimentRunning = false;
    let stopExperiment = false;

    let measureForces = null;
    let takeMeasurements = false;
    let meanForces = [0, 0, 0];


    // /////// UI Elements /////////
    const UI = {
        regularLogContainer: document.getElementById("regularLog"),// Reference to the log display container
        loadingLogContainer: document.getElementById("loadingLog"),// Reference to the loading log display container
        toggleScrollBtn: document.getElementById("toggleScrollBtn"), // Button to toggle automatic scrolling
        lineLockBtn: document.getElementById("toggleLineLockBtn"), // Button to lock the log view
        commandInput: document.getElementById('commandInput'),// Input elements for command entry and settings
        sendButton: document.getElementById('sendButton'),// Input elements for command entry and settings
        chartsLiveButton: document.getElementById('toggleLive'),// Input elements for command entry and settings
        connectionStatus: document.getElementById("connectionStatus"), // Display for connection status
        USB: document.getElementById("connectBtnUSB"), // Button to connect via USB
        progressBar: document.getElementById("experimentProgress"), // Progress bar for experiment status
        timeChartContainer: document.getElementById("timeChart"),
        distanceChartContainer: document.getElementById("distanceChart"),
        chartsContainer: document.getElementById("chartsContainer"),
        autoReturnPosition: document.getElementById("autoReturnPositionExperiment"),
    };

    // Connection status messages and colors
    const connectionStates = {
        connected: {text: "üü¢ Connected", color: "green"},
        reconnecting: {text: "üü† Reconnecting...", color: "orange"},
        disconnected: {text: "üî¥ Disconnected", color: "red"}
    };


    // /////// Event Listeners for UI Buttons /////////
    // These were commented out, but they could be used to attach click events


    document.getElementById("openSettingsContainer").addEventListener("click", function () {
        const container = document.getElementById("settingContainer");

        if (window.getComputedStyle(container).maxHeight === "0px") {
            container.style.maxHeight = container.scrollHeight + "px"; // Open the container and get real height
            container.style.opacity = 1;
            this.textContent = "üîº";
        } else {
            container.style.maxHeight = 0; // Close the container
            container.style.opacity = 0;
            this.textContent = "üîΩ";
        }
    });

    // /////// Auto-scroll Toggle /////////
    UI.toggleScrollBtn.addEventListener("click", () => {
        isAutoScroll = !isAutoScroll;
        UI.toggleScrollBtn.classList.toggle("active", isAutoScroll);
        UI.toggleScrollBtn.textContent = `üìå Auto-scroll: ${isAutoScroll ? "ON" : "OFF"}`;
        if (isAutoScroll) {
            UI.regularLogContainer.scrollTop = UI.regularLogContainer.scrollHeight;
        }

    });


    // Detects manual scrolling by the user
    UI.regularLogContainer.addEventListener("scroll", function () {
        isScrolledToBottom = checkScrolledToBottom();

        if (!isScrolledToBottom) {
            isAutoScroll = false;
            UI.toggleScrollBtn.textContent = "üìå Auto-scroll: OFF";
        } else {
            isAutoScroll = true;
            UI.toggleScrollBtn.textContent = "üìå Auto-scroll: ON";
            isLineLocker = true;
            UI.lineLockBtn.textContent = "üîí Fix Scroll: ON";
            UI.regularLogContainer.scrollTop = UI.regularLogContainer.scrollHeight
        }
        UI.toggleScrollBtn.classList.toggle("active", isAutoScroll);
    });

    // /////// Log Control Functions /////////

    // Toggles whether the log view is locked at a specific position
    function lineLock() {
        isLineLocker = !isLineLocker;
        if (isLineLocker) {
            UI.lineLockBtn.textContent = "üîí Fix Scroll: ON";
        } else {
            UI.lineLockBtn.textContent = "üîì Fix Scroll: OFF";
        }
    }

    // Clears the log completely
    function clearLog() {
        logContentLines.length = 0;
        logCount = 0;
        UI.regularLogContainer.textContent = "";
    }


    // /////// Input Validation and Adjustment /////////

    // Ensures user input is within valid min/max range
    function checkInput(element, valueType) {
        if (!element) return;


        // Validate input: if empty, set to a minimum or 0
        if (element.value.trim() === "") {
            element.value = element.min !== "" ? element.min : 0;
        } else {
            if (valueType === "floatInput") {
                element.value = parseFloat(element.value);
            } else if (valueType === "intInput") {
                element.value = parseInt(element.value, 10);
            }

            // Enforce min/max constraints
            if (element.min && parseFloat(element.value) < parseFloat(element.min)) {
                element.value = element.min;
            }
            if (element.max && parseFloat(element.value) > parseFloat(element.max)) {
                element.value = element.max;
            }
        }

        element.dispatchEvent(new Event("change", {bubbles: true}));
    }

    // Attaches validation checks to numeric inputs
    document.querySelectorAll("input[type=number]").forEach(input => {
        input.addEventListener("blur", () => checkInput(input, input.dataset.inputType));
        input.addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
                checkInput(event.target, event.target.dataset.inputType);
                event.target.blur();
            }
        });
    });


    // /////// Command Input Handling /////////

    // Listens for Enter key in the command input field and sends command
    UI.commandInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
            event.preventDefault();
            sendCommand(UI.commandInput.value.trim());
        }
    });

    // Sends command when clicking the send-button
    UI.sendButton.addEventListener('click', () => {
        if (!serialPort) return;
        sendCommand(UI.commandInput.value.trim());
    });

    // /////// Auto-scroll Detection /////////

    // Checks if the user is scrolled to the bottom of the log
    function checkScrolledToBottom(scrollTop = UI.regularLogContainer.scrollTop, clientHeight = UI.regularLogContainer.clientHeight, scrollHeight = UI.regularLogContainer.scrollHeight) {
        return Math.abs(scrollTop + clientHeight - scrollHeight) < 2;
    }

    function updateConnectionStatus(status, type = null) {
        if (!connectionStates[status]) return;
        UI.connectionStatus.innerHTML = `${connectionStates[status].text} ${type ? `via ${type}` : ""}`;
        UI.connectionStatus.style.color = connectionStates[status].color;
    }


    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////


    // /////// IndexedDB Database Configuration /////////


    const DB_NAME = "SerialPortData";// Database name
    const STORE_NAME = "LastLog";// Store name for saving log entries
    let db;// Database instance

    // /////// Opening IndexedDB /////////

    /**
     * Opens the IndexedDB database and initializes it if needed.
     */
    async function openDB() {
        let request = indexedDB.open(DB_NAME, 1);

        request.onupgradeneeded = function (event) {
            db = event.target.result;

            // Creates a new object store with an auto-incremented key
            db.createObjectStore(STORE_NAME, {keyPath: "id", autoIncrement: true});
            console.log("‚úÖ IndexedDB created");
        };

        request.onsuccess = function (event) {
            db = event.target.result;
            console.log("‚úÖ IndexedDB opened");
            checkExistingLog();
        };
    }

    // /////// Checking for Existing Log Entries /////////

    /**
     * Checks if there are existing log entries in IndexedDB.
     * If logs exist, prompts the user to either save or delete them.
     */
    function checkExistingLog() {
        let transaction = db.transaction(STORE_NAME, "readonly");
        let store = transaction.objectStore(STORE_NAME);
        let request = store.count();

        request.onsuccess = function () {
            loadDataFromDBToChart(false)

            if (request.result > 0) {
                if (confirm("üîÑ Old log exists. Save it or delete?\nOK = Save\nCancel = Delete and create new")) {
                    saveCSV();
                }
            }
        };
    }

    // /////// Clearing the Database Log /////////

    /**
     * Clears all log entries from IndexedDB.
     */
    function clearDBLog() {
        let transaction = db.transaction(STORE_NAME, "readwrite");
        let store = transaction.objectStore(STORE_NAME);
        store.clear().onsuccess = () => console.log("üóëÔ∏è Old log deleted.");
    }

    // /////// Adding Data to the Log /////////

    /**
     * Adds a new data entry to IndexedDB.
     *@param {Object} data - The data object to be stored.
     */
    function addDataToLog(data) {
        let transaction = db.transaction(STORE_NAME, "readwrite");
        let store = transaction.objectStore(STORE_NAME);

        // üìå Adds the object with an auto-generated key
        store.add(data);
    }

    // /////// Saving Log to File /////////

    /**
     * Saves the stored log entries from IndexedDB to a downloadable CSV file.
     */
    // Event listener for the save button
    document.getElementById("saveData").addEventListener("click", saveCSV);


    let handFolderSelect = false;

    function toggleDirectorySelector() {
        handFolderSelect = !handFolderSelect;
    }


    async function saveCSV() {
        let dirHandle = null;
        const experimentType = document.getElementById("experimentType").value.trim();
        const experimentDesc = document.getElementById("experimentDesc").value.trim();
        const delimiter = ";"; // Delimiter for CSV file "\t" = tab, "," = comma, ";" = semicolon

        handFolderSelect = document.getElementById("storagePath").checked;

        if (!experimentType) {
            alert("Unable to save the data.\n    Please enter the experiment type.");
            return;
        }

        const fileName = `${experimentType}.csv`;

        let fileHandle;
        if (handFolderSelect) {
            try {
                dirHandle = await window.showDirectoryPicker(); // User selects a folder
            } catch (error) {
                console.error("‚ùå Folder selection canceled or error occurred:", error);
                return;
            }
            fileHandle = await dirHandle.getFileHandle(fileName, {create: true});

        } else {
            fileHandle = {name: `${fileName}`}; // Simulated save outside File System Access API
        }

        const header = `Time [s]${delimiter}Distance [mm]${delimiter}Speed [mm/s]${delimiter}Loadcell 1 [N]${delimiter}Loadcell 2 [N]${delimiter}Loadcell 3 [N]${delimiter}Photo Index\n`;
        let content = `Date:${delimiter}${new Date().toISOString()}\nDescription:${delimiter}${experimentDesc}\n${header}`;

        let transaction = db.transaction(STORE_NAME, "readonly");
        let store = transaction.objectStore(STORE_NAME);
        let request = store.getAll();

        request.onsuccess = async function () {
            let dataEntries = request.result;

            if (!dataEntries || dataEntries.length === 0) {
                console.warn("‚ö†Ô∏è No data to save.");
                alert("‚ö†Ô∏è No data to save. Ensure experiment has been run.");
                return;
            }

            dataEntries.forEach(entry => {
                const time = isNaN(entry.time) ? "" : entry.time;
                const distance = isNaN(entry.distance) ? "" : entry.distance;
                const speed = isNaN(entry.speed) ? "" : entry.speed;

                // Ensure `load` exists and is an array
                const load1 = (entry.load && !isNaN(entry.load[0])) ? entry.load[0] : "";
                const load2 = (entry.load && !isNaN(entry.load[1])) ? entry.load[1] : "";
                const load3 = (entry.load && !isNaN(entry.load[2])) ? entry.load[2] : "";

                // Ensure `photoIndex` is properly handled
                const photoIndex = isNaN(entry.photoIndex) ? "" : entry.photoIndex;

                content += `${time}${delimiter}${distance}${delimiter}${speed}${delimiter}${load1}${delimiter}${load2}${delimiter}${load3}${delimiter}${photoIndex}\n`;
            });

            if (handFolderSelect) {
                // Save file to the selected folder using File System Access API
                const writable = await fileHandle.createWritable();
                await writable.write(`\uFEFF${content}`); // Add BOM for correct UTF-8 encoding
                await writable.close();
            } else {
                // Simulated file download (browsers don't allow direct writes)
                const blob = new Blob([`\uFEFF${content}`], {type: "text/csv;charset=utf-8"});
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = fileHandle.name.split("/").pop();
                link.click();
            }

            console.log(`‚úÖ Data saved to file: ${fileName}`);

            // Clear IndexedDB after saving
            let deleteTransaction = db.transaction(STORE_NAME, "readwrite");
            let deleteStore = deleteTransaction.objectStore(STORE_NAME);
            deleteStore.clear().onsuccess = () => console.log("üóëÔ∏è Data from IndexedDB cleared after saving.");
        };
    }


    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////


    // /////// Serial Connection Variables /////////

    // Variables for handling serial (USB) communication
    let serialPort, serialWriter, serialReader;

    // Connection status flags
    let isConnected = false;
    let isSerial = false;

    // Reconnection attempts for serial connection
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    let isReconnecting = false;

    // /////// Serial Connection Handling /////////

    UI.USB.addEventListener("click", startSerial);

    /**
     * Starts the Serial (USB) connection by opening the database and initiating the connection.
     */
    async function startSerial() {
        if (isConnected) {
            await disconnectSerial();
        } else {
            console.log("üöÄ Starting application...");
            await connectSerial();

        }

    }


    // /////// Sending Commands /////////

    /**
     * Sends a command to the connected device.
     * Works with Serial (USB) connection;
     * @param {string} command - The command string to send.
     */
    async function sendCommand(command) {
        if (!isConnected || !serialPort?.writable) {
            await logMessage("\n‚ö†Ô∏è No device is connected or port is unavailable!");
            return;
        }

        try {
            const encoder = new TextEncoder();

            //  Ensure a writer exists before writing
            if (!serialWriter) {
                serialWriter = serialPort.writable.getWriter();
            }

            await serialWriter.write(encoder.encode(command + "\n"));

            console.log("Sent:", command);
            await logMessage("üì§ Command sent: " + command);

        } catch (error) {
            await handleError(error, "sendCommand");
        }
    }

    // /////// Logging Messages /////////

    // Global array for storing log messages in memory for display on the canvas
    // let logs = [];

    // // /////// Canvas DPI Adjustment /////////
    // function adjustCanvasDPI(canvas) {
    //     const ctx = canvas.getContext('2d', {willReadFrequently: true}); // Optimized for frequent reading
    //     const dpi = (window.devicePixelRatio || 1) * 1.5;
    //
    //     // Get the size of the canvas in CSS pixels.
    //     const width = canvas.clientWidth;
    //     const height = canvas.clientHeight;
    //
    //     // Store the current transformation matrix
    //     const savedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    //
    //     // Scale the canvas up by the device pixel ratio
    //     canvas.width = width * dpi;
    //     canvas.height = height * dpi;
    //     ctx.scale(dpi, dpi);
    //
    //     // Restore the old transformation matrix
    //     ctx.putImageData(savedImageData, 0, 0);
    //
    //     // Redraw the text on the canvas
    //     redrawCanvasText();
    //
    //     console.log(`üé® Canvas DPI changed: ${dpi}`);
    // }
    //
    // // Redraws the text on the canvas
    // function redrawCanvasText() {
    //     const ctx = UI.loadingLogContainer.getContext('2d');
    //     ctx.clearRect(0, 0, UI.loadingLogContainer.width, UI.loadingLogContainer.height);
    //
    //     ctx.font = '14px monospace';
    //     ctx.textBaseline = 'top';
    //
    //     const lineHeight = 16;
    //     const visibleLines = Math.floor(UI.loadingLogContainer.clientHeight / lineHeight);
    //     let scrollOffset = Math.max(0, logs.length - visibleLines);
    //
    //     for (let i = scrollOffset; i < logs.length; i++) {
    //         let msg = logs[i];
    //
    //         // üî• Change color to yellow if a message starts with "ds" (case-insensitive)
    //         if (msg.toLowerCase().startsWith("ds")) {
    //             ctx.fillStyle = 'yellow';
    //         } else {
    //             ctx.fillStyle = 'white';
    //         }
    //
    //         ctx.fillText(msg, 5, (i - scrollOffset + 0.5) * lineHeight);
    //     }
    // }
    //
    // // Function to log measurements to the canvas
    // function logMeasurements(msg) {
    //     if (!msg || typeof msg !== 'string') return;
    //
    //     logs.push(msg);
    //     if (logs.length > 100) logs.shift(); // Keep only the last 100 messages
    //
    //     redrawCanvasText();
    // }
    //
    // // Initial DPI adjustment for the canvas
    // adjustCanvasDPI(UI.loadingLogContainer);
    //
    // // Event listener for resizing the window and adjusting the canvas DPI
    // window.addEventListener("resize", () => adjustCanvasDPI(UI.loadingLogContainer));


    const visibleLines = Math.floor(UI.loadingLogContainer.clientHeight / 16);
    UI.loadingLogContainer.style.fontStyle = "14px monospace";
    UI.loadingLogContainer.style.overflow = "hidden";

    function logMeasurements(msg) {
        if (!msg || typeof msg !== 'string') return;

        // Check if a message starts with "ds" and apply yellow color, else use white
        let formattedMsg = msg.toLowerCase().startsWith("ds")
            ? `<span style="color:yellow;">${msg}</span>` // Highlight DSLR data
            : `<span style="color:white;">${msg}</span>`; // Normal log

        // Append the formatted message directly
        UI.loadingLogContainer.innerHTML += formattedMsg + "<br>";

        // Auto-scroll to the bottom for the latest logs
        UI.loadingLogContainer.scrollTop = UI.loadingLogContainer.scrollHeight;

        // Limit logs to 100 lines for performance
        let lines = UI.loadingLogContainer.innerHTML.split("<br>");
        if (lines.length > visibleLines) {
            UI.loadingLogContainer.innerHTML = lines.slice(lines.length - visibleLines).join("<br>");
        }
    }


    // Logs a message to the regular log container
    function logMessage(msg) {
        if (!msg) return;

        logCount++;
        isScrolledToBottom = checkScrolledToBottom();

        while (isLineLimit && (logCount >= logContentMaxLines)) {
            logContentLines.shift();
            if (isLineLocker) {
                UI.regularLogContainer.scrollTop -= UI.regularLogContainer.scrollHeight / logCount;
            }
            logCount--;
        }

        if (isAutoScroll) {
            UI.regularLogContainer.scrollTop = UI.regularLogContainer.scrollHeight;
        }

        logContentLines.push(msg);
        UI.regularLogContainer.textContent = logContentLines.join("\n");

        if (isScrolledToBottom) {
            UI.regularLogContainer.scrollTop = UI.regularLogContainer.scrollHeight;
        }
    }

    // /////// Loading Commands from JSON /////////

    /**
     * Loads commands from an external JSON file and creates buttons for each command.
     */
    async function loadCommands() {
        try {
            const response = await fetch("commands.json");
            const commands = await response.json();

            for (const [name, command] of Object.entries(commands)) {
                const btn = document.createElement("button");
                btn.innerText = name;
                btn.onclick = () => sendFunction(name, command);
                // document.getElementById("buttons").appendChild(btn);
            }
        } catch (error) {
            await handleError(error, "loadCommands");
        }
    }


    /////////////////////////////////////////////////////////////////

    const serialFunctionGetPorts = async () => {
        try {
            const ports = await navigator.serial.getPorts();
            return ports.length ? ports : null;
        } catch (error) {
            console.error("Error getting serial ports:", error);
            return null;
        }
    };

    const serialFunctionRequestPort = async () => {
        try {
            return await navigator.serial.requestPort();
        } catch (error) {
            if (error.name === "NotFoundError") {
                console.warn("‚ö†Ô∏è No port selected.");
                await logMessage("\n‚ö†Ô∏è No port selected.");
                return null;
            } else {
                throw new Error("Error requesting serial port:", error);
            }
        }
    };


    function checkAllPorts() {
        let thymosPorts = [];
        navigator.serial.getPorts().then(ports => {
            ports.forEach(port => {
                if (port.manufacturer === "Thymio") {
                    thymosPorts.push(port);
                }
            });


            return port
        }).catch(error => {
            return null
        });
    }


    // /////// Serial (USB) Connection to ESP /////////

    /**
     * Establishes a connection with the ESP device via USB.
     */
    async function connectSerial() {
        isSerial = true;
        try {
            const ports = await serialFunctionGetPorts();
            if (ports && ports.length === 1) {
                serialPort = ports[0];
                await openPort(serialPort);
            } else {
                if (ports && ports.length > 1) {
                    console.log("Multiple ports found. Select one.");
                    // serialPort = checkAllPorts();

                    for (let port of ports) {
                        await port.close();
                    }
                } else {
                    console.log("No previously connected devices found.");
                }
                if (!serialPort) serialPort = await serialFunctionRequestPort();
                if (serialPort === null) return;
                await openPort(serialPort);
            }
        } catch (error) {

            await handleError(error, "connectSerial");
            isSerial = false;
            await disconnectSerial(true);

        }
    }

    /**
     * Opens a serial port for communication.
     *  SerialPort => comPort - The selected serial port.
     */

    async function openPort(comPort) {
        try {
            if (!comPort) {
                console.error("‚ö†Ô∏è No available port.");
                await logMessage("\n‚ö†Ô∏è No available port.");
                return;
            }

            // If the port is already open, close it first
            if (comPort.opened) {
                console.log("üîå Closing existing port...");
                await comPort.close();
            }

            console.log("üîå Opening new port...");
            await comPort.open({baudRate: parseInt(document.getElementById("inputNumBaudRate").value)});

            // Get the writer and reader for the port after opening
            if (serialWriter) {
                serialWriter.releaseLock();
                serialWriter = null;
            }

            serialWriter = comPort.writable.getWriter(); // üî•  writer
            serialReader = comPort.readable.getReader(); // üî•  reader


            isConnected = true;
            reconnectAttempts = 0;


            await checkSerialSignals(comPort);


            await setSerialSignals(comPort, true, false); // Set DTR to true and RTS to false


            await updateConnectionStatus("connected", "USB");
            UI.USB.innerText = "‚ùå Disconnect ESP (USB)";
            await logMessage("\n‚úÖ Connected to ESP via USB\n");
            await readSerial();


        } catch (error) {
            await handleError(error, "openPort");
            await disconnectSerial(true);
        }
    }


    async function checkSerialSignals(port) {
        if (!port) return;

        try {
            const signals = await port.getSignals();
            console.log("üì° Serial port signals...");
            console.log("\tüö¶ Signals:", signals);
        } catch (error) {
            console.error("‚ùå Error reading serial signals:", error);
        }
    }


    async function setSerialSignals(port, dtrState, rtsState, brkState) {
        if (!port) return;

        try {
            await port.setSignals({
                dataTerminalReady: dtrState,
                requestToSend: rtsState,
                break: brkState
            });

            console.log(`‚úÖ DTR: ${dtrState}, RTS: ${rtsState}, BRK: ${brkState}`);
        } catch (error) {
            console.error("‚ùå Error setting serial signals:", error);
        }
    }


    /**
     * Disconnects from the ESP device via USB.
     */
    async function disconnectSerial() {
        if (!isConnected) {
            console.warn("‚ö†Ô∏è Port is not connected.");
            return;
        }

        try {
            stopExperiment = true;
            isExperimentRunning = false;
            try {
                await sendCommand("MC STOP"); // Stop data collection
                await new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms
                await sendCommand("DSLR STOP CYCLIC");
                new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms
                await sendCommand("DATAC 0"); // Stop data collection
                await new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms
            } catch (error) {
                console.warn("‚ö†Ô∏è Error stopping data collection:", error);
            }

            await new Promise(resolve => setTimeout(resolve, 5)); // Stop for 1 ms

            // Stop data reading before releasing the reader
            if (serialReader) {
                console.log("üìå Stopping data reading...");
                try {
                    await serialReader.cancel(); // Cancel reading safely
                } catch (err) {
                    console.warn("‚ö†Ô∏è Error canceling reader:", err);
                }
                serialReader.releaseLock(); // Release reader lock
                serialReader = null;
            }

            // Release the writer before closing the port
            if (serialWriter) {
                console.log("üìå Releasing writer...");
                serialWriter.releaseLock();
                serialWriter = null;
            }

            // Now close the port safely
            if (serialPort) {
                console.log("üìå Closing serial port...");
                await serialPort.close();
                serialPort = null;
            }

            await logMessage("‚úñÔ∏è Disconnected from ESP\n\n");

            console.log("‚úÖ Disconnected successfully.");
        } catch (error) {
            console.error("‚ùå disconnectSerial error:", error);
        } finally {
            await resetValues();
        }
    }


    function resetValues() {
        parsedData = {time: NaN, distance: NaN, value: NaN, load: [NaN, NaN, NaN], photoIndex: NaN};
        liveUpdate = false


        UI.USB.innerText = "üîå Connect via USB";
        updateConnectionStatus("disconnected");

        isExperimentRunning = false;
        stopExperiment = true;
        UI.loadingLogContainer.style.background = "#323232";
        experimentEndPosition = 0;
        startTime = null;
        pendingDSLR = null;
        dataCount = null;
        maxLoad = [null, null, null];
        measureForces = [[], [], []];
        meanForces = [0, 0, 0];

        isSerial = false;
        isConnected = false;
        serialPort = null;
        serialReader = null;
        serialWriter = null;
        reconnectAttempts = 0;
    }


    // /////// Reading Data from ESP /////////

    /**
     * Reads incoming data from the ESP device over a serial connection.
     */


    async function readSerial() {
        isReadingSerial = true;
        const decoder = new TextDecoder();
        let buffer = "";

        if (!serialPort.readable) {
            await logMessage("\n‚ùå Port is unavailable.\n");
            return;
        }

        if (serialReader) {
            try {
                serialReader.releaseLock(); // Ensure only one active reader
            } catch (err) {
                console.error("Reader lock error:", err);
            }
        }

        serialReader = serialPort.readable.getReader(); // Get a reader only once

        try {
            while (isConnected) {
                const {value, done} = await serialReader.read();
                if (done) break; // Stop loop if the stream is closed

                buffer += decoder.decode(value, {stream: true});

                let lastNewline = buffer.lastIndexOf("\n");
                if (lastNewline !== -1) {
                    let dataChunk = buffer.slice(0, lastNewline).split("\n");
                    buffer = buffer.slice(lastNewline + 1);

                    await processMeasurements(dataChunk);
                }
            }
        } catch (error) {
            await handleError(error, "readSerial"); // Handle any errors
        } finally {
            if (serialReader) {
                await serialReader.cancel(); //  Immediately stop reading !!!!
                serialReader.releaseLock();
            }
            await logMessage("\n‚úÖ Reading stopped.\n");
        }
    }

    async function attemptReconnect() {
        if (isConnected || isReconnecting) {
            console.warn("üö® Reconnect aborted - Already connected or disconnect was expected.");
            // reconnectAttempts = 0;
            return;
        }

        if (reconnectAttempts >= maxReconnectAttempts) {
            console.warn("‚ö†Ô∏è Stopping auto-reconnect. Maximum attempts reached.");
            await logMessage("\n‚ö†Ô∏è Stopping auto-reconnect.\n");
            isReconnecting = false;
            await disconnectSerial();
            await resetValues();
            return;
        }

        isReconnecting = true;
        reconnectAttempts++;
        UI.USB.innerText = "üîÑ Reconnecting...";
        await updateConnectionStatus("reconnecting");
        await logMessage(`\nüîÑ Attempting reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);

        try {
            if (isSerial) {
                await connectSerial();
            }

            if (isConnected) {
                console.log("‚úÖ Reconnected successfully!");
            } else {
                new Error("Reconnect failed");
            }
        } catch (error) {
            console.warn("‚ö†Ô∏è Reconnection failed:", error);
            await logMessage("\n‚ùå Reconnection failed: " + error);

            if (reconnectAttempts < maxReconnectAttempts) {
                setTimeout(() => {
                    isReconnecting = false; //  Allow another reconnection attempt
                    attemptReconnect();
                }, 3000);
            } else {
                console.warn("‚ö†Ô∏è Max reconnect attempts reached. Stopping.");
                await logMessage("\n‚ùå Max reconnect attempts reached. Stopping.\n");
                await resetValues();
            }
        }
    }


    /////////////////////////////////////////////////////////////////


    // /////// Optimized Measurement Processing /////////

    /**
     * Processes incoming measurement data.
     * @param {Array} dataChunk - An array of measurement data lines.
     */

    //     let messageCount = 0;
    // let lastLogTime = Date.now();
    async function processMeasurements(dataChunk) {
        if (!dataChunk.length) return;

        for (let line of dataChunk) {
            let msg = line.trim();


            // üîé Wait for a specific data format to match
            if (waitingForDataFormat && dataFormat !== null) {
                let match = msg.match(dataFormat);

                if (match) {
                    console.log("‚úÖ Response match:", msg);

                    // If a callback is set, process the matched data
                    if (onDataMatch) {
                        onDataMatch(match);
                        onDataMatch = null; // Reset callback
                    }

                    waitingForDataFormat = false; // Reset the format
                    dataFormat = null; // Reset the format
                    return;
                }
            }


            if (msg.startsWith("DS")) {
                await parseData(msg);
            } else {
                logMessage(msg);
            }

            // // Increment the message counter
            // messageCount++;
        }

        // // Log the message count every second
        // let now = Date.now();
        // if (now - lastLogTime >= 1000) {
        //     console.log(`üì° Messages per second: ${messageCount}`);
        //     messageCount = 0; // Reset the counter
        //     lastLogTime = now; // Actualize the last log time
        // }
    }


    let maxLoad = [null, null, null];


    // /////// Data Parsing /////////
    function interpolateDSLRData(dslrEvent, nextData) {
        if (!parsedData || !parsedData.time) {
            console.log("‚ö†Ô∏è No valid previous data for interpolation.");
            return;
        }

        let prevData = parsedData; // Use the last stored data as the previous measurement
        let dslrTime = dslrEvent.time;
        let photoIndex = dslrEvent.photoIndex;

        // Ensure valid data for interpolation
        if (!prevData || !nextData || prevData.time >= nextData.time) {
            console.log("‚ö†Ô∏è Not enough data for interpolation.");
            return;
        }

        // Linear interpolation factor
        let t1 = prevData.time, t2 = nextData.time;
        let factor = (dslrTime - t1) / (t2 - t1);

        let interpolatedSpeed = prevData.speed + factor * (nextData.speed - prevData.speed);
        let interpolatedDistance = prevData.distance + factor * (nextData.distance - prevData.distance);
        let interpolatedLoad = prevData.load.map((val, i) => val + factor * (nextData.load[i] - val));

        // Store interpolated data
        let interpolatedData = {
            time: dslrTime,
            distance: interpolatedDistance,
            speed: interpolatedSpeed,
            load: interpolatedLoad,
            photoIndex: photoIndex // Store DSLR photo order
        };

        // Log interpolated data
        logMeasurements(`${interpolatedData}`);
        addDataToLog(interpolatedData);
        // addMarker(timeChart, dslrTime); // #TODO
        // addMarker(distanceChart, interpolatedDistance);
    }


    /**
     * Parses raw measurement data into a structured object.
     * @param {string} dataString - The raw data string received from ESP.
     * @returns {Object} - Parsed data object containing time, distance, value, and load values.
     */

    let pendingDSLR = null; // Store DSLR event until the next data arrives
    let dataCount = null;
    let dataChartInterval = 1; // Interval for live chart update
    let startTime = null;

    let isDelayed = false;
    // let firstPhoto = 0;
    let photoCount = 0;


    function delayData() {
        if (isDelayed) return;

        isDelayed = true;
        new Promise(resolve => setTimeout(() => {
            isDelayed = false;
            resolve(); // Call resolve() po 1000 ms
        }, 1000)); // Delay 1 second


    }

    async function parseData(dataString) {
        if (!isExperimentRunning && !isDelayed) {
            logMeasurements(dataString);
            return;
        }

        // === Detect DSLR shoot event ===
        if (dataString.startsWith("DSLR shoot:")) {
            let parts = dataString.split(":")[1].split(",");
            let dslrTime = parseFloat(parts[0]) * 1e-3; // Convert microseconds to seconds
            let photoIndex = parseInt(parts[1]); // Extract photo order

            // if (firstPhoto === 0) {  // #TODO
            //     firstPhoto = photoIndex - 1;
            // }

            // photoIndex - firstPhoto
            pendingDSLR = {time: dslrTime, photoIndex: photoCount}; // Store for later interpolation
            photoCount++;
            return;
        }


        dataString = dataString.substring(2);
        const parts = dataString.split(",");

        if (parts.length !== 6) {
            logMessage(dataString);
            return;
        }

        let timeVal = parseFloat(parts[0]) * 1e-6; // Convert microseconds to seconds
        let distVal = parseFloat(parts[1]); // Distance value
        let speedVal = parseFloat(parts[2]); // Speed value
        let loadVal = parts.slice(3).map(parseFloat); // Load cell values


        if (takeMeasurements) {

            loadVal.forEach((value, index) => {
                measureForces[index].push(value);
            });

        } else {
            if (startTime === null) {
                startTime = timeVal;
            }

            timeVal -= startTime;
            distVal -= startPosition;
            loadVal = loadVal.map((value, index) => value - meanForces[index]);


            const newData = {time: timeVal, distance: distVal, speed: speedVal, load: loadVal, photoIndex: NaN};

            // If a pending DSLR timestamp exists, interpolate values
            if (pendingDSLR) {
                await interpolateDSLRData(pendingDSLR, newData);
                pendingDSLR = null; // Reset after interpolation
            }

            // Stop experiment if speed is near zero for too long
            if (speedVal < 0.001 && !isDelayed) {
                zero_speed_counter++;
                if (zero_speed_counter > 5) {
                    // stopExperiment = true;
                    console.log("    üõë Experiment stopped due to zero speed.");
                    logMessage("üõë Experiment stopped due to zero speed.");
                }

            } else {
                zero_speed_counter = 0;
            }


            for (let i = 0; i < 3; i++) {
                if (maxLoad[i] < Math.abs(loadVal[i])) {
                    maxLoad[i] = Math.abs(loadVal[i]);
                }


                if (maxLoad[i] && !isDelayed) {
                    if (Math.abs(loadVal[i] * loadLimitDropPercent) < maxLoad[i] &&
                        (maxLoad[i] - Math.abs(loadVal[i])) > loadLimitDropValue) {

                        stopExperiment = true;
                        console.log(`    üõë Experiment stopped due to load cell ${i + 1} drop.`);
                        logMessage(`üõë Experiment stopped due to load cell ${i + 1} drop.`);
                        break; // Stop checking other load cells if one fails
                    }
                }
            }


            logMeasurements(dataString);
            addDataToLog(newData);
            parsedData = newData;


            // Update Progress Bar
            const progress = distVal / experimentEndPosition * 100
            if (progress >= 100 && !isDelayed) {
                stopExperiment = true;
                console.log("üèÅ Experiment finished.");
                logMessage("üèÅ Experiment finished.");
            }
            UI.progressBar.value = Math.max(0, progress);


            if (liveUpdate) {
                if (dataCount % dataChartInterval === 0) {
                    updateChart(parsedData);
                }
            }
            dataCount++;


            if (stopExperiment && !isDelayed) {
                console.log("üõë Experiment stopped.");
                isExperimentRunning = false;
                UI.loadingLogContainer.style.background = "#323232";
                dataCount = null;
                delayData();
            }
        }
    }

    // /////// Command Handling /////////

    /**
     * Sends a command to the ESP device.
     * If the command is for reading a specific load cell, it replaces the placeholder with the selected ID.
     * @param {string} name - The command name.
     * @param {string} inputCommand - The raw command string.
     */
    async function sendFunction(name, inputCommand) {
        let command;

        if (name === "read Loadcell[#]") {
            let loadcellId = parseInt(document.getElementById("inputNumLoadID").value);
            command = replaceVariables(inputCommand, {loadcellId: loadcellId});
        } else {
            command = inputCommand;
        }

        await sendCommand(command);
    }

    // /////// Template Variable Replacement /////////

    /**
     * Replaces variables inside a command template with actual values.
     * @param {string} template - The command template containing placeholders.
     * @param {Object} variables - An object mapping variable names to their actual values.
     * @returns {string} - The command string with replaced values.
     */
    function replaceVariables(template, variables) {
        return template.replace(/{{(.*?)}}/g, (match, key) => variables[key.trim()] || match);
    }


    /////////////////////////////////////////////////////////////////


    // /////// Page Initialization /////////

    /**
     * Runs when the page loads.
     * - Logs a message to the console.
     * - Loads available commands from the JSON file.
     */
    window.onload = async () => {
        console.log("Page loaded");
        await openDB();
        // await loadCommands();
    };


    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////


    // /////// Toggle Live Update /////////
    function chartUpdate() {
        if (!liveUpdate) loadDataFromDBToChart(!liveUpdate);

        liveUpdate = !liveUpdate;

        UI.chartsLiveButton.textContent = liveUpdate ? "‚è∏Ô∏è Disable Charts" : "‚ñ∂Ô∏è Activate Charts";
        UI.chartsContainer.style.background = liveUpdate ? "transparent" : "#f5f5f5";
    }


    let isPageVisible = true; // Visibility status of the page
    let hideTimeout = null; // Timeout for hiding the page
    const MIN_HIDE_TIME = 10_000; // 10 seconds

    // Event listener for page visibility change
    document.addEventListener("visibilitychange", () => {
        if (!liveUpdate && !isExperimentRunning) return;

        isPageVisible = !document.hidden;

        if (!isPageVisible) {
            console.log("‚è∏Ô∏è Page is hidden.");
            if (liveUpdate && !liveUpdatePaused) {
                console.log("‚è∏Ô∏è Pause live update of charts.");
                liveUpdatePaused = true;
                liveUpdate = false;
            }

            // üïí Set timeout for hiding the page
            hideTimeout = setTimeout(() => {
                if (!isPageVisible) {
                    console.log("‚è≥ Page is hidden longer than 10+ seconds. Hiding...");
                }
            }, MIN_HIDE_TIME);

        } else {
            if (hideTimeout) {
                clearTimeout(hideTimeout); // Clear the hide timeout
                hideTimeout = null;
            }

            console.log("üîÑ Page is visible");
            if (liveUpdatePaused) {
                console.log("üîÑ Resuming live update of charts.");
                loadDataFromDBToChart(true);
                liveUpdatePaused = false;
                liveUpdate = true;
            }
        }
    });


    async function loadDataFromDBToChart(stateAtEnd = false) {
        if (!db) {
            console.error("‚ö†Ô∏è IndexedDB is not available (not opened).");
            return;
        }

        liveUpdate = false;

        await clearCharts();

        console.log("üîÑ Loading data from IndexedDB to charts...");

        let transaction = db.transaction(STORE_NAME, "readonly");
        let store = transaction.objectStore(STORE_NAME);
        let request = store.getAll();

        request.onsuccess = function () {
            let dataEntries = request.result;
            if (!dataEntries || dataEntries.length === 0) {
                console.warn("‚ö†Ô∏è No data to load.");
                return;
            }

            console.log(`üìâ Loaded ${dataEntries.length} data points`);

            // ‚è© **Use `filter` to reduce the number of data points**
            const filteredEntries = dataEntries.filter((_, index) => index % dataChartInterval === 0);

            // ‚è© **Use `map` to extract specific data fields**
            timeData = filteredEntries.map(entry => entry.time);
            distanceData = filteredEntries.map(entry => entry.distance);
            loadcellData[0] = filteredEntries.map(entry => entry.load[0]);
            loadcellData[1] = filteredEntries.map(entry => entry.load[1]);
            loadcellData[2] = filteredEntries.map(entry => entry.load[2]);


            timeChart.setData([timeData, ...loadcellData]);
            distanceChart.setData([distanceData, ...loadcellData]);

            timeChart.setScale("x", {min: timeData[0], max: timeData[timeData.length - 1]});
            distanceChart.setScale("x", {min: distanceData[0], max: distanceData[distanceData.length - 1]});
            timeChart.setScale("y", {min: Math.min(...loadcellData.flat()), max: Math.max(...loadcellData.flat())});
            distanceChart.setScale("y", {
                min: Math.min(...loadcellData.flat()),
                max: Math.max(...loadcellData.flat())
            });

            // üîÑ Redraw graphs
            // timeChart.redraw();
            // distanceChart.redraw();

            liveUpdate = stateAtEnd;

            console.log("‚úÖ Graph data loaded successfully.");
        };
    }


    // Attach live update toggle to button
    UI.chartsLiveButton.addEventListener("click", chartUpdate);


    // /////// uPlot Chart Initialization /////////

    function addMarker(uplotInstance, xValue) {
        markers.push(xValue); // P≈ôid√°n√≠ nov√© znaƒçky do pole
        uplotInstance.redraw(); // P≈ôekreslen√≠ grafu
    }

    // Store dataset
    let timeData = [];
    let distanceData = [];
    let loadcellData = [[], [], []];


    let markers = []; // Pole pro ulo≈æen√© znaƒçky

    const markerPlugin = {
        hooks: {
            draw: (u) => {
                const ctx = u.ctx;
                ctx.save();
                ctx.strokeStyle = "red"; // Barva ƒç√°ry
                ctx.lineWidth = 2;

                markers.forEach(xValue => {
                    let xPixel = u.valToPos(xValue, "x", true);
                    ctx.beginPath();
                    ctx.moveTo(xPixel, u.bbox.top);
                    ctx.lineTo(xPixel, u.bbox.top + u.bbox.height);
                    ctx.stroke();
                });

                ctx.restore();
            }
        }
    };


    function createChart(containerID, seriesLabels, title = "Graph") {
        // Get the container element
        let container = document.getElementById(containerID);
        if (!container) {
            console.error(`‚ùå Error: container s ID "${containerID}" not found.`);
            return null;
        }

        // Get the container dimensions
        let width = container.clientWidth || 400; // Default width if container is empty
        let height = container.clientHeight || 300; // Default height if container is empty

        // Configurations for uPlot chart
        const options = {
            title: title,
            width: width,
            height: height,
            scales: {
                x: {time: false},
                y: {auto: true}
            },
            series: seriesLabels.map((label, index) => ({
                label: label,
                stroke: index === 0 ? "black" : ["red", "blue", "green"][index - 1] || "gray"
            })),
            plugins: [markerPlugin],
        };

        // Create the uPlot chart
        let chart = new uPlot(options, [[], ...seriesLabels.slice(1).map(() => [])], container);

        // Dynamic resizing of the chart
        window.addEventListener("resize", () => {
            let newWidth = container.clientWidth || 400;
            let newHeight = container.clientHeight || 300;
            chart.setSize({width: newWidth, height: newHeight});
            UI.chartsContainer.style.height = getChartHeightIncludingLegend() + "px";
        });

        return chart;
    }

    // Initialization of uPlot charts
    let timeChart = createChart("timeChart", ["Time (s)", "Loadcell 1", "Loadcell 2", "Loadcell 3"], "Time Graph");
    let distanceChart = createChart("distanceChart", ["Distance (mm)", "Loadcell 1", "Loadcell 2", "Loadcell 3"], "Distance Graph");

    function getChartHeightIncludingLegend() {
        let charts = document.querySelectorAll(".uplot");
        let maxHeight = 0;

        charts.forEach(chart => {
            maxHeight = Math.max(maxHeight, chart.clientHeight);
        });

        return maxHeight;

    }


    // /////// Chart Update Function /////////

    /**
     * Updates the charts with new data.
     */
    function updateChart(data) {

        // Check if the data is valid (not NaN)
        if (isNaN(data.time) || isNaN(data.distance) || data.load.some(isNaN)) {
            return;
        }

        // Add new data points
        timeData.push(data.time);
        distanceData.push(data.distance);
        loadcellData[0].push(data.load[0]);
        loadcellData[1].push(data.load[1]);
        loadcellData[2].push(data.load[2]);

        // Maintain max data points
        // if (timeData.length > maxDataPoints) {
        //     timeData.shift();
        //     distanceData.shift();
        //     loadcellData.forEach(dataset => dataset.shift());
        // }


        // Update charts
        timeChart.setData([timeData, ...loadcellData]);
        distanceChart.setData([distanceData, ...loadcellData]);
    }

    function refreshCharts() {
        loadDataFromDBToChart(liveUpdate);
        timeChart.redraw();
        distanceChart.redraw();
    }

    async function clearCharts() {
        // Reset axis X and Y
        await timeChart.setScale("x", {min: 0, max: 1e-10});
        await distanceChart.setScale("x", {min: 0, max: 1e-10});

        timeData.length = 0;
        distanceData.length = 0;
        loadcellData.forEach(dataset => dataset.length = 0);
        await timeChart.setData([[], [], [], []]);
        await distanceChart.setData([[], [], [], []]);

        await timeChart.setScale("y", {min: 0, max: 1e-10});
        await distanceChart.setScale("y", {min: 0, max: 1e-10});

        console.log("üßπ Distance chart cleared!");
    }


    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////


    async function handleError(error, context = "Unknown") {


        // üìå Connection Errors Handling Identifiers
        const connectionErrors = [
            "NetworkError",
            "The device was lost.",
            "The port is no longer available."
        ];

        if (connectionErrors.some(msg => error.message.includes(msg)) || error.name === "NetworkError") {
            console.warn("‚ö†Ô∏è Connection lost! Attempting to reconnect...");
            isConnected = false;
            await attemptReconnect();
        } else {
            console.error(`‚ùå ${context} error:`, error);
            await logMessage(`‚ùå ${context} error: ${error}`);
        }

    }


    function getPosition(timeout = 5000) {
        return new Promise((resolve, reject) => {
            setExpectedDataFormat(/^Motor position:\s(-?\d+(\.\d+)?)\smm$/, (match) => {
                let positionValue = parseFloat(match[1], 10);
                resolve(positionValue); // Resolve
            });

            sendCommand("MC GET POS");

            // ‚è≥ Timeout in case no data is received
            if (timeout && timeout > 0) {
                setTimeout(() => {
                    if (waitingForDataFormat) {
                        waitingForDataFormat = false;
                        dataFormat = null;
                        reject(new Error("‚è≥ Timeout: No data received."));
                    }
                }, timeout); // Timeout 5 seconds
            }
        });
    }

    function setExpectedDataFormat(regexPattern, callback) {
        waitingForDataFormat = true;
        dataFormat = new RegExp(regexPattern);
        onDataMatch = callback;
        console.log(`üîç Waiting for data in format: ${regexPattern}`);
    }

    // === Measure Position ===
    async function measurePosition() {
        if (!isConnected) {
            console.warn("‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        try {
            let position = await getPosition();
            console.log(`üìå Current position: ${position} mm`);
            return position;
        } catch (error) {
            console.error(error.message);
        }
    }

    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////

    // === Experiment Data Saving ===
    document.getElementById("startExperiment").addEventListener('click', startExperiment);

    document.getElementById("stopExperiment").addEventListener('click', () => {
        isExperimentRunning = false;
        stopExperiment = true;
        UI.progressBar.value = 0;
        sendCommand("MC STOP");
        new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms
        sendCommand("DSLR STOP CYCLIC");
        new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms
        sendCommand("DATAC 0");
        new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms
    });

    document.getElementById("inputLoadLimitDropPercent").addEventListener('change', (event) => {
        loadLimitDropPercent = 1 - parseFloat(event.target.value) / 100;
    });
    document.getElementById("inputLoadLimitDropValue").addEventListener('change', (event) => {
        loadLimitDropValue = parseFloat(event.target.value);
    });

    document.getElementById("inputTakePhotos").addEventListener('change', (event) => {
        if (event.target.checked) {
            // disable photo interval input
            document.getElementById("inputPhotoInterval").classList.remove("disabled");
            // disable photo interval input label
            document.querySelector(`label[for='${"inputPhotoInterval"}']`).classList.remove("disabled");
        } else {
            // disable photo interval input
            document.getElementById("inputPhotoInterval").classList.add("disabled");
            // disable photo interval input label
            document.querySelector(`label[for='${"inputPhotoInterval"}']`).classList.add("disabled");
        }
    });


    async function startExperiment() {


        if (!isConnected) {
            console.warn("‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }

        if (isExperimentRunning) {
            console.warn("‚ö†Ô∏è Experiment is already running.");
            await logMessage("‚ö†Ô∏è Experiment is already running.");
            return;
        }


        await new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms

        await clearDBLog();
        await clearCharts();

        if (!liveUpdate) await chartUpdate();

        await new Promise(resolve => setTimeout(resolve, 5)); // Stop for 1 ms

        UI.loadingLogContainer.style.background = "black";

        // === Retrieve Parameters from Inputs ===
        const distance_mm = parseFloat(document.getElementById("inputDistance").value);
        const speedForward_mmps = parseFloat(document.getElementById("inputSpeedForward").value);
        const speedBackward_mmps = parseFloat(document.getElementById("inputSpeedBackward").value);
        const photoInterval_ms = parseFloat(document.getElementById("inputPhotoInterval").value) * 1000;
        const dataInterval_us = parseInt(document.getElementById("inputDataInterval").value);
        const loadcellCapacity = parseFloat(document.getElementById("inputLoadcellCapacity").value);
        const loadcellOutput = parseFloat(document.getElementById("inputLoadcellOutput").value);
        const takePhotos = document.getElementById("inputTakePhotos").checked;
        loadLimitDropPercent = 1 - parseFloat(document.getElementById("inputLoadLimitDropPercent").value) / 100;
        loadLimitDropValue = parseFloat(document.getElementById("inputLoadLimitDropValue").value);


        await logMessage(`\nüéØ Starting experiment ${takePhotos ? "with" : "without"} photos üì∏`);
        console.log("üöÄ Starting experiment...");

        isExperimentRunning = true;
        stopExperiment = false;

        // === Progress Bar Setup ===
        UI.progressBar.value = 0;
        experimentEndPosition = distance_mm; // The total distance to be moved
        startTime = null;
        maxLoad = [null, null, null];
        // firstPhoto = 0;
        measureForces = [[], [], []];
        meanForces = [0, 0, 0];


        // === Load Cell Configuration ===
        for (let i = 0; i < 3; i++) {
            await sendCommand(`LC SET CAP ${i} ${loadcellCapacity}`);
            await new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms
            await sendCommand(`LC SET RO ${i} ${loadcellOutput}`);
            await new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms
        }

        // === Prepare Motor ===
        await sendCommand("MC STOP");
        await new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms
        await sendCommand(`MC SET SPEEDMM ${speedForward_mmps}`);
        await new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms


        // === Prepare Data Collection ===
        await new Promise(resolve => setTimeout(resolve, 5)); // Stop for 5 ms

        startPosition = await measurePosition();
        await new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms


        await sendCommand('DATA SET INTERVAL 2000');
        await new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms
        await sendCommand("DATAC 1");
        takeMeasurements = true;

        await new Promise(resolve => setTimeout(resolve, 1000)); // Stop for 1 s

        takeMeasurements = false;
        await sendCommand("DATAC 0");
        meanForces = measureForces.map(force => Math.round(force.reduce((a, b) => a + b, 0) / force.length * 100000) / 100000);
        measureForces = [[], [], []];

        await new Promise(resolve => setTimeout(resolve, 5)); // Stop for 5 ms

        await sendCommand('DSLR SHOOT');
        await addDataToLog({
            time: 0,
            distance: 0,
            speed: 0,
            load: [0, 0, 0],
            photoIndex: 0 // Store DSLR photo order
        });
        photoCount++;
        await new Promise(resolve => setTimeout(resolve, 5)); // Stop for 1 ms

        // === Enable Data Streaming and DSLR Shooting ===
        await sendCommand(`DATA SET INTERVAL ${dataInterval_us}`);
        await new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms
        await sendCommand("DATAC 1");
        await new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms
        if (takePhotos) await sendCommand(`DSLR START CYCLIC ${photoInterval_ms}`);
        await new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms

        // === Move Forward ===
        console.log("‚û°Ô∏è Moving forward...");
        await sendCommand(`MC MOVEBY USER ${distance_mm}`);


        // === Ensure Serial Reading is Running ===
        if (!isReadingSerial) {
            isReadingSerial = true;
            await readSerial();
        }

        // === Data Collection Loop ===
        while (isExperimentRunning) {
            await delay(cpuDelay); // Prevents excessive CPU usage
        }


        isExperimentRunning = false;
        stopExperiment = true;

        await sendCommand("MC STOP");
        await new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms

        // await showNotification("Experiment Finished", "The experiment has been completed successfully.");

        // === Stop Data Streaming and DSLR Shooting ===
        await sendCommand("DSLR STOP CYCLIC");
        await new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms
        await sendCommand("DATAC 0");
        await new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms

        // === Move Back ===
        console.log("‚¨ÖÔ∏è Moving backward...");
        await sendCommand(`MC SET SPEEDMM ${speedBackward_mmps}`);
        await new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms

        if (UI.autoReturnPosition.checked) {
            await moveToOriginalPosition();
        }


        // === Save Data ===
        console.log("üíæ Saving data...");
        await saveCSV();


        UI.loadingLogContainer.style.background = "#323232";
        console.log("‚úÖ Experiment completed.");
    }


    async function moveToOriginalPosition() {
        const endPosition = await measurePosition();
        if (!parseFloat(endPosition)) return;
        if (!startPosition || startPosition === 0) return;
        await sendCommand(`MC MOVEBY USER ${startPosition - endPosition}`);
        await new Promise(resolve => setTimeout(resolve, 1)); // Stop for 1 ms
    }


    function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }


    // Function Clear `localStorage`
    function clearLocalStorage() {
        localStorage.removeItem(storageKey); // Remove the saved data
        console.log("LocalStorage cleared.");

        window.location.reload();
    }


    let notificationsAllowed = false;

    function showNotification(title = "Notification", message = "This is a notification.") {
        if (!("Notification" in window)) {
            alert("Your browser does not support notifications.");
            return;
        }

        if (notificationsAllowed) {
            // Show notification immediately
            new Notification(title, {body: message});
        } else {
            // Request permission if not yet granted
            Notification.requestPermission().then(permission => {
                if (permission === "granted") {
                    notificationsAllowed = true;
                    new Notification(title, {body: message});
                } else {
                    alert("Notifications were not allowed.");
                }
            });
        }
    }


    document.addEventListener("DOMContentLoaded", function () {
        Notification.requestPermission().then(permission => {
            if (permission === "granted") {
                notificationsAllowed = true;
            }
        });


        // Function to save ONE input to localStorage
        function saveInputToLocalStorage(event) {
            const input = event.target; // Get the input element
            let formData = JSON.parse(localStorage.getItem(storageKey)) || {}; // Load the saved data

            // Save the input value to the formData object or select the checked state for checkboxes
            formData[input.id] = (input.type === "checkbox") ? input.checked : input.value;

            localStorage.setItem(storageKey, JSON.stringify(formData)); // Save the updated data
        }


        // Function to save ALL inputs to localStorage
        function saveAllInputsToLocalStorage() {
            let formData = {};

            optionsElements.forEach(input => {
                formData[input.id] = (input.type === "checkbox") ? input.checked : input.value;
            });

            localStorage.setItem(storageKey, JSON.stringify(formData));
            console.log("All data saved to localStorage.");
        }


        // Function to load inputs from localStorage
        function loadInputsFromLocalStorage() {
            const formData = JSON.parse(localStorage.getItem(storageKey)) || {}; // Load the saved data
            if (!formData) saveAllInputsToLocalStorage();
            optionsElements.forEach(input => {
                if (formData.hasOwnProperty(input.id)) {
                    if (input.type === "checkbox") {
                        input.checked = formData[input.id]; // Restore the checkbox state
                    } else {
                        input.value = formData[input.id]; // Restore the input value
                    }

                    // Trigger change event to update the UI
                    input.dispatchEvent(new Event("change", {bubbles: true}));
                    input.dispatchEvent(new Event("input", {bubbles: true}));
                    input.dispatchEvent(new Event("blur", {bubbles: true}));
                }
            });
        }


        const optionsElements = document.querySelectorAll("input, select");

        // Listen for changes in all inputs
        optionsElements.forEach(input => {
            input.addEventListener("change", saveInputToLocalStorage);
        });

        // Load saved data when the page loads
        loadInputsFromLocalStorage();
        UI.chartsContainer.style.height = getChartHeightIncludingLegend() + "px";
    });


    async function convertCSVtoXLSX() {
        const input = document.createElement('input');
        const delimiter = ";"; // Delimiter for CSV file "\t" = tab, "," = comma, ";" = semicolon

        input.type = 'file';
        input.accept = '.csv';
        input.multiple = true; // Allow multiple file selection
        input.onchange = async function (event) {
            let files = Array.from(event.target.files); // Convert FileList to Array
            if (!files.length) {
                alert("‚ùå No files selected.");
                return;
            } else {
                files.sort((a, b) => {
                    let nameA = a.name.toLowerCase();
                    let nameB = b.name.toLowerCase();

                    // Regular expression to extract the base name and optional index
                    let regex = /(.*?)(?:\s\((\d+)\))?\.csv$/;

                    let matchA = nameA.match(regex);
                    let matchB = nameB.match(regex);

                    if (!matchA || !matchB) return 0; // Skip if no match

                    let baseA = matchA[1]; // Base name
                    let indexA = matchA[2] ? parseInt(matchA[2]) : -1; // Index (if present) or -1

                    let baseB = matchB[1];
                    let indexB = matchB[2] ? parseInt(matchB[2]) : -1;

                    // Sort by base name first
                    if (baseA !== baseB) return baseA.localeCompare(baseB);

                    // Sort by index if base names are the same
                    if (indexA === -1) return -1;
                    if (indexB === -1) return 1;

                    // Sort by index
                    return indexA - indexB;
                });

                console.log("üìÇ Sorted files:", files.map(f => f.name)); // Log sorted file names
            }

            let wb = XLSX.utils.book_new(); // Create a new Excel workbook
            let sheetName = "P-" + files[0].name.replace(/\.csv$/, "").replace(/\s*\(\d+\)\s*$/, "").trim();
            let formattedData = [];
            let columnOffset = 0; // Column shift for each section
            let fileIndexData = [["File Order", "File Name"]]; // Second sheet data

            let fileCount = 0;
            for (let file of files) {
                fileCount++;
                let text = await file.text(); // Read file content
                let rows = text.split("\n").map(row => row.split(delimiter)); // Parse CSV into an array

                if (rows.length < 4) continue; // Skip if the file has no data
                rows = rows.slice(2); // Skip the first 2 rows

                let blockSize = 1000; // Number of rows in one block
                let firstShiftAbove1 = null; // Track first shift where force > 1 N

                fileIndexData.push([fileCount, file.name.replace(".csv", "")]);

                // Define headers for this section
                let sectionHeader1 = [], sectionHeader2 = [], sectionHeader3 = [], sectionHeader4 = [];
                sectionHeader1[columnOffset] = fileCount; // Section number
                sectionHeader2[columnOffset] = "Measured values from testing machine";
                sectionHeader3[columnOffset] = "Time";
                sectionHeader3[columnOffset + 1] = "Total distance covered by loading pin";
                sectionHeader3[columnOffset + 2] = "Force";
                sectionHeader3[columnOffset + 3] = "Deformation from F > 1N";
                sectionHeader4[columnOffset] = "s";
                sectionHeader4[columnOffset + 1] = "mm";
                sectionHeader4[columnOffset + 2] = "N";
                sectionHeader4[columnOffset + 3] = "mm";

                // Ensure headers are fully added for every section
                if (formattedData.length === 0) {
                    formattedData.push(sectionHeader1, sectionHeader2, sectionHeader3, sectionHeader4);
                } else {
                    formattedData[0][columnOffset] = sectionHeader1[columnOffset];
                    formattedData[1][columnOffset] = sectionHeader2[columnOffset];
                    formattedData[2][columnOffset] = sectionHeader3[columnOffset];
                    formattedData[3][columnOffset] = sectionHeader4[columnOffset];

                    // Ensure other section headers also extend fully in the new columns
                    for (let i = 0; i < 4; i++) {
                        for (let j = 1; j <= 3; j++) {
                            formattedData[i][columnOffset + j] = [sectionHeader1, sectionHeader2, sectionHeader3, sectionHeader4][i][columnOffset + j];
                        }
                    }
                }

                let shift = 0; // Displacement (mm)
                let force = 0; // Force (N)
                let time = 0; // Time (s)

                const firstTime = parseFloat(rows[1][0]) || 0; // First time value
                const firstShift = parseFloat(rows[1][1]) || 0; // First shift value

                // Add data to the section
                for (let row = 1; row < blockSize; row++) {
                    let index = row;
                    let dataRow = formattedData[row + 3] || [];

                    if (index < rows.length) {
                        let entry = rows[index];
                        if (entry.length >= 6) {
                            if (!entry[0]) continue; // Skip empty rows


                            time = parseFloat(entry[0]) - firstTime || 0; // Time (s)

                            force = (parseFloat(entry[3]) || 0) + (parseFloat(entry[4]) || 0) + (parseFloat(entry[5]) || 0); // Force sum

                            if (firstShiftAbove1 === null && force >= 1) firstShiftAbove1 = shift; // Save first shift above 1 N

                            shift = parseFloat(entry[1]) - firstShift || 0; // Displacement (mm)


                            let deformation = (firstShiftAbove1 === null) ? 0 : (shift - firstShiftAbove1); // Calculate deformation

                            dataRow[columnOffset] = time;
                            dataRow[columnOffset + 1] = shift;
                            dataRow[columnOffset + 2] = force;
                            dataRow[columnOffset + 3] = deformation;
                        }
                    }
                    formattedData[row + 3] = dataRow;
                }

                columnOffset += 5; // Shift by 4 columns + 1 empty column
            }

            // Create the first sheet with data
            let ws = XLSX.utils.aoa_to_sheet(formattedData); // Convert data to Excel sheet
            XLSX.utils.book_append_sheet(wb, ws, sheetName); // Append a sheet to workbook

            // Create the second sheet with file order index
            let wsIndex = XLSX.utils.aoa_to_sheet(fileIndexData);  // Convert data to Excel sheet
            XLSX.utils.book_append_sheet(wb, wsIndex, "File Order"); // Append a sheet to workbook

            // Save the file
            XLSX.writeFile(wb, "merged_data.xlsx");
            console.log("‚úÖ Excel file created.");
        };

        input.click(); // Open file selection dialog
    }


</script>

</body>
</html>
