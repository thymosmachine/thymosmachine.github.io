<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>Moira controller</title>

    <!--
          __  __       _                          __ _
         |  \/  |     (_)                        / _| |
         | \  / | ___  _ _ __ __ _     ___  ___ | |_| |___      ____ _ _ __ ___
         | |\/| |/ _ \| | '__/ _` |   / __|/ _ \|  _| __\ \ /\ / / _` | '__/ _ \
         | |  | | (_) | | | | (_| |   \__ \ (_) | | | |_ \ V  V / (_| | | |  __/
         |_|  |_|\___/|_|_|  \__,_|   |___/\___/|_|  \__| \_/\_/ \__,_|_|  \___|


    -->
    <!-- https://patorjk.com/software/taag/#p=display&f=Big -->


    <script>
        const softwareVersion = "0.0.2.0";
        const softwareDate = "06.10.2025";

        // Initial title
        const initialTitle = 'ŒúŒø·øñœÅŒ±‚ÄáController‚Äá-‚ÄáThymos';


        document.title = initialTitle;

        // Clear console - Fresh start
        console.clear();
        console.info(`%c\n\nMoira Controller - Thymos\n`, "color: #007bff; font-size: 20px; font-weight: bold;");
        console.info(`%c\n\nVersion: ${softwareVersion} , Release-date: ${softwareDate}\n\nApp initialization: ${(new Date().toLocaleString()).replaceAll(". ", ".")}\n`, "color: gray; font-size: 12px; font-weight: normal;");


        fetch("shared-header.html")
            .then(res => res.text())
            .then(html => document.head.insertAdjacentHTML("beforeend", html));
    </script>

    <!-- External libraries: -->
    <!-- uPlot -->
    <link rel="stylesheet" href="packages/uplot/uPlot.min.css"> <!-- Add uPlot CSS for styling -->
    <script defer src="packages/uplot/uPlot.iife.min.js"></script> <!-- Add uPlot JavaScript -->

    <!-- XLSX -->
    <script async src="packages/xlsx/xlsx.full.min.js"></script> <!-- Add XLSX (MS Excel) JavaScript -->
    <!--    <script async src="https://unpkg.com/xlsx-js-style/dist/xlsx.bundle.js"></script>-->

    <!-- ZIP -->
    <!--    <script async src="packages/zip/jszip.min.js"></script> &lt;!&ndash; Add JSZip JavaScript &ndash;&gt;-->
    <script async src="packages/zip/pako.min.js"></script> <!-- Add Pako JavaScript (for DEFLATE) -->

    <!-- KaTeX -->
    <!-- source: "https://cdn.jsdelivr.net/npm/katex@0.16.9/" -->
    <link rel="stylesheet" href="packages/katex/katex.min.css">
    <script defer src="packages/katex/katex.min.js"></script>
    <script defer src="packages/katex/auto-render.min.js"></script>
    <script>
        // automatic rendering: inline \( ‚Ä¶ \) a $ ‚Ä¶ $, block \[ ‚Ä¶ \]
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\(", right: "\\)", display: false},
                    // {left: "$", right: "$", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ],
                ignoredTags: ["script", "noscript", "style", "textarea", "pre", "code", "kbd", "samp"],
                ignoredClasses: ["katex", "katex-display", "no-math"],
            });
        });
    </script>


    <script>
        /**
         * Try to load "debug.txt" (or any URL) and evaluate if the content is "true".
         * - File do not exist / 404 / error -> false
         * - Content after trimming is "y", "yes", "true" (case-insensitive) -> true
         * - Else -> false
         */
        async function checkDebugFlag(url = 'debug.txt', {timeoutMs = 5_000, bustCache = true} = {}) {
            // Timeout p≈ôes AbortController (protection against hanging requests)
            const controller = new AbortController();
            const t = setTimeout(() => controller.abort(), timeoutMs);

            // Optionally bust cache by adding a query parameter
            const finalUrl = bustCache ? `${url}${url.includes('?') ? '&' : '?'}_=${Date.now()}` : url;

            try {
                const res = await fetch(finalUrl, {
                    method: 'GET',
                    cache: 'no-store', // 'no-store' ensures we don't get a cached response
                    headers: {'Accept': 'text/plain'},
                    signal: controller.signal
                });

                if (!res.ok) {
                    // nap≈ô. 404 -> false
                    return false;
                }

                let text = await res.text();
                clearTimeout(t);

                // Delete BOM, trim whitespace
                text = text.replace(/^\uFEFF/, '').trim().toLowerCase();

                // true/TRUE/True atd.
                return text === 'true' || text === 'y' || text === 'yes';
            } catch (err) {
                // network error, timeout, CORS atp. -> false
                clearTimeout(t);
                return false;
            }
        }

        let debugging = false;

        (async () => {
            debugging = await checkDebugFlag(); // find "debug.txt" in the main directory
            console.info(`%c\nDebug mode ${debugging ? 'ON' : 'OFF'}`, "color: orange; font-size: 16px; font-weight: bold;");
            const debugWrapper = await document.getElementById('debuggingWrapper');

            if (debugging) {
                debugWrapper.style.display = 'flex';
                document.querySelector('html').style.background = 'lightcoral';


                // load 'scripts/testingScript.js'
                const script = document.createElement('script');
                script.src = './scripts/testingScript.js';
                script.type = 'text/javascript';
                script.type = 'text/javascript';
                document.head.appendChild(script);


                const systemLevelSelect = $ID('systemLevelSelect');
                if (systemLevelSelect) {
                    systemLevelSelect.querySelectorAll('option')?.forEach(option => {
                        if (option.value === 'admin') {
                            option.disabled = false;
                        } else if (option.value === 'developer') {
                            option.disabled = false;
                        } else if (option.value === 'god') {
                            option.disabled = false;
                        }
                    });
                }


            } else {
                debugWrapper?.remove();
                document.querySelector('html').style.background = 'none';
            }
        })();


    </script>

    <!--    <script type="text/plain" src="./scripts/appState.js"></script>-->

    <script>
        Object.defineProperty(window, "softwareVersion", {
            value: softwareVersion,
            writable: false,
            configurable: false,
            enumerable: true
        });

        async function hasInternet(timeout = 3000) {
            const ctrl = new AbortController();
            const t = setTimeout(() => ctrl.abort(), timeout);
            try {
                const res = await fetch(`/ping.txt?ts=${Date.now()}`, {
                    method: 'HEAD',
                    cache: 'no-store',
                    signal: ctrl.signal
                });
                return res.ok;
            } catch (err) {
                return false;
            } finally {
                clearTimeout(t);
            }
        }

        // try {
        //     // Check if the File System Access API is supported
        //     if ('showDirectoryPicker' in window) {
        //         console.info("‚úÖ File System Access API is supported.");
        //     } else {
        //         console.error("‚õî File System Access API is not supported.");
        //     }
        // } catch (error) {
        //     console.error("‚õî Error checking File System Access API support:", error);
        // }

        function compareVersions(versionA, versionB) {
            const a = versionA.trim().split('.').map(Number);
            const b = versionB.trim().split('.').map(Number);
            const maxLength = Math.max(a.length, b.length);

            for (let i = 0; i < maxLength; i++) {
                const numA = a[i] || 0; // missing parts are treated as 0
                const numB = b[i] || 0;

                if (numA > numB) return 1;  // A is newer
                if (numA < numB) return -1; // B is newer
            }
            return 0; // Versions are equal
        }

        let reallyOnline;


        async function loadCurrentVersion() {
            if (!reallyOnline) return;

            try {
                // Try to load the latest version of the app from the latest.txt [server]
                fetch(`/latest.txt?ts=${Date.now()}`, {
                    cache: "no-store"
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error("Network response was not ok");
                        }
                        return response.text();
                    })
                    .then(data => {
                        // Trim the data to remove any extra spaces or newlines and take the first line
                        const latestVersion = data.split("\n")[0].trim();
                        const appStatus = compareVersions(softwareVersion, latestVersion);

                        if (appStatus === 0) {
                            console.info("%c\n\tüîß\tApp is upto date!", "color: blue; font-weight: bold;");
                        } else if (appStatus === 1) {
                            console.warn("%c\n\tüîß\tAvailable version is older than App!", "color: red; font-weight: bold;");
                        } else {
                            console.info("%c\n\tüîß\tNew version is available!", "color: orange; font-weight: bold;");
                        }

                        if (appStatus !== 0) {
                            document.getElementById("updateHeader").style.visibility = "visible";
                            document.getElementById("updateHeaderVersion").innerText = `[from: v${softwareVersion} to v${latestVersion}]`;
                        }
                    })
                    .catch(error => {
                        console.error("‚õî Error fetching latest version:", error);
                    });
            } catch (error) {
                console.error("‚õî Error checking File System Access API support:", error);
            }
        }

        // is online?
        document.addEventListener("DOMContentLoaded", async () => { // TODO: do async or window.onload ?
            reallyOnline = await hasInternet();
            if (reallyOnline) {
                console.info("%cüì∂ Ping successful. User is Online! üåê", "color: blue; font-weight: bold;");

                document.getElementById("softwareInfo").innerText = `v${softwareVersion} , ${softwareDate}`;

                await loadCurrentVersion();
            } else {
                console.info("%cüì¥ Offline.", "color: gray; font-weight: bold;");
            }
        });
    </script>


    <style>
        :root {
            --blue-dark-color: #004aa6;
            --blue-color: #007bff;
            --blue-lighter-color: #2196F3;
            --blue-light-color: #4CA2FF;
            --blue-lighest-color: #4bbae0;
            --green-color: #28a745;
            --green-light-color: #68C17C;
            --green-lighter-color: #90EE90;
            --red-color: #dc3545;
            --red-light-color: #E6717C;
            --red-lighter-color: #FFB6C1FF;
            --yellow-color: #FFD580;
            --orange-color: #ffc107;
            --darkorange-color: #FF8C00;
            --cyan-color: #17a2b8;
            --cyan-light-color: #3FC1E8;
            --cyan-lighter-color: #87CEEB;
            --purple-color: #6f42c1;
            --purple-light-color: #9B59B6;
            --purple-lighter-color: #D2B4DE;
            --pink-color: #e83e8c;
            --pink-light-color: #FF69B4;
            --pink-lighter-color: #FFB6C1;
            --light-color: #f8f9fa;
            --mid-color: #e9ecef;
            --mid-dark-color: #adb5bd;
            --dark-color: #ced4da;
            --dark-light-color: #495057;
            --darker-color: #343a40;
            --gray-color: #6c757d;


            --progressPrimary-color: linear-gradient(to right, var(--cyan-lighter-color), var(--cyan-light-color), var(--cyan-color)); /* Blue color for secondary progress */
            --progressSecondary-color: linear-gradient(to right, var(--purple-lighter-color), var(--purple-light-color), var(--purple-color)); /* Blue color for primary progress */
            --progressOnHold-color: linear-gradient(to right, var(--blue-light-color), var(--blue-lighter-color), var(--blue-color), var(--blue-dark-color)); /* Green color for completed progress */
            --progressDone-color: linear-gradient(to right, var(--green-lighter-color), var(--green-light-color), var(--green-color)); /* Green color for completed progress */
            --progressStoppedcolor: linear-gradient(to right, var(--yellow-color), var(--orange-color), var(--darkorange-color)); /* Green color for ongoing progress */
            --progressError-color: linear-gradient(to right, var(--red-lighter-color), var(--red-light-color), var(--red-color)); /* Red color for error progress */

            --progressColor: var(--progressPrimary-color); /* --blue-color // --orange-color  ///   linear-gradient(to right, #FFD580, #FF8C00) */

            --radius: 10px;

            --inputLabelWidth: 275px;
            --inputMinWidth: 230px;
            --gap: 10px;
        }


        html * {
            transition: color 0.3s, background 0.3s, background-color 0.3s, border-color 0.3s, filter 0.2s;
            /*scroll-behavior: smooth;*/
        }

        body[data-theme="light"] {
            --page-bg: white;
            --color-bg: var(--mid-color);
            --containers-bg: var(--dark-color);

            --chart-text: black;
            --charts-bg: #e6e6e6;
            --charts-bg-active: white;
            --chart-border: lightgray;

            --text-color: black;
            --text-info-1-color: var(--blue-lighter-color);
            --text-info-2-color: var(--blue-dark-color);
            --text-info-3-color: var(--blue-dark-color);

            --slider-bg: #ddd;
            --slider-fg: var(--blue-color);
            --slider-btn: var(--blue-dark-color);
            --input-bg: white;
            --button-color: #f0f0f0;
            --button2-color: var(--blue-color);
            --logBtn-bg: var(--gray-color);
            --border-color: darkgray;
            --headerPanel-color: darkgray;
            --progress-bg: #eee;

            --regular-log-color: darkgray;
            --loading-log-color: #323232;
            --command-log-color: #f5f5f5;


            --startEpx-bg: lightblue;
            --startEpx-color: var(--blue-color);
            --stopEpx-bg: lightpink;
            --stopEpx-color: var(--red-color);
            --returnEpx-bg: lightgray;
            --returnEpx-color: black;

            --logo-bg: white;
            --logo-fg: var(--blue-color);
            --logo-text: var(--blue-color);

            --highligth: rgba(255, 255, 255, 0.5);
            --shadow: rgba(0, 0, 0, 0.2);
        }

        body[data-theme="dark"] {
            /*--page-bg: var(--darker-color);*/
            /*--color-bg: var(--dark-light-color);*/
            /*--containers-bg: var(--gray-color);*/
            /*--charts-bg: var(--gray-color);*/
            /*--charts-bg-active: var(--mid-dark-color);*/
            /*--text-color: white;*/
            /*--slider-bg: var(--mid-dark-color);*/
            /*--input-bg: var(--mid-dark-color);*/
            /*--button-color: var(--mid-dark-color);*/
            /*--button2-color: var(--blue-color);*/
            /*--logBtn-bg: var(--dark-light-color);*/
            /*--border-color: var(--gray-color);*/
            /*--headerPanel-color: var(--gray-color);*/

            --page-bg: #181818;
            --color-bg: #212121;
            --containers-bg: #303030;

            --chart-text: black;
            --charts-bg: #303030;
            --charts-bg-active: #b4b4b4;
            --chart-border: #4e4e4e;

            --text-color: #b4b4b4;
            --text-info-1-color: #4e4e4e;
            --text-info-2-color: black;
            --text-info-3-color: var(--blue-lighest-color);

            --slider-bg: #4e4e4e;
            --slider-fg: #303030;
            --slider-btn: #212121;
            --input-bg: #4e4e4e;
            --button-color: #4e4e4e;
            --button2-color: var(--dark-light-color);
            --logBtn-bg: var(--dark-light-color);
            --border-color: #303030;
            --headerPanel-color: var(--gray-color);
            --progress-bg: var(--gray-color);

            --regular-log-color: #4e4e4e;
            --loading-log-color: #181818;
            --command-log-color: #212121;

            --startEpx-bg: var(--blue-light-color);
            --startEpx-color: lightblue;
            --stopEpx-bg: var(--red-light-color);
            --stopEpx-color: lightpink;
            --returnEpx-bg: var(--gray-color);
            --returnEpx-color: #181818;

            --logo-bg: var(--blue-light-color);
            --logo-fg: var(--page-bg);
            --logo-text: var(--blue-light-color);

            --highligth: rgba(255, 255, 255, 0.2);
            --shadow: rgba(0, 0, 0, 0.4);
        }

        /* General styling for the body */
        body {
            font-family: Arial, sans-serif;
            min-width: 650px;
            padding: 5px 20px 0;
            border-radius: 1em;
            background: var(--page-bg);
            color: var(--text-color);
            overflow-x: hidden;
            overflow-y: hidden;
        }

        *:disabled {
            background-color: #f0f0f0;
            color: #888;
            cursor: not-allowed;
        }

        .u {
            text-decoration: underline;
            text-underline-offset: 0.1em; /* offset from text */
            text-decoration-thickness: 0.1em; /* line thickness */
            text-decoration-color: color-mix(in srgb, var(--text-color), white 50%); /* line color */
            text-decoration-skip-ink: auto; /* avoid descenders from letters */
        }

        .insetShadow {
            box-shadow: inset 2px 2px 3px rgba(0, 0, 0, 0.2), inset -2px -2px 5px rgba(0, 0, 0, 0.15);
        }

        .outsetShadow {
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.15), 0 0 5px rgba(0, 0, 0, 0.35);
        }

        /* Button styling for spacing and cursor behavior */
        button {
            padding: 5px;
            cursor: pointer;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            font-size: 14px;
            background: var(--button-color);

            user-select: none; /* Disables text selection */
            color: color-mix(in srgb, var(--text-color) 10%, black);

            box-shadow: inset 2px 2px 5px var(--highligth), inset -2px -2px 3px var(--shadow);
        }

        /* When the button is hovered */
        button:not(:disabled):hover {
            filter: brightness(1.15); /* 15% brighter */
            transform: scale(1.05); /* Slightly larger */
            z-index: 4;
        }

        /* When the button is clicked */
        button:not(:disabled):active {
            filter: brightness(0.85); /* 15% darker */
            transform: scale(0.95); /* Slightly smaller */
            box-shadow: inset 2px 2px 3px rgba(0, 0, 0, 0.35), inset -2px -2px 3px rgba(0, 0, 0, 0.2);
        }

        /* Styling for textAreas used for user input */
        textarea {
            resize: none; /* Disables resizing */
            overflow: auto;
            border: none;
        }

        input, select, .textareaWrapper {
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 0 6px;
        }

        input:not([type="checkbox"]), select, textarea {
            background: var(--input-bg);
            min-height: 34px;
            box-sizing: border-box;

            font-family: Arial, sans-serif;
            font-size: 13px;
            font-weight: normal;

            color: var(--text-color);
            box-shadow: inset 2px 2px 3px rgba(0, 0, 0, 0.15), inset -2px -2px 3px rgba(0, 0, 0, 0.1);
        }

        input[type="checkbox"] {
            accent-color: var(--blue-color);
        }

        label {
            pointer-events: none; /* makes labels unselectable */
        }

        pre {
            white-space: pre-wrap; /* zachov√° \n a v√≠cen√°sobn√© mezery, ale dovol√≠ zalomen√≠ */
            overflow-wrap: break-word; /* prim√°rnƒõ l√°me na mezer√°ch, dlouh√° slova zlom√≠ jen kdy≈æ mus√≠ */
            word-break: normal; /* nemrskej slova zbyteƒçnƒõ (CJK nech norm√°lnƒõ) */
            hyphens: auto; /* voliteln√©: p≈ôid√° dƒõlen√≠ slov (s hyfenac√≠) */
        }

        .textareaWrapper {
            display: flex;
            background: var(--input-bg);
            width: -webkit-fill-available;
            height: min-content;
            padding: 4px;
            overflow: hidden;
            box-shadow: inset 2px 2px 3px rgba(0, 0, 0, 0.15), inset -2px -2px 3px rgba(0, 0, 0, 0.1);
        }

        .textareaWrapper:not(:disabled):focus-within {
            outline: 2px solid black; /* vlastn√≠ barva */
            outline-offset: -2px;
            box-shadow: 0 0 0 1px var(--input-bg);
        }

        .textareaWrapper textarea {
            width: 100%;
            padding: 3px 7px;
            box-shadow: none;
            background: transparent;
        }

        .textareaWrapper textarea:not(:disabled):focus {
            outline: none;
        }

        /* Disabled elements styling */
        .prohibited, .disabled, .prohibited *, .disabled * {
            cursor: not-allowed !important;
            user-select: none !important; /* Disables text selection */
            -webkit-user-select: none !important; /* Safari */
            -moz-user-select: none !important; /* Firefox */
            -ms-user-select: none !important; /* IE/Edge */
            pointer-events: none !important; /* Prevents interaction */
            tab-index: -1 !important;
            outline: none !important;
        }

        .prohibited, .disabled {
            opacity: 0.5;
        }

        .undisplayed {
            display: none !important;
        }

        .invisible {
            visibility: hidden !important;
        }


        .sizeableContainer {
            overflow: hidden;
            content-visibility: auto;

            max-height: 0;
            opacity: 0;
            transition: max-height 0.5s ease, opacity 0.45s; /* Animation */

            display: block;
            width: 95%;
            padding: 5px 15px 20px 15px;
            justify-self: center;
            justify-content: center;
        }

        .input-group {
            display: inline-flex;
            gap: var(--gap); /* Space between inputs and labels */
            white-space: nowrap; /* Prevents wrapping */
            padding-left: 20px;
            align-items: center;
            width: calc(var(--inputLabelWidth) + var(--inputMinWidth) + var(--gap)); /* Total width of the group */

        }

        .input-group label {
            flex-shrink: 0; /* Prevents shrinking */
            text-align: right;
            width: var(--inputLabelWidth); /* Label width */
            white-space: normal; /* Allows wrapping if necessary */
        }

        .input-group input {
            height: 25px;
        }

        .input-group input[type="number"], .input-group input[type="text"], .input-group select {
            flex-grow: 1; /* Input will grow if there is space */
            justify-self: left;
            width: -webkit-fill-available;
        }

        input[type="checkbox"] {
            transform: scale(1.5); /* Scale the checkbox to 1.5 */
            margin: 5px; /* Space around the checkbox */
            width: 16px;
            height: 16px;
            aspect-ratio: 1/1; /* Keep it square */
        }

        .input-group select {
            font-family: monospace;
            font-weight: bold;
            font-size: 16px;
        }

        h3 {
            position: relative;
            margin-top: 20px;
            margin-bottom: 5px;
            align-self: flex-start;
        }

        h4 {
            position: relative;
            margin-top: 5px;
            margin-bottom: 5px;
        }


        hr {
            width: 100%;
            margin: 20px auto;
            border: 1px solid gray;
        }


        .headerContainer {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            gap: var(--gap);
        }

        #nameHeader {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: var(--gap);
        }

        #updateHeader {
            visibility: hidden;

            font-weight: bold;
            display: flex;
            flex-direction: column;
            color: var(--headerPanel-color);
            font-size: 12px;
            text-align: right;
        }

        .statusContainer {
            gap: var(--gap);
            display: flex;
            justify-self: center;
            justify-content: center;
            align-items: center;
            flex-direction: column;

            background: var(--color-bg);
            padding: 10px 20px;
            border-radius: var(--radius);
        }

        .graphContainer {
            display: flex;
            width: 100%;
            max-width: 1600px;
            flex-direction: column;
            margin-top: 50px;
            margin-bottom: 50px;
            align-items: center;
            justify-self: center;
            padding: 20px;
            background: var(--color-bg);
            border-radius: 10px;
        }

        .sectionTitle {
            margin-top: 0;
        }

        .inlineDiv {
            display: inline-flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: calc(var(--gap) * 2.5);
        }

        .inlineDiv .inlineDiv {
            gap: calc(var(--gap));
        }

        #inputNumBaudRate {
            padding: 5px;
            width: 140px;
            height: 50px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        #connectionStatus {
            font-weight: bold;
            color: gray;
        }

        .graphBtnWrapper {
            display: flex;
            gap: var(--gap);
        }

        .connectBtn {
            padding: 5px 20px;
            height: 50px;
            width: 160px;
            min-width: 135px;
        }

        .btnGraph {
            display: flex;
            min-width: 100px;
            height: 50px;
            padding: 20px;
            align-items: center;
            justify-content: center;
        }

        #thymosLogo {
            width: 50px;
            height: 50px;
        }

        #chartsWrapper {
            width: 100%;
            min-height: min-content;
            gap: 20px;

            color: var(--chart-text);
            background: var(--charts-bg);
            border-radius: 10px;
            border: 2px solid var(--chart-border);
            padding: 1em 0.5em 2em;
            margin: 15px 0 10px;
        }

        #chartsContainer, #chartsInfoContainer {
            display: flex;
            justify-content: space-between;
            width: 100%;
            min-height: min-content;
            gap: 20px;
        }

        #chartsInfoContainer {
            margin-top: calc(3 * var(--gap));
            justify-content: space-around;
        }


        .chart {
            width: 49%;
            height: 400px;
        }

        /*.chartWrapper {*/
        /*    display: flex;*/
        /*    width: 49%;*/
        /*    height: fit-content;*/
        /*    flex-direction: column;*/
        /*    gap: max(calc(var(--gap) * 2.5), 25px);*/
        /*    justify-content: center;*/
        /*    align-items: center;*/
        /*}*/

        /*.chart {*/
        /*    display: flex;*/
        /*    width: 100%;*/
        /*    height: fit-content;*/
        /*    max-height: 400px;*/
        /*}*/


        #controlContainer {
            display: grid;
            grid-template-columns:  1fr auto;
            grid-auto-rows: auto;
            gap: 30px;
            width: 100%;
            justify-content: center;
        }

        .controlBtn.moveBtnLeft, .controlBtn.moveBtnRight {
            position: relative;
            touch-action: none;
            background: var(--button2-color);
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
            justify-content: center;
            border-radius: 50vh 0 0 50vh;
            min-width: 0;
            width: 100px;
            height: 50px;
            border: none;
            transform: translateX(1px);
            z-index: 3;

            box-shadow: inset 2px 2px 5px var(--highligth), inset 0 -2px 3px var(--shadow);
        }

        #moveMachineUP {
            padding-top: .2rem; /* men≈°√≠ naho≈ôe */
            padding-bottom: .8rem; /* vƒõt≈°√≠ dole -> text vypad√° v√Ω≈° */
        }

        #moveMachineDOWN {
            padding-top: .6rem; /* vƒõt≈°√≠ naho≈ôe */
            padding-bottom: .4rem; /* men≈°√≠ dole -> text vypad√° n√≠≈æ */
        }


        .controlBtn.moveBtnRight {
            border-radius: 0 50vh 50vh 0;
            font-size: 16px;
            width: 65px;
            font-style: italic;
            transform: translateX(-1px);
            z-index: 2;

            box-shadow: inset 0 2px 5px var(--highligth), inset -2px -2px 3px var(--shadow);
        }


        .movementWrapper {
            /*background: var(--button2-color);*/
            border-radius: 50vh;
            position: relative;
            display: flex;
        }

        .controlBtn.moveBtnRight:not(:disabled):hover {
            transform: scale(1.05) translateX(calc((65px * (0.05 / 2))));
        }

        .controlBtn.moveBtnLeft:not(:disabled):hover {
            transform: scale(1.05) translateX(calc((100px * (-0.05 / 2)) + 2px));
        }

        .controlBtn.moveBtnRight:not(:disabled):active {
            transform: scale(0.9) translateX(calc((65px * (-0.1 / 2)) - 1px));
        }

        .controlBtn.moveBtnLeft:not(:disabled):active {
            transform: scale(0.9) translateX(calc((100px * (0.05 / 2)) + 5px));
        }

        /* svisl√° ƒç√°ra vlevo od 10% do 90% v√Ω≈°ky */
        .movementWrapper::before {
            content: "";
            position: absolute;
            left: calc(100px - 1px / 2); /* p≈ôesnƒõ na lev√©m kraji */
            top: 15%;
            bottom: 15%; /* => v√Ω≈°ka = 80 % */
            width: 3px; /* tlou≈°≈•ka ƒç√°ry */
            background: var(--text-info-2-color); /* nebo nap≈ô. #0ea5e9 */
            border-radius: 2px; /* hezk√© zakonƒçen√≠ */
            pointer-events: none;
            z-index: 6;
        }


        .controllerBtn {
            touch-action: none;
            background: var(--button2-color);
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            justify-content: center;
            border-radius: var(--radius);
            border: none;
        }

        .machineControlContainer {
            display: flex;
            flex-grow: 1;
            flex-direction: column;
            gap: 15px;
            align-items: flex-start;
            justify-content: center;
            margin-top: 20px;

            background: var(--containers-bg);
            border-radius: var(--radius);
            padding: 20px;
        }

        .btnControlWrapper {
            display: flex;
            flex-direction: row;
            width: 100%;
            gap: var(--gap);
            align-items: center;
            justify-content: left;
        }

        .controlBtn {
            display: flex;
            height: 50px;
            width: clamp(100px, 170px, 200px);
            padding: 20px;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        #startExperiment {
            background: var(--startEpx-bg);
            color: var(--startEpx-color);
            border-color: color-mix(in srgb, var(--startEpx-color) 30%, transparent);
        }

        #stopMachine {
            background: var(--stopEpx-bg);
            color: var(--stopEpx-color);
            border-color: color-mix(in srgb, var(--stopEpx-color) 30%, transparent);
        }

        #returnPositionExperimentBtn {
            background: var(--returnEpx-bg);
            color: var(--returnEpx-color);
            border-color: color-mix(in srgb, var(--returnEpx-color) 30%, transparent);
            width: 200px;
        }

        #experimentProgress {
            flex-grow: 1;
            max-width: 450px;
            min-width: 50px;
            height: 15px;
            appearance: none; /* reset of style */
        }

        /* For Chrome, Edge (outer frame of progressbar) */
        progress::-webkit-progress-bar {
            background-color: var(--progress-bg); /* background color */
            border-radius: calc(15px / 2); /* roundness to 50% */
            border: 1px solid var(--border-color);
            box-shadow: inset 2px 2px 3px var(--shadow);
            transition: background 0.3s ease;
            overflow: hidden;
        }

        /* For Chrome, Edge (internal infill part of progressbar) */
        progress::-webkit-progress-value {
            background: var(--progressColor); /* infill color */
            box-shadow: inset 2px 2px 3px var(--shadow);
            border-radius: calc(15px / 2);
            transition: background 0.3s ease;
            overflow: hidden;
        }

        /* For Firefox (internal infill part of progressbar) */
        progress::-moz-progress-bar {
            background: var(--progressColor); /* infill color */
            box-shadow: inset 2px 2px 3px var(--shadow);
            border-radius: calc(15px / 2);
            transition: background 0.3s ease;
            overflow: hidden;
        }

        #experimentProgressLabel {
            font-size: 15px;
            display: inline-block;
            min-width: 65px; /* nebo fixn√≠ width */
            text-align: center; /* voliteln√©, zarovn√°n√≠ obsahu */
        }

        #progressWrapper {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--gap);
            flex-grow: 1;
            width: 100%;
            min-width: 50px;
            padding-left: 5px;
        }

        .experimentContainer {
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: var(--gap);
            left: 0;
            justify-self: center;
            align-items: center;
            width: 100%;
            max-width: 1300px;

            background: var(--color-bg);
            border-radius: var(--radius);
        }

        .appSelector {
            min-width: 200px;
            width: max-content;
            height: 50px;
        }

        #experimentInputsContainer {
            display: grid;
            grid-template-columns: max-content minmax(min-content, 1fr) min-content;
            grid-auto-rows: auto;
            max-width: 1200px;
            width: 100%;
            min-width: 300px;
            gap: var(--gap);
            justify-items: left;
        }

        #experimentName, #experimentCount {
            flex-grow: 1;
            /*height: 24px;*/
            height: 44px;
            padding: 0 10px;
            /*background: lightgray;*/
        }

        #experimentCount {
            max-width: 65px;
            box-sizing: border-box; /* THIS IS THE MAGIC */
        }

        #convertCSV {
            height: 56px;
        }

        #experimentDesc {
            height: 46px;
        }

        #experimentBtnsWrapper {
            display: flex;
            width: fit-content;
            flex-direction: column;
            gap: var(--gap);
        }

        #saveDataBtn {
            width: 150px;
            height: 44px;
        }

        #convertCSV {
            width: 150px;
        }

        .openingContainer {
            position: relative;
            display: flex;
            align-items: flex-start;
            width: 100%;
            background: var(--containers-bg);
            border-radius: calc(1px + 10px);
            border: 1px solid var(--border-color);
        }

        .openingContainerBtn {
            padding: 10px;
        }

        .inputsContainer, #machSettings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(calc(var(--inputLabelWidth) + var(--inputMinWidth) + var(--gap) + 20px + 5px), 1fr)); /* Dynamic grid */
            grid-auto-rows: auto;
            overflow: hidden;
            width: -webkit-fill-available;
            gap: var(--gap);
            justify-items: center;
        }

        /* prvek p≈ôes celou ≈°√≠≈ôku gridu v obou kontejnerech */
        .inputsContainer > #machSettings {
            grid-column: 1 / -1; /* od prvn√≠ho po posledn√≠ sloupec */
            max-width: 100%;
        }

        .inputsContainer .katex-display {
            margin: 0;
        }

        .katex-display, .katex-display * {
            transition: none !important;
        }


        .inputsContainer button {
            width: 80%;
            max-width: 200px;
        }


        .autoGrid {
            grid-template-columns: repeat(auto-fit, minmax(max-content, 1fr));
            grid-auto-rows: auto;
            justify-items: center;
        }

        .innerInputLabel {
            min-width: fit-content;
            width: 125px !important;
        }

        .innerInput {
            min-width: 25px;
        }

        #inputInitialForceLabel {
            width: 100px;
        }

        #clearStorageButton {
            padding: 20px;
        }

        #regularLog, #loadingLog, #commandInput {
            padding: 10px;
        }

        #consoleContainer {
            display: grid;
            grid-template-columns: 1fr;
            grid-auto-rows: auto;
            gap: var(--gap);
            width: 100%;
            padding-top: 20px;
        }

        #regularLogWrapper {
            min-width: 300px;
            width: 100%;
            flex-grow: 1;
            height: 200px;
            background: var(--regular-log-color);
            border: 2px solid var(--regular-log-color);
            margin: 0;
            border-radius: 10px;
            overflow: hidden;
            font-size: 12px;
        }

        #regularLog {
            width: -webkit-fill-available;
            height: -webkit-fill-available;
            overflow-y: auto;
            box-sizing: border-box;
            margin: 0;
        }

        #loadingLog {
            width: 100%;
            min-width: 300px;
            height: 80px;
            background: var(--loading-log-color);
            border-radius: 10px;
            margin: 0;
        }

        .logContainer {
            display: flex;
            width: 100%;
            flex-direction: row;
            gap: var(--gap);
        }

        .logBtn {
            height: -webkit-fill-available;
            min-width: 150px;
            background: var(--logBtn-bg);
            color: white;
        }

        #commandInput {
            width: 100%;
            min-width: 300px;
            height: 40px;
            border: none;
            background: var(--command-log-color);
            border-radius: 10px;

            padding: 7px 10px;
            font-size: 16px;
            font-family: monospace;

        }

        input[type="range"] {
            accent-color: #007bff; /* zmƒõna barvy na modrou (nov√© prohl√≠≈æeƒçe) */
            box-shadow: inset 2px 2px 5px var(--highligth), inset -2px -2px 3px var(--shadow);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: var(--slider-bg);
            border-radius: 3px;
            outline: none;
            /*border: none;*/
        }

        /* Styl pro slider track (Chrome, Safari) */
        input[type="range"]::-webkit-slider-runnable-track {
            background: var(--slider-fg);
            height: 6px;
            border-radius: 2px;
        }

        /* Styl pro slider thumb (Chrome, Safari) */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 25%;
            background: var(--slider-btn);
            cursor: pointer;
            margin-top: -5px;
        }

        /* Firefox: track */
        input[type="range"]::-moz-range-track {
            /*background: #007bff;*/
            height: 6px;
            border-radius: 3px;
        }

        /* Firefox: thumb */
        input[type="range"]::-moz-range-thumb {
            background: var(--slider-btn);
            height: 16px;
            width: 16px;
            border-radius: 25%;
            cursor: pointer;
        }

        .sliderInputLabel {
            display: flex;
            align-items: center;
            min-width: 1.5em;
            max-width: 4.5em;
            border: 1px solid transparent;
            font-size: 16px !important;
            text-align: right !important;
            color: var(--text-info-2-color) !important;
            font-weight: bold !important;
            background: none !important;
            box-shadow: none !important;
        }

        .sliderInputLabel:not(:disabled):hover {
            cursor: pointer;
            color: var(--text-info-2-color) !important;;
            background: var(--input-bg) !important;
            border: 1px solid var(--border-color);
        }


        .sliderInputLabel:not(:disabled):focus {
            outline: none;
            color: var(--text-color) !important;;
            background: var(--input-bg) !important;
            border: 1px solid var(--text-info-2-color);
        }

        .sliderInputLabel::-webkit-outer-spin-button,
        .sliderInputLabel::-webkit-inner-spin-button {
            -webkit-appearance: none;
        }

        #positionWrapper {
            width: 0.1rem; /* tlou≈°≈•ka ƒç√°ry */
            height: 14px;
            background: black;
            opacity: 65%;
            border-radius: 2px;
            pointer-events: none;
            z-index: 5;
        }

        button {
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
        }

        .units-text {
            font-size: 14px;
            color: #4f4f4f;
        }


    </style>


    <style>
        /* ========== BASE: shared wrapper of action pills ========== */
        .action-wrap, .copy-wrap { /* '.copy-wrap' left for backward compatibility */
            position: relative;
            display: inline-flex;
            flex-grow: 1;
            max-width: 230px;
        }

        /* Base of pills (copy / set) */
        .action-pill,
        .copy-pill, .adjust-pill { /* compatibility: copy/adjust made from action-pill */
            height: clamp(24px, 80%, 40px) !important;
            aspect-ratio: 1/1 !important;
            width: auto !important;

            position: absolute;
            top: 50%;
            right: 5px;
            transform: translateY(-50%) !important;
            z-index: 9999;

            border: 0;
            padding: 6px;
            border-radius: 9999px;

            background: rgba(255, 255, 255, .55);
            -webkit-backdrop-filter: blur(6px);
            backdrop-filter: blur(6px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, .1);

            cursor: pointer;
            line-height: 0;

            opacity: 0;
            pointer-events: none;
            transition: opacity .15s ease, background .2s ease, transform .1s ease;
        }

        .action-pill:hover {
            background: rgba(255, 255, 255, .7);
            transform: translateY(-50%) !important;
        }

        .action-pill:active {
            transform: scale(.95) translateY(calc(-50% + 1px)) translateX(1px) !important;
        }

        .action-wrap:hover .action-pill,
        .action-pill.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .action-pill.hidden {
            display: none !important;
        }

        /* Icons inside pills (deff: hide or show) */
        .action-pill svg {
            display: none;
            width: 100%;
            height: 100%;
        }

        /* COPY: gray/OK/ERR */
        .copy-pill[data-state="idle"] .icon-copy {
            display: block;
            stroke: #6b7280;
        }

        .copy-pill[data-state="ok"] .icon-check {
            display: block;
            stroke: #22c55e;
        }

        .copy-pill[data-state="err"] .icon-x {
            display: block;
            stroke: #ef4444;
        }

        /* ADJUST: gray/OK/ERR */
        .adjust-pill[data-state="idle"] .icon-wand {
            display: block;
            stroke: #3b82f6;
        }


        .adjust-pill[data-state="set"] .icon-wand {
            display: block;
            stroke: #6b7280;
        }

        .adjust-pill[data-state="diff"] .icon-wand {
            display: block;
            stroke: #ff8c00;
        }

        .adjust-pill[data-state="ok"] .icon-check {
            display: block;
            stroke: #22c55e;
        }

        .adjust-pill[data-state="err"] .icon-x {
            display: block;
            stroke: #ef4444;
        }

        /* Visual feedback inside the wrapper on hover (only when not focused/action) */
        .action-wrap:hover > .copyableInput:not(:focus):not(.action-ok):not(.action-err) {
            outline: none;
            box-shadow: inset 0 0 0 2px #3b82f6;
            transition: box-shadow .1s ease;
        }

        .action-wrap.has-auto:hover > .adjustableInput:not(:focus):not(.action-ok):not(.action-err) {
            outline: none;
            box-shadow: inset 0 0 0 2px #6b7280;
            transition: box-shadow .1s ease;
        }

        /* post-action */
        .action-wrap > .action-ok {
            outline: none;
            box-shadow: inset 0 0 0 2px #22c55e;
            transition: box-shadow .1s ease;
        }

        .action-wrap > .action-err {
            outline: none;
            box-shadow: inset 0 0 0 2px #ef4444;
            transition: box-shadow .1s ease;
        }

        /* Pomocn√° utilita, pokud ji u≈æ nƒõkde pou≈æ√≠v√°≈° */
        .data-eq {
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
    </style>

</head>

<body>


<div id="preloadScreen"
     tabindex="-1"
     style="position: fixed;
            inset: 0;              /* top:0; right:0; bottom:0; left:0 */
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-flow: column; gap: 5%;
            background: #181818; justify-content: center; align-items: center;  z-index: 999;
            user-select: none !important; /* Disables text selection */
            -webkit-user-select: none !important; /* Safari */
            -moz-user-select: none !important; /* Firefox */
            -ms-user-select: none !important; /* IE/Edge */
            pointer-events: auto; /* Prevents interaction */
            tab-index: -1 !important;
            color: lightgray; font-weight: bold; text-align: center; font-size: 2em;
            opacity: 1;
            transition: opacity 0.5s;">
    <noscript>
        <div style="color: red;">
            JavaScript is disabled in your browser. Please enable it to use this application.
        </div>
    </noscript>

    <svg style="width:10%; height: auto; aspect-ratio: 1/1" viewBox="0 0 177.81437 177.9034"
         xmlns="http://www.w3.org/2000/svg">
        <g transform="translate(225.12939,129.3157)">
            <path fill="lightgray" stroke="lightgray" stroke-width="4.63292"
                  d="m -183.53862,7.9393313 0.37992,-28.6806303c -3.46806,-0.838763 -6.47358,-2.670752 -8.82206,-5.154387 -3.35392,-3.546427 -5.32276,-8.431072 -5.32276,-13.618672v -30.30165c 0,-9.89763 4.27076,-21.98757 12.85714,-30.761632 6.93867,-7.09086 16.65032,-12.05614 29.13465,-12.05614h 67.983775l 11.83638,83.692256 -18.4011,0.0017v 60.189316l -3.79175,0.439257c -0.15191,0.02838 -53.466715,6.885861 -53.466715,-57.521684h 8.55402c 0,44.888568 29.48901,49.136615 40.15129,49.207313v -60.833856h 17.131595l -9.42174,-66.617732h -60.575755c -9.92062,0 -17.59527,3.90532 -23.05376,9.483912 -6.93498,7.08604 -10.38374,16.82239 -10.38374,24.78041v 30.30165c 0,2.99757 1.10511,5.78559 2.98196,7.77034 1.70875,1.80842 4.10749,2.95469 6.91965,2.95469h 4.31732l -0.4861,36.8294603 -8.52222,-0.102216 z"
            />
            <path fill="lightgray" stroke="lightgray" stroke-width="4.63292"
                  d="m -115.91317,-44.595488c 5.72369,0 10.36216,-4.63847 10.36216,-10.36102 0,-5.72256 -4.63847,-10.3613 -10.36216,-10.3613 -5.72255,0 -10.36102,4.63874 -10.36102,10.3613 0,5.72255 4.63847,10.36102 10.36102,10.36102"
            />
        </g>
    </svg>
    <span>Loading...</span>
</div>

<main id="app">
    <section class="headerContainer">

        <div id="nameHeader">
            <svg id="thymosLogo" class="custom-icon" viewBox="0 0 177.81437 177.9034"
                 xmlns="http://www.w3.org/2000/svg">
                <style>
                    .rect-bg {
                        fill: var(--logo-bg, white);
                        stroke: var(--logo-bg, white);
                    }

                    .dot-shape, .main-shape {
                        fill: var(--logo-fg, black);
                        stroke: var(--logo-fg, black);
                    }
                </style>

                <g transform="translate(225.12939,129.3157)">
                    <rect class="rect-bg" width="130.01212" height="130.01208" x="-201.22827" y="-105.37005"
                          ry="9.1106987" rx="9.4112854" stroke-width="47.8913"/>
                    <path class="main-shape" stroke-width="4.63292"
                          d="m -183.53862,7.9393313 0.37992,-28.6806303c -3.46806,-0.838763 -6.47358,-2.670752 -8.82206,-5.154387 -3.35392,-3.546427 -5.32276,-8.431072 -5.32276,-13.618672v -30.30165c 0,-9.89763 4.27076,-21.98757 12.85714,-30.761632 6.93867,-7.09086 16.65032,-12.05614 29.13465,-12.05614h 67.983775l 11.83638,83.692256 -18.4011,0.0017v 60.189316l -3.79175,0.439257c -0.15191,0.02838 -53.466715,6.885861 -53.466715,-57.521684h 8.55402c 0,44.888568 29.48901,49.136615 40.15129,49.207313v -60.833856h 17.131595l -9.42174,-66.617732h -60.575755c -9.92062,0 -17.59527,3.90532 -23.05376,9.483912 -6.93498,7.08604 -10.38374,16.82239 -10.38374,24.78041v 30.30165c 0,2.99757 1.10511,5.78559 2.98196,7.77034 1.70875,1.80842 4.10749,2.95469 6.91965,2.95469h 4.31732l -0.4861,36.8294603 -8.52222,-0.102216 z"
                    />
                    <path class="dot-shape" stroke-width="4.63292"
                          d="m -115.91317,-44.595488c 5.72369,0 10.36216,-4.63847 10.36216,-10.36102 0,-5.72256 -4.63847,-10.3613 -10.36216,-10.3613 -5.72255,0 -10.36102,4.63874 -10.36102,10.3613 0,5.72255 4.63847,10.36102 10.36102,10.36102"
                    />
                </g>
            </svg>

            <div style="display: flex; flex-direction: column; align-content: space-between;">
                <div style="border-bottom: 2px solid var(--headerPanel-color); margin-bottom: 1px;"><span
                        style="font-weight: bolder; font-size: 24px;"><span
                        style="color: var(--logo-text); text-decoration: none;">THYMOS</span> - ŒúŒø·øñœÅŒ± controller</span>
                </div>
                <span id="softwareInfo"
                      style="color: var(--headerPanel-color); font-size: 12px;">v0.0.0.0, 00.00.0000</span>
            </div>
        </div>
        <div id="updateHeader">
            <a style="font-size: 22px; color: darkorange;">Upgrade available</a>
            <a id="updateHeaderVersion" style="color: coral; font-size: 12px;">[from: v0.0.3 to v0.0.4]</a>
            (press 'F5')
        </div>
    </section>

    <section class="statusContainer outsetShadow">
        <!-- USB Connection Section -->
        <div class="inlineDiv">
            <div class="inlineDiv" style="width: max-content">
                <button id="connectBtnUSB" class="connectBtn"
                        title="Connect to the Thymos machine by selecting USB port.">
                    üîå Connect via USB
                </button>
                <div class="inlineDiv" data-system-level="3">
                    <label for="inputNumBaudRate">Baud-Rate:</label>
                    <input data-input-type="intInput" type="number" id="inputNumBaudRate" placeholder="Baud-Rate"
                           value="921600" min="1" max="921600" step="100">
                </div>
            </div>
            <div class="inlineDiv" data-system-level="5">
                <button id="connectBtnBluetooth" class="connectBtn"
                        title="Connect to the Thymos machine via Bluetooth.">
                    üì∂ Connect via Bluetooth
                </button>
            </div>
            <div class="inlineDiv" data-system-level="5">
                <button id="connectBtnWiFi" class="connectBtn" title="Connect to the Thymos machine via Wi-Fi.">
                    üåê Connect via Wi-Fi
                </button>
            </div>
        </div>
        <div id="connectionStatus"> üî¥ Disconnected</div>
    </section>

    <section id="debuggingWrapper" style="display: none; width: 100%; gap: 20px; margin-top: 20px; justify-content: center; align-items: center;
                border-radius: 1em; padding: 10px; background: lightpink; box-sizing: border-box;">
        <button id="degubDeleteDisabled"
                style="box-sizing: border-box; justify-self: center; width: 100px; height: 100px;">
            ‚úñÔ∏è<br>Delete 'Disabled' Class
        </button>
        <button id="degubDeleteProhibited"
                style="box-sizing: border-box; justify-self: center; width: 100px; height: 100px;">
            ‚ùå<br>Delete 'Prohibited' Class
        </button>
        <button onclick="sendCommandGeneral('mc service')"
                style="font-weight: bold; box-sizing: border-box; justify-self: center; width: 150px; height: 100px; background: #ff8c00; color:white">
            üõ†Ô∏è<br>Service Mode<br><em style="font-weight: normal;">(MC SERVICE)</em>
        </button>
        <button onclick="sendCommandGeneral('datac')"
                style="font-weight: bold; box-sizing: border-box; justify-self: center; width: 150px; height: 100px; background: #2196F3; color:white">
            üìä<br>Data Measurement<br><em style="font-weight: normal;">(DATAC)</em>
        </button>
        <button id="degubRunTestSequenceBtn"
                style="font-weight: bold; box-sizing: border-box; justify-self: center; width: 150px; height: 100px; background: #4CAF50; color:white">
            üß™<br>Run Test Sequence
        </button>
        <button id="degubEndTestingBtn"
                style="font-weight: bold; box-sizing: border-box; justify-self: center; width: 150px; height: 100px; background: #de364c; color:white">
            üõë<br>End Testing
        </button>

        <pre id="brailleOut"
             style="font-weight: normal; border: 2px solid black; min-width: 50px; max-width: 200px; height: 100px; font-size: 16px; letter-spacing: 0;"></pre>


        <label for="testInput"></label>
        <input id="testInput"
               type="number" inputmode="decimal" step="any"
               style="font-weight: normal; border: 2px solid black; min-width: 50px; max-width: 200px; height: 100px; font-size: 16px; letter-spacing: 0;"
               placeholder="Type here..."/>
    </section>

    <!-- Graph Display Section -->

    <section class="graphContainer outsetShadow">
        <h3 class="sectionTitle">üìà Graphs:</h3>
        <nav class="graphBtnWrapper" data-system-level="1">
            <button class="btnGraph" id="toggleLive"> ‚èØÔ∏è Activate Charts</button>
            <button id="clearChartBtn" class="btnGraph">üßπ Clear Charts</button>
            <button id="refreshChartBtn" class="btnGraph">üîÑ Refresh Charts</button>
        </nav>


        <div id="chartsWrapper" class="outsetShadow">
            <div id="chartsContainer">
                <div id="timeChart" class="chart"></div>
                <div id="positionChart" class="chart"></div>
            </div>
            <div id="chartsInfoContainer" style="display: none;">
                <div style="display: inline-block; gap: 10px;"><a>Min/Max:</a>
                    <div style="display: inline-block;">
                        <span style="color: #000000;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="display: inline-flex; min-width: 30px;  justify-content: center;">mm</span>
                    </div>
                    <div style="display: inline-block;">
                        <span style="color: #FF3330;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="color: #2196F3;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="color: #4CAF50;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="display: inline-flex; min-width: 30px;  justify-content: center;">N</span>
                    </div>
                </div>
                <div style="display: inline-block; gap: 10px;"><a>Min/Max:</a>
                    <div style="display: inline-block;">
                        <span style="color: #000000;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="display: inline-flex; min-width: 30px;  justify-content: center;">mm</span>
                    </div>
                    <div style="display: inline-block;">
                        <span style="color: #FF3330;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="color: #2196F3;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="color: #4CAF50;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="display: inline-flex; min-width: 30px;  justify-content: center;">N</span>
                    </div>
                </div>
            </div>
        </div>

        <hr>

        <!-- Progress Bar -->
        <h3 class="sectionTitle">üíª Control Panel:</h3>
        <div style="gap:15px; display: flex; flex-direction: column;">
            <div id="controlContainer">
                <nav class="machineControlContainer outsetShadow">
                    <div class="btnControlWrapper">
                        <!-- Start Experiment Button -->
                        <button id="startExperiment" class="controlBtn movementControlElement machineControlElement">
                            ‚ö°<br>Start Experiment
                        </button>

                        <!-- Stop Experiment Button -->
                        <button id="stopMachine" class="controlBtn machineControlElement">üõë<br>Stop Machine</button>

                        <!-- Return to the original position Button -->
                        <button id="returnPositionExperimentBtn"
                                class="controlBtn movementControlElement machineControlElement">‚Ü©Ô∏è Return to start
                            position
                        </button>

                        <!-- Automatic returning to the original position Checkmark -->
                        <div style="
            display: inline-flex;
            gap: var(--gap);
            padding-left: var(--gap);
            align-items: center;
            justify-content: center;"
                             data-eq-type="-InB">
                            <label id="autoReturnPositionExperimentLabel" for="autoReturnPositionExperiment">‚ÜïÔ∏è Final
                                Auto-positioning:</label>
                            <input type="checkbox" id="autoReturnPositionExperiment">
                        </div>
                    </div>

                    <!-- Experiment Progress -->
                    <div id="progressWrapper">
                        <div style="flex-grow: 1; display: flex; align-items: center; gap: 10px; max-width: 630px;">
                            <label for="experimentProgress">Experiment Progress:</label>
                            <progress id="experimentProgress" value="0" max="100"></progress>
                            <span id="experimentProgressLabel"></span>
                        </div>
                        <div style="width: 135px;">
                            <b>Stage:</b>
                            <span id="experimentStage">None</span>
                        </div>
                    </div>
                </nav>

                <nav class="machineControlContainer outsetShadow">
                    <div class="movementWrapper movementControlElement machineControlElement">
                        <button id="moveMachineUP" class="controlBtn moveBtnLeft">ü¢Å</button>
                        <button id="moveUp50" class="controlBtn moveBtnRight">50<br>(mm)</button>
                    </div>

                    <div class="movementWrapper movementControlElement machineControlElement">
                        <button id="moveMachineDOWN" class="controlBtn moveBtnLeft">ü¢É</button>
                        <button id="moveDown50" class="controlBtn moveBtnRight">50<br>(mm)</button>
                    </div>

                </nav>
            </div>
            <nav class="outsetShadow"
                 style="display: flex; flex-direction: row; background: var(--containers-bg); padding: 10px 20px; border-radius: 10px; justify-content: space-between; gap: 10%; font-weight: bold; color: var(--text-info-2-color);">
                <div class="movementControlElement machineControlElement"
                     style="display: flex; flex-direction: row; flex-grow: 1; align-items: center; gap: 10px;">
                    <label for="movementSpeed" style="min-width: max-content; font-weight: normal; color: black;">‚ñ∂Ô∏è
                        Speed:</label>
                    <input type="range" id="movementSpeed" min="0.01" max="25" value="25" step="0.01"
                           data-system="-1"
                           style="height: 10px; flex-direction: row; flex-grow: 1; border-radius: var(--radius); touch-action: none;">
                    <label for="labelSpeed"></label>
                    <div style="display: inline-flex; gap: .2em; align-items: center;">
                        <input type="number"
                               data-system="-1"
                               placeholder="Num."
                               id="labelSpeed"
                               class="sliderInputLabel"><span>mm/s</span>
                    </div>
                </div>
                <div class="movementControlElement machineControlElement"
                     style="display: flex; flex-direction: row; flex-grow: 1; align-items: center; gap: 10px;">
                    <label for="movementAcceleration" style="min-width: max-content; font-weight: normal; color: black;"
                    >‚è© Acceleration:</label>
                    <input type="range" id="movementAcceleration" min="10" max="200" value="200" step="0.01"
                           data-system="-1"
                           style="height: 10px; flex-direction: row; flex-grow: 1; border-radius: var(--radius); touch-action: none;">
                    <label for="labelAcceleration"></label>
                    <div style="display: inline-flex; gap: .2em; align-items: center;">
                        <input type="number"
                               data-system="-1"
                               placeholder="Num."
                               id="labelAcceleration"
                               class="sliderInputLabel"><span>mm/s<sup style="font-size: 65%;">2</sup></span></div>
                </div>
            </nav>

            <nav class="outsetShadow"
                 style="display: flex; flex-direction: row; background: var(--containers-bg); padding: 10px 20px; gap:10px; border-radius: 10px; justify-content: space-between; font-weight: bold; color:  var(--text-info-2-color);">
                <div style="display: flex; flex-direction: row; align-items: center; gap: 40px;" class="prohibited">
                    <div style="display: flex; flex-direction: row; align-items: center; gap: 10px;">
                    <span id=""
                          style="min-width: 50px; text-align: right; color:black;  opacity: 65%;">Position: </span>
                        <span id=""
                              style="color: var(--text-info-1-color); min-width: 50px; text-align: right;">000.00</span>
                        <div id="positionWrapper"></div>
                        <span id="" style="min-width: 60px; text-align: right;">¬±000.00</span>
                        <a>mm</a>
                    </div>
                    <div style="display: flex; flex-direction: row; align-items: center; gap: 10px;">
                        <label for="moveToInput"
                               style="min-width: max-content; font-weight: normal; color: var(--text-info-2-color);">
                            Move to (mm):
                        </label>
                        <input type="number" id="moveToInput" min="0" max="450" step="0.01" placeholder="0.00 mm"
                               style="height: 10px; flex-direction: row; flex-grow: 1; border-radius: var(--radius); touch-action: none;">
                    </div>
                    <button id="moveToBtn"
                            class="movementControlElement machineControlElement controlBtn controllerBtn">‚û°Ô∏è Move
                    </button>

                </div>
                <button id="setUserZeroBtn"
                        class="movementControlElement machineControlElement controlBtn controllerBtn prohibited">üéØ Set
                    Zero
                </button>
                <button id="calibrateBtn" class="movementControlElement machineControlElement controlBtn controllerBtn">
                    üìè
                    Calibrate
                </button>
            </nav>
        </div>
    </section>


    <section class="experimentContainer outsetShadow">
        <h3>üìù Experiment options:</h3>
        <section id="experimentInputsContainer">

            <label for="experimentName">üß™ Experiment Name:</label>
            <div style="display: flex; width: 100%; gap: var(--gap);">
                <input type="text" id="experimentName" placeholder="Experiment name (mandatory) ..."
                       data-system="-1">
                <label for="experimentCount">üî¢ Experiment count:</label>
                <input type="number" id="experimentCount" placeholder="Num ..."
                       data-input-type="intInput" data-system="-1"
                       value="1" step="1" min="1" max="999">
            </div>

            <button id="saveDataBtn" class="saveDataBtns controlElement">üíæ Save single CSV</button>

            <label for="experimentDesc">üìÑ Experiment description:</label>
            <div class="textareaWrapper">
                <textarea id="experimentDesc" placeholder="Short description of the experiment (optional)..."
                          data-system="-1"></textarea>
            </div>

            <button id="convertCSV" class="controlElement">
                üìä Convert CSV files to XLSX (MATTES)
            </button>

            <label for="storagePath">üìÅ Handpick the folder:</label>
            <div style="align-items: center; display: flex; gap: var(--gap);">
                <input type="checkbox" id="storagePath" onchange="toggleDirectorySelector()"> (Default folder:
                Downloads)
            </div>

            <div>
                <button type="button" id="btnLoadSettings" class="controlElement">üóÉÔ∏è Load experiment data (CSV)</button>
                <div hidden>
                    <span id="loadedFileName" aria-live="polite"></span>
                    <input type="file" id="appFileInput" accept=".csv,text/csv">
                </div>
            </div>
        </section>


        <!--            <div id="experimentBtnsWrapper">-->


        <!--            </div>-->

        <h3>üìë Experiment Results:</h3>
        <section class="openingContainer insetShadow">
            <button id="resultsContainerOpenBtn" class="openingContainerBtn">üîΩ</button>
            <div id="resultsContainer" class="sizeableContainer">
                <h4>‚úèÔ∏è Calculation inputs:</h4>
                <div class="inputsContainer">
                    <div class="input-group data-eq">
                        <label for="inputTareForce">Taring Force \( F_{\mathrm{Tare}} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="number" id="inputTareForce" class="adjustableInput calcInput"
                               data-default-value="0" value="0" step="any" data-unit="N" data-essence="force">
                    </div>

                    <div class="input-group data-eq">
                        <label for="inputTareDisp">Taring Displacement \( w_{\mathrm{Tare}} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="number" id="inputTareDisp" class="adjustableInput calcInput"
                               data-default-value="0" value="0" step="any" data-unit="mm" data-essence="position">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx, InB, HBr">
                        <label for="inputForce">Force \( F \)<span class="units-text"></span>: </label>
                        <input type="number" id="inputForce" class="adjustableInput calcInput"
                               value="" step="any" data-unit="N" data-essence="force">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="inputTargetForce">Target force \( F_{T} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="number" id="inputTargetForce" class="adjustableInput calcInput"
                               step="any" data-unit="N" data-essence="force">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx">
                        <label for="inputDisp">Displacement \( w \) at \( F \)<span class="units-text"></span>:
                        </label>
                        <input type="number" id="inputDisp" class="adjustableInput calcInput"
                               value="" step="any" data-unit="mm" data-essence="position">
                    </div>


                    <div class="input-group data-eq" data-eq-type="Flx, InB">
                        <label for="inputWidth">Cross-section width \( b \)<span class="units-text"></span>:
                        </label>
                        <input type="number" id="inputWidth" class="adjustableInput calcInput"
                               value="" step="any" data-unit="mm"
                               data-essence="dimension, cross-section">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx">
                        <label for="inputHeight">Cross-section height \( h \)<span class="units-text"></span>:
                        </label>
                        <input type="number" id="inputHeight" class="adjustableInput calcInput"
                               value="" step="any" data-unit="mm"
                               data-essence="dimension, cross-section">
                    </div>

                    <div class="input-group data-eq" data-eq-type="InB">
                        <label for="inputLength">Cross-section length \( l \)<span class="units-text"></span>:
                        </label>
                        <input type="number" id="inputLength" class="adjustableInput calcInput"
                               value="" step="any" data-unit="mm"
                               data-essence="dimension, cross-section">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx">
                        <label for="inputSpan">Span \( L \)<span class="units-text"></span>: </label>
                        <input type="number" id="inputSpan" class="adjustableInput calcInput"
                               value="" step="any" data-unit="mm" data-essence="dimension">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="inputIndDepth">Depth of indentation \( h_{D} \)<span class="units-text"></span>:
                        </label>
                        <input type="number" id="inputIndDepth" class="adjustableInput calcInput"
                               value="" step="any" data-unit="mm" data-essence="position">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="inputIndDiameter">Diameter of Indenter <b>‚åÄ</b> \( D \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="number" id="inputIndDiameter" class="adjustableInput calcInput"
                               step="any" data-unit="mm" data-essence="dimension">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="inputLoadingTime">Target loading time \( t \)<span class="units-text"></span>:
                        </label>
                        <input type="number" id="inputLoadingTime" class="adjustableInput calcInput"
                               step="any" data-unit="s" data-essence="time">
                    </div>

                    <div class="input-group data-eq">
                        <label for="inputMaterialName"><a class="u">Material name</a><span
                                class="units-text"> (text)</span>:
                        </label>
                        <input type="text" id="inputMaterialName" class="adjustableInput calcInput"
                               step="any" data-essence="label">
                    </div>
                </div>

                <div data-eq-type="Flx" style="display: inline-flex; width: 100%">
                    <hr style="width: 85% ; margin: 50px auto 10px;">
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(500px, 1fr)); gap: 20px;">

                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <h4 data-eq-type="Flx" style="margin-left: 10%;">‚òî <a class="u"> Before drying</a>:</h4>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputWidth_BeforeDrying">Cross-section width \( b_{w} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputWidth_BeforeDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension, cross-section">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputHeight_BeforeDrying">Cross-section height \( h_{w} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputHeight_BeforeDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension, cross-section">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputLength_BeforeDrying">Length \( L_{w} \)<span class="units-text"></span>:
                            </label>
                            <input type="number" id="inputLength_BeforeDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputWeight_BeforeDrying">Cross-section weight \( m_{w} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputWeight_BeforeDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="g"
                                   data-essence="weight">
                        </div>

                    </div>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <h4 data-eq-type="Flx" style="margin-left: 10%;">üåÇ <a class="u"> After drying</a>:</h4>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputWidth_AfterDrying">Cross-section width \( b_{0} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputWidth_AfterDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension, cross-section">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputHeight_AfterDrying">Cross-section height \( h_{0} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputHeight_AfterDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension, cross-section">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputLength_AfterDrying">Length \( L_{0} \)<span class="units-text"></span>:
                            </label>
                            <input type="number" id="inputLength_AfterDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputWeight_AfterDrying">Cross-section weight \( m_{0} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputWeight_AfterDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="g"
                                   data-essence="weight">
                        </div>

                    </div>
                </div>

                <hr data-system-level="1">

                <h4 data-system-level="1">üî£ Equations:</h4>
                <div class="inputsContainer" data-system-level="1"
                     style="grid-template-columns: repeat(auto-fit, minmax(430px, 1fr)); padding-left: 50px; gap: 25px 10px;">
                    <span class="data-eq">
                        \[
                        F_{i} = F_{j} - F_{\mathrm{Tare}}
                        \]
                    </span>
                    <span class="data-eq">
                        \[
                        w_{i} = w_{j} - w_{\mathrm{Tare}}
                        \]
                    </span>
                    <span class="data-eq" data-eq-type="Flx">
                        \[
                        I_{y} = \frac{1}{12} \cdot b \cdot h^{3}
                        \]
                    </span>
                    <span class="data-eq" data-eq-type="Flx">
                        \[
                        E = \frac{F\,L^{3}}{48\,I_{y}\,w}
                        \]
                    </span>
                    <span class="data-eq" data-eq-type="InB">
                        \[
                        A = b \cdot h
                        \]
                    </span>
                    <span class="data-eq" data-eq-type="InB">
                        \[ \sigma_{\mathrm{max}} = \dfrac{F_{\mathrm{max}}}{A} \]
                    </span>
                    <span class="data-eq" data-eq-type="HBr">
                        \[
                        d = 2\cdot\sqrt{\,h_{D}\,(2D - h_{D})\,}
                        \]
                    </span>
                    <span class="data-eq" data-eq-type="HBr">
                        \[
                        H_{BW} = \frac{2F}{\pi D\left( D - \sqrt{D^{2} - d^{2}} \right)}
                        \]
                    </span>
                    <span class="data-eq" data-eq-type="HBr">
                        \[
                        v = \frac{w_{T}}{t}
                        \]
                    </span>
                </div>

                <hr>

                <h4>üìê Calculated values:</h4>
                <div class="inputsContainer">
                    <div class="input-group data-eq" data-eq-type="-HBr">
                        <label for="outputForceMax">Max Force \( F_{\mathrm{max}} \)<span class="units-text"></span>:
                        </label>
                        <input type="text" id="outputForceMax" class="copyableInput calcInput" readonly
                               data-system="-1" data-unit="N" data-essence="force">
                    </div>

                    <div class="input-group data-eq" data-eq-type="-HBr">
                        <label for="outputDisp">Displacement \( w_{F_{\mathrm{max}}} \) at \( F_{\mathrm{max}} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="text" id="outputDisp" class="copyableInput calcInput" readonly
                               data-system="-1" data-unit="mm" data-essence="position">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx">
                        <!-- TODO: zobrazuje se kdy≈æ nem√°: data-system-level="1"   -->
                        <label for="outputIy">Moment of Inertia \( I_{y} \)<span
                                class="units-text"></span>: </label>
                        <input type="text" id="outputIy" class="copyableInput calcInput" readonly
                               data-system="-1" data-unit="mm^4"
                               data-essence="dimension, cross-section, moment-of-inertia">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx">
                        <label for="outputModulus">Young's Module \( E \)<span class="units-text"></span>:
                        </label>
                        <input type="text" id="outputModulus" class="copyableInput calcInput" readonly
                               data-system="-1" data-unit="MPa" data-essence="result, modulus">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx">
                        <label for="outputFlexStrength">Maximal Flexural strength \( f_{m} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="text" id="outputFlexStrength" class="copyableInput calcInput" readonly
                               data-system="-1" data-unit="MPa" data-essence="result, strength">
                    </div>

                    <div class="input-group data-eq" data-eq-type="InB">
                        <label for="outputArea">Cross-section Area \( A \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="text" id="outputArea" class="copyableInput calcInput" readonly
                               data-system="-1" data-unit="mm^2" data-essence="dimension, cross-section, area">
                    </div>

                    <div class="input-group data-eq" data-eq-type="InB">
                        <label for="outputMaxStress">Max Stress \( \sigma_{\mathrm{max}} \)<span
                                class="units-text"></span>: </label>
                        <input type="text" id="outputMaxStress" class="copyableInput calcInput" readonly
                               data-system="-1" data-unit="MPa" data-essence="result, stress">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="outputDiameterInd">Diameter of indentation <b>‚åÄ</b> \( d \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="text" id="outputDiameterInd" class="copyableInput calcInput" readonly
                               data-system="-1" data-unit="mm" data-essence="dimension">
                    </div>


                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="inputTargetDisp">Displacement \( w_{T} \) at Target force<span
                                class="units-text"></span>:
                        </label>
                        <input type="text" id="inputTargetDisp" class="copyableInput calcInput" readonly
                               data-system="-1" data-unit="mm" data-essence="position">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="outputHardness">Hardness (Brinell) \( H_{\mathrm{BW}} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="text" id="outputHardness" class="copyableInput calcInput" readonly
                               data-system="-1" data-unit="-" data-essence="result, hardness, ratio">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="outputLoadingSpeed">Loading speed \( v \)<span class="units-text"></span>:
                        </label>
                        <input type="text" id="outputLoadingSpeed" class="copyableInput calcInput" readonly
                               data-system="-1" data-unit="mm/s" data-essence="speed">
                    </div>
                </div>

                <div id="saveCalcDataBtnWrapper" style="margin-top: 60px; justify-items: center;">
                    <hr style="width: 85% ; margin: 0 auto 10px;">
                    <button class="controlBtn saveDataBtns controlElement">üíæ Save data (CSV)</button>
                </div>
            </div>
        </section>


        <!-- Experiment Parameter Inputs -->
        <h3>‚öôÔ∏è Settings:</h3>
        <section class="openingContainer insetShadow">
            <button id="settingsContainerOpenBtn" class="openingContainerBtn">üîΩ</button>
            <div id="settingsContainer" class="sizeableContainer">

                <h4>üõ†Ô∏è Loading settings:</h4>
                <div class="inputsContainer">
                    <div class="input-group">
                        <label for="inputDistance">Distance<span class="units-text"></span>: </label>
                        <input data-input-type="floatInput" type="number" id="inputDistance" class="expInput"
                               value="20" min="0.01" step="any" max="100000000" data-unit="mm" data-essence="position">
                    </div>

                    <div class="input-group">
                        <label for="experimentTypeDropdown">Experiment type: </label>
                        <select id="experimentTypeDropdown" class="expInput">
                            <option value="none" hidden>
                                &nbsp;‚¨ú&nbsp;No selection
                            </option>
                            <option value="Option-UP-POS-BASIC" data-essence="move_up">
                                &nbsp;UP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üî∫
                            </option>
                            <option value="Option-UP-POS-Ten" disabled data-essence="tensile">
                                &nbsp;TENSION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚è´
                            </option>
                            <option value="Option-UP-POS-InB" data-essence="internal_bond">
                                &nbsp;INTERNAL BOND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚è´
                            </option>
                            <option value="Option-DOWN-POS-BASIC" data-essence="move_down" selected>
                                &nbsp;DOWN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üîª
                            </option>
                            <option value="Option-UP-POS-Com" disabled data-essence="compression">
                                &nbsp;COMPRESION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚è¨
                            </option>
                            <option value="Option-DOWN-POS-Flx" data-essence="flexural">
                                &nbsp;FLEXURAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚è¨
                            </option>
                            <option value="Option-DOWN-POS-HBr" data-essence="hardness_br">
                                &nbsp;HARDNESS (Brinell)&nbsp;‚è¨
                            </option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="inputLoadLimitDropPercent">Force drop limit<span class="units-text"></span>:
                        </label>
                        <input data-input-type="floatInput" type="number" id="inputLoadLimitDropPercent"
                               class="expInput"
                               value="30" min="0" max="1000000" data-unit="%" data-essence="ratio">
                        <!-- % ‚Ä∞ -->
                    </div>


                    <div class="input-group">
                        <label for="inputTakePhotos">Take photos: </label>
                        <input type="checkbox" id="inputTakePhotos" class="expInput" data-essence="switch">
                        <label id="inputPhotoIntervalLabel" class="innerInputLabel" for="inputPhotoInterval">Photo
                            Interval<span class="units-text"></span>: </label>
                        <input data-input-type="floatInput" type="number" id="inputPhotoInterval"
                               class="expInput innerInput"
                               value="1" min="0" step="any" max="120000000" data-unit="s" data-essence="time">
                    </div>


                    <div class="input-group">
                        <label for="inputLoadLimitDropValue">Force drop limit<span class="units-text"></span>:
                        </label>
                        <input data-input-type="floatInput" type="number" id="inputLoadLimitDropValue" class="expInput"
                               value="5" min="0" step="any" max="100000000" data-unit="N" data-essence="ratio, force">
                    </div>


                    <div class="input-group">
                        <label for="inputSpeedForward">Loading speed<span class="units-text"></span>: </label>
                        <input data-input-type="floatInput" type="number" id="inputSpeedForward" class="expInput"
                               value="1" min="0.01" step="any" max="25" data-unit="mm/s" data-essence="speed">
                    </div>

                    <div class="input-group"> <!-- TODO minimum na 10000 -->
                        <label for="inputDataInterval">Data Interval<span class="units-text"></span>: </label>
                        <input data-input-type="intInput" type="number" id="inputDataInterval" class="expInput"
                               value="30000" min="10000" step="any" max="100000000" data-unit="¬µs" data-essence="time">
                    </div>

                    <div class="input-group" data-eq-type="InB, HBr">
                        <label id="inputInitialSpeedLabel" for="inputInitialSpeed">Initial speed<span
                                class="units-text"></span>:</label>
                        <input data-input-type="floatInput" type="number"
                               id="inputInitialSpeed" class="expInput" style="max-width: 60px; min-width: 25px;"
                               value="1" min="0.01" step="any" max="25" data-unit="mm/s" data-essence="speed">
                        <label id="inputInitialForceLabel" for="inputInitialForce"
                               style="min-width: max-content;">Force lim.
                            <span class="units-text"></span>:</label>
                        <input data-input-type="floatInput" type="number"
                               id="inputInitialForce" class="expInput" style="max-width: 50px; min-width: 25px;"
                               value="1" min="0" step="any" max="100000000" data-unit="N" data-essence="force">
                    </div>

                    <div class="input-group" data-eq-type="HBr">
                        <label id="inputStopForceLabel" for="inputStopForce">Stopping Force Limit<span
                                class="units-text"></span>: </label>
                        <input data-input-type="floatInput" type="number" id="inputStopForce" class="expInput"
                               value="1000" min="0" step="any" max="100000000" data-unit="N" data-essence="force">
                    </div>

                    <div class="input-group" data-eq-type="HBr">
                        <label id="inputEndDelayLabel" for="inputEndDelay">End load delay<span
                                class="units-text"></span>: </label>
                        <input data-input-type="floatInput" type="number" id="inputEndDelay" class="expInput"
                               value="25" min="0" step="any" max="120000000" data-unit="s" data-essence="time">
                    </div>

                    <div class="input-group" data-eq-type="-Flx, -InB,-HBr">
                        <label for="inputDoCycles">Do cycles: </label>
                        <input type="checkbox" id="inputDoCycles" class="expInput" data-essence="switch">
                        <label id="inputCyclesLabel" class="innerInputLabel" for="inputCycles">Cycles<span
                                class="units-text"></span>: </label>
                        <input data-input-type="intInput" type="number" id="inputCycles" class="expInput innerInput"
                               value="1" min="1" step="any" data-unit="-" data-essence="count">
                    </div>
                </div>

                <hr>

                <h4>üìü Machine settings:</h4>
                <div class="inputsContainer">
                    <div id="machSettings">
                        <!-- Machine settings (LoadCells) will be dynamically inserted here -->
                    </div>

                    <div class="input-group machineControlElement" data-system-level="1">
                        <label for="inputMachineName" style="min-width: max-content;">Machine name:</label>
                        <div style="display: flex; gap: 0;">
                            <input data-input-type="intInput" type="text" id="inputMachineName"
                                   placeholder="My Machine Name" value="" data-system="-1"
                                   data-essence="identification"
                                   style="height: 40px; width: 200px; border-bottom-right-radius: 0; border-top-right-radius: 0; border-right: 0 solid transparent;">
                            <button id="sendMachineNameBtn"
                                    style="height: 40px; width: 30px; border-bottom-left-radius: 0; border-top-left-radius: 0;">
                                ‚ñ∂ <!-- ‚Üµ‚èé‚éÜ -->
                            </button>
                        </div>
                    </div>


                    <div class="input-group machineControlElement" data-system-level="4">
                        <label for="inputMachineID" style="min-width: max-content;">Machine ID:</label>
                        <div style="display: flex; gap: 0;">
                            <input data-input-type="intInput" type="text" id="inputMachineID"
                                   placeholder="My Machine ID" value="" data-system="-1"
                                   data-essence="identification"
                                   style="height: 40px; width: 200px; border-bottom-right-radius: 0; border-top-right-radius: 0; border-right: 0 solid transparent;">
                            <button id="sendMachineIDBtn"
                                    style="height: 40px; width: 30px; border-bottom-left-radius: 0; border-top-left-radius: 0;">
                                ‚ñ∂ <!-- ‚Üµ‚èé‚éÜ -->
                            </button>
                        </div>
                    </div>
                </div>

                <hr>

                <h4>üì∫ App settings:</h4>
                <div class="inputsContainer autoGrid">
                    <div class="input-group">
                        <label for="systemLevelSelect">System Level: </label>
                        <select id="systemLevelSelect" class="appSelector" data-system="1">
                            <option value="none" hidden>&nbsp;‚¨ú&nbsp;No selection</option>
                            <!--                            <option value="" hidden>&nbsp;üÖøÔ∏è&nbsp;Public</option>-->
                            <!--                            <option value="" hidden>&nbsp;‚ûø&nbsp;Guest</option>-->
                            <!--                            <option value="" hidden>&nbsp;‚ìÇÔ∏è&nbsp;Member</option>-->
                            <!--                            <option value="" hidden>&nbsp;¬ÆÔ∏è&nbsp;Registered</option>-->
                            <!--                            <option value="" hidden>&nbsp;üëΩ&nbsp;Remote</option>-->
                            <!--                            <option value="" hidden>&nbsp;‚¨õ&nbsp;Restricted</option>-->
                            <!--                            <option value="" hidden>&nbsp;üî≥&nbsp;Protected</option>-->
                            <!--                            <option value="" hidden>&nbsp;üî≤&nbsp;Limited</option>-->
                            <!--                            <option value="" hidden>&nbsp;‚èπÔ∏è&nbsp;Minimal</option>-->
                            <option value="basic" selected>&nbsp;üü¶&nbsp;Basic</option>
                            <option value="standard">&nbsp;üü©&nbsp;Standard</option>
                            <option value="advanced">&nbsp;üü®&nbsp;Advanced</option>
                            <option value="expert">&nbsp;üüß&nbsp;Expert</option>
                            <option value="admin" disabled>&nbsp;üü•&nbsp;Administrator</option>
                            <option value="operator" disabled>&nbsp;üÖæÔ∏è&nbsp;Operator</option>
                            <option value="developer" disabled>&nbsp;üü™&nbsp;Developer</option>
                            <option value="god" disabled>&nbsp;‚ôæÔ∏è&nbsp;God Mode</option>
                        </select>
                    </div>

                    <div class="input-group" data-system-level="4">
                        <label for="inputAppInterval" style="min-width: max-content;">Data Interval:</label>
                        <input data-input-type="intInput" type="number" id="inputAppInterval" data-system="1"
                               value="50000" min="1" step="any" max="100000000" data-unit="¬µs" data-essence="time"
                               style="height: 50px; width: 200px;">
                    </div>

                    <div class="input-group">
                        <label for="languageSelect">App Language: </label>
                        <select id="languageSelect" class="appSelector" data-system="1">
                            <option value="none" hidden>&nbsp;‚¨ú&nbsp;No selection</option>
                            <option value="en" selected>&nbsp;English&nbsp;&nbsp;&nbsp;&nbsp;üáßüá¨</option>
                            <option value="cs" disabled>&nbsp;ƒåe≈°tina&nbsp;&nbsp;&nbsp;&nbsp;üá®üáø</option>
                            <option value="de" disabled>&nbsp;Deutsch&nbsp;&nbsp;&nbsp;&nbsp;üá©üá™</option>
                            <option value="es" disabled>&nbsp;Espa√±ol&nbsp;&nbsp;&nbsp;&nbsp;üá™üá∏</option>
                            <option value="pt" disabled>&nbsp;Portugu√™s&nbsp;&nbsp;üáµüáπ</option>
                            <option value="fr" disabled>&nbsp;Fran√ßais&nbsp;&nbsp;&nbsp;üá´üá∑</option>
                            <option value="it" disabled>&nbsp;Italiano&nbsp;&nbsp;&nbsp;üáÆüáπ</option>
                            <option value="ru" disabled>&nbsp;–†—É—Å—Å–∫–∏–π&nbsp;&nbsp;&nbsp;&nbsp;üá∑üá∫</option>
                            <option value="ja" disabled>&nbsp;Êó•Êú¨Ë™û&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üáØüáµ</option>
                            <option value="ko" disabled>&nbsp;ÌïúÍµ≠Ïñ¥&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üá∞üá∑</option>
                            <option value="zh" disabled>&nbsp;‰∏≠Êñá&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üá®üá≥
                            </option>
                        </select>
                    </div>

                    <div class="input-group" data-system-level="1">
                        <label for="inputAutoConnect">Automatically connect to the machine: </label>
                        <select id="inputAutoConnect" class="appSelector" data-system="1">
                            <option value="none" hidden>&nbsp;‚¨ú&nbsp;No selection</option>
                            <option value="never" title="Don't connect to the device automatically">&nbsp;‚ùå&nbsp;Never
                            </option>
                            <option value="beginning"
                                    title="Connect to the device automatically on the start-up of the app">&nbsp;üåü&nbsp;Beginning
                            </option>
                            <option value="during"
                                    title="Connect to the device automatically at any point of time during the session">
                                &nbsp;‚è≥&nbsp;During
                            </option>
                            <option value="ask"
                                    title="Always ask if connect to the device at any point of time during the session">
                                &nbsp;‚ùî&nbsp;Ask
                            </option>
                            <option value="always"
                                    title="Always connect to the device automatically at any point of time during the session"
                                    selected>&nbsp;‚úÖ&nbsp;Always
                            </option>
                        </select>
                    </div>

                    <!-- TODO: add that this and some other settings are tight to the Different storage 'System'  -->
                    <div class="input-group" data-system-level="2">
                        <label for="inputUseMachineSettings">
                            Apply machine settings on connect:
                        </label>
                        <select id="inputUseMachineSettings" class="appSelector" data-system="1">
                            <option value="none" hidden>&nbsp;‚¨ú&nbsp;No selection</option>
                            <option value="no_not" title="Keep and don't save to machine">&nbsp;‚ùå&nbsp;No (keep)
                            </option>
                            <option value="no_save" title="Keep and save to machine">&nbsp;‚úñÔ∏è&nbsp;No (save)</option>
                            <option value="ask" title="Ask what to do">&nbsp;‚ùî&nbsp;Ask</option>
                            <option value="yes_save" title="Overwrite and save to machine" selected>&nbsp;‚úÖ&nbsp;Yes
                                (save)
                            </option>
                            <option value="yes_not" title="Overwrite and don't save to machine">&nbsp;‚òëÔ∏è&nbsp;Yes
                                (keep)
                            </option>
                        </select>
                    </div>

                    <div class="input-group" data-system-level="1">
                        <label for="decimalSymbol" style="min-width: max-content;">CSV Decimal Symbol: </label>
                        <select id="decimalSymbol" class="appSelector" data-system="1">
                            <option value="none" hidden>&nbsp;‚¨ú&nbsp;No selection</option>
                            <option value="Option-Dot" selected>&nbsp;Dot&nbsp;&nbsp;&nbsp;( . )&nbsp;</option>
                            <option value="Option-Comma">&nbsp;Comma&nbsp;( , )&nbsp;</option>
                        </select>
                    </div>

                    <div class="input-group" data-system-level="1">
                        <label for="delimiterSymbol" style="min-width: max-content;">CSV Delimiter Symbol: </label>
                        <select id="delimiterSymbol" class="appSelector" data-system="1">
                            <option value="none" hidden>&nbsp;‚¨ú&nbsp;No selection</option>
                            <option value="Option-Semicolon" selected>&nbsp;Semicolon&nbsp;( ; )&nbsp;</option>
                            <option value="Option-Comma">&nbsp;Comma&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( , )&nbsp;</option>
                            <option value="Option-Space">&nbsp;Space&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( _ )&nbsp;</option>
                            <option value="Option-Tab">&nbsp;Tab&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( \t )&nbsp;
                            </option> <!-- ‚Üπ, ‚á•, ‚ÆÇ -->
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="inputAutoSave">
                            Save data to CSV automatically:
                        </label>
                        <select id="inputAutoSave" class="appSelector" data-system="1">
                            <option value="none" hidden>&nbsp;‚¨ú&nbsp;No selection</option>
                            <option value="Option-Never" title="Save data only by 'save' buttons" selected>&nbsp;‚ùå&nbsp;Never</option>
                            <option value="Option-Before" title="Save data before the start of the next Experiment">
                                &nbsp;‚èÆÔ∏è&nbsp;Before
                            </option>
                            <option value="Option-After" title="Save data right at the end of the Experiment">&nbsp;‚è≠Ô∏è&nbsp;After</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="inputClearCalculations">
                            Clear calculation inputs at the start of each experiment:
                        </label>
                        <input type="checkbox" id="inputClearCalculations" data-system="1" checked>
                    </div>

                    <button id="clearCalculationsButton" class="controlBtn" data-system-level="1">
                        üßº Clear calculations
                    </button>

                    <button id="darkModeButton" class="controlBtn">
                        üåô Dark mode
                    </button>

                    <button id="reportButton" class="controlBtn controlElement prohibited"
                            style="color: var(--stopEpx-color);">
                        üêû Report bug
                    </button>

                    <button id="clearAllButton" class="controlBtn controlElement" data-system-level="4"
                            style="color: var(--stopEpx-color);">
                        üóëÔ∏è Clear All Data
                    </button>

                    <div style="padding: 0; margin: 0; display: flex; gap: 0;" data-system-level="1">
                        <button id="exportSettingButton" class="controlBtn controlElement"
                                style="width: 100px; border-bottom-right-radius: 0; border-top-right-radius: 0; border-right: 0 solid transparent;  color: var(--text-info-3-color); font-size: 12px;">
                            ‚ÜóÔ∏è Export settings <!-- üìÅüì§ -->
                        </button>
                        <button id="importSettingButton" class="controlBtn controlElement"
                                style="width: 100px; border-bottom-left-radius: 0; border-top-left-radius: 0; border-left: 0 solid transparent;  color: var(--text-info-3-color); font-size: 12px;">
                            ‚ÜòÔ∏è Import settings <!-- üìÇ üì• -->
                        </button>
                    </div>

                    <button id="aboutButton" class="controlBtn"
                            style="color: var(--text-info-3-color);">
                        ‚ÑπÔ∏è About app
                    </button>

                    <button id="updateMachButton" class="controlBtn controlElement machineControlElement"
                            data-system-level="1"
                            style="color: var(--text-info-3-color);">
                        ‚¨ÜÔ∏è Update device firmware
                    </button>


                    <button id="rebootButton" class="controlBtn controlElement machineControlElement"
                            data-system-level="1"
                            style="color: var(--text-info-3-color);">
                        üîÇ Reboot device
                    </button>

                    <button id="clearStorageButton" class="controlBtn controlElement"
                            style="color: var(--text-info-3-color);">
                        üîÅ Reset app
                    </button>
                </div>
            </div>
        </section>

        <!-- Device Console Output Section -->
        <h3>üìã Device Console:</h3>
        <section class="openingContainer insetShadow">
            <button id="consoleContainerOpenBtn" class="openingContainerBtn">üîΩ</button>
            <div id="consoleContainer" class="sizeableContainer">

                <div class="logContainer">
                    <div id="regularLogWrapper">
                        <pre id="regularLog"></pre>
                    </div>

                    <div style="display: flex; gap: var(--gap); flex-flow: column;" data-system-level="2">
                        <button id="toggleScrollBtn" class="logBtn" data-system-level="2">
                            üìå Auto-scroll: ON
                        </button>

                        <button id="toggleLineLockBtn" class="logBtn prohibited" data-system-level="3">
                            üîí Fix Scroll: ON
                        </button>
                    </div>
                </div>

                <div class="logContainer">
                    <pre id="loadingLog"></pre>

                    <button id="clearRegularLog" class="logBtn" data-system-level="1">
                        üóëÔ∏è Clear Log
                    </button>
                </div>

                <div class="logContainer machineControlElement controlElement" data-system-level="1">
                    <div style="height: 40px; width: 100%">
                        <label for="commandInput"></label>
                        <textarea id="commandInput" placeholder="Enter command..."></textarea>
                    </div>

                    <button style="height: 40px; min-height: 40px; max-height: 40px;" id="sendButton"
                            class="logBtn">
                        üì° Send Command
                    </button>
                </div>

            </div>
        </section>

    </section>

</main>


<script>
    // Zapnut√≠/ vypnut√≠ varov√°n√≠
    let warnOnClose = true;

    // Prevent native reload/close dialog (zobrazen√≠ varov√°n√≠)
    window.addEventListener('beforeunload', (e) => {
        if (warnOnClose && !debugging) {
            e.preventDefault();
            // Standard: vƒõt≈°ina prohl√≠≈æeƒç≈Ø ignoruje vlastn√≠ text
            e.returnValue = '';
        }
    });

    // Zachycen√≠ kl√°ves, kter√© bƒõ≈ænƒõ reload/close/close-tab zp≈Øsobuj√≠
    window.addEventListener('keydown', (e) => {
        // F5 (116), Ctrl+R, Ctrl+F5, Ctrl+W, Ctrl+F4, Ctrl+Shift+R, Meta(Command)+R
        if (
            e.key === 'F5' ||
            (e.ctrlKey && e.key.toLowerCase() === 'r') ||
            (e.metaKey && e.key.toLowerCase() === 'r') ||
            (e.ctrlKey && e.key.toLowerCase() === 'w') ||
            (e.ctrlKey && e.key === 'F4')
        ) {
            e.preventDefault();
            // M√≠sto reloadu m≈Ø≈æe≈° uk√°zat vlastn√≠ upozornƒõn√≠
            if (warnOnClose && !debugging) {
                if (confirm('Are you sure you want to leave this page? Make sure to fisish all tasks, stop machine and save your data before leaving.')) {
                    // p≈ô√≠padnƒõ povolit navigaci
                    window.location.reload();
                }
            }
        }
    });

    // Zachytit kliky na odkazy, kter√© mohly page opustit
    document.addEventListener('click', (e) => {
        if (warnOnClose && !debugging) {
            const a = e.target.closest && e.target.closest('a[href]');
            if (!a) return;
            const href = a.getAttribute('href');
            // intern√≠ kotvy povolit
            if (href && !href.startsWith('#') && !href.startsWith('javascript:')) {
                e.preventDefault();
                if (confirm('Are you sure you want to leave this page? Make sure to fisish all tasks, stop machine and save your data before leaving.')) {
                    // p≈ô√≠padnƒõ povolit navigaci
                    window.location.href = href;
                }
            }
        }
    });

    // Push state / back button trap (back-button). Pom≈Ø≈æe zabr√°nit "zpƒõt" opu≈°tƒõn√≠.
    history.pushState({page: 1}, '', '');
    window.addEventListener('popstate', (event) => {
        // Znovu vlo≈æ√≠me stav a uk√°≈æeme varov√°n√≠
        history.pushState({page: 1}, '', '');
        if (warnOnClose && !debugging) {
            if (confirm('Are you sure you want to leave this page? Make sure to fisish all tasks, stop machine and save your data before leaving.')) {
                // p≈ô√≠padnƒõ povolit navigaci
                history.back();
            }
        }
    });

    // // Funkce pro doƒçasn√© vypnut√≠ ochrany (konstruktivn√≠ UX)
    // function allowCloseTemporarily(action) {
    //     warnOnClose = false;
    //     try {
    //         action();
    //     } finally {
    //         warnOnClose = true;
    //     }
    // }
    //
    // // Utility: bezpeƒçn√© ukonƒçen√≠ (nap≈ô. tlaƒç√≠tko v UI)
    // async function safeExit() {
    //     // dokonƒçi flush / ulo≈æ stav
    //     await saveStateToServerOrLocal();
    //     allowCloseTemporarily(() => window.close());
    // }
    //
    // async function saveStateToServerOrLocal() {
    //     // Implementuj ulo≈æen√≠ stavu (localStorage / server call)
    //     try {
    //         localStorage.setItem('myAppSavedAt', new Date().toISOString());
    //         // nebo await fetch('/save', {method:'POST', body:...})
    //     } catch (e) {
    //         console.warn('Save failed', e);
    //     }
    // }
</script>


<script>


</script>


<script>

    // serviceWorkerRegistration();
    //
    // async function serviceWorkerRegistration() {
    //
    //     if ('serviceWorker' in navigator) {
    //         console.info('‚òëÔ∏è Service Worker is supported.');
    //
    //         navigator.serviceWorker.getRegistration()
    //             .then(reg => {
    //                 const match = reg && reg.active && reg.active.scriptURL.includes('service-worker.js');
    //
    //                 if (match) {
    //                     // serviceWorkerRegistrationStatus = true;
    //                     console.info('‚úÖ Service worker is registered:', reg);
    //                 } else {
    //                     navigator.serviceWorker.register('service-worker.js').then(function (registration) {
    //                         console.info('üÜï Service Worker was registered', registration);
    //                     }).catch(function (error) {
    //                         console.info('‚ùå Registration failed.', error);
    //                     });
    //                 }
    //             })
    //             .catch(err => {
    //                 console.error('‚ö†Ô∏è Error checking service worker registration:', err);
    //             });
    //     } else {
    //         console.info('üö´ Service Worker is not supported.');
    //     }
    //
    //     await sleep(10);  // Stop
    //
    //     // console.info(serviceWorkerRegistrationStatus);
    //     // if (!serviceWorkerRegistrationStatus) window.location.reload();
    // }

    // Unregister all service workers
    async function unregisterServiceWorkers() {
        if ('serviceWorker' in navigator) {
            const registrations = await navigator.serviceWorker.getRegistrations();
            for (let registration of registrations) {
                await registration.unregister();
                console.log('Service worker unregistered:', registration);
            }
        }
    }

    unregisterServiceWorkers();

</script>

<script>
    const expTypesLabels = {
        "": "No selection",
        "no_selection": "No selection",
        "none": "No selection",
        "move_up": "Move up",
        "move_down": "Move down",
        "load": "Load test",
        "unload": "Unload test",
        "hold": "Hold test",
        "static": "Static test",
        "dynamic": "Dynamic test",
        "fatigue": "Fatigue test",
        "creep": "Creep test",
        "impact": "Impact test",
        "tensile": "Tensile test",
        "internal_bond": "Internal bond test",
        "compression": "Compression test",
        "pressure": "Compression test",
        "flexural": "Flexural test",
        "bending": "Flexural test",
        "shear": "Shear test",
        "adhesion": "Adhesion test",
        "peel": "Peel test",
        "lap_shear": "Lap shear test",
        "punch_shear": "Punch shear test",
        "tear": "Tear test",
        "burst": "Burst test",
        "puncture": "Puncture test",
        "indentation": "Indentation test",
        "hardness": "Hardness test",
        "hardness_br": "Brinell hardness test",
        "hardness_vh": "Vickers hardness test",
        "hardness_hb": "Rockwell hardness test",
        "hardness_hr": "Rockwell hardness test",
        "hardness_hc": "Rockwell hardness test",
        "hardness_hd": "Rockwell hardness test",
        "hardness_hf": "Rockwell hardness test",
        "hardness_ho": "Rockwell hardness test",
        "hardness_hk": "Knoop hardness test",
        "other": "Other",
    };

    const maxPrecision = 16; // max poƒçet platn√Ωch desetinn√Ωch m√≠st u zaokrouhlov√°n√≠
    const precisionTime = 6;
    const precisionPosition = 4;
    const precisionPositionSystem = precisionPosition;
    const precisionForce = 2;
    const precisionForceSystem = 4;
    const precisionSpeed = 2;
    const precisionSpeedSystem = 2;
    const precisionAcceleration = 4;
    const precisionAccelerationSystem = 2;

    const timeConversionDATAC = 1e-6;   // p≈ôevod (mikrosekund) na sekundy
    const timeConversionDSLR = 1e-3;    // p≈ôevod (milisekund) na sekundy

    const loadCellNumMax = 3; // maximal number of load cells supported
    let loadCellNum = loadCellNumMax;
</script>


<script>

    // =====================================================================
    // ====================      HELPERS      ==============================
    // =====================================================================


    // -------------------- Pomocn√© DOM utilitky --------------------
    const $ = (sel, root = null) => (root || document).querySelector(String(sel));
    const $$ = (sel, root = null) => {
        root = root || document;
        let els = root.querySelectorAll(String(sel));
        if (els.length === 0 && !String(sel).startsWith('.')) els = root.querySelectorAll('.' + String(sel));
        if (els.length === 0) els = catchVal($ID(String(sel)), [], not(isVoid));
        return els;
    }
    const $ID = (id) => document.getElementById(String(id));

    const $NAME = (name, root = null) => (root || document).getElementsByName(String(name));
    const $$CLS = (cls, root = null) => (root || document).getElementsByClassName(String(cls));
    const $$TAG = (tag, root = null) => (root || document).getElementsByTagName(String(tag));
    const $MAKE = (tag, root = null) => (root || document).createElement(String(tag));
    const $MAKE_NS = (tag, ns, root = null) => (root || document).createElementNS(String(ns), String(tag));
    const $FRAG = (root = null) => (root || document).createDocumentFragment();

    const exists = (id) => !!$ID(id);


    // 1) Z√°kladn√≠ typov√© kontroly
    const isNumber = (x) => typeof x === 'number';
    const isBigInt = (x) => typeof x === 'bigint';
    const isArr = (x) => Array.isArray(x);
    const isEmptyArr = (x) => isArr(x) && x.length === 0;
    const isNonEmptyArr = (x) => isArr(x) && x.length > 0;
    const isStr = (x) => typeof x === 'string';
    const isEmptyStr = (x) => isStr(x) && x.trim() === '';
    const isNonEmptyStr = (x) => isStr(x) && x.trim() !== '';
    const isBool = (x) => typeof x === 'boolean';
    const isFunc = (x) => typeof x === 'function';
    const isObj = (x) => isDef(x) && typeof x === 'object' && !isArr(x);
    const isEmptyObj = (x) => isObj(x) && Object.keys(x).length === 0;
    const isNonEmptyObj = (x) => isObj(x) && Object.keys(x).length > 0;
    const isSymbol = (x) => typeof x === 'symbol';
    const isUndefined = (x) => x === undefined || typeof x === 'undefined';
    const isNull = (x) => x === null;
    const isDef = (x) => !isUndefined(x) && !isNull(x);
    const isVoid = (x) => isUndefined(x) || isNull(x);

    const isElement = (x) => x instanceof Element;
    const isNodeList = (x) => x instanceof NodeList;
    const isEmptyNodeList = (x) => isNodeList(x) && x.length === 0;
    const isNonEmptyNodeList = (x) => isNodeList(x) && x.length > 0;

    const isNum = (x) => isFiniteNumber(x, false); // only Finite numbers
    const isVal = (x) => isNum(x) || !isEmptyStr(x); // only Finite numbers or non-empty strings
    const isAny = (x) => isNotEmpty(x) && x !== false; // all except undefined, null and NaN + false
    const isOk = (x) => isAny(x) && !isInvalidValue(x); // all except undefined, null, NaN and false + invalid values

    const not = (fn) => {
        return function (...args) {
            return !fn.apply(this, args);
        }
    };


    const getInputVal = (id) => {
        if (isFiniteNumber(id)) return id;
        const el = isElement(id) ? id : $ID(String(id));
        if (el?.classList.contains('undisplayed') || el?.classList.contains('invisible')) { // el.disabled
            if (el?.dataset.hasOwnProperty('defaultValue')) {
                return el?.dataset.defaultValue;
            } else {
                return null;
            }
        }
        return catchVal(el?.value?.trim(), null, isNonEmptyStr);
    }


    const getInputValDef = (id, d) =>
        catchVal(getInputVal(id), d, isNotEmpty);

    const getInputNumDef = (id_x, d) =>
        catchVal(toNumber((isFiniteNumeric(id_x) ? id_x : getInputValDef(id_x, null)), true), d, isNum);
    const getInputNumDefAbsFlt = (id_x, d) =>
        Math.abs(getInputNumDef(id_x, d));
    const getInputNumDefAbsInt = (id_x, d) =>
        Math.round(getInputNumDefAbsFlt(id_x, d));

    const isValidInputNum = (x) =>
        isFiniteNumber(x, false) && x > 0;

    const catchVal = (val, def, cond = isOk) =>
        (isFunc(cond) ? cond(val) : isOk(cond)) ? val : def;

    const isNumberOrBigInt = (x) =>
        isNumber(x) || isBigInt(x);

    const isNumberOrInfinity = (x, bigInt = true) =>
        (isNumber(x) && !Number.isNaN(x)) || (isBigInt(x) && bigInt); // true i pro ¬±Infinity

    const isFiniteNumber = (x, bigInt = true) =>
        (isNumber(x) && Number.isFinite(x)) || (isBigInt(x) && bigInt);

    const isFiniteInteger = (x, bigInt = true) =>
        (isNumber(x) && Number.isInteger(x)) || (isBigInt(x) && bigInt);

    // 2) Parsov√°n√≠ stringu na ƒç√≠slo (podpora ƒç√°rky jako desetinn√© teƒçky)
    const toNumber = (x, all = true) => {
        if (isNumber(x)) return x;
        if (isBigInt(x)) return Number(x); // Number(x) pozor na p≈ôesnost u velk√Ωch hodnot
        return strToNumber(x, all); // if (isStr(x))
    };
    const toNumeric = (x, all = true) => {
        if (isNumberOrBigInt(x)) return x;
        return strToNumber(x, all); // if (isStr(x))
    };

    const toRounds = (x, digits = 0, way = 'round') => {
        const n = toNumber(x, true);
        if (!isNumberOrInfinity(n)) return NaN; // NaN/¬±Infinity

        if (way === 'round' || way === 'auto') {

            if (!Number.isFinite(n)) return n; // ¬±Infinity

            digits = Math.min(Math.abs(Math.round(toNumber(digits, true))), maxPrecision);

            if (!isFiniteInteger(digits)) return NaN;
            return roundDecimalFast(n, digits);
        }
        if (way === 'ceil' || way === 'up') return Math.ceil(n);
        if (way === 'floor' || way === 'down') return Math.floor(n);
        if (way === 'trunc' || way === 'drop') return Math.trunc(n);
        return NaN;
    };

    const toInteger = (x, way = 'drop', bigInt = false) => {
        if (isNumber(x) && Number.isInteger(x)) return x;
        if (isBigInt(x) && bigInt) return x;

        const n = toRounds(x, 0, way);

        if (Number.isInteger(n)) return n;

        return NaN;
    };

    const strToNumber = (x, all = false) => {
        if (isStr(x)) {
            const s = x.trim();
            if (s === '') return NaN;
            const n = s.replaceAll(',', '.').replaceAll('¬±', ' ');
            return all ? parseFloat(n) : Number(n);
        }
        return NaN;
    };

    // 3) ‚ÄûJe to numerick√©‚Äú (vƒçetnƒõ ¬±Infinity)
    const isNumericOrInfinity = (x) => {
        if (isNumberOrInfinity(x)) return true; // true i pro ¬±Infinity
        const n = toNumeric(x, true);
        return !Number.isNaN(n); // true i pro ¬±Infinity
    };

    // 4) ‚ÄûJe to koneƒçn√© numerick√©‚Äú (bez NaN/¬±Infinity)
    const isFiniteNumeric = (x) => {
        if (isFiniteNumber(x, true)) return true;
        const n = toNumeric(x, true);
        return Number.isFinite(n);
    };

    // (voliteln√©) ‚Äûd√° se to s rozumn√Ωm v√Ωsledkem pou≈æ√≠t jako ƒç√≠slo‚Äú ‚Äì alias:
    const isAnyFiniteNumeric = (x) => {
        if (isFiniteNumber(x, true)) return true;
        const n = toNumeric(x, true);
        if (isBigInt(n)) return true; // BigInt je OK
        return Number.isFinite(n);
    };

    // 5) ‚ÄûM√° hodnotu‚Äú ‚Äì pokud pot≈ôebuje≈° zvl√°≈°≈• (0 projde, null/undef/"" ne)
    const hasValue = (x) => isDef(x) && (isNumberOrInfinity(x) || isNonEmptyStr(x));

    // Varianta, kter√° NEpova≈æuje false/true za ‚Äûhodnotu‚Äú
    const hasValueButNotBoolean = (x) => hasValue(x) && !isBool(x) && x.toLowerCase().trim() !== 'false' && x.toLowerCase().trim() !== 'true';

    const isNotEmpty = (x) => {
        if (isVoid(x)) return false;
        if (isNumberOrInfinity(x) && !Number.isNaN(x)) return true; // 0 i ¬±Infinity projde,  0n i velk√© hodnoty projdou
        if (isStr(x)) return x.trim() !== '';
        if (isArr(x)) return x.length > 0;
        if (isObj(x)) return Object.keys(x).length > 0;
        if (isBool(x)) return true; // false i true projde
        if (isSymbol(x)) return true;
        if (isFunc(x)) return true;
        if (isElement(x)) return true;
        if (isNodeList(x)) return x.length > 0;
        return false;
    };


    const isInvalidValue = (x, additionSet = [], use_extended = false) => {
        if (!hasValue(x)) return true;
        if (isNumberOrInfinity(x)) return false;

        const BAD_basic = new Set([
            'false',
            'nil', 'null', 'nullable', 'nullptr',
            'errno', 'error', 'err', 'error 404',
            'none', 'no', 'n/o', 'not', 'nothing', 'never',
            'nan', 'nat', 'n/a', 'na', 'n/d', 'nd',
            'undefined', 'empty', 'missing', 'void', 'voided', 'forgotten', 'out',
            'val', 'inv', 'invalid', 'not valid', 'disabled', 'expired', 'cancelled', 'not applicable', 'deleted', 'del',
            '‚Åø/‚Çê', '‚êÄ', '‚ê§', '‚ê°',
            'x', '‚úñ', '‚úñÔ∏è', '‚ùå',
            '!', '‚Äº',
            '?', '‚Åá',
            '‚ÄΩ', '!?', '?!',
        ]);

        const BAD_extended = new Set([
            '„éÅ',
            '√ó', '‚ï≥', '‚òì', '‚úï', '‚úó', '‚úò', '‚®â', '‚®Ø', 'üóô', 'üó¥', 'üó∂', 'üû©',
            '‚ùé', '‚òí', '‚ÆΩ', 'üóµ', 'üó∑', '‚ä†', '‚åß', 'üù±',
            '‚Ææ', '‚Æø', '‚äó', '‚®Ç', '‚≠ô',
            '‚ö†Ô∏é', '‚ö†', '‚ö†Ô∏è',
            '‚õî', '‚äò', 'üö´',
            '«É', '‚ùï', '‚ùó', '‚ù¢', 'Íúù', '·µé·µé',
            '‚Åâ', '‚Åà', 'üôπ', 'üô∫', 'üôª',
            'Ôπñ', '‚ùî', '‚ùì', '‚ç∞', 'ÔøΩ', '‚Øë', '¬ø', '‚∏Æ', 'Ô∏ñ', 'Ôºü',
            'üõë', '‚≠ïÔ∏è', 'üö®', 'üí•', 'üöß', 'üÜò', 'üÖæÔ∏è', '4Ô∏è‚É£0Ô∏è‚É£4Ô∏è‚É£', '‚Å¥‚Å∞‚Å¥',
            'Ôøº',
        ]);


        const norm = v => String(v || '')
            .normalize('NFKD')
            .replace(/\p{Diacritic}/gu, '') // odstran√≠ diakritiku
            .replace(/[.,]/g, '')           // sma≈æe ƒç√°rky a teƒçky
            .replace(/\\/g, '/')            // nahrad√≠ \ za /
            .replace(/\s+/g, ' ')           // zjednodu≈°√≠ v√≠cen√°sobn√© mezery
            .trim()
            .toLowerCase();


        if (use_extended) for (const v of BAD_extended) BAD_basic.add(norm(v));

        if (isNonEmptyArr(additionSet)) for (const v of additionSet) BAD_basic.add(norm(v));

        return BAD_basic.has(norm(x));
    }

    const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    const checkArray = (arr) => {
        if (!isNotEmpty(arr)) return NaN;
        return isArr(arr) ? arr : [arr];
    }

    const checkObject = (obj) => {
        if (!isNotEmpty(obj)) return NaN;
        if (isObj(obj)) return obj;
        if (isArr(obj)) {
            const res = {};
            for (let i = 0; i < obj.length; i++) {
                res[i] = obj[i];
            }
            return res;
        }
        if (isStr(obj) || isNumberOrInfinity(obj) || isBool(obj)) {
            return {0: obj};
        }
        return NaN;
    }

    const decimalSymbol = (num, symbol = '.') => {
        if (!isAnyFiniteNumeric(num)) return "N/A";
        if (!isFiniteNumber(num, true)) num = String(num);
        const s = String(num);
        return symbol === '.' ? s : s.replace('.', symbol);
    };

    const getValue = (x, dec = "none", strOut = false) => {
        const def = strOut ? "N/A" : NaN;

        if (!isNumericOrInfinity(x)) return def;

        // 1) p≈ôevedeme vstup na ƒç√≠slo (tv≈Øj toNumber um√≠ i ƒç√°rku apod.)
        let n = toNumeric(x, true);

        if (strOut && typeof isBigInt(n)) n = Number(n);

        if (isVoid(dec) || dec === "none" || isBigInt(n)) {
            // ≈æ√°dn√© dec -> vra≈• n
            return strOut ? String(n) : n;
        }

        // 2) vyhodnot√≠me desetinn√° m√≠sta jen jednou
        if (!isAnyFiniteNumeric(dec)) return def;
        const d = Math.min(Math.round(toNumber(dec, true)), maxPrecision);

        if (d < 0) return def; // neplatn√© dec -> vra≈• NaN/"N/A"

        // 3) zaokrouhlen√≠
        return strOut ? n.toFixed(d) : roundDecimalFast(n, d);
    };

    // Bezpeƒçn√° koerce na BigInt (p≈ôijme number/BigInt/string s ƒç√≠slem)
    const toBigInt = (x) => {
        if (isBigInt(x)) return x;
        let n = toNumber(x, true);
        if (!isFiniteNumber(n, true)) return NaN;
        if (!isFiniteInteger(n)) n = Math.round(n);
        try {
            return BigInt(n);
        } catch (e) {
            return NaN;
        }
    };

    // O≈ô√≠znut√≠ na n bit≈Ø (nap≈ô. 64bit bezznam√©nkov√© ID)
    const toUintN = (n, b) => BigInt.asUintN(n, toBigInt(b));
    // a se znam√©nkem:
    const toIntN = (n, b) => BigInt.asIntN(n, toBigInt(b));

    const decimalToHex = (num) => {
        if (!isFiniteInteger(num) || num < 0) return "N/A";
        return "0x" + Number(num).toString(16).toUpperCase();
    };
    const decimalToBinary = (num) => {
        if (!isFiniteInteger(num) || num < 0) return "N/A";
        return "0b" + Number(num).toString(2);
    };
    const binaryToDecimal = (str) => {
        if (!isStr(str)) return NaN;
        const s = str.trim();
        if (!/^0b[01]+$/i.test(s)) return NaN;
        return parseInt(s.slice(2), 2);
    };
    const hexToDecimal = (str) => {
        if (!isStr(str)) return NaN;
        const s = str.trim();
        if (!/^0x[0-9a-f]+$/i.test(s)) return NaN;
        return parseInt(s.slice(2), 16);
    };


    const getNumValue = (x, dec = "none") => getValue(x, dec, false);
    const getStrFixedValue = (x, dec = "none") => getValue(x, dec, true);
    const getStrValue = (x, dec = "none") => ((n => Number.isNaN(n) ? "N/A" : String(n))(getNumValue(x, dec)));
    const getCustomStrValue = (x, dec = "none", decSym = '.', writeSign = false, fixed = false, customError = "N/A") => {
        const v = fixed ? getStrFixedValue(x, dec) : getStrValue(x, dec);
        if (v === "N/A") return customError;
        let s = v;
        if (!(v === "Infinity" || v === "-Infinity")) s = decimalSymbol(v, decSym);
        s = s.replace('Infinity', '‚àû')
        if (writeSign && !s.startsWith('-')) {
            if (roundDecimalFast(strToNumber(v), 12) === 0) {
                s = '¬±' + s;
            } else {
                s = '+' + s;
            }
        }
        return s;
    };

    function roundDecimalFast(num, decimalPlace) {
        const p = Math.pow(10, clamp(decimalPlace || 0, 0, maxPrecision));
        return Math.round(num * p) / p;
    }

    const arrayWrapper = (arr, func, args) => {
        // console.log(arrayWrapper([0.000, "0", 454214878181871n, 0n, "0n", "900800700600500400300200100", "   -45   ", "   +45   ", "   ¬±45¬±45   ", 488.45, "100.005  ", "100. 005  ", "12,34", "  56.78  ", "text", null, undefined, {}, [], "NaN", "Infinity", "-Infinity"], getCustomStrValue, [12, '.', false, true]));
        if ((!arr && arr !== 0) || !func) return NaN;
        if (!isFunc(func)) return NaN;
        arr = checkArray(arr);
        if (!isNotEmpty(arr)) return NaN;
        args = checkArray(args);
        const res = [];
        for (let i = 0; i < arr.length; i++) {
            res.push(func(arr[i], ...args));
        }
        return res;
    }

    const objectWrapper = (obj, func, args) => {
        if ((!obj && obj !== 0) || !func) return NaN;
        if (!isFunc(func)) return NaN;
        obj = checkObject(obj);
        if (!isNotEmpty(obj)) return NaN;
        args = checkArray(args);
        const res = {};
        for (const key in obj) {
            if (Object.hasOwnProperty.call(obj, key)) {
                res[key] = func(obj[key], ...args);
            }
        }
        return res;
    }

    // =====================================================================
    // S T A T   &   E X T R E M A   U T I L S   (2D, ragged-friendly)
    // =====================================================================

    // ---------- intern√≠ helpery ----------
    /** Normalizace vstupu na 2D pole ≈ô√°dk≈Ø; pr√°zdno -> [] */
    const normalize2D = (input) => {
        const outer = checkArray(input);
        if (Number.isNaN(outer)) return [];
        return outer.map(r => {
            const row = checkArray(r);
            return Number.isNaN(row) ? [] : row;
        });
    };

    /** D√©lka nejdel≈°√≠ho ≈ô√°dku */
    const rowsMaxLen = (rows) => rows.reduce((m, r) => Math.max(m, r.length), 0);

    /** Vyta≈æen√≠ sloupce j jako pole (m≈Ø≈æe obsahovat undefined) */
    const getCol = (rows, j) => rows.map(r => r[j]);

    /** Vr√°t√≠ pouze koneƒçn√° ƒç√≠sla (toNumber(..., true)); ostatn√≠ vyhod√≠ */
    const valuesFinite = (list) => {
        const arr = checkArray(list);
        if (Number.isNaN(arr)) return [];
        const out = [];
        for (const v of arr) {
            const n = toNumber(v, true);
            if (Number.isFinite(n)) out.push(n);
        }
        return out;
    };

    /** Aplikaƒçn√≠ kostra: vezme 1D oper√°tor a aplikuje ho po dimenzi (0/1/2) */
    const aggregateND = (input, dim, op1D) => {
        const rows = normalize2D(input);

        if (dim === 0 || isVoid(dim)) {
            const flat = [];
            for (const r of rows) flat.push(...r);
            return op1D(flat);
        }
        if (dim === 1) return rows.map(r => op1D(r));
        if (dim === 2) {
            const W = rowsMaxLen(rows);
            const out = new Array(W);
            for (let j = 0; j < W; j++) out[j] = op1D(getCol(rows, j));
            return out;
        }
        return NaN;
    };

    /** Glob√°ln√≠ argmin/argmax v 2D -> [rowIdx, colIdx] nebo NaN */
    const argExtremum2D = (rows, acceptInf, isMin) => {
        let best = isMin ? Infinity : -Infinity;
        let bi = -1, bj = -1, seen = false;
        for (let i = 0; i < rows.length; i++) {
            const r = rows[i];
            for (let j = 0; j < r.length; j++) {
                const n = toNumber(r[j], true);
                const ok = acceptInf ? !Number.isNaN(n) : Number.isFinite(n);
                if (!ok) continue;
                if ((isMin && n < best) || (!isMin && n > best)) {
                    best = n;
                    bi = i;
                    bj = j;
                    seen = true;
                }
            }
        }
        return seen ? [bi, bj] : NaN;
    };

    // ---------- 1D oper√°tory ----------
    const sum1D = (list) => {
        const v = valuesFinite(list);
        if (!v.length) return NaN;
        let s = 0;
        for (let i = 0; i < v.length; i++) s += v[i];
        return s;
    };

    const mean1D = (list) => {
        const v = valuesFinite(list);
        return v.length ? sum1D(v) / v.length : NaN;
    };

    const median1D = (list) => {
        const v = valuesFinite(list);
        if (!v.length) return NaN;
        v.sort((a, b) => a - b);
        const m = Math.floor(v.length / 2);
        return v.length % 2 ? v[m] : (v[m - 1] + v[m]) / 2;
    };

    /** Smƒõrodatn√° odchylka; sample=true -> Bessel (N-1), jinak populace (N) */
    const std1D = (list, sample = false) => {
        const v = valuesFinite(list);
        const n = v.length;
        if (!n || (sample && n < 2)) return NaN;

        let sum = 0;
        for (let i = 0; i < n; i++) sum += v[i];
        const mu = sum / n;

        let acc = 0;
        for (let i = 0; i < n; i++) {
            const d = v[i] - mu;
            acc += d * d;
        }
        const denom = sample ? (n - 1) : n;
        return Math.sqrt(acc / denom);
    };

    // ---------- 1D extr√©my (sjednocen√©) ----------
    /** Hodnota extr√©mu v 1D podle which='min'|'max' */
    const extremum1DValue = (arr, which = 'min', acceptInf = false) => {
        if (!isArr(arr) || arr.length === 0) return NaN;
        let best = which === 'min' ? Infinity : -Infinity;
        let seen = false;
        for (const v of arr) {
            const n = toNumber(v, true);
            if (Number.isNaN(n)) continue;
            if ((which === 'min' && n < best) || (which === 'max' && n > best)) {
                best = n;
                seen = true;
            }
        }
        if (!seen) return NaN;
        return acceptInf ? best : (Number.isFinite(best) ? best : NaN);
    };

    /** Index extr√©mu v 1D podle which='min'|'max' */
    const extremum1DIndex = (arr, which = 'min', acceptInf = false) => {
        if (!isArr(arr) || arr.length === 0) return NaN;
        let best = which === 'min' ? Infinity : -Infinity;
        let idx = -1;
        for (let i = 0; i < arr.length; i++) {
            const n = toNumber(arr[i], true);
            if (Number.isNaN(n)) continue;
            if ((which === 'min' && n < best) || (which === 'max' && n > best)) {
                best = n;
                idx = i;
            }
        }
        return acceptInf ? idx : (Number.isFinite(best) ? idx : NaN);
    };

    // ---------- ND extr√©my (sjednocen√©) ----------
    const extremumND = (input, dim = 0, which = 'min', acceptInf = false) =>
        aggregateND(input, dim, (list) => extremum1DValue(list, which, acceptInf));

    const extremumNDIdx = (input, dim = 0, which = 'min', acceptInf = false) => {
        const rows = normalize2D(input);

        if (dim === 0 || isVoid(dim)) {
            return argExtremum2D(rows, acceptInf, which === 'min');
        }
        if (dim === 1) {
            return rows.map(r => extremum1DIndex(r, which, acceptInf));
        }
        if (dim === 2) {
            const W = rowsMaxLen(rows);
            const out = new Array(W);
            for (let j = 0; j < W; j++) {
                out[j] = extremum1DIndex(getCol(rows, j), which, acceptInf);
            }
            return out;
        }
        return NaN;
    };

    const extremumNDWithIdx = (input, dim = 0, which = 'min', acceptInf = false) => {
        const rows = normalize2D(input);
        const idx = extremumNDIdx(rows, dim, which, acceptInf);
        if (Number.isNaN(idx)) return {value: NaN, index: NaN};

        if (dim === 0 || isVoid(dim)) {
            const [i, j] = idx;
            return {value: toNumber(rows[i]?.[j], true), index: [i, j]};
        }

        if (dim === 1) {
            const values = rows.map((r, i) => {
                const j = idx[i];
                return Number.isFinite(j) ? toNumber(r[j], true) : NaN;
            });
            return {value: values, index: idx};
        }

        if (dim === 2) {
            const W = rowsMaxLen(rows);
            const values = new Array(W);
            for (let j = 0; j < W; j++) {
                const i = idx[j];
                values[j] = Number.isFinite(i) ? toNumber(rows[i]?.[j], true) : NaN;
            }
            return {value: values, index: idx};
        }

        return {value: NaN, index: NaN};
    };

    // Najde indexy a hodnoty prvk≈Ø nejbl√≠≈æe k c√≠lov√© hodnotƒõ (1D pole).
    // Vrac√≠ { indexes: number[], values: number[], distance: number }.
    // Pokud nic validn√≠ho, vrac√≠ { indexes: NaN, values: NaN, distance: NaN }.
    const nearest1D = (list, target) => {
        const arr = checkArray(list);
        if (Number.isNaN(arr)) return {indexes: NaN, values: NaN, distance: NaN};

        const t = toNumber(target, true);
        if (Number.isNaN(t)) return {indexes: NaN, values: NaN, distance: NaN};

        // Speci√°l: kdy≈æ c√≠l je +‚àû/-‚àû, smysluplnƒõ zvol√≠me extr√©m
        if (t === Infinity || t === -Infinity) {
            const which = t === Infinity ? 'max' : 'min';
            // najdi extr√©mn√≠ hodnotu (koneƒçnou, pokud existuje)
            let bestVal = extremum1DValue(arr, which, /*acceptInf*/ true);
            if (Number.isNaN(bestVal)) return {indexes: NaN, values: NaN, distance: NaN};

            // seber v≈°echny indexy s touto hodnotou
            const indexes = [];
            const values = [];
            for (let i = 0; i < arr.length; i++) {
                const n = toNumber(arr[i], true);
                if (Object.is(n, bestVal) || (Number.isFinite(n) && Number.isFinite(bestVal) && n === bestVal)) {
                    indexes.push(i);
                    values.push(n);
                }
            }
            return {indexes, values, distance: Math.abs(bestVal - t)}; // bude Infinity u koneƒçn√Ωch bestVal proti ¬±‚àû
        }

        // Bƒõ≈æn√Ω p≈ô√≠pad: koneƒçn√Ω c√≠l
        const EPS = 1e-12;
        let bestDist = Infinity;
        let indexes = [];
        let values = [];

        for (let i = 0; i < arr.length; i++) {
            const n = toNumber(arr[i], true);
            if (!Number.isFinite(n)) continue;

            const d = Math.abs(n - t);
            if (d + EPS < bestDist) {        // lep≈°√≠ kandid√°t
                bestDist = d;
                indexes = [i];
                values = [n];
            } else if (Math.abs(d - bestDist) <= EPS) { // stejnƒõ bl√≠zko ‚Üí p≈ôidej
                indexes.push(i);
                values.push(n);
            }
        }

        if (!indexes.length) return {indexes: NaN, values: NaN, distance: NaN};
        return {indexes, values, distance: bestDist};
    };

    const findFirstHigher = (arr, limit) => {
        for (let i = 0; i < arr.length; i++) {
            const n = toNumber(arr[i], true);
            if (Number.isFinite(n) && n >= limit) {
                return i;
            }
        }
    }

    const findTargetForce = (arr_F, arr_W, target_F) => {
        const idx = findFirstHigher(arr_F, target_F);
        if (idx < 1) return [arr_F[0], 0];
        return [linearInterpolation(arr_F[idx], arr_W[idx], arr_F[idx - 1], arr_W[idx - 1], target_F), idx];
    }


    // ---------- ND oper√°tory ----------
    // Dim = 0 -> global; 1 -> by rows; 2 -> by cols
    const sumND = (input, dim = 0) => aggregateND(input, dim, sum1D);
    const meanND = (input, dim = 0) => aggregateND(input, dim, mean1D);
    const medianND = (input, dim = 0) => aggregateND(input, dim, median1D);
    const stdND = (input, dim = 0) => aggregateND(input, dim, (list) => std1D(list, false)); // stdND: sample = false ‚Üí populace; true ‚Üí v√Ωbƒõr (N-1)
    const stdNDsample = (input, dim = 0) => aggregateND(input, dim, (list) => std1D(list, true)); // Alias pokud chce≈° v√Ωslovnƒõ ‚Äûsample‚Äú signaturu
    const nearestND = (input, dim = 0, target) => aggregateND(input, dim, (list) => nearest1D(list, target));

    // ---------- aliasy ‚Äûmin/max‚Äú pro pohodl√≠ a kompatibilitu ----------
    const minND = (input, dim = 0, acceptInf = false) => extremumND(input, dim, 'min', acceptInf);
    const maxND = (input, dim = 0, acceptInf = false) => extremumND(input, dim, 'max', acceptInf);
    const minNDIdx = (input, dim = 0, acceptInf = false) => extremumNDIdx(input, dim, 'min', acceptInf);
    const maxNDIdx = (input, dim = 0, acceptInf = false) => extremumNDIdx(input, dim, 'max', acceptInf);
    const minNDWithIdx = (input, dim = 0, acceptInf = false) => extremumNDWithIdx(input, dim, 'min', acceptInf);
    const maxNDWithIdx = (input, dim = 0, acceptInf = false) => extremumNDWithIdx(input, dim, 'max', acceptInf);

    const nearest = (arr, target) => nearest1D(arr, target);
    const minimum = (arr, acceptInf = false) => extremum1DValue(arr, 'min', acceptInf);
    const maximum = (arr, acceptInf = false) => extremum1DValue(arr, 'max', acceptInf);
    const minimumIdx = (arr, acceptInf = false) => extremum1DIndex(arr, 'min', acceptInf);
    const maximumIdx = (arr, acceptInf = false) => extremum1DIndex(arr, 'max', acceptInf);


    const invLerp = (a, b, x) => (x - a) / (b - a);
    const lerp = (start, end, t) => start + t * (end - start);
    const mapLetp = (a1, b1, a2, b2, c1) => lerp(a2, b2, invLerp(a1, b1, c1));


    const linearInterpolation = (a1, a2, b1, b2, c1) => {
        if (a1 === b1) return a2; // Avoid division by zero
        return mapLetp(a1, b1, a2, b2, c1);
    }

    // UTF-8 <-> Base64 helpers bez unescape/escape:
    const u8ToB64 = (u8) => {
        let s = "";
        for (let i = 0; i < u8.length; i++) s += String.fromCharCode(u8[i]);
        return btoa(s);
    };
    const b64ToU8 = (b64) => {
        const bin = atob(b64);
        const u8 = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
        return u8;
    };

    // =====================================================================

    const txtE = new TextEncoder();
    const txtD = new TextDecoder();

    // =====================================================================

    const isSkippable = (el) =>
        el.type === 'file' ||
        el.type === 'password' ||
        el.dataset.system === '-1' ||
        el.dataset.system === 'skip' ||
        el.dataset.system === 'none' ||
        el.dataset.system === 'null' ||
        el.dataset.system === 'false';

    // =====================================================================


    function getLocaleOrder(locales = null, {
        timeZone = undefined,           // nech pr√°zdn√© pro aktu√°ln√≠ z√≥nu
        force24h = false                // true => vynut√≠ 24h (H), i kdy≈æ je locale 12h
    } = {}) {
        const opts = {
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            timeZone
        };

        if (isVoid(locales)) {
            locales = navigator.languages && navigator.languages.length ? navigator.languages : [navigator.language || 'en-US'];
        }

        // vytvo≈ô form√°tovaƒç a p≈ôeƒçti meta
        const dtf = new Intl.DateTimeFormat(locales, opts);
        const ro = dtf.resolvedOptions();

        // zji≈°tƒõn√≠, zda je 12h form√°t (nebo vynucenƒõ 24h)
        const is12h = !force24h && (ro.hour12 === true || /^h1[12]$/.test(ro.hourCycle || ""));
        const hourSymbol = is12h ? "h" : "H";

        // pou≈æij ‚Äûrozli≈°iteln√©‚Äú datum/ƒças (kv≈Øli po≈ôad√≠ je jedno, ale a≈• jsou ƒç√≠sla jasn√°)
        const d = new Date(Date.UTC(2001, 10, 21, 13, 14, 15)); // 21.11.2001 13:14:15

        // rozpitvej form√°t na ƒç√°sti
        const parts = dtf.formatToParts(d);

        // poskl√°dej po≈ôad√≠
        const mapDate = {day: "D", month: "M", year: "Y"};
        const mapTime = {hour: hourSymbol, minute: "m", second: "s"};

        const dateOrder = parts
            .filter(p => p.type === "day" || p.type === "month" || p.type === "year")
            .map(p => mapDate[p.type])
            .join(",");

        const timeOrder = parts
            .filter(p => p.type === "hour" || p.type === "minute" || p.type === "second")
            .map(p => mapTime[p.type])
            .join(",");

        const hasDayPeriod = parts.some(p => p.type === "dayPeriod");

        return {
            locale: ro.locale,                 // skuteƒçnƒõ pou≈æit√Ω locale (po fallbacku)
            date: dateOrder || null,           // nap≈ô. "D,M,Y" | "M,D,Y" | "Y,M,D"
            time: hasDayPeriod ? `${timeOrder},a` : timeOrder, // nap≈ô. "H,m,s" nebo "h,m,s,a"
            hourCycle: ro.hourCycle || (is12h ? "h12" : "h23"),
        };
    }

    // =====================================================================

    function progressCalculate(current, end) {
        if (!isFiniteNumber(current) || !isFiniteNumber(end) || end === 0) return NaN;
        let progress = clamp((current / end) * 100, 0, 100);
        return roundDecimalFast(progress, 6);
    }

</script>

<script>

    // ==========================
    // Jednotky, prefixy, parser
    // ==========================

    // --- Rozmƒõry a operace ---
    const ZERO = [0, 0, 0, 0, 0, 0, 0]; // L, M, T, I, Œò, N, J
    const DIMS = {L: 0, M: 1, T: 2, I: 3, Th: 4, N: 5, J: 6};

    const dim = (...d) => d;
    const addDim = (a, b) => a.map((v, i) => v + b[i]);
    const mulDim = (a, k) => a.map(v => v * k);
    const sameDim = (a, b) => a.every((v, i) => v === b[i]);

    // --- SI p≈ôedpony (vƒç. '¬µ' a fallback 'u') ---
    const PREFIX = new Map(Object.entries({
        Y: 1e24, Z: 1e21, E: 1e18, P: 1e15, T: 1e12, G: 1e9, M: 1e6,
        k: 1e3, h: 1e2, da: 1e1,
        d: 1e-1, c: 1e-2, m: 1e-3, u: 1e-6, '¬µ': 1e-6,
        n: 1e-9, p: 1e-12, f: 1e-15, a: 1e-18, z: 1e-21, y: 1e-24
    }));

    // --- Textov√© p≈ôedpony (slova) ‚Üí symbol p≈ôedpony ---
    const TEXT_PREFIX_ALIASES = new Map(Object.entries({
        yotta: 'Y', zetta: 'Z', exa: 'E', peta: 'P', tera: 'T',
        giga: 'G', mega: 'M', kilo: 'k', hecto: 'h', deka: 'da', deca: 'da',
        deci: 'd', centi: 'c', milli: 'm', micro: 'u', nano: 'n',
        pico: 'p', femto: 'f', atto: 'a', zepto: 'z', yocto: 'y'
    }));

    // --- Datab√°ze jednotek ---
    const UNITS = new Map(); // sym -> { dim, factor }
    const def = (sym, dimv, factor = 1) => UNITS.set(sym, {dim: dimv, factor});

    /* Z√°kladn√≠ SI + p√°r bƒõ≈æn√Ωch */
    def('m', dim(1, 0, 0, 0, 0, 0, 0));
    def('s', dim(0, 0, 1, 0, 0, 0, 0));
    def('A', dim(0, 0, 0, 1, 0, 0, 0));
    def('K', dim(0, 0, 0, 0, 1, 0, 0));
    def('mol', dim(0, 0, 0, 0, 0, 1, 0));
    def('cd', dim(0, 0, 0, 0, 0, 0, 1));

    def('kg', dim(0, 1, 0, 0, 0, 0, 0), 1);
    def('g', dim(0, 1, 0, 0, 0, 0, 0), 1e-3); // 1 g = 1e-3 kg

    // ƒåasov√© zkratky
    def('min', dim(0, 0, 1, 0, 0, 0, 0), 60);
    def('h', dim(0, 0, 1, 0, 0, 0, 0), 3600);

    // Odvozen√© (faktor 1, jen dimenze)
    const mD = UNITS.get('m').dim;
    const sD = UNITS.get('s').dim;
    const AD = UNITS.get('A').dim;
    const kgD = UNITS.get('kg').dim;
    const cdD = UNITS.get('cd').dim;

    const HzD = mulDim(sD, -1);
    def('Hz', HzD, 1);

    const ND = addDim(kgD, addDim(mD, mulDim(sD, -2)));
    def('N', ND, 1);

    const PaD = addDim(ND, mulDim(mD, -2));
    def('Pa', PaD, 1);

    const JD = addDim(ND, mD);
    def('J', JD, 1);

    const WD = addDim(JD, mulDim(sD, -1));
    def('W', WD, 1);

    const VD = addDim(WD, mulDim(AD, -1));
    def('V', VD, 1);

    // C, F, Œ©/ohm, T, lx
    const CD = addDim(AD, sD);
    def('C', CD, 1);

    const FD = addDim(CD, mulDim(VD, -1));
    def('F', FD, 1);

    const OhmD = addDim(VD, mulDim(AD, -1));
    def('Œ©', OhmD, 1);
    def('ohm', OhmD, 1);
    def('Ohm', OhmD, 1);

    const TD = addDim(ND, addDim(mulDim(AD, -1), mulDim(mD, -1)));
    def('T', TD, 1);

    // Lux = cd / m^2
    const lxD = addDim(cdD, mulDim(mD, -2));
    def('lx', lxD, 1);

    // Bezrozmƒõrn√© pomocn√©
    def('1', ZERO.slice(), 1);
    def('%', ZERO.slice(), 0.01);
    def('‚Ä∞', ZERO.slice(), 0.001);
    def('ppm', ZERO.slice(), 1e-6);
    def('ppb', ZERO.slice(), 1e-9);

    // Den, t√Ωden, mƒõs√≠c(30d), rok(365d)
    const SECONDS_PER_DAY = 24 * 60 * 60;
    def('d', dim(0, 0, 1, 0, 0, 0, 0), SECONDS_PER_DAY);
    def('day', dim(0, 0, 1, 0, 0, 0, 0), SECONDS_PER_DAY);
    def('wk', dim(0, 0, 1, 0, 0, 0, 0), 7 * SECONDS_PER_DAY);
    def('week', dim(0, 0, 1, 0, 0, 0, 0), 7 * SECONDS_PER_DAY);
    def('mo', dim(0, 0, 1, 0, 0, 0, 0), 30 * SECONDS_PER_DAY);
    def('month', dim(0, 0, 1, 0, 0, 0, 0), 30 * SECONDS_PER_DAY);
    def('yr', dim(0, 0, 1, 0, 0, 0, 0), 365 * SECONDS_PER_DAY);
    def('year', dim(0, 0, 1, 0, 0, 0, 0), 365 * SECONDS_PER_DAY);

    // Teploty ‚Äì symbolick√©; afinn√≠ p≈ôevod ≈ôe≈°√≠ convertUnits
    def('degC', UNITS.get('K').dim, 1); // ¬∞C
    def('degF', UNITS.get('K').dim, 1); // ¬∞F

    // Seznam symbol≈Ø (nejdel≈°√≠ nap≈ôed)
    let UNIT_SYMBOLS = Array.from(UNITS.keys()).sort((a, b) => b.length - a.length);

    // --- Textov√© aliasy jednotek (plur√°ly, n√°zvy, p≈ôeklepy) ‚Üí kanonick√© symboly ---
    const TEXT_UNIT_ALIASES = new Map(Object.entries({
        // ƒças
        sec: 's', secs: 's', second: 's', seconds: 's',
        mins: 'min', minute: 'min', minutes: 'min',
        hr: 'h', hrs: 'h', hour: 'h', hours: 'h',
        day: 'd', days: 'd',
        wks: 'wk', week: 'wk', weeks: 'wk',
        mos: 'mo', month: 'mo', months: 'mo',
        yrs: 'yr', year: 'yr', years: 'yr',

        // d√©lka / hmota
        meter: 'm', meters: 'm', metre: 'm', metres: 'm',
        gram: 'g', grams: 'g',

        // z√°kladn√≠ SI
        ampere: 'A', amperes: 'A',
        kelvin: 'K',
        mole: 'mol', moles: 'mol',
        candela: 'cd',

        // odvozen√©
        newton: 'N', newtons: 'N',
        pascal: 'Pa', pascals: 'Pa',
        joule: 'J', joules: 'J',
        watt: 'W', watts: 'W',
        volt: 'V', volts: 'V',
        coulomb: 'C', coulombs: 'C',
        farad: 'F', farads: 'F',
        ohm: 'ohm', ohms: 'ohm', Ohm: 'ohm',
        tesla: 'T', teslas: 'T',
        lux: 'lx',

        // teploty (text)
        celsius: 'degC', 'degree celsius': 'degC', degreecelsius: 'degC', 'degrees celsius': 'degC',
        fahrenheit: 'degF', 'degree fahrenheit': 'degF', degreefahrenheit: 'degF', 'degrees fahrenheit': 'degF'
    }));

    const TEXT_UNIT_TYPO_ALIASES = new Map(Object.entries({
        secnd: 's', minut: 'min', houer: 'h',
        gramm: 'g',
        nevtonn: 'N', newtonn: 'N', newtons: 'N',
        pascalss: 'Pa', jouless: 'J', wattss: 'W', voltss: 'V',
        coulombss: 'C', faradss: 'F', teslass: 'T',
        luxx: 'lx', luxes: 'lx',
        metre: 'm', metres: 'm' // (duplicitnƒõ pro jistotu)
    }));

    // --- Normalizace vstupu p≈ôed parsov√°n√≠m ---
    // 1) nahrad√≠ ¬∞C/¬∞F ‚Üí degC/degF
    // 2) nahrad√≠ textov√© p≈ôedpony & jednotky & p≈ôeklepy
    // 3) slep√≠ "<prefix><mezera><unit>" ‚Üí "<prefix><unit>" (nap≈ô. "k m" ‚Üí "km")
    function normalizeUnitsString(input) {
        if (isVoid(input)) return input;
        let s = String(input);

        // ¬∞C / ¬∞F ‚Üí degC / degF
        s = s.replace(/¬∞\s*[cC]/g, 'degC')
            .replace(/¬∞\s*[fF]/g, 'degF');

        const replaceWordMap = (map) => {
            const keys = Array.from(map.keys()).sort((a, b) => b.length - a.length);
            for (const k of keys) {
                const re = new RegExp(`\\b${k}\\b`, 'gi');
                s = s.replace(re, map.get(k));
            }
        };

        // nejd≈ô√≠v slova-p≈ôedpony, pak jednotky a p≈ôeklepy
        replaceWordMap(TEXT_PREFIX_ALIASES);
        replaceWordMap(TEXT_UNIT_ALIASES);
        replaceWordMap(TEXT_UNIT_TYPO_ALIASES);

        // slep "prefix symbol"+"mezera"+"unit" ‚Üí "prefix+unit"
        const prefixSymbols = ['Y', 'Z', 'E', 'P', 'T', 'G', 'M', 'k', 'h', 'da', 'd', 'c', 'm', 'u', '¬µ', 'n', 'p', 'f', 'a', 'z', 'y'];
        for (const pre of prefixSymbols) {
            for (const u of UNIT_SYMBOLS) {
                if (u === 'kg') continue; // kg je speci√°l
                const re = new RegExp(`\\b${pre}\\s+${u}\\b`, 'g');
                s = s.replace(re, `${pre}${u}`);
            }
        }

        return s;
    }

    // --- Parser jednotkov√©ho v√Ωrazu ---
    function parseUnitExpr(input) {
        if (!input || String(input).trim() === '' || input === '1') {
            return {dim: ZERO.slice(), factor: 1};
        }

        // normalizace
        let s = normalizeUnitsString(input);

        s = String(s)
            .replace(/[¬∑‚ãÖ‚Ä¢√ó]/g, '*')
            .replace(/[‚Äì‚Äî‚àí]/g, '-')   // r≈Øzn√© minusy
            .replace(/\s+/g, '*')     // mezery jako n√°soben√≠
            .replace(/[()]/g, '');    // bez z√°vorek

        const parts = s.split('/');
        let acc = {dim: ZERO.slice(), factor: 1};

        parts.forEach((segment, idx) => {
            const sign = (idx === 0) ? +1 : -1; // ƒçitatel / jmenovatel
            const tokens = segment.split('*').filter(Boolean);
            tokens.forEach(tok => {
                const {dim, factor} = parseUnitToken(tok);
                acc.dim = addDim(acc.dim, mulDim(dim, sign));
                acc.factor *= Math.pow(factor, sign);
            });
        });

        return acc;
    }

    function parseUnitToken(tok) {
        let t = String(tok).trim();
        if (!t) throw new Error(`Invalid unit token: "${tok}"`);
        let exp = 1;

        // exponent ^{...} nebo ^...
        const mPow = t.match(/\^(?:\{([^}]+)}|(.+))$/);
        if (mPow) {
            const raw = (mPow[1] || mPow[2]).trim();
            exp = parseInt(raw, 10);
            t = t.slice(0, mPow.index);
            if (!Number.isInteger(exp)) throw new Error(`Invalid exponent: "${raw}"`);
        }

        // unicode mocniny
        t = t.replace(/¬≤/g, '^2').replace(/¬≥/g, '^3');
        if (exp === 0) return {dim: ZERO.slice(), factor: 1};
        if (t === '1') return {dim: ZERO.slice(), factor: 1};

        // speci√°l: "kg" ‚Äì nesm√≠ se rozpadnout na k + g
        if (t === 'kg') {
            return {dim: mulDim(UNITS.get('kg').dim, exp), factor: 1};
        }

        // nejdel≈°√≠ zn√°m√Ω symbol jednotky jako sufix
        const unit = UNIT_SYMBOLS.find(u => t.endsWith(u));
        if (!unit) throw new Error(`Unknown unit: "${t}"`);

        const base = UNITS.get(unit);
        if (!base) throw new Error(`Unit "${unit}" is not supported`);

        const prefixStr = t.slice(0, t.length - unit.length);
        let pf = 1;
        if (prefixStr) {
            pf = PREFIX.get(prefixStr);
            if (isVoid(pf) && prefixStr === 'da') pf = 10; // fallback
            if (isVoid(pf)) throw new Error(`Unknown prefix: "${prefixStr}" in "${tok}"`);
        }

        return {
            dim: mulDim(base.dim, exp),
            factor: Math.pow(base.factor * pf, exp)
        };
    }

    // --- Teplotn√≠ helpery (ƒçist√© teploty jen) ---
    const isPureTempUnit = (u) => {
        const s = String(u).trim();
        return s === 'K' || s === 'degC' || s === 'degF';
    };
    const toKelvin = (value, sym) => {
        switch (sym) {
            case 'K':
                return value;
            case 'degC':
                return value + 273.15;
            case 'degF':
                return (value - 32) * (5 / 9) + 273.15;
            default:
                throw new Error(`Unsupported temperature unit: ${sym}`);
        }
    };
    const fromKelvin = (valueK, sym) => {
        switch (sym) {
            case 'K':
                return valueK;
            case 'degC':
                return valueK - 273.15;
            case 'degF':
                return (valueK - 273.15) * (9 / 5) + 32;
            default:
                throw new Error(`Unsupported temperature unit: ${sym}`);
        }
    };

    // --- Ve≈ôejn√© API: konverze hodnoty mezi jednotkami ---
    function convertUnits(value, fromUnit, toUnit) {
        const fNorm = normalizeUnitsString(fromUnit);
        const tNorm = normalizeUnitsString(toUnit);

        const fIsTemp = isPureTempUnit(fNorm);
        const tIsTemp = isPureTempUnit(tNorm);

        if (fIsTemp || tIsTemp) {
            // afinn√≠ p≈ôevod sm√≠ b√Ωt jen mezi ƒçist√Ωmi teplotami
            if (!(fIsTemp && tIsTemp)) {
                throw new Error(`Temperature units cannot be combined with other units: "${fromUnit}" ‚Üí "${toUnit}"`);
            }
            const k = toKelvin(value, fNorm);
            return fromKelvin(k, tNorm);
        }

        const a = parseUnitExpr(fNorm);
        const b = parseUnitExpr(tNorm);
        if (!sameDim(a.dim, b.dim)) {
            throw new Error(`Noncompatible units: "${fromUnit}" vs "${toUnit}"`);
        }
        return roundDecimalFast(value * (a.factor / b.factor), maxPrecision);
    }

    // ==========================
    // TESTY & V√ùPIS DO KONZOLE
    // ==========================
    // function runTests() {
    //     console.log('--- TEST: ¬∞C / ¬∞F / K ---');
    //     console.log('normalize "¬∞C" ->', normalizeUnitsString('¬∞C')); // oƒçek√°v√°me "degC"
    //     console.log('normalize "¬∞F" ->', normalizeUnitsString('¬∞F')); // oƒçek√°v√°me "degF');
    //
    //     const tC = 25;
    //     console.log(`25 ¬∞C -> K: `, convertUnits(tC, '¬∞C', 'K'));     // 298.15
    //     console.log(`25 ¬∞C -> ¬∞F:`, convertUnits(tC, '¬∞C', '¬∞F'));    // 77
    //     console.log(`300 K -> ¬∞C:`, convertUnits(300, 'K', 'degC'));  // 26.85
    //     console.log(`77 ¬∞F -> ¬∞C:`, convertUnits(77, 'degF', 'degC')); // 25
    //
    //     console.log('\n--- TEST: textov√© n√°zvy & p≈ôeklepy ---');
    //     console.log('normalize "seconds" ->', normalizeUnitsString('seconds')); // s
    //     console.log('normalize "metres"  ->', normalizeUnitsString('metres'));  // m
    //     console.log('normalize "gramm"   ->', normalizeUnitsString('gramm'));   // g
    //     console.log('normalize "nevtonn" ->', normalizeUnitsString('nevtonn')); // N
    //
    //     console.log('\n--- TEST: textov√© p≈ôedpony ---');
    //     console.log('normalize "kilo meter" ->', normalizeUnitsString('kilo meter')); // km
    //     console.log('parse "kilo meter / second" == "km/s":',
    //         JSON.stringify(parseUnitExpr('kilo meter / second')) === JSON.stringify(parseUnitExpr('km/s'))
    //     );
    //
    //     console.log('\n--- TEST: bƒõ≈æn√© SI konverze ---');
    //     console.log('1 km -> m:', convertUnits(1, 'km', 'm'));           // 1000
    //     console.log('500 g -> kg:', convertUnits(500, 'g', 'kg'));       // 0.5
    //     console.log('1 N¬∑m -> J:', convertUnits(1, 'N*m', 'J'));         // 1
    //     console.log('1 Pa -> N/m^2:', convertUnits(1, 'Pa', 'N/m^2'));   // 1
    //
    //     console.log('\n--- TEST: chybov√© stavy ---');
    //     try {
    //         console.log('degC/s ‚Üí K/s (nemƒõlo by proj√≠t):', convertUnits(1, 'degC/s', 'K/s'));
    //     } catch (e) {
    //         console.log('Oƒçek√°van√° chyba (afinn√≠ teplota v pomƒõru):', e.message);
    //     }
    //     try {
    //         console.log('nezn√°m√° jednotka:', convertUnits(1, 'smurf', 'm'));
    //     } catch (e) {
    //         console.log('Oƒçek√°van√° chyba (unknown unit):', e.message);
    //     }
    //
    //
    //     convertUnits(2, 'min', 's');             // 120
    //     convertUnits(1, 'h', 'min');             // 60
    //
    //     convertUnits(1, 'mV/V', '1');            // 0.001  (bezrozmƒõrn√©)
    //     convertUnits(1, 'mV/V', '%');            // 0.1    (%)
    //     convertUnits(2.5, 'mV/V', '‚Ä∞');          // 2.5    (promile)
    //     convertUnits(500, 'ppm', '%');           // 0.05
    //
    //     convertUnits(1, 'kŒ©', 'ohm');            // 1000
    //     convertUnits(1, 'mA', 'A');              // 0.001
    //     convertUnits(1, 'C', 'A*s');             // 1
    //     convertUnits(1, 'F', 'C/V');             // 1
    //     convertUnits(1, 'T', 'N/(A*m)');         // 1
    //     convertUnits(1, 'lx', 'cd/m^2');         // 1
    //
    //     convertUnits(2, 'mm/min', 'mm/s');
    //     convertUnits(2.5, 'mV/GV', 'GV/mV');
    //     convertUnits(4, 'mV/V', 'MV/GV');
    //     convertUnits(4, 'mV/V', 'GV/GV');
    //     convertUnits(4, 'mm^2', 'cm^2');
    //     convertUnits(4, '¬µm^4', 'm^4');
    //     convertUnits(4, '¬µm^4', 'm^4');
    //
    //     convertUnits(1, 'd', 's');           // 86400
    //     convertUnits(2, 'wk', 'd');          // 14 (2x 7)
    //     convertUnits(60, 'mo', 'd');         // 1800 (2 mƒõs√≠ce po 30 dnech)
    //     convertUnits(1, 'yr', 'h');          // 365 * 24 = 8760
    //     convertUnits(1, 'km/yr', 'm/d');      // ‚âà 0.27778 (beze zmƒõny)
    //     convertUnits(1, 'mm/wk', 'mm/day');   // 60
    //
    //     convertUnits(1, 'N', 'kg*m/s^2');     // 1
    //     convertUnits(10, 'N', 'kN');          // 0.01
    //
    //     convertUnits(1, 'J', 'N*m');          // 1
    //     convertUnits(1, 'J', 'kg*m^2/s^2');   // 1
    //     convertUnits(500, 'kJ', 'MJ');        // 0.5
    //
    //     convertUnits(1, 'W', 'J/s');          // 1
    //     convertUnits(2.5, 'kW', 'W');         // 2500
    //     convertUnits(1, 'W', 'kg*m^2/s^3');   // 1
    // }

</script>

<script>
    (() => {
        /* ======= KONFIG ======= */
        const COPY_SELECTOR = '.copyableInput';
        const ADJUST_SELECTOR = '.adjustableInput';
        const LINGER_MS = 1_000; // jak dlouho z≈Østane pilulka viditeln√° po akci/opu≈°tƒõn√≠

        /* ======= POMOCN√â FUNKCE (bezpeƒçn√© fallbacky) ======= */
        const normalize = (v) => String(v || '').toLowerCase()
            .replaceAll('\\', '/').replaceAll('.', '').replaceAll(',', '').trim();

        /* ======= GLOB√ÅLN√ç EXKLUZIVITA POSLEDN√ç AKCE ======= */
        let currentActive = null; // { el, btn }

        const cancelFadeListener = (btn) => {
            if (btn._onFadeEnd) {
                btn.removeEventListener('transitionend', btn._onFadeEnd);
                btn._onFadeEnd = null;
            }
        };
        const cancelHideTimer = (btn) => {
            if (btn._hideTimer) {
                clearTimeout(btn._hideTimer);
                btn._hideTimer = null;
            }
        };
        const deactivateCurrent = () => {
            if (!currentActive) return;
            const {el, btn} = currentActive;
            cancelHideTimer(btn);
            cancelFadeListener(btn);
            el.classList.remove('action-ok', 'action-err');
            btn.classList.remove('visible');
            btn.dataset.state = 'idle';
            currentActive = null;
        };

        const setStateExclusive = (el, btn, state) => {
            if (!currentActive || currentActive.btn !== btn) {
                deactivateCurrent();
                currentActive = {el, btn};
            }
            cancelFadeListener(btn);
            btn.dataset.state = state;
            btn.classList.add('visible');
        };

        const checkAdjustBtn = (btn, wrap) => {
            if (!btn) return;
            if (!wrap || !wrap.classList.contains('has-auto')) return;
            if (btn.dataset.state === 'idle' || btn.dataset.state === 'set' || btn.dataset.state === 'diff') {
                const input = $(ADJUST_SELECTOR, wrap);
                if (!input) return;
                const id = input.id || normalize(input.name) || normalize(input.dataset.adjustId);
                if (!id) return;
                const inputValue = input.value;
                const autoValue = adjustRegistryAPI.get(id);
                if (hasValue(autoValue) && hasValue(inputValue)) {
                    if (toNumber(autoValue) === toNumber(inputValue)) {
                        btn.dataset.state = 'set'; // already set
                    } else {
                        btn.dataset.state = 'diff'; // can be set
                    }
                } else {
                    btn.dataset.state = 'idle'; // no auto-value
                }
            }
        };

        const showBtn = (btn, wrap) => {
            cancelHideTimer(btn);
            cancelFadeListener(btn);
            btn.classList.add('visible');
            checkAdjustBtn(btn, wrap);
        };

        const hideBtnLater = (btn) => {
            cancelHideTimer(btn);
            btn._hideTimer = setTimeout(() => {
                btn.classList.remove('visible');
                cancelFadeListener(btn);
                btn._onFadeEnd = (ev) => {
                    if (ev.propertyName === 'opacity') {
                        const op = getComputedStyle(btn).opacity;
                        if (op === '0') {
                            btn.dataset.state = 'idle';
                            cancelFadeListener(btn);
                        }
                    }
                };
                btn.addEventListener('transitionend', btn._onFadeEnd);
            }, LINGER_MS - 100);
        };

        // wand (idle)
        const iconWand = '<svg class="icon-wand" viewBox="0 0 24 24" fill="none" stroke-width="2.75" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"> <path stroke="none" d="M0 0h24v24H0z" fill="none"/> <path d="M4 8v-2a2 2 0 0 1 2 -2h2"/> <path d="M4 16v2a2 2 0 0 0 2 2h2"/> <path d="M16 4h2a2 2 0 0 1 2 2v2"/> <path d="M16 20h2a2 2 0 0 0 2 -2v-2"/> <path d="M9 16v-5.5a2 2 0 1 1 6 0v5.5"/> <path d="M9.5 13h5"/></svg>';
        // Copy (idle)
        const iconCopy = '<svg class="icon-copy" viewBox="0 0 24 24" fill="none" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"> <rect width="13" height="16" x="8" y="7" rx="1.5" ry="1.5"/> <path d="M 3,15.5 V 3.5 C 3,2.7 3.7,2 4.5,2 H 15"/></svg>';
        // check
        const iconOK = '<svg class="icon-check" viewBox="0 0 24 24" fill="none" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"> <path d="M 4.8,13.4 9,17.6 19.6,7"/> </svg>';
        // X
        const iconX = '<svg class="icon-x" viewBox="0 0 24 24" fill="none" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"> <path d="M6 6 L18 18 M18 6 L6 18"/> </svg>';


        /* ======= VYTVO≈òEN√ç WRAPPERU ======= */
        const ensureWrap = (el) => {
            const parent = el.parentElement;
            if (parent && (parent.classList.contains('action-wrap') || parent.classList.contains('copy-wrap'))) {
                // kompatibilita: pokud u≈æ existuje copy-wrap, pov√Ω≈°√≠me ho na action-wrap
                parent.classList.add('action-wrap');
                return parent;
            }
            const wrap = $MAKE('span');
            wrap.className = 'action-wrap';
            el.insertAdjacentElement('beforebegin', wrap);
            wrap.appendChild(el);
            return wrap;
        };

        /* ======= PILULKY ======= */
        const makeCopyButton = () => {
            const btn = $MAKE('button');
            btn.type = 'button';
            btn.className = 'action-pill copy-pill';
            btn.dataset.state = 'idle';
            btn.setAttribute('aria-label', 'Zkop√≠rovat hodnotu');
            btn.title = 'Copy value';
            btn.innerHTML = `${iconCopy} ${iconOK} ${iconX}`;
            return btn;
        };

        const makeAdjustButton = () => {
            const btn = $MAKE('button');
            btn.type = 'button';
            btn.className = 'action-pill adjust-pill';
            btn.dataset.state = 'idle';
            btn.setAttribute('aria-label', 'Automaticky nastavit hodnotu');
            btn.title = 'Set automatic value';
            btn.innerHTML = `${iconWand} ${iconOK} ${iconX}`;
            return btn;
        };

        /* ======= REGISTR AUTO-HODNOT ======= */
        const _registry = {};
        const ensureId = (el, prefix = 'adj') => {
            if (el.id && el.id.trim().length) return el.id;
            const auto = `${prefix}-${Math.random().toString(36).slice(2, 8)}`;
            el.id = auto;
            return auto;
        };

        // ve≈ôejn√© API
        const adjustRegistryAPI = {
            get(id) {
                return _registry[id];
            },
            set(id, value) {
                _registry[id] = value;
                refreshAdjustButtonsFor(id); // UI refresh jen pro dan√Ω input
            },
            all() {
                return Object.assign({}, _registry);
            }
        };
        window.adjustRegistry = adjustRegistryAPI;        // ƒçti/zapisuj p≈ôes metody

        window.adjustSet = (id, v) => {
            const el = $ID(id);
            const val = toNumber(v);

            if (!hasValue(el.value) && isNum(val)) blinkBorder(el, {
                restart: true,
                color: '#2196F3',
                backgroundOn: '#a7e7ff',
                blinks: 3,
            });

            else if (isNum(val) && val === toNumber(el.value)) blinkBorder(el, {
                restart: true,
                color: '#4CAF50',
                backgroundOn: '#a9ffa9',
                blinks: 3,
            });

            else if (isNum(val) && val !== adjustGet(id)) blinkBorder(el, {restart: true});

            else if (!isNum(val) && isNum(adjustGet(id))) blinkBorder(el, {
                restart: true,
                color: '#DC143C',
                backgroundOn: '#ffaeb9',
                blinks: 3,
            });

            adjustRegistryAPI.set(id, val);
        };
        window.adjustGet = (id) => adjustRegistryAPI.get(id);
        window.adjustDel = (id) => {
            if (!isUndefined(adjustRegistryAPI.get(id))) {
                adjustRegistryAPI.set(id, NaN);
            }
        };

        /* ======= VAZBA ID -> tlaƒç√≠tko pro rychl√Ω refresh ======= */
        const idToAdjustBtn = new Map();

        const refreshAdjustButtonsFor = (id) => {
            const btn = idToAdjustBtn.get(id);
            if (!btn) return;
            const val = adjustRegistryAPI.get(id);
            const valid = !isInvalidValue(val);

            const input = $ID(id);
            const wrap = input?.closest('.action-wrap');

            if (valid) {
                btn.classList.remove('hidden');
                wrap?.classList.add('has-auto');
                checkAdjustBtn(btn, wrap);
            } else {
                btn.classList.add('hidden');
                btn.dataset.state = 'idle';
                wrap?.classList.remove('has-auto');
            }
        };

        // window.adjustRefresh = () => idToAdjustBtn.forEach((_, id) => refreshAdjustButtonsFor(id));

        /* ======= KOP√çROVAC√ç LOGIKA ======= */
        const bindCopy = (wrap, el) => {
            const btn = makeCopyButton();
            wrap.appendChild(btn);

            const copyValue = async () => {
                let ok = false;
                const val = (el.value || el.textContent || '').toString().trim();
                try {
                    if (!hasValue(val)) throw new Error('Empty');
                    const testVal = normalize(val);
                    if (!isInvalidValue(testVal)) {
                        await navigator.clipboard.writeText(val);
                        ok = true;
                    }
                } catch (err) {
                    try {
                        if (el.select) {
                            const s = el.selectionStart, e = el.selectionEnd;
                            el.focus();
                            el.select();
                            ok = document.execCommand('copy');
                            if ((isDef(s) && isDef(e)) && (s <= e) && e !== 0) {
                                el.setSelectionRange(s, e);
                                ok = true;
                            } else {
                                ok = false;
                            }
                            el.blur();
                        }
                    } catch (err) {
                        ok = false;
                    }
                } finally {
                    el.classList.remove('action-err', 'action-ok');
                    if (ok) {
                        el.classList.add('action-ok');
                        setStateExclusive(el, btn, 'ok');
                    } else {
                        el.classList.add('action-err');
                        setStateExclusive(el, btn, 'err');
                    }
                    setTimeout(() => {
                        el.classList.remove('action-ok', 'action-err');
                        btn.dataset.state = 'idle';
                    }, LINGER_MS);
                    hideBtnLater(btn);
                }
            };

            wrap.addEventListener('mouseenter', () => showBtn(btn, wrap));
            wrap.addEventListener('mouseleave', () => hideBtnLater(btn));
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                copyValue();
            });
            el.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || (e.ctrlKey && e.key.toLowerCase() === 'c')) {
                    e.preventDefault();
                    showBtn(btn, wrap);
                    copyValue();
                }
            });
        };

        /* ======= NASTAVOVAC√ç LOGIKA (.adjustableInput) ======= */
        const bindAdjust = (wrap, el) => {
            const id = ensureId(el);
            if (!(_registry).hasOwnProperty(id)) _registry[id] = NaN; // init registru

            const btn = makeAdjustButton();
            idToAdjustBtn.set(id, btn);
            wrap.appendChild(btn);

            el.addEventListener('input', () => checkAdjustBtn(btn, wrap));

            const applyValue = () => {
                const raw = adjustRegistryAPI.get(id);
                const valid = !isInvalidValue(raw);
                if (!valid) {
                    // ikona se nem√° zobrazit ani nic vkl√°dat
                    btn.classList.add('hidden');
                    btn.dataset.state = 'idle';
                    return false;
                }
                const str = String(raw);
                // vlo≈æit
                try {
                    const prev = {s: el.selectionStart, e: el.selectionEnd};
                    el.value = str;
                    // vyvolat standardn√≠ eventy
                    el.dispatchEvent(new Event('input', {bubbles: true}));
                    el.dispatchEvent(new Event('change', {bubbles: true}));
                    // navr√°tit caret pokud d√°v√° smysl
                    if (isDef(prev.s) && isDef(prev.e) && el.setSelectionRange) {
                        const end = str.length;
                        el.setSelectionRange(end, end);
                    }
                    btn.dataset.state = 'set';
                    return true;
                } catch (err) {
                    return false;
                }
            };

            const doAdjust = () => {
                const ok = applyValue();
                el.classList.remove('action-ok', 'action-err');
                blinkBorder.stop(el);
                if (ok) {
                    el.classList.add('action-ok');
                    setStateExclusive(el, btn, 'ok');
                } else {
                    el.classList.add('action-err');
                    setStateExclusive(el, btn, 'err');
                }
                setTimeout(() => {
                    el.classList.remove('action-ok', 'action-err');
                    btn.dataset.state = 'idle';
                    refreshAdjustButtonsFor(id); // po animaci znovu zhodnotit viditelnost
                }, LINGER_MS);
                hideBtnLater(btn);
            };

            // poƒç√°teƒçn√≠ viditelnost dle registru
            refreshAdjustButtonsFor(id);

            // interakce
            wrap.addEventListener('mouseenter', () => showBtn(btn, wrap));
            wrap.addEventListener('mouseleave', () => hideBtnLater(btn));
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                doAdjust();
            });
            el.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    showBtn(btn, wrap);
                    doAdjust();
                }
            });
        };

        /* ======= SCAN & INIT ======= */
        const setupOne = (el) => {
            const wrap = ensureWrap(el);
            // Pokud je to copyable, p≈ôidej copy pilulku
            if (el.matches(COPY_SELECTOR) && !$('.copy-pill', wrap)) bindCopy(wrap, el);
            // Pokud je to adjustable, p≈ôidej adjust pilulku
            if (el.matches(ADJUST_SELECTOR) && !$('.adjust-pill', wrap)) bindAdjust(wrap, el);
        };

        const scan = () => {
            $$(`${COPY_SELECTOR}, ${ADJUST_SELECTOR}`)?.forEach(setupOne);
        };

        // Ve≈ôejn√© API pro dynamick√© DOM zmƒõny
        window.adjustScan = scan;

        // INIT
        scan();

    })
    ();
</script>


<script>
    // ===================================
    // ======= Calculation helpers =======

    const calc_val_tare = (x, x_tare = 0) => x - x_tare;
    const calc_area = (b, h) => b * h;
    const calc_moment_of_inertia = (b, h) => 1 / 12 * b * (h * h * h);
    const calc_flex_modulus = (L, I, F, w) => (F * (L * L * L)) / (48 * I * w);
    const calc_flex_strength = (F, L, b, h) => (3 * F * L) / (2 * b * (h * h));
    const calc_stress = (F, A) => F / A;
    const calc_speed = (d, t) => d / t;
    const calc_load_speed = (v_orig, t_orig, t_load) => v_orig * (t_orig / t_load);
    const calc_indentation_diameter = (h, D) => 2 * Math.sqrt(h * (D - h));
    const calc_hardness_brinell = (F, D, d) => (2 * F) / (Math.PI * D * (D - Math.sqrt((D * D) - (d * d))));

    // =====================================================================
    // =====================================================================


    // ƒçten√≠ ƒç√≠sla z inputu p≈ôes tvoje utility
    const readNum = (id, positiveOnly = false) => {
        const el = $ID(id);
        if (!el) return NaN;
        const val = getNumValue(el.value, "none");  // umo≈æn√≠ ƒç√°rku, ¬±, apod.
        return !positiveOnly ? val : (val < 0 ? NaN : val);
    };

    // z√°pis do outputu jako ƒç√≠sla s fixn√≠ p≈ôesnost√≠
    const writeOut = (id, value, dec = 3) => {
        const el = $ID(id);
        if (!el) return;
        el.value = getCustomStrValue(value, String(dec), '.', false, false, "‚Åø/‚Çê"); // TODO: dec jako ƒç√≠slo nebo string??
    };

    const applyAdjust = (id, value) => (exists(id) && adjustGet(id) !== value) ? adjustSet(id, (!isInvalidValue(value) ? value : NaN)) : null;


    // -------------------- Hlavn√≠ p≈ôepoƒçet --------------------
    function recomputeAll() {
        if (!pageLoaded) return;

        fillComputableInputs();

        // --- naƒçten√≠ spoleƒçn√Ωch vstup≈Ø (tare) ---
        const F_tare = readNum("inputTareForce");      // N
        const w_tare = readNum("inputTareDisp");       // mm

        // --- B/IB/HB spoleƒçn√© ---
        const F_raw = readNum("inputForce");           // N
        const w_raw = readNum("inputDisp");            // mm
        const F = calc_val_tare(F_raw, F_tare);
        const w = calc_val_tare(w_raw, w_tare);

        const expType = $ID("experimentTypeDropdown")?.value.toLowerCase();

        const isB = expType.endsWith("-flx");
        const isIB = expType.endsWith("-inb");
        const isHB = expType.endsWith("-hbr");

        if (!isB && !isIB && !isHB) return; // nic dal≈°√≠ho nep≈ôepoƒç√≠t√°me

        const b = readNum("inputWidth", true);   // mm
        const h = readNum("inputHeight", true);  // mm


        // -------------------- IB: pr≈Ø≈ôez + napƒõt√≠ --------------------
        if (isIB) {
            // A = b*h
            const l = readNum("inputLength", true);     // mm
            const A = calc_area(b, l); // mm^2
            if (exists("outputArea")) writeOut("outputArea", A, 3);


            // œÉ_max = F / A
            const sigma = calc_stress(F, A); // N/mm^2 = MPa
            if (exists("outputMaxStress")) writeOut("outputMaxStress", sigma, 3);

        }

        // -------------------- B: ohyb (I_y, E) --------------------
        if (isB) {
            const I = calc_moment_of_inertia(b, h); // mm^4
            if (exists("outputIy")) writeOut("outputIy", I, 3);

            // Modulus: E = (F * L^3) / (48 * I * w)   (3-bodov√Ω ohyb uprost≈ôed)
            const L = readNum("inputSpan", true); // mm
            const E = calc_flex_modulus(L, I, F, w); // vych√°z√≠ v N/mm^2 = MPa
            if (exists("outputModulus")) writeOut("outputModulus", E, 3);


            // (Max strength) f_m = (3*F*L) / (2*b*h^2)
            const Fmax = readNum("outputForceMax", false); // N
            const f_m = calc_flex_strength(Fmax, L, b, h) // N/mm^2 = MPa
            if (exists("outputFlexStrength")) writeOut("outputFlexStrength", f_m, 3);

            const b_dry = readNum("inputWidth_BeforeDrying", true);     // mm
            applyAdjust('inputWidth', b_dry);
            applyAdjust('inputWidth_BeforeDrying', b);

            const h_dry = readNum("inputHeight_BeforeDrying", true);   // mm
            applyAdjust('inputHeight', h_dry);
            applyAdjust('inputHeight_BeforeDrying', h);

            // const L_dry = readNum("inputLength_BeforeDrying", true);       // mm
            // applyAdjust('inputSpan', L_dry);
            // applyAdjust('inputLength_BeforeDrying', L);
        } else {
            adjustDel('inputWidth');
            adjustDel('inputHeight');
            adjustDel('inputWidth_BeforeDrying');
            adjustDel('inputHeight_BeforeDrying');
            adjustDel('inputSpan');
        }

        // -------------------- HB: Brinell --------------------
        if (isHB) {
            const D = readNum("inputIndDiameter", true); // mm (‚åÄ indenteru)
            const hD = readNum("inputIndDepth", true);    // mm (hloubka vtisku)

            // d = 2 * sqrt( h * (2r - h) )  ;  2r = D  ; d = 2 * sqrt( h * (D - h) )
            const d = calc_indentation_diameter(hD, D);

            if (exists("outputDiameterInd")) writeOut("outputDiameterInd", (hD > D / 2) ? NaN : d, precisionPositionSystem);

            // HB = (2*F) / (œÄ*D*(D - sqrt(D^2 - d^2)))
            const HB = calc_hardness_brinell(F, D, d);
            if (exists("outputHardness")) writeOut("outputHardness", (hD > D / 2) ? NaN : HB, 4);
        }
    }

    // -------------------- Event wiring --------------------
    function bindRecalcOnInputs() {
        if (!exists("experimentTypeDropdown")) return;

        // jak√Ωkoli input/number v bloc√≠ch s class .data-eq spust√≠ p≈ôepoƒçet
        const inputs = $$('.data-eq input[type="number"]');
        inputs?.forEach((el) => {
            // "input" je plynulej≈°√≠; "change" je a≈æ po opu≈°tƒõn√≠ pole. D√°me oboje.
            el.addEventListener('input', async () => recomputeAll());
        });

        $ID('experimentTypeDropdown')?.addEventListener('change', async () => recomputeAll());
    }

    function fillComputableInputs() {
        const forces = sumND(forceData, 2); // souƒçet sil ze v≈°ech kan√°l≈Ø
        const displacements = positionData;

        // const minimalForceID = minimumIdx(forces);
        const maximalForceID = maximumIdx(forces);

        const F_tare = readNum("inputTareForce");      // N
        const w_tare = readNum("inputTareDisp");       // mm

        const Fmax_raw = forces[maximalForceID];            // N
        const w_Fmax_raw = displacements[maximalForceID];   // mm

        const Finitial_raw = readNum("inputInitialForce"); // N
        const [w_Finitial_raw, FinitialInd] = findTargetForce(forces, displacements, Finitial_raw);
        const w_Finitial = calc_val_tare(w_Finitial_raw, w_tare);

        const Fmax = calc_val_tare(Fmax_raw, F_tare);
        const w_Fmax = calc_val_tare(w_Fmax_raw, w_tare);

        // Zapi≈° z√°kladn√≠ "max" (rozumƒõj aktu√°ln√≠ zadan√©) hodnoty, pokud v√Ωstupy existuj√≠
        if (exists("outputForceMax")) writeOut("outputForceMax", Fmax, precisionForceSystem);
        if (exists("outputDisp")) writeOut("outputDisp", w_Fmax, precisionPositionSystem);

        const Ftarget_goal = readNum("inputTargetForce"); // N
        const [w_Ftarget_raw, FtargetInd] = findTargetForce(forces, displacements, Ftarget_goal);
        const w_Ftarget = calc_val_tare(w_Ftarget_raw, w_tare);
        if (exists("inputTargetDisp")) writeOut('inputTargetDisp', w_Ftarget, precisionPositionSystem + 1);

        const inputForce = readNum("inputForce");
        const foundForce = nearest(forces, inputForce);
        const foundForceInd = foundForce.indexes;
        const isCloseForce = foundForceInd.length > 0 && (foundForce.distance < Math.max((inputForce * 0.02), (1 / Math.pow(10, Math.round(precisionForce / 2)))));
        const w_inputForce = isCloseForce ? roundDecimalFast(displacements[foundForceInd[0]], precisionPositionSystem) : NaN; // mm
        applyAdjust('inputDisp', w_inputForce);


        if ($ID("experimentTypeDropdown")?.value.toLowerCase().endsWith("-hbr")) {
            const finalForce = roundDecimalFast(mean1D(forces.slice(FtargetInd)), precisionForceSystem);
            applyAdjust('inputForce', finalForce);


            const depthIndentation = roundDecimalFast(displacements[displacements.length - 1] - displacements[FinitialInd], precisionPositionSystem);
            applyAdjust('inputIndDepth', depthIndentation);


            // Rychlost zatƒõ≈æov√°n√≠: v = w_T / t
            const time = timeData;

            const t_goal = readNum("inputLoadingTime", true);                   // s
            const w_goal = calc_val_tare(w_Ftarget_raw, w_Finitial_raw);        // mm

            const t_Finitial_raw = time[FinitialInd];                                               // s
            const t_set_raw = time[FtargetInd];                                                     // s
            const t_set = calc_val_tare(t_set_raw, t_Finitial_raw);                                 // s
            const v_set = catchVal(speedForward_mmps, readNum("inputSpeedForward", true), isNum);   // mm/s

            const v1 = calc_speed(w_goal, t_goal);              // variant 1     mm/s
            const v2 = calc_load_speed(v_set, t_set, t_goal);  // variant 2     mm/s

            console.log("\n",
                "\n\tGuest 1:", roundDecimalFast(v1, precisionSpeedSystem),
                "\n\tGuest 2:", roundDecimalFast(v2, precisionSpeedSystem));
            const v = v2;

            if (exists("outputLoadingSpeed")) writeOut("outputLoadingSpeed", v, precisionSpeedSystem + 2);

            // TODO: speed: 0.6825mm/s => time: 2.6s - 5.2s => target time: 15s => new speed: 0.2944mm/s
            // TODO: ŒîT = 5.2 - 2.6 = 2.6s
            // TODO: ((5.2-2.6) / 15) = 0.1733 [-]
            // TODO: 0.6825 * ((5.2-2.6) / 15) = 0.1183 mm/s

            // TODO: v_new1 = position / T_target = (v_old * T_old) / T_target = ((position / T_old) * T_old) / T_target = position / T_target
            // TODO: v_new2 = v_old * (T_old / T_target) = (position / T_old) * (T_old / T_target) = position / T_target

        } else {
            const inputDisp = readNum("inputDisp");
            const foundDisp = nearest(displacements, inputDisp);
            const foundDispInd = foundDisp.indexes;
            const isCloseDisp = foundDispInd.length > 0 && (foundDisp.distance < Math.max((inputDisp * 0.02), (1 / Math.pow(10, Math.round(precisionPosition / 2)))));
            const F_inputDisp = isCloseDisp ? roundDecimalFast(forces[foundDispInd[0]], precisionForceSystem) : NaN; // N
            applyAdjust('inputForce', F_inputDisp);
        }
    }

    function clearCalculations() {

        $ID('inputTareForce').value = '0';
        $ID('inputTareDisp').value = '0';
        $ID('inputMaterialName').value = '';
        $$(".data-eq[data-eq-type]")?.forEach(el => {
            $$('input', el)?.forEach(input => {
                input.value = '';
            });
        });
        recomputeAll();
    }
</script>


<script>

    // -------------------- Global variables --------------------
    let systemLevel = 0;

    let pageLoaded = false;
    let dataLoaded = false;
    let allLoaded = false;
    let pageLoadTimeout = 0;

    let lastTitle = document.title;


    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////


    let calibrationStatus = false;
    let currentSpeed = null;
    let currentAcceleration = null;

    /////////////////////////////////////////////////////////////////


    // Store dataset
    let timeData = [];
    let positionData = [];
    let forceData = Array(catchVal(loadCellNum, 0, isNum)).fill(null).map(() => []);
    let photoData = []; // List of time markers

    let notificationsAllowed = false;


    /////////////////////////////////////////////////////////////////

    // -------- Local Storage Keys ------ //
    const storageKeyBase = "MoiraUIData";                    // Base-name of Key in localStorage
    const storageKeyDefaults = `${storageKeyBase}_Defaults`; // System Defaults Key in localStorage (all)
    const storageKeyIdle = `${storageKeyBase}_Idle`;         // User Defaults Key in localStorage (some)
    const storageKeySys = `${storageKeyBase}_Sys`;           // User-System Defaults Key in localStorage (rest)
    let storageKey = storageKeyIdle;                         // Current Key in localStorage

    // -------- IndexedDB Setup -------- //
    const DB_NAME = "MoiraMeasurementData";// Database name
    const STORE_NAME = "LastLog";// Store name for saving log entries
    let db;// Database instance

</script>

<script>
    function showNotification(title = "Notification", message = "This is a notification.") {
        if (!("Notification" in window)) {
            alert("Your browser does not support notifications.");
            return;
        }

        if (notificationsAllowed) {
            // Show notification immediately
            new Notification(title, {body: message});
        } else {
            // Request permission if not yet granted
            Notification.requestPermission().then(permission => {
                if (permission === "granted") {
                    notificationsAllowed = true;
                    new Notification(title, {body: message});
                } else {
                    alert("Notifications were not allowed.");
                }
            });
        }
    }

</script>

<script>
    // /////// UI Elements /////////
    const UI = {
        regularLogContainer: $ID("regularLog"),// Reference to the log display container
        loadingLogContainer: $ID("loadingLog"),// Reference to the loading log display container
        toggleScrollBtn: $ID("toggleScrollBtn"), // Button to toggle automatic scrolling
        lineLockBtn: $ID("toggleLineLockBtn"), // Button to lock the log view
        commandInput: $ID('commandInput'),// Input elements for command entry and settings
        sendButton: $ID('sendButton'),// Input elements for command entry and settings

        chartsLiveButton: $ID('toggleLive'),// Input elements for command entry and settings
        connectionStatus: $ID("connectionStatus"), // Display for connection status
        connectBtns: $$(".connectBtn"), // Container for connection buttons
        USB: $ID("connectBtnUSB"), // Button to connect via USB
        Bluetooth: $ID("connectBtnBluetooth"), // Button to connect via Bluetooth
        WiFi: $ID("connectBtnWiFi"), // Button to connect via WiFi

        progressBar: $ID("experimentProgress"), // Progress bar for experiment status
        progressLabel: $ID("experimentProgressLabel"), // Label for progress percentage
        experimentStageLabel: $ID("experimentStage"), // Label for current experiment stage

        timeChartContainer: $ID("timeChart"),
        positionChartContainer: $ID("positionChart"),
        chartsContainer: $ID("chartsContainer"),

        autoReturnPosition: $ID("autoReturnPositionExperiment"),
        autoReturnPositionLabel: $ID("autoReturnPositionExperimentLabel"),

        moveUpBtn: $ID("moveMachineUP"), // Button to move the device up
        moveDownBtn: $ID("moveMachineDOWN"), // Button to move the device down
        moveUp50Btn: $ID("moveUp50"), // Button to move the device up
        moveDown50Btn: $ID("moveDown50"), // Button to move the device down


        moveToBtn: $ID("moveToBtn"), // Button to move to a specific position
        moveToInput: $ID("moveToInput"), // Input field for target position

        calibrateBtn: $ID("calibrateBtn"), // Button to calibrate the device

        speedSlider: $ID("movementSpeed"), // Slider for speed adjustment
        speedLabel: $ID("labelSpeed"), // Label for speed value
        accelerationSlider: $ID("movementAcceleration"), // Slider for acceleration adjustment
        accelerationLabel: $ID("labelAcceleration"), // Label for acceleration value
    };

    // Connection status messages and colors
    const connectionStates = {
        connected: {statusText: "üü¢ Connected", btnText: "‚ùå Disconnect ESP (USB)", color: "#4CAF50", functional: true},
        connecting: {statusText: "üîµ Connecting...", btnText: "üîì Connecting...", color: "#2196F3", functional: false},
        reconnecting: {
            statusText: "üü† Reconnecting...",
            btnText: "üîÑ Reconnecting...",
            color: "#FFA500",
            functional: false
        },
        disconnected: {statusText: "üî¥ Disconnected", btnText: "üîå Connect via USB", color: "#FF0000", functional: true},
        disconnecting: {
            statusText: "üü£ Disconnecting...",
            btnText: "üîê Disconnecting...",
            color: "#886CE4",
            functional: false
        },
    };

    function updateConnectionStatus(status, type = null) {
        if (!connectionStates[status]) return;
        UI.connectionStatus.innerHTML = `${connectionStates[status].statusText || ""} ${type ? `via ${type}` : ""}`;
        UI.connectionStatus.style.color = connectionStates[status].color;
        UI.connectBtns?.forEach(btn => btn.classList.toggle('disabled', !connectionStates[status].functional));
        UI.USB.innerText = `${connectionStates[status].btnText || ""}`;
    }

    // /////// Event Listeners for UI Buttons /////////
    // These were commented out, but they could be used to attach click events
    (() => {
        const addControlContainer = (name) => {
            const btn = $ID(name + "OpenBtn");
            const el = $ID(name);
            btn?.addEventListener('click', async () => controlContainer(btn, el));
            window.addEventListener('resize', async () => controlContainerWidth(el));
        };

        addControlContainer("resultsContainer");
        addControlContainer("settingsContainer");
        addControlContainer("consoleContainer");
    })();


    function controlContainerWidth(container) {
        if (!container) return;
        if (isStr(container)) container = $ID("resultsContainer");
        if (window.getComputedStyle(container).maxHeight !== "0px") {
            container.style.maxHeight = container.scrollHeight + "px"; // Adjust height on window resize
        }
    }


    function controlContainer(btn, container) {
        if (!container || !btn) return;

        if (window.getComputedStyle(container).maxHeight === "0px") {
            container.style.visibility = 'visible';
            container.style.maxHeight = container.scrollHeight + "px"; // Open the container and get real height
            container.style.opacity = "1";
            btn.textContent = "üîº";
        } else {
            container.style.maxHeight = "0"; // Close the container
            container.style.opacity = "0";
            btn.textContent = "üîΩ";
            setTimeout(() => container.style.visibility = 'hidden', 550);
        }
    }


    // /////// Input Validation and Adjustment /////////

    // Ensures user input is within a valid min / max range
    function checkInput(element, valueType, decimalPlaces) {
        if (!element) return;

        const val = parseFloat(element?.value);
        const min = parseFloat(element?.min);
        const max = parseFloat(element?.max);
        let newVal = val;

        // Validate input: if empty, set to a minimum or 0
        if (!isNum(val)) {
            if (isNum(min)) newVal = min;
            else if (isNum(max)) newVal = max;
            else return;
        } else if (typeof valueType === "string") {
            if (valueType === "intInput") {
                newVal = Math.floor(val)
            }

            // Enforce min/max constraints
            if (isNum(min) && newVal < min) {
                newVal = min;
            }
            if (isNum(max) && newVal > max) {
                newVal = max;
            }

            if (valueType.includes("floatInput")) {

                decimalPlaces = toNumber(decimalPlaces);
                let roundTo =
                    isNum(decimalPlaces) ? decimalPlaces : parseFloat(valueType.replace('floatInput', ''));

                if (!isNum(roundTo)) {
                    roundTo = maxPrecision;
                    const step = element?.step.trim();

                    if (step && !step.includes("any")) { // step !== "any" && step !== "any,any"
                        const decimals = (step.replace(',', '.').split(".")[1] || "").length;
                        const stepVal = Math.abs(parseFloat(step));

                        if (isNum(stepVal) && stepVal > 0) {
                            if (stepVal < 1 && decimals > 0) roundTo = decimals;
                            if (stepVal >= 1) roundTo = stepVal;
                        }
                    }

                    roundTo = Math.max(roundTo, 5);
                }


                if (!isNum(roundTo)) roundTo = maxPrecision;

                roundTo = Math.abs(Math.min(Math.round(roundTo), maxPrecision));

                if (roundTo >= 0) newVal = roundDecimalFast(newVal, roundTo);
            }
        }
        if (val !== newVal) {
            element.value = newVal;
            element.dispatchEvent(new Event("change", {bubbles: true}));
        }
    }


    // --- p≈ôevod jednotkov√© notace na HTML (povoleno jen <sub>/<sup>) ---
    function unitMarkupToHTML(str = '') {
        // escape v≈°eho‚Ä¶
        let out = String(str).replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

        // ‚Ä¶a povol jen tyto formy z√°pisu sub/sup:

        // [sub]x[/sub], [sup]x[/sup]
        out = out.replace(/\[sub]([\s\S]*?)\[\/sub]/gi, '<sub>$1</sub>')
            .replace(/\[sup]([\s\S]*?)\[\/sup]/gi, '<sup>$1</sup>');

        // entity &lt;sub&gt;x&lt;/sub&gt; a &lt;sup&gt;‚Ä¶&lt;/sup&gt;
        out = out.replace(/&lt;(sub|sup)&gt;([\s\S]*?)&lt;\/\1&gt;/gi, '<$1>$2</$1>');

        // podtr≈æ√≠tko / st≈ô√≠≈°ka: _{...}, _x, ^{...}, ^x
        out = out.replace(/_\{([^}]+)}/g, '<sub>$1</sub>')
            .replace(/_([A-Za-z0-9+\-‚àí¬±]+)/g, '<sub>$1</sub>')
            .replace(/\^\{([^}]+)}/g, '<sup>$1</sup>')
            .replace(/\^([A-Za-z0-9+\-‚àí¬±]+)/g, '<sup>$1</sup>');

        return out;
    }

    // --- doplnƒõn√≠ labelu ---
    function updateUnitsLabel(input) {
        if (!input || !input.id) return;
        const unitRaw = (input.dataset.unit || '').trim();
        const span = $(`label[for="${input.id}"] .units-text`);
        if (!span) return;
        span.innerHTML = unitRaw ? ` (${unitMarkupToHTML(unitRaw)})` : '';
    }
</script>

<script>

    function toggleDarkMode() {
        const body = document.body;
        const currentTheme = body.dataset.theme;
        const newTheme = currentTheme === "dark" ? "light" : "dark";
        $ID('darkModeButton').innerText = currentTheme === "dark" ? "üåô Dark mode" : "‚òÄÔ∏è Light mode";
        body.dataset.theme = newTheme;
        localStorage.setItem("theme", newTheme); // Save the theme to localStorage
        console.info("Theme changed to:", newTheme);
    }


    // Load the saved theme from localStorage on initialization
    const savedTheme = localStorage.getItem("theme") || "light";
    if (exists('darkModeButton')) $ID('darkModeButton').innerText = savedTheme === "dark" ? "‚òÄÔ∏è Light mode" : "üåô Dark mode"
    document.body.dataset.theme = savedTheme;

</script>


<script>

    // Function Clear `localStorage`
    function clearLocalStorage() {
        if (!storageKey) {
            console.error("Storage key is not defined.");
            return;
        }
        setSerialSignals(serialPort, true, true);

        disconnectSerial();

        localStorage.removeItem(storageKey); // Remove the saved data
        console.info("LocalStorage cleared.");

        window.location.reload();
    }

    // Function to save ONE input to localStorage
    function saveInputToLocalStorage(event) {
        if (!storageKey) {
            console.error("Storage key is not defined.");
            return;
        }
        const input = event.target; // Get the input element
        let formData = JSON.parse(localStorage.getItem(storageKey)) || {}; // Load the saved data

        // Save the input value to the formData object or select the checked state for checkboxes
        formData[input.id] = (input.type === "checkbox") ? input.checked : input.value;

        localStorage.setItem(storageKey, JSON.stringify(formData)); // Save the updated data
    }


    // Function to save ALL inputs to localStorage
    function saveAllInputsToLocalStorage(elements, storage) {
        if (!storage) {
            console.error("Storage key is not defined.");
            return;
        }
        if (!elements) {
            console.error("Elements to load are not defined.");
            return;
        }

        let formData = {};

        elements?.forEach(input => {
            formData[input.id] = (input.type === "checkbox") ? input.checked : input.value;

        });

        localStorage.setItem(storage, JSON.stringify(formData));
        console.info("All data saved to localStorage.");
    }

    // Function to load inputs from localStorage
    function loadInputsFromLocalStorage(elements, storage) {
        if (!storage) {
            console.error("Storage key is not defined.");
            return;
        }
        if (!elements) {
            console.error("Elements to load are not defined.");
            return;
        }

        const formData = JSON.parse(localStorage.getItem(storage)) || {}; // Load the saved data

        if (!formData) saveAllInputsToLocalStorage(elements, storage);

        elements?.forEach(input => {
            if (formData.hasOwnProperty(input.id)) {
                if (input.type === "checkbox") {
                    input.checked = formData[input.id]; // Restore the checkbox state
                } else if (input.tagName.toLowerCase() === "select") {
                    const options = Array.from(input.options).map(option => option.value);
                    if (options.some(option => option === formData[input.id])) {
                        input.value = formData[input.id]; // Restore the select value if it exists
                    } else if (options.some(option => option === "none")) {
                        // Set to fallback if saved value doesn't exist and make it display properly
                        input.value = "none";
                    }
                } else {
                    input.value = formData[input.id]; // Restore the input value
                }
            }

            // Trigger change event to update the UI
            input.dispatchEvent(new Event("change", {bubbles: true}));
            input.dispatchEvent(new Event("input", {bubbles: true}));
            input.dispatchEvent(new Event("blur", {bubbles: true}));
        });
    }


    function importSettings() {
        if (!allLoaded) return;
        if (isExperimentRunning) return;

        if (!storageKey) {
            console.error("Storage key is not defined.");
            return;
        }

        const input = $MAKE('input');
        input.type = 'file';
        input.accept = '.json,application/json';

        input.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const content = e.target.result || '';
                    const formData = JSON.parse(String(content));

                    if (typeof formData !== 'object' || isVoid(formData)) {
                        console.error("Invalid settings file format.");
                        return;
                    }

                    localStorage.setItem(storageKey, JSON.stringify(formData));
                    loadInputsFromLocalStorage(null, storageKey); // TODO: pass elements instead of null
                    console.info("\nüìÇ Settings imported successfully.");
                } catch (error) {
                    console.error("Error reading settings file:", error);
                }
            };
            reader.readAsText(file);
        });

        input.click();
    }


    function exportSettings() {
        if (!allLoaded) return;

        if (!storageKey) {
            console.error("Storage key is not defined.");
            return;
        }

        const data = localStorage.getItem(storageKey)

        if (!data) {
            console.warn("No settings found to export.");
            return;
        }

        const formData = JSON.parse(data) || {};
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(formData, null, 2));
        const downloadAnchorNode = $MAKE('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", "moira_settings.json"); // TODO: add profiles later
        document.body.appendChild(downloadAnchorNode); // required for firefox
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
        console.info("\nüìÅ Settings exported successfully.");
    }
</script>


<script>
    // /////// Log Control Functions /////////

    // ------------ Log Settings ------------
    let isAutoScroll = true;// Enables automatic scrolling of log output
    let isLineLimit = true;// Limits the number of stored log lines
    let isLineLocker = true;// Locks the view at a fixed position when scrolling is disabled
    let logContentMaxLines = 150;// Maximum number of log lines to keep in memory
    let isScrolledToBottom = true;// Tracks whether the user has scrolled to the bottom of the log
    let logCount = 0; // Counter for received messages
    let logContentLines = []; // Array storing the log content

    let lastAutoScroll = null;
    let rafId = null;

    // ------------ Auto-scroll ------------
    UI.toggleScrollBtn.addEventListener('click', async () => {
        isAutoScroll = !isAutoScroll;
        UI.toggleScrollBtn.classList.toggle('active', isAutoScroll);
        UI.toggleScrollBtn.textContent = `üìå Auto-scroll: ${isAutoScroll ? "ON" : "OFF"}`;
        if (isAutoScroll) {
            UI.regularLogContainer.scrollTop = UI.regularLogContainer.scrollHeight;
        }
    });

    // Detects manual scrolling by the user
    UI.regularLogContainer.addEventListener('scroll', () => {
        if (rafId) return;
        rafId = requestAnimationFrame(() => {
            const atBottom = checkScrolledToBottom();
            if (atBottom !== lastAutoScroll) {
                lastAutoScroll = atBottom;
                isAutoScroll = atBottom;
                UI.toggleScrollBtn.textContent = `üìå Auto-scroll: ${atBottom ? "ON" : "OFF"}`;
                UI.toggleScrollBtn.classList.toggle('active', atBottom);
            }
            rafId = null;
        });
    }, {passive: true}); // scroll je sice necancelovateln√Ω, ale passive=hint


    // Checks if the user is scrolled to the bottom of the log
    function checkScrolledToBottom(scrollTop = UI.regularLogContainer.scrollTop, clientHeight = UI.regularLogContainer.clientHeight, scrollHeight = UI.regularLogContainer.scrollHeight) {
        return Math.abs(scrollTop + clientHeight - scrollHeight) < 2;
    }

    // Toggles whether the log view is locked at a specific position
    function lineConsoleLock() {
        isLineLocker = !isLineLocker;
        if (isLineLocker) {
            UI.lineLockBtn.textContent = "üîí Fix Scroll: ON";
        } else {
            UI.lineLockBtn.textContent = "üîì Fix Scroll: OFF";
        }
    }

    // Clears the log completely
    function clearConsoleLog() {
        logContentLines = [];
        logCount = 0;
        UI.regularLogContainer.textContent = "";
    }


    // ------------ Command Input Handling ------------

    // Listens for the Enter key in the command input field and sends command
    UI.commandInput.addEventListener("keydown", async (event) => {
        if (event.key === "Enter") {
            event.preventDefault();
            await sendCommandConsole(UI.commandInput.value.trim());
        }
    });

    // Sends command when clicking the send-button
    UI.sendButton.addEventListener('click', async () => {
        await sendCommandConsole(UI.commandInput.value.trim());
    });


</script>


<script>
    // /////// Logging Messages /////////
    const visibleLines = Math.floor(UI.loadingLogContainer.clientHeight / 16);
    UI.loadingLogContainer.style.fontFamily = "monospace";
    UI.loadingLogContainer.style.fontSize = "14px";
    UI.loadingLogContainer.style.overflow = "hidden";

    // Global array for storing log messages in memory for display on the canvas
    // let logs = [];

    // // /////// Canvas DPI Adjustment /////////
    // function adjustCanvasDPI(canvas) {
    //     const ctx = canvas.getContext('2d', {willReadFrequently: true}); // Optimized for frequent reading
    //     const dpi = (window.devicePixelRatio || 1) * 1.5;
    //
    //     // Get the size of the canvas in CSS pixels.
    //     const width = canvas.clientWidth;
    //     const height = canvas.clientHeight;
    //
    //     // Store the current transformation matrix
    //     const savedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    //
    //     // Scale the canvas up by the device pixel ratio
    //     canvas.width = width * dpi;
    //     canvas.height = height * dpi;
    //     ctx.scale(dpi, dpi);
    //
    //     // Restore the old transformation matrix
    //     ctx.putImageData(savedImageData, 0, 0);
    //
    //     // Redraw the text on the canvas
    //     redrawCanvasText();
    //
    //     console.info(`üé® Canvas DPI changed: ${dpi}`);
    // }
    //
    // // Redraws the text on the canvas
    // function redrawCanvasText() {
    //     const ctx = UI.loadingLogContainer.getContext('2d');
    //     ctx.clearRect(0, 0, UI.loadingLogContainer.width, UI.loadingLogContainer.height);
    //
    //     ctx.font = '14px monospace';
    //     ctx.textBaseline = 'top';
    //
    //     const lineHeight = 16;
    //     const visibleLines = Math.floor(UI.loadingLogContainer.clientHeight / lineHeight);
    //     let scrollOffset = Math.max(0, logs.length - visibleLines);
    //
    //     for (let i = scrollOffset; i < logs.length; i++) {
    //         let msg = logs[i];
    //
    //         // üî• Change color to yellow if a message starts with "ds" (case-insensitive)
    //         if (msg.toLowerCase().startsWith("ds")) {
    //             ctx.fillStyle = 'yellow';
    //         } else {
    //             ctx.fillStyle = 'white';
    //         }
    //
    //         ctx.fillText(msg, 5, (i - scrollOffset + 0.5) * lineHeight);
    //     }
    // }
    //
    // // Function to log measurements to the canvas
    // function logMeasurements(msg) {
    //     if (!msg || typeof msg !== 'string') return;
    //
    //     logs.push(msg);
    //     if (logs.length > 100) logs.shift(); // Keep only the last 100 messages
    //
    //     redrawCanvasText();
    // }
    //
    // // Initial DPI adjustment for the canvas
    // adjustCanvasDPI(UI.loadingLogContainer);
    //
    // // Event listener for resizing the window and adjusting the canvas DPI
    // window.addEventListener("resize", () => adjustCanvasDPI(UI.loadingLogContainer));

    function logMeasurements(msg) {
        if (!msg || typeof msg !== 'string') return;

        // Check if a message starts with "ds" and apply yellow color, else use white
        let formattedMsg = msg.toLowerCase().startsWith("ds")
            ? `<span style="color:yellow;">${msg}</span>` // Highlight DSLR data
            : `<span style="color:white;">${msg}</span>`; // Normal log

        // Append the formatted message directly
        UI.loadingLogContainer.innerHTML += formattedMsg + "<br>";

        // Auto-scroll to the bottom for the latest logs
        UI.loadingLogContainer.scrollTop = UI.loadingLogContainer.scrollHeight;

        // Limit logs to 100 lines for performance
        let lines = UI.loadingLogContainer.innerHTML.split("<br>");
        if (lines.length > visibleLines) {
            UI.loadingLogContainer.innerHTML = lines.slice(lines.length - visibleLines).join("<br>");
        }
    }

    // Logs a message to the regular log container
    // const logLineHeight = 1.2 * parseInt(window.getComputedStyle(UI.regularLogContainer).fontSize);


    function logMessage(msg) {
        msg = (msg)?.toString() || "";
        if (isEmptyStr(msg)) return;

        isScrolledToBottom = checkScrolledToBottom();

        while (isLineLimit && (logCount >= logContentMaxLines)) {
            logContentLines.shift();
            logCount--;
        }


        logContentLines.push(msg);
        logCount++;
        UI.regularLogContainer.textContent = logContentLines.join("\n");


        if (isAutoScroll) {
            UI.regularLogContainer.scrollTop = UI.regularLogContainer.scrollHeight;
        }

        // // TODO : change to remember scrollPosition and scrollHeight, and scroll to it minus the new scrollHeight
        // if (isLineLocker) {
        //     UI.regularLogContainer.scrollTop -= Math.floor(UI.regularLogContainer.scrollHeight / (logCount - 1)); // UI.regularLogContainer.scrollHeight / logContentLines.length; // logCount;
        //     // console.info(UI.regularLogContainer.scrollHeight, logLineHeight * logCount, UI.regularLogContainer.scrollHeight / (logLineHeight * (logCount + 1)))
        //     // UI.regularLogContainer.scrollTop -= logLineHeight; // UI.regularLogContainer.scrollHeight / logContentLines.length; // logCount;
        // }

        if (isScrolledToBottom) {
            UI.regularLogContainer.scrollTop = UI.regularLogContainer.scrollHeight;
        }
    }


</script>


<script>
    // /////// IndexedDB Database Configuration /////////

    // /////// Opening IndexedDB /////////

    /**
     * Opens the IndexedDB database and initializes it if needed.
     */
    async function openDB() {
        let request = indexedDB.open(DB_NAME, 1);

        request.onupgradeneeded = function (event) {
            db = event.target.result;

            // Creates a new object store with an auto-incremented key
            db.createObjectStore(STORE_NAME, {keyPath: "id", autoIncrement: true});
            console.info("%c\n‚úÖ IndexedDB created", "color: green; font-weight: bold;");
        };

        request.onsuccess = function (event) {
            db = event.target.result;
            console.info("%c\n‚úÖ IndexedDB opened", "color: green; font-weight: bold;");
            checkExistingLog();
        };
    }

    function checkExistingLog() {
        const transaction = db.transaction(STORE_NAME, "readonly");
        const store = transaction.objectStore(STORE_NAME);
        const request = store.count();

        request.onsuccess = async function () {
            await loadDataFromDBToChart(false);

            if (request.result > 0) {
                // TODO: p≈ôem√≠stit dotaz na 'star√° data' a≈æ po naƒçten√≠ v≈°eho a upravit dotaz, aby se ptal na smaz√°n√≠ a chtƒõl to 2x potvrdit
                // if (confirm("üîÑ Old log exists. Keep it or delete?\nOK = Keep\nCancel = Delete")) {
                //     saveCSV();
                // } else {


                // transaction = db.transaction(STORE_NAME, "readonly");
                // store = transaction.objectStore(STORE_NAME);
                const request2 = store.getAll();
                request2.onsuccess = async function () {
                    let dataEntries = request2.result;
                    const experimentInfo = dataEntries[0];


                    let date = "Unknown date";
                    const expDate = experimentInfo.experimentDate;
                    if (expDate) {
                        const dateFormat = getLocaleOrder();
                        date = `${expDate} [${dateFormat.date} ${dateFormat.time}]`;
                        console.info(`\t\nüïí %cLast log date: ${date}`, "color: #0078d7; font-style: italic; font-weight: normal;");
                    }

                    const loadDirection = experimentInfo.loadDirection === -1 ? "DOWN" : (experimentInfo.loadDirection === 1 ? "UP" : "N/A");

                    const experimentLabel = experimentInfo.experimentLabel || "";

                    const expBasicInformation = "¬ß " + `(${date}); ` + "Loading direction: " + loadDirection + ";  " + experimentLabel + " ¬ß";

                    // replace any original Basic Information in description - up new lines and ¬ß...¬ß
                    const description = expBasicInformation + ";  " + experimentInfo.experimentDescription.replace(/(\r\n|\n|\r)/gm, " ").replace(/¬ß.*¬ß;/gm, "").trim();

                    $ID("experimentCount").value = experimentInfo.experimentCounter || "1";
                    $ID("experimentName").value = experimentInfo.experimentName || "";
                    $ID("experimentDesc").value = description || "";

                    dataLoaded = true;
                };
                // }
            } else {
                dataLoaded = true;
            }
        };
    }

    // /////// Adding Data to the Log /////////

    const dbQueue = [];
    let dbFlushTimer = null;

    /**
     * Adds a new data entry to IndexedDB.
     *@param {Object} data - The data object to be stored.
     * @param id
     */
    function addDataToLog(data, id = undefined) {
        dbQueue.push({data, id});
        if (!dbFlushTimer) dbFlushTimer = setTimeout(flushDB, 500); // flush ~2√ó za sekundu
    }

    function flushDB() {
        if (dbQueue.length === 0) {
            dbFlushTimer = null;
            return;
        } else {
            if (!db || !(pageLoaded && dataLoaded)) {
                console.warn("\n‚ùå IndexedDB not ready, cannot flush log.");
                // Wait for another 5 seconds and try again
                dbFlushTimer = setTimeout(flushDB, 5_000);
                return;
            }
        }

        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const keyPath = store.keyPath || null; // m≈Ø≈æe b√Ωt i pole, zde p≈ôedpokl√°d√°me single keyPath

        // vyber v≈°e z fronty (atomicky v jedn√© transakci)
        const items = dbQueue.splice(0);

        for (const {data, id} of items) {
            // pozor: id m≈Ø≈æe b√Ωt 0 => kontrola na null/undefined
            const hasId = isDef(id);

            if (hasId) {
                // Upsert se zadan√Ωm kl√≠ƒçem
                if (keyPath === 'id') {
                    const value = (data && typeof data === 'object')
                        ? {...data, id} : {id, value: data};
                    store.put(value); // kl√≠ƒç je v objektu (keyPath)
                } else {
                    store.put(data, id); // kl√≠ƒç p≈ôed√°n samostatnƒõ
                }
            } else {
                // ƒçist√Ω add => autoIncrement/autoKey
                store.add(data);
            }
        }

        tx.oncomplete = () => {
            dbFlushTimer = null;
        };
        tx.onerror = (e) => {
            console.error('‚ùå flushDB error:', e?.target?.error || e);
            dbFlushTimer = null;
        };
    }

    /**
     * Update (merge) z√°znamu podle id. Vrac√≠ Promise<boolean> (true = zaps√°no).
     * - Pokud z√°znam neexistuje a upsert=true, vytvo≈ô√≠ se.
     * - patch se merguje p≈ôes st√°vaj√≠c√≠ hodnotu.
     */
    function updateLogById(id, patch, {upsert = true} = {}) {
        if (isVoid(id)) return Promise.resolve(false);
        if (!(dataLoaded && pageLoaded)) return Promise.resolve(false);
        if (!db) return Promise.resolve(false);
        return new Promise((resolve, reject) => {
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            const keyPath = store.keyPath || null;


            // 1) Zjisti, jestli v≈Øbec existuj√≠ nƒõjak√© logy
            const countReq = store.count();
            countReq.onsuccess = () => {
                const total = countReq.result || 0;
                if (total > 1) {
                    // 2) Pokraƒçuj v update
                    const getReq = store.get(id);
                    getReq.onsuccess = () => {
                        const current = getReq.result;
                        if (!current && !upsert) {
                            resolve(false);
                            return;
                        }

                        // slo≈æ updated z√°znam (zachovat kl√≠ƒç)
                        let updated;
                        if (keyPath === 'id') {
                            updated = {...(current || {}), ...(patch || {}), id};
                            store.put(updated);
                        } else {
                            updated = {...(current || {}), ...(patch || {})};
                            store.put(updated, id);
                        }
                    };


                    getReq.onerror = (err) => reject(err);
                } else {
                    // nic nen√≠, nelze update
                    resolve(false);
                }
            };
            countReq.onerror = (err) => reject(err);

            tx.oncomplete = () => resolve(true);
            tx.onerror = (e) => {
                console.error('‚ùå updateById error:', e?.target?.error || e);
                reject(e);
            };
        });
    }


    // /////// Clearing the Database Log /////////
    async function clearDatabase() {
        if (!db) {
            console.warn("\n‚ùå IndexedDB not ready, cannot clear database.");
            return;
        }
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, "readwrite");
            const store = transaction.objectStore(STORE_NAME);
            const clearRequest = store.clear();

            clearRequest.onsuccess = () => {
                console.info("üóëÔ∏è Database cleared successfully.");
                resolve(true);
            };

            clearRequest.onerror = (event) => {
                console.error("‚ùå Error clearing database:", event.target.error);
                reject(event.target.error);
            };
        });
    }

</script>

<script>
    // /////// Live Data Update and Chart Configuration /////////
    let timeChart;
    let positionChart;


    // Live update flag (disabled by default)
    let liveUpdate = false;
    let liveUpdatePaused = false;

    let dataChartInterval = 1; // Interval for live chart update

    // Maximum number of data points displayed in the charts
    const maxDataPointsExp = 1e5;
    const maxDataPointsIdle = 1_000 / 10; // 10x in 1 seconds (100 ms)
    let maxDataPoints = maxDataPointsIdle;


    // /////// Toggle Live Update /////////
    function chartUpdate() {
        if (!liveUpdate) loadDataFromDBToChart(!liveUpdate);

        liveUpdate = !liveUpdate;

        UI.chartsLiveButton.textContent = liveUpdate ? "‚è∏Ô∏è Disable Charts" : "‚èØÔ∏è Activate Charts";
        $ID("chartsWrapper").style.background = liveUpdate ? "var(--charts-bg-active)" : "var(--charts-bg)";
    }


    let isPageVisible = true; // Visibility status of the page
    let hideTimeout = null; // Timeout for hiding the page
    const MIN_HIDE_TIME = 20_000; // milliseconds

    // Event listener for page visibility change
    document.addEventListener("visibilitychange", async () => {
        if (!isExperimentRunning) return;
        if (!liveUpdate && !liveUpdatePaused) return;

        isPageVisible = !document.hidden;

        if (!isPageVisible) {
            console.info("\nüìÑ - üï∂Ô∏è Page is hidden.");


            // Set timeout for hiding the page
            if (hideTimeout) {
                clearTimeout(hideTimeout);
                hideTimeout = null; // Reset the timeout
            }
            hideTimeout = setTimeout(() => {
                if (!isPageVisible) {
                    console.info(`‚è≥ Page is hidden longer than ${roundDecimalFast(MIN_HIDE_TIME / 1_000, 2)}+ seconds.\n\tHiding...`);

                    if (liveUpdate && !liveUpdatePaused) {
                        console.info("‚è∏Ô∏è Pause live update of charts.");
                        liveUpdatePaused = true;
                        liveUpdate = false;
                    }
                }
            }, MIN_HIDE_TIME);

        } else {

            if (hideTimeout) {
                clearTimeout(hideTimeout); // Clear the hide timeout
                hideTimeout = null;
            }

            console.info("\nüìÑ - üëì Page is visible");
            if (liveUpdatePaused) {
                console.info("üîÑ Resuming live update of charts.");
                await loadDataFromDBToChart(true);
                liveUpdatePaused = false;
                liveUpdate = true;
            }
        }
    });


    function aggregateData(dataEntries, chunkSize, timeData, positionData, forceData, photoData, overflowData) {
        if (!isNum(loadCellNum)) throw new Error(`Total Loadcell count is not defined: ${loadCellNum}`);
        if (!isNum(chunkSize)) chunkSize = 1;
        chunkSize = Math.max(1, Math.round(chunkSize));

        // const photoValidStep = dataEntries.findIndex((entry, i) => isFiniteNumber(entry.photoIndex, false) && i > 0);
        // if (photoValidStep > 0 && chunkSize > photoValidStep) {
        //     chunkSize = photoValidStep; // Ensure chunkSize does not exceed the first photo event step
        //     console.warn(`‚ö†Ô∏è Adjusted chunkSize to ${chunkSize} to capture first photo event.`);
        // }

        if (chunkSize === 1) {
            // If chunkSize = 1, no aggregation is needed (1:1 mapping)
            for (let i = 0; i < dataEntries.length; i++) {
                let entry = dataEntries[i];
                timeData[i] = entry.time;
                positionData[i] = entry.position;
                entry.force?.forEach((value, index) => forceData[index][i] = value);
                photoData[i] = isNum(entry.photoIndex) ? 0 : null; // Mark photo event
            }
            return;
        }

        // const photosCount = dataEntries.reduce((count, entry) => count + (isNum(entry.photoIndex) ? 1 : 0), 0);

        let fullChunks = Math.floor(dataEntries.length / chunkSize) * chunkSize;
        // let chunkCount = Math.floor(dataEntries.length / chunkSize) + photosCount; // Block count
        let remainderStart = fullChunks; // First index of data

        // Predefine array size to match the new chunk count
        // timeData.length = chunkCount;
        // positionData.length = chunkCount;
        // photoData.length = chunkCount;
        // forceData?.forEach(arr => arr.length = chunkCount);

        let sumTime = 0, sumPosition = 0;
        let sumForce = Array(loadCellNum).fill(0);
        let count = 0, chunkIndex = 0;

        for (let i = 0; i < fullChunks; i++) {
            const entry = dataEntries[i];
            sumTime += entry.time;
            sumPosition += entry.position;
            entry.force?.forEach((value, index) => sumForce[index] += value);
            count++;

            if (isNum(entry.photoIndex)) {
                // If a photo event is detected, add data immediately to the current chunk
                // timeData[chunkIndex] = entry.time;
                // positionData[chunkIndex] = entry.position;
                // sumForce?.forEach((value, index) => {
                //     forceData[index][chunkIndex] = value;
                // });
                timeData[chunkIndex] = null;
                positionData[chunkIndex] = null;
                forceData[chunkIndex] = [...Array(loadCellNum).fill(null)];
                photoData[chunkIndex] = 0; // Mark photo event
                chunkIndex++;
            }

            if (count === chunkSize) {
                let invCount = 1 / count; // Inverse count: quicker than '%' division operation
                timeData[chunkIndex] = sumTime * invCount;
                positionData[chunkIndex] = sumPosition * invCount;
                sumForce?.forEach((value, index) => {
                    forceData[index][chunkIndex] = value * invCount;
                    sumForce[index] = 0; // Reset for next chunk
                });
                photoData[chunkIndex] = isNum(entry.photoIndex) ? 0 : null; // Mark photo event

                sumTime = sumPosition = 0;
                count = 0;
                chunkIndex++;
            }
        }

        // Add remaining data to an overflow array
        // console.info("Overflow: ", dataEntries.length - remainderStart);
        for (let i = remainderStart; i < dataEntries.length; i++) {
            let entry = dataEntries[i];
            overflowData.push({
                time: entry.time,
                position: entry.position,
                force: [...entry.force]
            });
        }
    }

    async function loadDataFromDBToChart(stateAtEnd = false) {
        if (!db) {
            console.error("‚ö†Ô∏è IndexedDB is not available (not opened).");
            return;
        }

        if (!isNum(loadCellNum)) throw new Error(`Total Loadcell count is not defined: ${loadCellNum}`);

        liveUpdate = false;

        await clearCharts();

        console.info("\n%cüîÑ Loading data from IndexedDB to charts...", "color: blue;");

        let transaction = db.transaction(STORE_NAME, "readonly");
        let store = transaction.objectStore(STORE_NAME);
        let request = store.getAll();

        request.onsuccess = async function () {
            let dataEntries = request.result;
            if (!dataEntries || dataEntries.length === 0) {
                return;
            } else if (dataEntries.length < 3) {
                console.warn("\n‚ö†Ô∏è Not enough data to load.");
                return;
            }

            // remove first element from entry
            dataEntries.shift();


            console.info("üìâ Loaded", dataEntries.length, "data points");


            // // ‚è© **Use `filter` to reduce the number of data points**
            // const filteredEntries = dataEntries.filter((_, index) => index % dataChartInterval === 0);
            //
            // // ‚è© **Use `map` to extract specific data fields**
            // timeDataTemp = filteredEntries.map(entry => entry.time);
            // positionDataTemp = filteredEntries.map(entry => entry.position);
            // forceDataTemp = Array(loadCellNum).fill().map((_, i) => filteredEntries.map(entry => entry.force[i]));

            const timeDataTemp = [];
            const positionDataTemp = [];
            const forceDataTemp = Array(loadCellNum).fill(null).map(() => []);
            const aggregatedDataBetweenStepsTemp = [];
            const photoDataTemp = [];

            aggregateData(dataEntries, dataChartInterval, timeDataTemp, positionDataTemp, forceDataTemp, photoDataTemp, aggregatedDataBetweenStepsTemp);


            const minTime = catchVal(minND(timeDataTemp), 0, isNum);
            const maxTime = catchVal(maxND(timeDataTemp), 1e-10, isNum);
            const timeRange = (maxTime - minTime) * 0.005;
            const minDist = catchVal(minND(positionDataTemp), 0, isNum);
            const maxDist = catchVal(maxND(positionDataTemp), 1e-10, isNum);
            const distRange = (maxDist - minDist) * 0.005;
            const forceMin = catchVal(minND(forceDataTemp), 0, isNum);
            const forceMax = catchVal(maxND(forceDataTemp), 1e-10, isNum);
            const forceRange = (forceMax - forceMin) * 0.125;


            timeData = timeDataTemp;
            positionData = positionDataTemp;
            forceData = forceDataTemp;
            photoData = photoDataTemp;

            // TODO: replace with 'updateChart' function
            timeChart.setData([timeDataTemp, ...forceDataTemp, photoDataTemp]);
            positionChart.setData([positionDataTemp, ...forceDataTemp, photoDataTemp]);

            timeChart.setScale("x", {min: minTime - timeRange, max: maxTime + timeRange});
            positionChart.setScale("x", {min: minDist - distRange, max: maxDist + distRange});
            timeChart.setScale("y", {min: forceMin - forceRange, max: forceMax + forceRange});
            positionChart.setScale("y", {min: forceMin - forceRange, max: forceMax + forceRange});

            // // üîÑ Redraw graphs
            // timeChart.redraw();
            // positionChart.redraw();


            console.info("\n\t‚òëÔ∏è Graph data loaded successfully.");

            await sleep(1);
            liveUpdate = stateAtEnd;
        };
    }


    // Attach live update toggle to button
    UI.chartsLiveButton.addEventListener("click", async () => chartUpdate());


    // /////// uPlot Chart Initialization /////////
    function createChart(containerID, seriesLabels, title = "Graph", labelX = "", labelY = "") {
        // Get the container element
        let container = $ID(containerID);
        if (!container) {
            console.error(`‚ùå Error: container s ID "${containerID}" not found.`);
            return null;
        }


        // Get the container dimensions
        let width = container.clientWidth || 400; // Default width if the container is empty
        let height = container.clientHeight || 300; // Default height if the container is empty

        // Configurations for uPlot chart
        const options = {
            title: title,
            width: width,
            height: height,
            axes: [
                {
                    label: labelX, // Axis label X
                },
                {
                    label: labelY, // Axis label Y
                }
            ],
            scales: {
                x: {time: false},
                y: {auto: true}
            },
            series: [...seriesLabels.map((label, index) => ({
                label: label,
                stroke: index === 0 ? "000000" : ["#FF2730", "#2196F3", "#4CAF50", "#9C27B0", "#00BCD4", "#8BC34A", "#E91E63", "#3F51B5", "#009688", "#FF9800"][index - 1] || "#555555"
            })),
                {
                    label: "Photos",          // pou≈æijeme pro nalezen√≠ ≈ô√°dku legendy a skryjeme ho n√≠≈æe
                    // points-only: nejefektivnƒõj≈°√≠ je vypnout cesty (≈æ√°dn√° ƒç√°ra)
                    // points-only: nejefektivnƒõj≈°√≠ je vypnout cesty (≈æ√°dn√° ƒç√°ra)
                    paths: () => null,      // ofiko doporuƒçen√≠ pro ‚Äûpouze body‚Äú
                    points: {show: true, size: 8, width: 2.5}, // velikost a tlou≈°≈•ka bod≈Ø
                    stroke: "#FF8C00", fill: "#FF8C00", // u bod≈Ø staƒç√≠ points.show
                },],

            // hooks: {
            //     init: [
            //         (u) => {
            //             // find "Photos" and hide it
            //             $$(".u-legend tr", u.root)?.forEach((tr) => {
            //                 if (tr.textContent?.trim().startsWith("Photos")) tr.style.display = "none";
            //             });
            //         },
            //     ],
            // },

        };

        // Create the uPlot chart
        if (!window?.uPlot) {
            console.error("‚ùå uPlot library is not loaded.");
            return null;
        }
        let chart = new uPlot(options, [[], ...seriesLabels.slice(1).map(() => [])], container);

        // Dynamic resizing of the chart
        window.addEventListener("resize", async () => onResize(container, chart));

        // Initial resize to fit container
        onResize(container, chart);

        return chart;
    }

    function onResize(container, chart) {
        const newWidth = container.clientWidth || 400;
        const newHeight = container.clientHeight || 300;
        chart.setSize({width: newWidth, height: newHeight});
        UI.chartsContainer.style.height = getChartHeightIncludingLegend() + "px";
    }

    function getChartHeightIncludingLegend() {
        let charts = $$(".uplot");
        let maxHeight = 0;

        charts?.forEach(chart => {
            maxHeight = Math.max(maxHeight, chart.clientHeight);
        });

        return maxHeight;

    }


    // /////// Chart Update Function /////////

    /**
     * Updates the charts with new data.
     */

    function updateChart(inputData) {
        // TODO: probl√©m s grafem bƒõhem experimentu, nen√≠ tam update

        const chartData = checkArray(inputData);

        if (!isNonEmptyArr(chartData)) return;


        for (let i = 0; i < chartData.length; i++) {
            const data = chartData[i];

            if (!isObj(data)) continue;

            // Check if the data is valid
            if (!isNum(data.time) || !isNum(data.position)) {
                //   || data.force.every(x => !isNum(x))   ///    || data.force.some(!isNum)
                return;
            }

            // Add new data points
            timeData?.push(data?.time);
            positionData?.push(data?.position);
            data.force?.forEach((value, index) => forceData[index]?.push(value));
            photoData?.push(isNum(data.photoIndex) ? 0 : null); // Mark photo event


            // Maintain max data points
            if (timeData?.length > maxDataPoints) {
                timeData?.shift();
                positionData?.shift();
                forceData?.forEach(dataset => dataset?.shift());
                photoData?.shift();
            }
        }

        // Update charts
        timeChart.setData([timeData, ...forceData, photoData]);
        positionChart.setData([positionData, ...forceData, photoData]);

    }

    async function refreshCharts() {
        await loadDataFromDBToChart(liveUpdate);  // Load data from DB to charts will wait for the data to be loaded
        timeChart.redraw();
        positionChart.redraw();
        console.info("üîÅ Charts refreshed.");
    }

    async function clearCharts() {
        if (!isNum(loadCellNum)) throw new Error(`Total Loadcell count is not defined: ${loadCellNum}`);

        // Reset axis X and Y
        await timeChart.setScale("x", {min: 0, max: 1e-10});
        await positionChart.setScale("x", {min: 0, max: 1e-10});

        // timeData = [];
        // positionData = [];
        // photoData = [];
        // forceData?.forEach((_) => []);

        await timeChart.setData(Array(loadCellNum + 1 + 1).fill(null).map(() => []));
        await positionChart.setData(Array(loadCellNum + 1 + 1).fill(null).map(() => []));

        await timeChart.setScale("y", {min: 0, max: 1e-10});
        await positionChart.setScale("y", {min: 0, max: 1e-10});


        console.info("üßπ Charts cleared!");
    }


</script>

<script>

    // /////// Serial Connection Variables /////////

    // Variables for handling serial (USB) communication
    let serialPort, serialWriter, serialReader;

    // Connection status flags
    let isConnected = false;

    // Reconnection attempts for serial connection
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    let isReconnecting = false;

    async function writeCommand(text) {
        try {
            //  Ensure a writer exists before writing
            if (!serialWriter) {
                serialWriter = serialPort.writable.getWriter();
            }

            await serialWriter.write(txtE.encode(text + "\n"));

            return true;
        } catch (error) {
            await handleError(error, "sendCommand");

            return false;
        }
    }

    function checkCommand(command) {
        if (debugging) console.info(`Preparing to send command:\n\t\t${command}`);
        if (!isConnected || !serialPort?.writable) {
            logMessage("\n‚ö†Ô∏è No device is connected or port is unavailable!");
            return false;
        }

        if (command.toLowerCase().includes(" nan")) {
            logMessage("\n‚ö†Ô∏è Command contains 'NaN' values. Please check the input.");
            console.error("‚ö†Ô∏è Command contains 'NaN' values. Please check the input.");
            alert("‚ö†Ô∏è Aborted command due to 'NaN' values in the input.");
            return false;
        }

        return true;
    }

    // /////// Sending Commands /////////

    /**
     * Sends a command to the connected device.
     * Works with Serial (USB) connection;
     * @param {string} command - The command string to send.
     * @param timeOut
     * @param type
     */
    async function sendCommand(command, type = "general", timeOut = 1) {
        switch (type) {
            case "console":
                await sendCommandConsole(command);
                break;
            case "app":
                await sendCommandApp(command);
                break;
            case "user":
                await sendCommandUser(command);
                break;
            case "silent":
                await sendCommandSilent(command);
                break;
            case "general":
            default:
                await sendCommandGeneral(command, timeOut);
        }
    }

    async function sendCommandGeneral(command, timeOut = 1) {
        if (!checkCommand(command)) return;

        writeCommand(command);

        if (!isNum(timeOut)) timeOut = 1;
        timeOut = Math.max(0, Math.round(timeOut));

        if (command.toLowerCase() !== "syswr" && command.toLowerCase() !== "misc watchdog_reset") {
            await logMessage("üì§ General-Command sent: " + command);
        }
        await sleep(timeOut);  // Stop for at least 1 ms
    }

    async function sendCommandConsole(command) {
        if (!checkCommand(command)) return;


        switch (command.trim().toLowerCase()) {
            case "toggle port filter":
                useFilteredPort = !useFilteredPort;
                await logMessage(`\nüîÄ Toggled port filter: ${useFilteredPort ? "ON" : "OFF"}`);
                return;

            case "toggle port autoconnect":
                usePortAutoConnect = !usePortAutoConnect;
                await logMessage(`\nüîÄ Toggled port auto-connect: ${usePortAutoConnect ? "ON" : "OFF"}`);
                return;

            case "toggle debugging":
                debugging = !debugging;
                await logMessage(`\nüîÄ Toggled debugging: ${debugging ? "ON" : "OFF"}`);
                return;

            default:
                await writeCommand(command);
        }

        // User feedback in console
        await logMessage("  üó£Ô∏è User-Command sent: " + command);
    }

    async function sendCommandApp(command) {
        if (!checkCommand(command)) return;

        await writeCommand(command);

        // User feedback in console
        await logMessage("üëæ App-Command sent: " + command);
    }

    async function sendCommandUser(command) {
        if (!checkCommand(command)) return;

        await writeCommand(command);

        // User feedback in console
        await logMessage("üïπÔ∏è User-Command sent: " + command);
    }

    async function sendCommandSilent(command) {
        if (!checkCommand(command)) return;

        await writeCommand(command);
    }

</script>


<script>

    async function sendMoveCommand(command, pauseMs = 1) {
        // ovƒõ≈ôen√≠ kalibrace
        calibrationStatus = await getCalibrationStatus(2_000);

        if (!calibrationStatus) {
            const msg = "\n‚ö†Ô∏è Motors are not calibrated.";
            await lockMovementExcept(UI.calibrateBtn);
            console.warn(msg);
            await logMessage(msg);
            await endedMoving();
            alert(msg);
            return;
        }

        // Watchdog ≈ôe≈°√≠ beganMoving/endedMoving, tady jen po≈°li p≈ô√≠kaz
        await sendCommandGeneral(command, pauseMs);
    }

    async function setMachineName(name, pauseMs = 1) {
        if (!isNonEmptyStr(name)) {
            console.warn("‚ö†Ô∏è Machine name cannot be empty.");
            return;
        }
        if (isInvalidValue(name, true)) {
            console.warn("‚ö†Ô∏è Machine name contains invalid value.");
            return;
        }
        // ensure forbidden characters are removed
        name = name.replace(/[^a-zA-Z0-9 _-]/g, '').trim().replaceAll(" ", "_");
        if (name.length === 0) {
            console.warn("‚ö†Ô∏è Machine name cannot be empty or contain only forbidden characters.");
            return;
        }

        $ID("inputMachineName").value = name;
        machineName = name;
        const command = `MISC SET NAME ${name}`;

        await sendCommandGeneral(command, pauseMs);
    }

    async function setMachineID(id, pauseMs = 1) {
        if (!isNonEmptyStr(id) && !isNum(id)) {
            console.warn("‚ö†Ô∏è Machine ID cannot be empty.");
            return;
        }
        if (isInvalidValue(id, true)) {
            console.warn("‚ö†Ô∏è Machine ID contains invalid value.");
            return;
        }
        id = toInteger(id);
        if (!isNum(id)) {
            console.warn("‚ö†Ô∏è Machine ID is not a valid number.");
            return;
        }
        if (0 >= id || id > 255) {
            console.warn("‚ö†Ô∏è Machine ID must be between 1 and 255.");
            return;
        }

        $ID("inputMachineID").value = id;
        machineID = id;
        const command = `MISC SET MACHINE_ID ${id}`;

        await sendCommandGeneral(command, pauseMs);
    }


    // /////// Loading Commands from JSON /////////

    /**
     * Loads commands from an external JSON file and creates buttons for each command.
     */
    async function loadCommands() {
        try {
            const response = await fetch("commands.json");
            const commands = await response.json();

            for (const [name, command] of Object.entries(commands)) {
                const btn = $MAKE("button");
                btn.innerText = name;
                btn.onclick = () => sendFunction(name, command);
                // $$("buttons").appendChild(btn);
            }
        } catch (error) {
            await handleError(error, "loadCommands");
        }
    }

    // /////// Command Handling /////////

    /**
     * Sends a command to the ESP device.
     * If the command is for reading a specific LoadCell, it replaces the placeholder with the selected ID.
     * @param {string} name - The command name.
     * @param {string} inputCommand - The raw command string.
     */
    async function sendFunction(name, inputCommand) {
        let command;

        if (name === "read Loadcell[#]") { // LC GET FORCE 0-2
            let loadcellId = parseInt($ID("inputNumLoadID").value);
            command = replaceVariables(inputCommand, {loadcellId: loadcellId});
        } else {
            command = inputCommand;
        }

        await sendCommandGeneral(command);
    }

    // /////// Template Variable Replacement /////////

    /**
     * Replaces variables inside a command template with actual values.
     * @param {string} template - The command template containing placeholders.
     * @param {Object} variables - An object mapping variable names to their actual values.
     * @returns {string} - The command string with replaced values.
     */
    function replaceVariables(template, variables) {
        return template.replace(/{{(.*?)}}/g, (match, key) => variables[key.trim()] || match);
    }

</script>


<script>
    async function handleError(error, context = "Unknown") {
        // üìå Connection Errors Handling Identifiers
        const connectionErrors = [
            "NetworkError",
            "The device was lost.",
            "The port is no longer available.",
            "Device not responding",
        ];

        if (connectionErrors.some(msg => error.message.includes(msg)) || error.name === "NetworkError") {

            if (isExperimentRunning) {
                await endMeasuring(0, {
                    ednStatus: 'connection lost',
                    endText: "‚ùå Experiment stopped due to connection loss.",
                    immediateText: "Connection lost! Stopping experiment..."
                });
                UI.experimentStageLabel.textContent = `Error`;
                document.documentElement.style.setProperty('--progressColor', 'var(--progressError-color)');
            }

            console.warn("\n‚ö†Ô∏è Connection lost! Attempting to reconnect...");
            isConnected = false;
            await attemptReconnect(); // TODO: change reconnect handle
        } else {
            stopMachine();
            console.error(`‚ùå ${context} error:`, error);
            await logMessage(`‚ùå ${context} error: ${error}`);
        }

    }

</script>


<script>

    // MOVING
    let movingTimeout = null;

    let watchdogTimer = null;
    let activeWatchDog = false;
    const WATCHDOG_INTERVAL_MS = 500; // min 500 ms


    async function moveToOriginalPosition({overRide = false} = {}) {
        if (!isConnected) return;
        if (isExperimentRunning) return;
        if (!overRide && machineOccupation) return;

        const endPosition = await measurePosition();
        if (!(isNum(tareValues.position) && isNum(endPosition))) {
            endedMoving();
            return;
        }

        const distance = tareValues.position - endPosition;
        if (Math.abs(distance) < 1e-2) {
            endedMoving();
            console.info("üö© Already at the original position.");
            return;
        }

        console.info("‚¨ÖÔ∏è Moving backward...");
        await moveBy(distance, {overRide: overRide});
        console.info("üö© Returning to original position completed.");
    }

    function disableInputsAndLabelsIn(root) {
        root.querySelectorAll?.("input")?.forEach(inp => {
            inp.disabled = true;
        });

        root.querySelectorAll?.("*")?.forEach(el => {
            if (el.shadowRoot) disableInputsAndLabelsIn(el.shadowRoot);
        });
    }

    function enableInputsAndLabelsIn(root) {
        root.querySelectorAll?.("input[disabled]")?.forEach(inp => {
            inp.disabled = false;
        });

        root.querySelectorAll?.("*")?.forEach(el => {
            if (el.shadowRoot) enableInputsAndLabelsIn(el.shadowRoot);
        });
    }


    const movementElements = $$(".movementControlElement");
    const controlElements = $$(".controlElement");
    const machineElements = $$(".machineControlElement");

    const lockMovement = () => lockElements(movementElements);
    const lockMovementExcept = (exceptEl) => lockElementsExcept(movementElements, exceptEl);
    const unlockMovement = () => unlockElements(movementElements);

    const lockControls = () => lockElements(controlElements);
    const lockControlsExcept = (exceptEl) => lockElementsExcept(controlElements, exceptEl);
    const unlockControls = () => unlockElements(controlElements);

    const lockMachineControls = () => lockElements(machineElements);
    const unlockMachineControls = () => unlockElements(machineElements);
    const lockMachineControlsExcept = (exceptEl) => lockElementsExcept(machineElements, exceptEl);

    const lockControlAndMove = () => {
        lockMovement();
        lockControls();
    };
    const unlockControlAndMove = () => {
        unlockMovement();
        unlockControls();
    };

    function lockElements(elements) {
        elements?.forEach((el) => {
            el?.classList.add("disabled");
            disableInputsAndLabelsIn(el);
        });
    }


    function lockElementsExcept(elements, exceptEl) {
        elements?.forEach(el => {
            const isExcept = el === exceptEl || el?.contains?.(exceptEl);
            if (!isExcept) {
                el?.classList?.add("disabled");
                disableInputsAndLabelsIn(el);
            } else {
                el?.classList?.remove?.("disabled");
                enableInputsAndLabelsIn(el);
            }
        });
    }

    function unlockElements(elements) {
        elements?.forEach((el) => {
            el?.classList.remove("disabled");
            enableInputsAndLabelsIn(el);
        });
    }

    // ------- Watchdog (bƒõ≈æ√≠ jen p≈ôi pohybu) -------
    function startWatchdog(intervalMs = WATCHDOG_INTERVAL_MS) {
        const interval = Math.max(100, Number(intervalMs) || WATCHDOG_INTERVAL_MS);
        if (watchdogTimer) return; // u≈æ bƒõ≈æ√≠

        activeWatchDog = true;

        // Nastaven√≠ watchdog HW (p≈ôedstihem ~10% + 50ms)
        const hwInterval = interval + Math.ceil(clamp(interval * 0.10, 100, 250)) + 50;
        // nezdr≈æujeme ‚Äî fire and forget
        sendCommandGeneral(`MISC SET WATCHDOG_INTERVAL ${hwInterval}`);
        sendCommandGeneral(`MISC SET WATCHDOG_ENABLED 1`);
        console.info("üêï Watchdog is active.");

        watchdogTimer = setInterval(() => {
            // pos√≠lej SYSWR pouze kdy≈æ je to smyslupln√©
            if (!isConnected || !activeWatchDog || !machineOccupation) return;
            sendCommandGeneral("SYSWR");
        }, interval * 0.9); // 90% intervalu
    }

    function stopWatchdog() {
        activeWatchDog = false;
        if (watchdogTimer) {
            clearInterval(watchdogTimer);
            watchdogTimer = null;
        }
        // HW watchdog vyp√≠nat nemus√≠me ‚Äî ale m≈Ø≈æeme:
        if (isConnected) sendCommandGeneral(`MISC SET WATCHDOG_ENABLED 0`);
    }

    // ------- Spr√°va pohybu -------
    async function beganMoving(timeoutMs = null) {
        if (machineOccupation) return; // u≈æ bƒõ≈æ√≠

        // napl√°nuj automatick√© ukonƒçen√≠ (voliteln√©)
        if (isValidInputNum(timeoutMs)) {
            machineOccupation = true;
            warnOnClose = true;
            startWatchdog(WATCHDOG_INTERVAL_MS);

            const delay = toInteger(timeoutMs, "round");
            if (!isNumber(delay)) {
                console.warn("\nInvalid delay for beganMoving:", timeoutMs);
                endedMoving();
                return;
            }
            if (isDef(movingTimeout)) {
                clearTimeout(movingTimeout);
                movingTimeout = null;
            }
            movingTimeout = setTimeout(() => {
                endedMoving();
            }, delay);
        }
    }

    function setSpeed(speed, updateCurrent = true, timeOut = 1) {
        if (!isConnected) return;

        if (!isValidInputNum(speed)) return;

        if (!isValidInputNum(timeOut)) timeOut = 1;

        sendCommandGeneral(`MC SET SPEEDMM ${speed}`, timeOut);

        if (updateCurrent === true) currentSpeed = speed;
        UI.speedSlider.value = speed;
        UI.speedLabel.value = `${speed.toFixed(2)}`;
    }

    function setAcceleration(acceleration, updateCurrent = true, timeOut = 1) {
        if (!isConnected) return;

        if (!isValidInputNum(acceleration)) return;
        if (!isValidInputNum(timeOut)) timeOut = 1;

        sendCommandGeneral(`MC SET ACCELMM ${acceleration}`, timeOut);

        if (updateCurrent === true) currentAcceleration = acceleration;
        UI.accelerationSlider.value = acceleration;
        UI.accelerationLabel.value = `${acceleration.toFixed(2)}`;
    }

    function setSpeedAndAcceleration(speed, acceleration, updateCurrent = true, timeOut = 2) {
        if (!isConnected) return;

        timeOut = Math.max(Math.abs(Math.round(timeOut / 2)), 1);
        setSpeed(speed, updateCurrent, timeOut);
        setAcceleration(acceleration, updateCurrent, timeOut);
    }

    function endedMoving() {
        // idempotence
        if (isDef(movingTimeout)) {
            clearTimeout(movingTimeout);
            movingTimeout = null;
        }

        if (isConnected) sendCommandGeneral("MC STOP");

        warnOnClose = false;
        machineOccupation = false;
        stopWatchdog();

        if (isConnected) setSpeedAndAcceleration(currentSpeed, currentAcceleration, true, 10);

        if (calibrationStatus) unlockMovement();
        else if (!calibrationStatus && isConnected) lockMovementExcept(UI.calibrateBtn);
    }

    function speedFromDistance(goal, dMax = 100, sMin = 1, sMax = 25) { // 25 u≈æ od 100 mm
        const d = Math.max(0, Math.abs(toNumber(goal)) || 0);
        const t = Math.min(1, d / dMax);              // 0..1
        const v = sMin + (sMax - sMin) * t;           // line√°rnƒõ 1..25
        return roundDecimalFast(v, 2);                    // float f.2
    }

    async function moveBy(distance, {requiredSpeed = null, requiredAcceleration = null, overRide = false} = {}) {
        if (!isConnected) return;
        if (isExperimentRunning) return;
        if (!overRide && machineOccupation) {
            console.warn("\nMachine is already busy. Please wait.");
            return;
        }

        try {
            // ovƒõ≈ôen√≠ kalibrace
            calibrationStatus = await getCalibrationStatus(2_000);

            if (!calibrationStatus) {
                const msg = "\n‚ö†Ô∏è Motors are not calibrated.";
                await lockMovementExcept(UI.calibrateBtn);
                console.warn(msg);
                await logMessage(msg);
                endedMoving();
                return;
            }

            currentSpeed = (await getSpeed()) || 15;
            currentAcceleration = (await getAcceleration()) || 150;

            const acceleration = requiredAcceleration || 100; // mm/s¬≤
            const speed = requiredSpeed || await speedFromDistance(distance, acceleration, 0.5, 25); // mm/s

            if (!speed || !acceleration) {
                console.warn("\n‚ö†Ô∏è Invalid speed or acceleration values.");
                endedMoving();
                return;
            }

            await setSpeedAndAcceleration(speed, acceleration, false, 10);


            lockMovement();               // u bƒõ≈æn√Ωch krok≈Ø zamkni celou pohybovou sekci
            await beganMoving();          // bez timeoutu ‚Äî dopoƒç√≠t√°me a nastav√≠me n√≠≈æ


            const movingTime =
                Math.ceil((computeMotionTime(distance, speed, acceleration) * 1_000) + 150);


            // nastav/obnov timeout ukonƒçen√≠ pohybu
            if (isDef(movingTimeout)) {
                clearTimeout(movingTimeout);
                movingTimeout = null;
            }

            await sendMoveCommand(`MC MOVEBY MACH ${distance}`, 5);

            movingTimeout = setTimeout(() => endedMoving(), movingTime);


            await sleep(movingTime);

        } catch (e) {
            console.error("Error during moveBy:", e);
            endedMoving();
        }
    }

    function computeMotionTime(distance, speed, acceleration) {
        const t_accel = speed / acceleration;               // time acceleration
        const s_accel = 0.5 * acceleration * t_accel ** 2;  // distance during acceleration

        distance = Math.abs(distance);

        if (2 * s_accel >= distance) {
            // üö© Triangular profile ‚Äì only acceleration and deceleration
            return 2 * Math.sqrt(distance / acceleration);
        } else {
            // üö© Trapezoidal profile ‚Äì acceleration, constant speed, and deceleration
            const s_cruise = distance - 2 * s_accel;
            const t_cruise = s_cruise / speed;
            return 2 * t_accel + t_cruise;
        }
    }


    function stopMachine(type = 'machine') {
        if (isConnected) {
            setAcceleration(200, false); // Set acceleration to 200 mm/s¬≤
            sendStopAllMeasuring();
        }

        if (isExperimentRunning) {
            let reason;
            let endColor;

            switch (type) {
                case 'user':
                    endColor = 'var(--progressError-color)';
                    reason = "user stop";
                    break;
                case 'machine':
                    endColor = 'var(--progressWarning-color)';
                    reason = "machine stop";
                    break;
                case 'error':
                    endColor = 'var(--progressError-color)'
                    reason = "error";
                    break;
                case 'alarm':
                    endColor = 'var(--progressError-color)'
                    reason = "machine alarm";
                    break;
                default:
                    endColor = 'var(--progressError-color)'
                    reason = "unknown stop";
            }

            endMeasuring(0, {
                overRide: true,
                ednStatus: String(reason),
                endText: 'üõë Experiment stopped',
            });

            UI.experimentStageLabel.textContent = `Stopped`;
            document.documentElement.style.setProperty('--progressColor', String(endColor));

        }

        endedMoving();
    }


    async function softStopMachine() {
        setAcceleration(200, false); // Set acceleration to 200 mm/s¬≤

        await rampSpeed(currentSpeed, 0.1);

        endedMoving();

        if (isExperimentRunning) {
            await endMeasuring(0, {
                overRide: true,
                ednStatus: 'user soft stop',
                endText: 'üõë Experiment stopped',
            });
            UI.experimentStageLabel.textContent = `Stopped`;
            document.documentElement.style.setProperty('--progressColor', 'var(--progressError-color)');
        }
    }

    /**
     * Ramping rychlosti s pevn√Ωmi rozestupy 20ms, max. ~300ms celkem.
     * @param {number} currSpeed - aktu√°ln√≠ rychlost (mm/s)
     * @param {number} targetSpeed - c√≠lov√° rychlost (mm/s), default 0.05
     */
    async function rampSpeed(currSpeed, targetSpeed = 0.05) {
        const INTERVAL_MS = 8;
        const MAX_INTERVALS = 9; // 15 * 20ms = 300ms mezi 1. a posledn√≠m sendem
        const PREFERRED_STEP = 1;   // mm/s
        const MIN_STEP = 0.5;       // mm/s

        if (!isConnected) return;
        if (!isNum(currSpeed)) currSpeed = currentSpeed;

        const delta = targetSpeed - currSpeed;
        const dir = Math.sign(delta);
        const absDelta = Math.abs(delta);

        // Pokud u≈æ jsme na c√≠li (nebo velmi bl√≠zko), po≈°li rovnou p≈ôesn√Ω p≈ô√≠kaz.
        if (absDelta < 1e-9) {
            return sendCommandSilent(`MC SET SPEEDMM ${targetSpeed.toFixed(3)}`);
        }

        // Zvol krok: preferuj 1 mm/s; pokud by to nestihlo do 300 ms, krok zvƒõt≈°i.
        // Max. poƒçet SEND≈Ø je 16 (15 interval≈Ø + fin√°ln√≠ p≈ô√≠kaz).
        let step = PREFERRED_STEP;
        const neededWithPreferred = Math.ceil(absDelta / step);
        // Poƒçet interval≈Ø je (poƒçet_send≈Ø - 1). Tj. max 16 send≈Ø => 15 interval≈Ø.
        if (neededWithPreferred - 1 > MAX_INTERVALS) {
            step = Math.max(MIN_STEP, absDelta / MAX_INTERVALS); // m≈Ø≈æe b√Ωt >1, kdy≈æ je pot≈ôeba
        }

        // Kolik mezikrok≈Ø stihneme s vybran√Ωm krokem v r√°mci 15 interval≈Ø
        let intermediateSteps = Math.min(Math.floor(absDelta / step), MAX_INTERVALS);

        // Pro jistotu zaokrouhluj v√Ωstup na 3 desetinn√° m√≠sta (0.001 mm/s)
        const fmt = (v) => Number(v).toFixed(3);

        let curr = currSpeed;

        // Pos√≠lej mezikroky po 20 ms (ka≈æd√Ω krok m√° velikost >= 0.5 mm/s)
        for (let i = 0; i < intermediateSteps; i++) {
            curr += dir * step;

            // O≈°et≈ôi p≈ôest≈ôelen√≠
            if ((dir > 0 && curr > targetSpeed) || (dir < 0 && curr < targetSpeed)) {
                curr = targetSpeed;
            }

            await sleep(INTERVAL_MS);
            await sendCommandSilent(`MC SET SPEEDMM ${fmt(curr)}`);

            // Kdy≈æ jsme u≈æ na c√≠li, skonƒçi d≈ô√≠v
            if (Math.abs(curr - targetSpeed) < 1e-9) {
                return;
            }
        }

        // Pokud je≈°tƒõ nejsme p≈ôesnƒõ na c√≠li, po≈°li fin√°ln√≠ p≈ôesn√Ω p≈ô√≠kaz.
        // Tohle je posledn√≠ SEND (celkem max 16), opƒõt s odstupem 20ms od p≈ôedchoz√≠ho.
        if (Math.abs(curr - targetSpeed) >= 1e-9) {
            await sleep(INTERVAL_MS);
            await sendCommandGeneral(`MC SET SPEEDMM ${fmt(targetSpeed)}`);
        }
    }

</script>


<script>
    // /////// Optimized Measurement Processing /////////
    let _msgQueue = Promise.resolve();

    function handleIncomingChunkQueued(dataChunk) {
        _msgQueue = _msgQueue
            .then(() => processMessage(dataChunk))
            .catch(err => console.error('processMessage failed:', err));
    }


    /**
     * Processes incoming measurement data.
     * @param {Array} dataChunk - An array of measurement data lines.
     */
    async function processMessage(dataChunk) {
        if (!dataChunk || !dataChunk.length) return;

        for (let raw of dataChunk) {
            const msg = String(raw).trim();


            if (msg === "S0:WR") continue; // ignore

            // If 'alarm' or 'alarmed' is in the message, log it and skip further processing
            if (/alarm(ed)?/i.test(msg)) {
                await logMessage("üö®\t" + msg);
                if (isExperimentRunning) {
                    isExperimentRunning = false;
                    await stopMachine("alarm");
                    logMessage("‚ö†Ô∏è Experiment stopped due to alarm.");
                }
                continue;
            }

            // First, try to match and resolve waiting messages in the queue
            const consumed = _tryMatchAndResolve(msg);
            if (consumed) {
                if (debugging) logMessage("   üìØ\t" + msg);
                continue;             // If a message is consumed, skip further processing
            }

            // ostatn√≠ logiky
            // TODO: rozmyslet co pou≈æ√≠vat:         split(":") // substring(measurementPrefix.length)
            const measurementPrefix = "DS"; // "S205:"
            if (msg.startsWith(measurementPrefix)) {
                await processMeasurements(msg.substring(measurementPrefix.length));
            } else {
                logMessage("üì©\t" + msg);
            }
        }
    }

</script>


<script>
    const getMeasurementPartsLength = (obj) =>
        Object.entries(obj).reduce((sum, [key, val]) => {
            if (key === 'length' || key === 'lengths') return sum; // p≈ôeskoƒç speci√°ln√≠ kl√≠ƒçe

            const arr = isArr(val) ? val : (isNumber(val) ? [val] : []);

            obj[key] = arr;                 // normalizace zpƒõt do objektu
            (obj.lengths ||= {})[key] = arr.length; // ulo≈æ d√©lku ƒç√°sti
            return sum + arr.length;                     // akumuluj souƒçet d√©lek
        }, 0);

    function analyzeForces(fields) {
        return fields.map(arr => {
            let found = false;
            let min = Infinity, max = -Infinity;

            for (const v of arr) {
                if (isNum(v)) {
                    found = true;
                    if (v < min) min = v;
                    if (v > max) max = v;
                }
            }

            if (!found) return {min: NaN, max: NaN, allInvalid: true};
            if (Math.abs(min) === 0 && Math.abs(max) === 0) return {min: NaN, max: NaN, allInvalid: true};
            if (min === max) {
                logMessage(`‚ö†Ô∏è Warning: min and max forces are equal: ${min}, ${max}`);
                console.warn("‚ö†Ô∏è Warning: min and max forces are equal:", min, max);
                return {min: NaN, max: NaN, allInvalid: true};
            }
            return {min, max, allInvalid: false};
        });
    }

    function hasRequiredParsedKeys(experimentEndLimits, parsedData) {
        if (!isObj(experimentEndLimits) || !isObj(parsedData)) return false;

        // kl√≠ƒçe, kter√© opravdu vy≈æadujeme (hodnota nen√≠ null ani NaN)
        const required = Object.entries(experimentEndLimits).filter(([, v]) => !isNum(v));

        // mus√≠ existovat aspo≈à jeden po≈æadovan√Ω kl√≠ƒç
        if (required.length === 0) return false;

        // v≈°echny po≈æadovan√© kl√≠ƒçe mus√≠ b√Ωt v parsedData
        return required.every(([k]) => Object.prototype.hasOwnProperty.call(parsedData, k));
    }

    function calculateStep(frequencyMicroseconds, updateFrequencyMilliseconds = 200, minimum = 1) {
        if (!isValidInputNum(frequencyMicroseconds)) return minimum;
        minimum = catchVal(minimum, 1, isValidInputNum);
        updateFrequencyMilliseconds = catchVal(updateFrequencyMilliseconds, 200, isValidInputNum);
        return Math.max(1, minimum, Math.ceil((updateFrequencyMilliseconds * 1_000) / frequencyMicroseconds));
    }

    function computeFrenchingMs(frequencyMicroseconds, inSeconds = 1, minimum = 50) {
        if (!isValidInputNum(frequencyMicroseconds)) return minimum;
        minimum = catchVal(minimum, 50, isValidInputNum);
        inSeconds = catchVal(inSeconds, 1, isValidInputNum);

        const samplesPerSecond = Math.floor((inSeconds * 1_000_000) / frequencyMicroseconds); // (Hz)

        return Math.max(minimum, samplesPerSecond);
    }

</script>


<script>
    // /////// Experiment Configuration /////////
    let forceLimitDropPercent = 0;
    let forceLimitDropValue = 0;
    let experimentEndLimits = {position: null, force: null, time: null};
    let expControl = '';

    let checkSpeed = true;
    let isExperimentRunning = false;
    let machineOccupation = false;

    let maxForces = Array(catchVal(loadCellNum, 0, isNum)).fill(null);

    let measureForces = Array(catchVal(loadCellNum, 0, isNum)).fill(null).map(() => []);
    let takeMeasurements = false;

    let tareValues = {time: null, position: null, force: Array(catchVal(loadCellNum, 0, isNum)).fill(0)};

    let parsedData = {
        time: null,
        position: null,
        speed: null,
        force: Array(catchVal(loadCellNum, 0, isNum)).fill(null),
        photoIndex: null
    }; // Last data log

    // TODO: make One large Experiment variable object: measurementParts, tareValues, limits, loadcellErr, measuredData
    // TODO: make Tow large Experiment variable objects: measuredData (time, pos, ...) vs chartData (timeData, posData, ...)
    const measurementPartDefault = {
        length: null,
        time: [0],
        position: [1],
        speed: [2],
        force: [3, 4, 5],
    };
    measurementPartDefault.length = getMeasurementPartsLength(measurementPartDefault);

    let measurementParts = measurementPartDefault; // Array to store measurement parts

    let aggregatedDataBetweenSteps = [];
    let displacementSignCorrection = 1;
    let loadSignCorrections = [-1, -1, -1];

    let loadcellErrRate = null;
    let measurementErrRate = null;
    let totalErrRate = null;

    let endMeasurement = false;
    let endMeasurementCounter = null;
    const delayMsAfterEndMeasurement = 100; // microseconds

    let experimentProgress = 0;

    let endedBy = null;


    let measurement_limits = {
        zero_speed: {counter: 0, limit: 2},
        over_limitForce: {counter: 0, limit: 2},
        invalid_data: {counter: 0, limit: 2},
    };

</script>

<script>
    function createPIController(userOpts = {}) {
        // Kp (mm/s)/N = mm/(N¬∑s)
        // Ki (mm/s)/(N¬∑s) = mm/N
        const cfg = {
            // --- nastaven√≠ p≈ôevzat√© z tv√© simulace (lze p≈ôepsat v userOpts) ---
            setForceN: null,    // c√≠lov√° s√≠la [N]
            deadbandN: 0.5,     // mrtv√° z√≥na ¬± [N]
            vMin: +0.00,        // min rychlost [mm/s]
            vMax: 25.00,        // max rychlost [mm/s]
            Kp: 0.20,           // [mm/s ¬∑ N‚Åª¬π]
            Ki: 0.03,           // [mm/s ¬∑ N‚Åª¬π ¬∑ s‚Åª¬π]
            accel: null,        // omezen√≠ zmƒõny rychlosti [mm/s¬≤]; null = bez omezen√≠
            integLimit: 500,    // anti-windup clamp
            roundDigits: 3,     // zaokrouhlen√≠ v√Ωstupu (0.001 mm/s)
            unilateral: true,   // jen kladn√° rychlost (dol≈Ø)
            ...userOpts,
        };

        let integ = 0;
        let lastT = null;
        let lastV = 0;

        function step(t, x, F) {
            // t [s], x [mm], F [N]  ‚Üí  v [mm/s]
            if (isNull(lastT)) lastT = t;
            const dt = Math.max(1e-6, t - lastT);
            lastT = t;

            const err = cfg.setForceN - F;

            // integrace jen kdy≈æ jsme mimo mrtvou z√≥nu (stejnƒõ jako v p≈Øvodn√≠m k√≥du)
            if (err > cfg.deadbandN) {
                integ = clamp(integ + err * dt, -cfg.integLimit, cfg.integLimit);
            }

            // PI v√Ωstup jen p≈ôi pozitivn√≠ chybƒõ mimo mrtvou z√≥nu (jen dol≈Ø)
            let vCmd = 0;
            if (err > cfg.deadbandN) {
                vCmd = cfg.Kp * err + cfg.Ki * integ;
                // vMin..vMax (pokud je aktivn√≠)
                vCmd = clamp(vCmd, cfg.vMin, cfg.vMax);
            }

            // jednostrann√© omezen√≠ (bezpeƒçnostnƒõ, i kdy≈æ u≈æ je vCmd‚â•vMin)
            if (cfg.unilateral && vCmd < 0) vCmd = 0;

            // voliteln√Ω slew-rate limit p≈ôes 'accel' (mm/s¬≤)
            if (isValidInputNum(cfg.accel)) {
                const dvMax = cfg.accel * dt;
                if (vCmd > lastV + dvMax) vCmd = lastV + dvMax;
                else if (vCmd < lastV - dvMax) vCmd = lastV - dvMax;
            }

            // zaokrouhlen√≠ jako v simulaci
            const k = 10 ** cfg.roundDigits;
            vCmd = Math.round(vCmd * k) / k;

            lastV = vCmd;
            return vCmd;
        }

        function reset(newOpts) {
            if (newOpts) Object.assign(cfg, newOpts);
            integ = 0;
            lastT = null;
            lastV = 0;
        }

        return {
            step,   // (t, x, F) => v
            reset,  // reset stavu integr√°toru/ƒçasovaƒçe (+ volitelnƒõ nov√© nastaven√≠)
            get state() {
                return {integ, lastT, lastV, cfg: {...cfg}};
            },
        };
    }

    let pi;

    // // jednou p≈ôi startu:
    // pi = createPIController({
    //     setForceN: 100,
    //     Kp: 0.20,
    //     Ki: 0.03,
    //     deadbandN: 0.5,
    //     vMin: 0.025,
    //     vMax: 25,
    // });
    //
    // // v bƒõ≈æ√≠c√≠m cyklu ≈ô√≠zen√≠/simulace:
    // const v = pi.step(tSeconds, xMm, forceN);
    // // ‚Üí po≈°li v do pohonu jako po≈æadovanou rychlost (mm/s)

</script>

<script>
    let speedForward_mmps = 0;
    let takePhotos = false;
    let dataInterval_us = null;
    let initialForceLim_N = null;
    let experimentDoubleSpeed = false;
    let experimentHoldConstantForce = false;
    let stoppingForceLimit = null;
    let holdForceTimeMs = null;

    let timer = null; // TODO: create a universal dicionary for all experiment-based variables needed for experiment

    let presentLoadcells = [];

    async function startExperiment() {

        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }

        if (isExperimentRunning) {
            console.warn("\n‚ö†Ô∏è Experiment is already running.");
            await logMessage("‚ö†Ô∏è Experiment is already running.");
            return;
        }

        if (machineOccupation) {
            console.warn("\n‚ö†Ô∏è Machine is currently moving. Please wait until it stops.");
            await logMessage("‚ö†Ô∏è Machine is currently moving. Please wait until it stops.");
            return;
        }

        if (!isNum(loadCellNum)) throw new Error(`Total Loadcell count is not defined: ${loadCellNum}`);

        // === System Limits ===
        const minDistance = 5e-3;
        const minFSpeed = 0.025; // TODO: check this
        const maxFSpeed = 25;
        const minInt = 5e-6;
        const minLoadCap = 5e-4;
        const minLoadOut = 5e-4;


        try {
            UI.experimentStageLabel.textContent = `Starting`;

            await lockControlAndMove();
            await beganMoving();

            if (!debugging) await console.clear();
            if (!debugging) await clearConsoleLog();
            await console.info("%c\n\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NEW EXPERIMENT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n\n", "color: black; font-size: 14px; font-weight: bold;");
            await console.groupCollapsed("New Experiment Section");
            await console.info(`%cüïí Experiment started at: ${new Date().toLocaleString()}`, "color: gray; font-size: 12px; font-style: italic;");

            // === Retrieve Parameters from Inputs ===
            const distance_mm = getInputNumDefAbsFlt("inputDistance", NaN);
            const experimentType = $ID("experimentTypeDropdown")?.value.toLowerCase();
            displacementSignCorrection = experimentType.includes("down") ? 1 : -1;
            speedForward_mmps = getInputNumDefAbsFlt("inputSpeedForward", NaN);
            dataInterval_us = Math.max(getInputNumDefAbsInt("inputDataInterval", NaN), 100);
            takePhotos = $ID("inputTakePhotos").checked;
            const photoInterval_ms = Math.round(getInputNumDefAbsFlt("inputPhotoInterval", NaN) * 1_000);
            forceLimitDropPercent = catchVal((toNumber($ID("inputLoadLimitDropPercent").value) / 100), Infinity, isNum);
            forceLimitDropValue = getInputNumDefAbsFlt("inputLoadLimitDropValue", Infinity);

            let loadcellCapacities = Array(loadCellNum).fill(null);
            let loadcellOutputs = Array(loadCellNum).fill(null);
            if (systemLevel >= 2) {
                for (let i = 0; i < loadCellNum; i++) {
                    loadcellCapacities[i] = getInputNumDefAbsInt(`inputLoadcellCapacity${i + 1}`, NaN);
                    loadcellOutputs[i] = getInputNumDefAbsInt(`inputLoadcellOutput${i + 1}`, NaN);
                }
            } else {
                const loadcellCapacity = getInputNumDefAbsInt("inputLoadcellCapacity", NaN);
                const loadcellOutput = getInputNumDefAbsFlt("inputLoadcellOutput", NaN);

                loadcellCapacities = Array(loadCellNum).fill(loadcellCapacity);
                loadcellOutputs = Array(loadCellNum).fill(loadcellOutput);
            }


            let initialSpeed_mmps = speedForward_mmps;
            initialForceLim_N = null;
            experimentDoubleSpeed = false;
            experimentHoldConstantForce = false;
            stoppingForceLimit = Number.POSITIVE_INFINITY;
            holdForceTimeMs = null;
            presentLoadcells = [];


            const suffixes = ["-inb", "-hbr"]; // TODO: doplnit i pro Flex ("-flx")
            if (suffixes.some(suf => experimentType.endsWith(suf))) {
                initialSpeed_mmps = getInputNumDefAbsFlt("inputInitialSpeed", NaN);
                initialForceLim_N = getInputNumDefAbsFlt("inputInitialForce", NaN);
                experimentDoubleSpeed = true;

                if (experimentType.endsWith("-hbr")) {
                    stoppingForceLimit = getInputNumDefAbsFlt("inputStopForce", NaN);
                    holdForceTimeMs = Math.round(getInputNumDefAbsFlt("inputEndDelay", NaN) * 1_000);
                    experimentHoldConstantForce = true;
                }
            }

            let doCycles = false;
            let cyclesCount = NaN;

            if (!experimentType.endsWith("-basic")) {
                doCycles = $ID("inputDoCycles").checked;
                if (doCycles) cyclesCount = getInputNumDefAbsInt("inputCycles", NaN);

            }

            if (experimentType.includes("-pos-")) {
                experimentEndLimits = {position: distance_mm, force: null, time: null};  // The total distance to be moved; force and time limits are not used now
                expControl = 'position'; // Control the experiment by position
                console.info("\n\t\t‚û°Ô∏è Experiment type: Position controlled");
                await logMessage("\t\t‚û°Ô∏è Experiment type: Position controlled");
            } else {
                throw new Error("Unknown Experiment type error");
            }

            if (expControl === 'position') {
                if (!isValidInputNum(distance_mm) || distance_mm < minDistance) {
                    console.warn(`\n‚ö†Ô∏è Distance must be greater than ${minDistance} mm.`);
                    await logMessage(`‚ö†Ô∏è Distance must be greater than ${minDistance} mm.`);
                    alert(`‚ö†Ô∏è Distance must be greater than ${minDistance} mm.`);
                    throw new Error("Distance error");
                }
            }

            if (doCycles && !(isNum(cyclesCount) && cyclesCount > 0)) {
                    console.warn(`\n‚ö†Ô∏è Number of cycles must be a positive integer.`);
                    await logMessage(`‚ö†Ô∏è Number of cycles must be a positive integer.`);
                    alert(`‚ö†Ô∏è Number of cycles must be a positive integer.`);
                    throw new Error("Cycles count error");
                }

            if (!isNum(speedForward_mmps) || speedForward_mmps < minFSpeed) {
                console.warn(`\n‚ö†Ô∏è Speed must be greater than ${minFSpeed} mm.`);
                await logMessage(`‚ö†Ô∏è Speed must be greater than ${minFSpeed} mm.`);
                alert(`‚ö†Ô∏è Speed must be greater than ${minFSpeed} mm.`);
                throw new Error("Speed error");
            } else if (speedForward_mmps > maxFSpeed) {
                console.warn(`\n‚ö†Ô∏è Speed must be less than ${maxFSpeed} mm/s.`);
                await logMessage(`‚ö†Ô∏è Speed must be less than ${maxFSpeed} mm/s.`);
                alert(`‚ö†Ô∏è Speed must be less than ${maxFSpeed} mm/s.`);
                throw new Error("Speed error");
            }

            if (!isNum(dataInterval_us) || dataInterval_us < 1) {
                console.warn(`\n‚ö†Ô∏è Data interval must be greater than 1 ¬µs.`);
                await logMessage(`‚ö†Ô∏è Data interval must be greater than 1 ¬µs.`);
                alert(`‚ö†Ô∏è Data interval must be greater than 1 ¬µs.`);
                throw new Error("Data interval error");
            }

            if (!isArr(loadcellCapacities) || loadcellCapacities.some(cap => !isNum(cap) || cap < minLoadCap)) {
                console.warn(`\n‚ö†Ô∏è Loadcell capacity must be greater than ${minLoadCap} kg.`);
                await logMessage(`‚ö†Ô∏è Loadcell capacity must be greater than ${minLoadCap} kg.`);
                alert(`‚ö†Ô∏è Loadcell capacity must be greater than ${minLoadCap} kg.`);
                throw new Error("Loadcell capacity error");
            } else if (!isArr(loadcellOutputs) || loadcellOutputs.some(out => !isNum(out) || out < minLoadOut)) {
                console.warn(`\n‚ö†Ô∏è Loadcell output must be greater than ${minLoadOut} mV/V.`);
                await logMessage(`‚ö†Ô∏è Loadcell output must be greater than ${minLoadOut} mV/V.`);
                alert(`‚ö†Ô∏è Loadcell output must be greater than ${minLoadOut} mV/V.`);
                throw new Error("Loadcell output error");
            }

            if (experimentDoubleSpeed === true) {
                if (!isNum(initialSpeed_mmps) || initialSpeed_mmps < minFSpeed) {
                    console.warn(`\n‚ö†Ô∏è Initial speed must be greater than ${minFSpeed} mm/s.`);
                    await logMessage(`‚ö†Ô∏è Initial speed must be greater than ${minFSpeed} mm/s.`);
                    alert(`‚ö†Ô∏è Initial speed must be greater than ${minFSpeed} mm/s.`);
                    throw new Error("Initial speed error");
                } else if (initialSpeed_mmps > maxFSpeed) {
                    console.warn(`\n‚ö†Ô∏è Initial speed must be less than ${maxFSpeed} mm/s.`);
                    await logMessage(`‚ö†Ô∏è Initial speed must be less than ${maxFSpeed} mm/s.`);
                    alert(`‚ö†Ô∏è Initial speed must be less than ${maxFSpeed} mm/s.`);
                    throw new Error("Initial speed error");
                } else if (!isValidInputNum(initialForceLim_N)) {
                    console.warn(`\n‚ö†Ô∏è Initial force load must be greater than 0 N.`);
                    await logMessage(`‚ö†Ô∏è Initial force load must be greater than 0 N.`);
                    alert(`‚ö†Ô∏è Initial force load must be greater than 0 N.`);
                    throw new Error("Initial force load error");
                }
            }

            if (takePhotos) {
                if (!isNum(photoInterval_ms) || photoInterval_ms <= minInt) {
                    console.warn(`\n‚ö†Ô∏è Photo interval must be greater than ${minInt * 1_000} s.`);
                    await logMessage(`‚ö†Ô∏è Photo interval must be greater than ${minInt * 1_000} s.`);
                    alert(`‚ö†Ô∏è Photo interval must be greater than ${minInt * 1_000} s.`);
                    throw new Error("Photo interval error");
                }
                if (photoInterval_ms * 1_000 < dataInterval_us) {
                    console.warn("\n‚ö†Ô∏è Photo interval must be bigger than data interval.");
                    await logMessage("‚ö†Ô∏è Photo interval must be bigger than data interval.");
                    const newDataInterval = photoInterval_ms * 1_000 * 0.9;
                    await logMessage(`‚ùó Changing data interval from ${dataInterval_us} to ${newDataInterval} ¬µs ‚ùó`);
                    dataInterval_us = newDataInterval;
                    $ID("inputDataInterval").value = dataInterval_us;
                }
            }

            if (experimentType.endsWith("-hbr")) {
                if (!isValidInputNum(stoppingForceLimit)) {
                    console.warn(`\n‚ö†Ô∏è Stopping force must be greater than 0 N.`);
                    await logMessage(`‚ö†Ô∏è Stopping force must be greater than 0 N.`);
                    alert(`‚ö†Ô∏è Stopping force must be greater than 0 N.`);
                    throw new Error("Stopping force error");
                }

                if (stoppingForceLimit <= initialForceLim_N) {
                    console.warn(`\n‚ö†Ô∏è Stopping force must be greater than initial force.`);
                    await logMessage(`‚ö†Ô∏è Stopping force must be greater than initial force.`);
                    alert(`‚ö†Ô∏è Stopping force must be greater than initial force.`);
                    throw new Error("Stopping force error");
                }

                if (!isNum(holdForceTimeMs) || holdForceTimeMs < minInt || (holdForceTimeMs / 1_000) < 0) {
                    console.warn(`\n‚ö†Ô∏è Hold force time must be equal or greater than ${minInt * 1_000} s.`);
                    await logMessage(`‚ö†Ô∏è Hold force time must be equal or greater than ${minInt * 1_000} s.`);
                    alert(`‚ö†Ô∏è Hold force time must be equal or greater than ${minInt * 1_000} s.`);
                    throw new Error("Hold force time error");
                }

                const minDataInterval = 25_000;
                if (dataInterval_us < minDataInterval) {
                    console.warn(`\n‚ö†Ô∏è Data interval must be at least 30000 ¬µs for hold constant force mode.`);
                    await logMessage(`‚ö†Ô∏è Data interval must be at least 30000 ¬µs for hold constant force mode.`);
                    await logMessage(`‚ùó Changing data interval from ${dataInterval_us} to ${minDataInterval} ¬µs ‚ùó`);
                    dataInterval_us = minDataInterval;
                    $ID("inputDataInterval").value = minDataInterval;
                }

                const minDataIntervalHold = holdForceTimeMs * 1_000 * 0.05;
                if (minDataIntervalHold < dataInterval_us) {
                    console.warn(`\n‚ö†Ô∏è Hold force time must be at least 20 times bigger than data interval: holdForceTime=${holdForceTimeMs} ms, dataInterval=${dataInterval_us / 1_000} ms.`);
                    await logMessage(`‚ö†Ô∏è Hold force time must be at least 20 times bigger than data interval: holdForceTime=${holdForceTimeMs} ms, dataInterval=${dataInterval_us / 1_000} ms.`);
                    await logMessage(`‚ùó Changing data interval from ${dataInterval_us} to ${minDataIntervalHold} ¬µs ‚ùó`);
                    dataInterval_us = minDataIntervalHold;
                    $ID("inputDataInterval").value = minDataIntervalHold;
                }
            }


            if (isEmptyStr(expControl)) throw new Error("Experiment control is not set.");
            if (isUndefined(experimentEndLimits[expControl])) throw new Error(`Experiment end limit for ${expControl} is not set.`);
            if (isUndefined(parsedData[expControl])) throw new Error(`Parsed data for ${expControl} is not available.`);
            if (!hasRequiredParsedKeys(experimentEndLimits, parsedData)) throw new Error("Experiment end limits are not properly set.");


            for (let i = 1; i <= (loadCellNum + 1); i++) {
                if (timeChart) timeChart.setSeries(i, {show: false});
                if (positionChart) positionChart.setSeries(i, {show: false});
            }

            calibrationStatus = await getCalibrationStatus(2_000);

            if (!calibrationStatus) {
                // if (confirm("‚ö†Ô∏è Motors are not calibrated. Calibrate the motor?\n\nOK = Calibrate\tCancel = Not Calibrate")) {
                //     let confirmCalibrationCount = 0;
                //
                //     await logMessage("‚ö†Ô∏è Motors are not calibrated. Calibrating the motor...");
                //     console.warn("\n‚ö†Ô∏è Motors are not calibrated. Calibrating the motor...");
                //     await sendCommandGeneral('MC CALIBRATE');
                //     await sleep(5); // Stop for 5 ms
                //
                //
                //     while (!calibrationStatus) {
                //         await sleep(2500);
                //         calibrationStatus = await getCalibrationStatus(500);
                //
                //         // log time
                //         // console.info("üïí Time: ", new Date().toLocaleTimeString());
                //
                //         if (confirmCalibrationCount > 50) {
                //             await logMessage("‚ùå Calibration timeout reached. Please check the motor.\n\tMotors are not calibrated.");
                //             console.error("‚ùå Calibration timeout. Please check the motor.\n\tMotors are not calibrated.");
                //             await sleep(5); // Stop for 5 ms
                //         } else {
                //             confirmCalibrationCount++;
                //         }
                //
                //         if (!isConnected) {
                //             console.warn("\n‚ö†Ô∏è Serial connection lost during calibration.");
                //             await logMessage("‚ö†Ô∏è Serial connection lost during calibration.");
                //             throw new Error("Serial connection lost during calibration.");
                //         }
                //     }

                // console.info("üìê Machine is calibrated.");
                // await logMessage("üìê Machine is calibrated.\n\tüîÉ Please restart the experiment.");
                // alert("üìê Machine is calibrated.\n\tüîÉ Please restart the experiment.");
                // } else {
                await lockMovementExcept(UI.calibrateBtn);
                await logMessage("‚ùå Calibration is required to start the experiment.");
                console.error("‚ùå Calibration is required to start the experiment.");
                alert("‚ùå Calibration is required to start the experiment.");
                // }
                throw new Error("Calibration is required to start the experiment.");
            }


            if ($ID('inputAutoSave').value.trim().toLowerCase().endsWith('before')) {
                UI.experimentStageLabel.textContent = `Saving`;
                await saveCSV();
            }

            await logMessage(`\nüéØ Starting experiment ${takePhotos ? "with photos üì∏" : ""}`);
            await console.info("üß™ Starting experiment...");
            UI.loadingLogContainer.style.background = "black";

            await clearDatabase();
            await clearCharts();

            // for (let attempt = 1; attempt <= 3; attempt++) {
            //     try {
            //         presentLoadcells = (await isLoadcellsPresent(2000)) || [];
            //         if (presentLoadcells.some(p => p)) break; // At least one loadcell is present
            //     } catch (e) {
            //         console.warn("‚ö†Ô∏è Warning: Could not determine loadcell presence, attempt", attempt, "of 3.");
            //     }
            //     if (attempt === 3) {
            //         await logMessage("‚ùå No loadcells detected. Please check the connection.");
            //         console.error("‚ùå No loadcells detected. Please check the connection.");
            //         alert("‚ùå No loadcells detected. Please check the connection.");
            //         throw new Error("No loadcells detected. Please check the connection.");
            //     }
            //     await sleep(500); // Wait before retrying
            // }

            if (!liveUpdate) await chartUpdate();


            // === Progress Bar Setup ===
            document.documentElement.style.setProperty('--progressColor', 'var(--progressPrimary-color)');
            UI.experimentStageLabel.textContent = `Running`;
            UI.progressBar.value = 0;
            UI.progressLabel.textContent = `0%`;

            // === Experiment Parameters ===
            if (await $ID('inputClearCalculations').checked) await clearCalculations();

            maxDataPoints = maxDataPointsExp;

            // TODO: use 'resetVariables' function !!!!!!!!!!!!!!!!

            // === Reset Variables ===
            tareValues.time = null;
            tareValues.position = null;
            lastAcceptedTime = null;
            maxForces = Array(loadCellNum).fill(null);
            timeData = [];
            positionData = [];
            forceData = Array(loadCellNum).fill(null).map(() => []);
            photoData = [];
            measureForces = Array(loadCellNum).fill(null).map(() => []);
            tareValues.force = Array(loadCellNum).fill(0);


            measurementParts = {
                length: null,
                time: [0],
                position: [1],
                speed: [2],
                force: [3, 4, 5],
            }; // TODO: adjust if needed by type of experiments, loadcells, etc.

            measurementParts.length = getMeasurementPartsLength(measurementParts);

            dataChartInterval = calculateStep(dataInterval_us, 150, 1);
            const minimumConditionCount = calculateStep(dataInterval_us, 50, 3);

            aggregatedDataBetweenSteps = [];
            dataCount = 0;

            Object.values(measurement_limits).forEach(v => {
                v.counter = 0;
                v.limit = minimumConditionCount;
            });
            measurement_limits.over_limitForce.limit = calculateStep(dataInterval_us, 10, 2);
            if (doCycles) {
                experimentEndLimits = {position: null, force: null, time: null};
                measurement_limits.zero_speed.limit = calculateStep(dataInterval_us, 1_000, 2);
            }

            checkSpeed = true; // TODO: reset if needed
            timer = null;
            endedBy = null;
            pendingDSLR = null;
            parsedData = {
                time: 0,
                position: 0,
                speed: 0,
                force: Array(loadCellNum).fill(0),
                photoIndex: takePhotos ? 0 : null // Store DSLR photo order
            };

            currentSpeed = (await getSpeed()) || 15;
            currentAcceleration = (await getAcceleration()) || 150;

            // === LoadCell Configuration ===
            for (let i = 0; i < loadCellNum; i++) {
                await sendCommandGeneral(`LC SET CAP ${i} ${loadcellCapacities[i]}`);
                await sendCommandGeneral(`LC SET RO ${i} ${loadcellOutputs[i]}`);
            }

            // === Prepare Machine ===
            await sendStopAllMeasuring();
            if (takePhotos) await sendCommandGeneral('DSLR RESET COUNTERS');

            await setSpeedAndAcceleration(initialSpeed_mmps, 200, false);

            // === Prepare Data Collection ===
            tareValues.position = await measurePosition();
            $ID("returnPositionExperimentBtn").textContent = `‚Ü©Ô∏è Return to start position: ${tareValues.position} mm`;

            loadSignCorrections = Array(loadCellNum).fill(displacementSignCorrection * -1);
            for (let i = 0; i < loadCellNum; i++) {
                if (loadcellCapacities[i] <= 50) loadSignCorrections[i] *= -1; // Reverse direction if loadcell capacity is less than or equal to 50 N
            }

            const settings = await collectExpSettings(".expInput", "Moira-exp-settings") || {};

            const expInfoV = settings?.version;
            let experimentKey = null;
            if (expInfoV === 1) {
                experimentKey = settings?.inputs["experimentTypeDropdown"]?.extra?.essence;
            }
            const experimentLabel = catchVal(expTypesLabels[experimentKey], "", isOk);

            await addDataToLog({
                status: "collecting",
                expSettings: settings,
                experimentName: $ID("experimentName")?.value?.trim(),
                experimentLabel: experimentLabel?.trim(),
                experimentCounter: $ID("experimentCount")?.value?.trim(),
                experimentDescription: $ID("experimentDesc")?.value?.trim(),
                experimentDate: (new Date().toLocaleString())?.replaceAll(". ", "."),
                loadDirection: displacementSignCorrection,
                loadDistance: distance_mm,
                loadSpeed: speedForward_mmps,
                loadcellCapacity: loadcellCapacities,
                loadcellType: 'Undefined',
                appSoftWare: softwareVersion,
                machineFirmware: machineFirmware,
                endStatus: endedBy,
                experimentProgress: experimentProgress,
                precisions: {
                    time: precisionTime,
                    position: precisionPosition,
                    speed: precisionSpeed,
                    acceleration: precisionAcceleration,
                    force: precisionForce,
                },
                experimentLimits: experimentEndLimits,
                experimentControl: expControl,
            }, 0);


            await addDataToLog(parsedData);
            await updateChart(parsedData);

            UI.experimentStageLabel.textContent = `Tarring`;

            await sendCommandGeneral('DATA SET INTERVAL 2000');

            for (let i = 0; i < loadCellNum; i++) {
                await sendCommandGeneral(`LC TARE ${i}`);
            }

            // --- 1) Take measurements ---
            takeMeasurements = true;
            await sendCommandGeneral("DATAC 1");


            // Take measurements for 1.5 second
            await sleep(1_500); // Wait


            await sendCommandGeneral("DATAC 0");
            takeMeasurements = false;


            // --- 2) Mean forces ---
            tareValues.force = meanND(measureForces, 1).map(force => roundDecimalFast(force, precisionForce)); // TODO: zbyteƒçn√©

            // --- 3) Analysis ---
            const forceAnalysis = await analyzeForces(measureForces);  // TODO: Implement and save present/used loadcells to the experiment log and use it when loading form DB and when loading CSV
            console.info("Force analysis:");
            console.table(forceAnalysis);

            // --- 4) Valid fields ---
            const validFields = await forceAnalysis.filter(r => !r.allInvalid);

            // indexes of valid fields => presentLoadcells
            presentLoadcells = forceAnalysis.flatMap((r, i) => r.allInvalid ? [] : i);


            // --- 5) Check for errors ---
            // If more one force is not eaqule to zero, than Stop and Alert
            if (!experimentType.endsWith("-basic")) {
                if (validFields.length > 1) {
                    console.warn("\n‚ö†Ô∏è Multiple loadcells are connected.");
                    await logMessage("‚ö†Ô∏è Multiple loadcells are connected. Please check the loadcell connections and connect only one loadcell.");
                    alert("‚ö†Ô∏è Multiple loadcells are connected. Please check the loadcell connections and connect only one loadcell.");
                    throw new Error("Multiple loadcells connected");

                } else if (validFields.length === 0) {
                    console.warn("\n‚ö†Ô∏è No loadcell is connected.");
                    await logMessage("‚ö†Ô∏è No loadcell is connected. Please check the loadcell connection and try again.");
                    alert("‚ö†Ô∏è No loadcell is connected. Please check the loadcell connection and try again.");
                    throw new Error("No loadcell connected");
                }
            }

            const setChart = (chart) => {
                if (isVoid(chart)) return;
                forceAnalysis?.forEach((r, i) => chart.setSeries((i + 1), {show: !r?.allInvalid}));
                chart.setSeries((loadCellNum + 1), {show: takePhotos});
            };
            setChart(timeChart);
            setChart(positionChart);

            // --- 6) Valid dispersion ---
            const diffs = validFields.flatMap(({
                                                   min, max
                                               }) => (isNum(min) && isNum(max)) ? [max - min] : []);
            console.info("\nValid dispersions:", diffs);

            // --- 7) Error rates ---
            measurementErrRate = await roundDecimalFast(await diffs.reduce((a, b) => a + b, 0) / diffs.length, precisionForce);
            console.info("\n\t\tüé∞ Measurement error rate:", measurementErrRate, "N");

            loadcellErrRate = await (loadcellCapacity * 9.81) / 2_000; // 0.05% of the capacity
            console.info("\n\t\tüé∞ Loadcell error rate:", loadcellErrRate, "N");

            // --- 8) Final error rate ---
            const alpha = 0.65; // Weighting factor between measurement and loadcell error rates
            totalErrRate = alpha * measurementErrRate + (1 - alpha) * loadcellErrRate;
            console.info("\n\tüé≤ Final error rate:", totalErrRate, "N");
            await logMessage(`\tüé≤ Set error rate: ${totalErrRate} N`);

            // --- 9) Clear force fields ---
            measureForces = Array(loadCellNum).fill(null).map(() => []);


            if (experimentType.endsWith("-hbr")) {
                pi = createPIController({
                    setForceN: stoppingForceLimit,
                    Kp: 0.100,
                    Ki: 0.015,
                    deadbandN: (totalErrRate * 1.15), // deadband set to 115% of total error rate
                    vMin: minFSpeed,
                    vMax: Math.max(minFSpeed * 3 / 2, speedForward_mmps * 2 / 3), // limit max speed during holding
                    accel: null, // slew-rate limit to 5 mm/s¬≤
                    integLimit: computeFrenchingMs(dataInterval_us, holdForceTimeMs * 0.25, 125), // anti-windup clamp: readings in the last 25% of hold time
                });
            }


            // ==================================
            // === Reset Experiment Variables ===

            experimentProgress = 0
            tareValues.time = null;
            lastAcceptedTime = null;
            isExperimentRunning = true;
            endMeasurement = false;
            clearTimeout(endMeasurementCounter)
            endMeasurementCounter = null;


            timeData = [];
            positionData = [];
            forceData = Array(loadCellNum).fill(null).map(() => []);
            photoData = [];

            UIupdate();

            if (experimentDoubleSpeed === true) UI.experimentStageLabel.textContent = `Initial`;
            else UI.experimentStageLabel.textContent = `Loading`;

            // ==================================
            // ==================================


            if (takePhotos) await sendCommandGeneral('DSLR SHOOT', 250);

            // === Enable Data Streaming and DSLR Shooting ===
            await sendCommandGeneral(`DATA SET INTERVAL ${dataInterval_us}`, 5);
            if (takePhotos) await sendCommandGeneral(`DSLR START CYCLIC ${photoInterval_ms}`);
            await sendCommandGeneral("DATAC 1");

            // === Move Forward ===
            console.info("‚û°Ô∏è Moving forward...");
            await sendCommandGeneral(`MC MOVEBY MACH ${distance_mm * displacementSignCorrection}`);

            if (doCycles && isNum(cyclesCount) && cyclesCount > 0) {
                const movementTime = computeMotionTime(distance_mm, speedForward_mmps, 200);

                setInterval(async () => {
                    if (!isExperimentRunning) return;
                    if (cyclesCount <= 0) return;

                    cyclesCount--;
                    console.info(`üîÑ Cycle detected, moving back. Cycles left: ${cyclesCount}`);
                    displacementSignCorrection *= -1;
                    await sendCommandGeneral(`MC MOVEBY MACH ${distance_mm * displacementSignCorrection}`);
                }, movementTime + 5);
            }


            // === Data Collection Loop ===
            while (isExperimentRunning) {
                await sleep(1_000); // Prevents excessive CPU usage
            }

            isExperimentRunning = false;

            // === Stop Data Streaming and DSLR Shooting ===
            await sendStopAllMeasuring();

            await logMessage("üé¨ Measurements stopped.");
            await console.info("üé¨ Measurements stopped.");


            if (experimentType.endsWith("-inb")) {
                // // === Move Further ===
                // // TODO: Make sure, that it will not break sample (window to user to accept)
                // if (UI.autoReturnPosition.checked) {
                //     await sleep(2000); // Stop for 2 s
                //
                //     let endPosition = await measurePosition();
                //
                //     const shift = Math.abs(100);
                //
                //     console.info(`‚û°Ô∏è Moving further to ${endPosition - shift} mm...`);
                //
                //     await sendCommandGeneral(`MC MOVEBY MACH -${shift}`);
                //     await sleep(((computeMotionTime(shift, returningSpeed, returningAcceleration) * 1_000) + 500)); // Wait
                //
                //     endPosition = await measurePosition();
                //
                //     console.info(`üö© Reached position: ${endPosition} mm`);
                // }
            } else {
                // === Move Back ===
                if (UI.autoReturnPosition.checked) {
                    UI.experimentStageLabel.textContent = `Returning`;
                    await moveToOriginalPosition({overRide: true}); // TODO: neposune se: chyba (Machine is already busy. Please wait.) => add overRide
                }
            }

            // === Save Data ===
            if ($ID('inputAutoSave').value.trim().toLowerCase().endsWith('after')) {
                UI.experimentStageLabel.textContent = `Saving`;
                await saveCSV();
            }

            UI.experimentStageLabel.textContent = `Finalizing`;

            await console.info("\n‚òëÔ∏è Experiment finished.");
            await showNotification("Experiment Finished", "The experiment has been completed successfully.");

        } catch
            (error) {
            await handleError(error, "Experiment");
            document.documentElement.style.setProperty('--progressColor', 'var(--progressError-color)');
            UI.experimentStageLabel.textContent = `Error`;
            endedBy = 'error';
            await alert(`Experiment Finished\n     ‚ùå Experiment failed. Please check the logs and machine.\n\n     Error:${error.message || error}`);

        } finally {
            await endMeasuring(0, {endText: ''});

            if (!isNum(loadCellNum)) {
                console.error("Loadcell number is not defined during experiment finalization.");
                alert("Loadcell number is not defined during experiment finalization.");
            } else {
                for (let i = 0; i < loadCellNum; i++) {
                    await sendCommandGeneral(`LC TARE RESET ${i}`);
                }
            }

            await sleep(20);

            clearTimeout(dbFlushTimer);
            dbFlushTimer = null;
            await flushDB();
            await recomputeAll();
            if (isDef(endedBy)) await updateLogById(0, {endStatus: endedBy});
            await updateLogById(0, {experimentProgress: experimentProgress, status: "collected"});
            document.title = initialTitle;

            UI.experimentStageLabel.textContent = `Idle`;
            maxDataPoints = maxDataPointsIdle;

            endedMoving();    // unlock UI and watchdog
            unlockControlAndMove();
            await console.info(`\n‚úÖ Experiment completed.\n\t\tExperiment Status: ${endedBy || "completed"}\n`);

            await console.groupEnd();

        }
    }

    async function sendStopAllMeasuring() {
        await sendCommandGeneral("MC STOP"); // Stop movement
        await sendCommandGeneral("DSLR STOP CYCLIC"); // Stop DSLR cyclic
        await sendCommandGeneral("DATAC 0"); // Stop data collection
    }


    async function endMeasuring(timeoutMs = 0, {

        overRide = false,
        ednStatus = '',
        endText = '‚õî Experiment stopped.',
        immediateText = '',
        command = ''

    } = {}) {


        if (endMeasurement && !overRide) return;
        endMeasurement = true;

        const delayFixMs = 5; // fix for setTimeout delays

        if (endMeasurementCounter) {
            clearTimeout(endMeasurementCounter);
            endMeasurementCounter = null;
        }

        if (!isNum(timeoutMs)) timeoutMs = 0;

        if (isNonEmptyStr(command)) {
            await sendCommandGeneral(command);
        }
        if (isNonEmptyStr(immediateText)) {
            console.info(immediateText);
            logMessage(immediateText);
        }

        const totDelayMs = Math.max(0, timeoutMs - delayFixMs);

        console.info(`üïê Ending in ${totDelayMs} miliseconds...`);
        logMessage(`üïê Ending in ${totDelayMs} miliseconds...`);


        endMeasurementCounter = setTimeout(async () => {
            if (isNonEmptyStr(endText)) {
                console.info(endText);
                logMessage(endText);
            }

            if (isConnected) {
                await sendStopAllMeasuring();
            }

            isExperimentRunning = false;
            dataCount = null;
            dataChartInterval = 1;

            UI.loadingLogContainer.style.background = "#323232";

            if (aggregatedDataBetweenSteps.length > 0) {
                console.info("\nüëÅÔ∏è‚Äçüó®Ô∏è Data not sent to chart.", aggregatedDataBetweenSteps.length);
                await updateChart(calculateAverageParsedData(aggregatedDataBetweenSteps));
            }

            // progress UI
            if (experimentProgress >= 99.999_900) {
                experimentProgress = 100;
                document.documentElement.style.setProperty('--progressColor', 'var(--progressDone-color)');
                UI.experimentStageLabel.textContent = `Finished`;
                UI.progressBar.value = 100;
                UI.progressLabel.textContent = `100%`;
                document.title = `ŒúŒø·øñœÅŒ±‚Äá-‚ÄáExperiment done (100%)`;
                if (debugging) console.info("‚úÖ Experiment done üíØ");
            }

            aggregatedDataBetweenSteps = [];

            // const lastData = await calculateAverageParsedData(aggregatedDataBetweenSteps);
            // console.warn(lastData);
            // aggregatedDataBetweenSteps.forEach(data => {
            //     updateChart(data);
            // });

            clearTimeout(endMeasurementCounter);
            endMeasurementCounter = null;

            if (ednStatus) endedBy = ednStatus;

            await sleep(1_000); // Allow any final data processing

            await refreshCharts();

        }, totDelayMs);
    }

</script>

<script>

    async function UIupdate() {
        lastTitle = document.title;

        while (isExperimentRunning) {

            let progressNumber, progressLabel, progressTitle;

            if (!isNum(experimentProgress)) {
                progressNumber = 0;
                progressLabel = 'N/A';
                progressTitle = 'Unknown';
            } else {
                progressNumber = experimentProgress;
                progressLabel = `${experimentProgress.toFixed(2)}%`; // .padStart(5, "0")
                progressTitle = `${Math.floor(experimentProgress)}%`;
            }

            UI.progressBar.value = progressNumber;
            UI.progressLabel.innerText = progressLabel;
            const newTitle = `ŒúŒø·øñœÅŒ±‚Äá-‚Äá${progressTitle}`;
            if (lastTitle !== newTitle) {
                document.title = newTitle;
                lastTitle = newTitle;
            }

            if (experimentProgress >= 100) break;

            // wait for 50 ms => 20FPS
            await sleep(50);
        }
    }

</script>

<script>
    // -------------------------
    // Fronta ƒçekaj√≠c√≠ch po≈æadavk≈Ø
    // -------------------------

    let _reqId = 0;
    /** Pomocn√°: odstran√≠ po≈æadavek z fronty podle id */
    const _pending = /** @type {PendingReq[]} */([]);

    /** @typedef {{
     *   id: number,
     *   regex: RegExp,
     *   valueIndex: number,
     *   resolve: (v:any)=>void,
     *   timeoutId: ReturnType<typeof setTimeout>
     * }} PendingReq
     */
    function _removePending(id) {
        const idx = _pending.findIndex(p => p.id === id);
        if (idx !== -1) _pending.splice(idx, 1);
    }

    /** P≈ôid√° po≈æadavek do fronty a nastav√≠ timeout */
    function _enqueue(format, valueIndex, timeoutMs) {
        const regex = (format instanceof RegExp)
            // zajist√≠me "global" a "m" pro p≈ô√≠pad v√≠ce ≈ô√°dk≈Ø; zachov√°me i p≈Øvodn√≠ flagy:
            ? new RegExp(format.source, new Set((format.flags + "gm").split(""))
                .size ? Array.from(new Set((format.flags + "gm").split(""))).join("") : "gm")
            : new RegExp(String(format), "gm");

        const id = ++_reqId;

        let resolveRef;
        const p = new Promise((resolve) => {
            resolveRef = resolve;
        });

        // timeout: po vypr≈°en√≠ odstran√≠me z fronty a resolve(null)
        const timeoutId = setTimeout(() => {
            _removePending(id);
            resolveRef(null);
        }, Math.max(0, timeoutMs || 0));

        /** @type {PendingReq} */
        const entry = {id, regex, valueIndex, resolve: resolveRef, timeoutId};
        _pending.push(entry);

        return {id, promise: p};
    }

    /** Zpracuje jednu p≈ô√≠choz√≠ zpr√°vu: zkus√≠ ji sp√°rovat s frontou.
     *  Vrac√≠ true, pokud zpr√°va byla spot≈ôebovan√° (sp√°rovala se s nƒõkter√Ωm po≈æadavkem).
     */
    function _tryMatchAndResolve(msg) {
        // Pozn√°mka: zpr√°vu m√°me porovnat ‚Äûse v≈°√≠m ve frontƒõ‚Äú, ale jakmile JEDEN souhlas√≠,
        // zpr√°vu u≈æ d√°l neporovn√°v√°me.
        for (let i = 0; i < _pending.length; i++) {
            const req = _pending[i];

            // reset lastIndex because of the 'g' flag
            req.regex.lastIndex = 0;
            const match = req.regex.exec(msg);
            if (match) {
                clearTimeout(req.timeoutId);
                _pending.splice(i, 1); // delete from pending
                const val = match[req.valueIndex];
                req.resolve(val);
                return true; // do not process further
            }
        }
        return false;
    }


    function cancelAllPending() {
        while (_pending.length) {
            const p = _pending.pop();
            clearTimeout(p.timeoutId);
            p.resolve(null);
        }
    }


    function waitForFormat(format, valueIndex, timeout = 5_000) {
        const {promise} = _enqueue(format, valueIndex, timeout);
        return promise;
    }


    /**
     * Sends a command and waits for a value extracted from the first message
     * that matches the given format (regex). If nothing is received within
     * `timeout` ms, it returns `null`.
     *
     * @param {string} command - command to send
     * @param {RegExp|string} format - regex or string pattern
     * @param {number} valueIndex - index from match field (0 = whole match, 1.. = capture groups)
     * @param {number} [timeout=5000]
     * @returns {Promise<any|null>}
     */
    async function getPromisedValue(command, format, valueIndex, timeout = 5_000) {
        // 1) First, set up the expected data format and create a promise to wait for it
        const p = waitForFormat(format, valueIndex, timeout);

        // 2) Then, send the command to request the data
        await sendCommandGeneral(command);

        // 3)
        return p;
    }


    // === Firmware version ===
    async function getFirmwareVersion(timeOut = 2_000) {
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet firmware version...");
            const version = await getPromisedValue("MISC GET LIBINFO", /Firmware:\s*([^,]+)/, 1, timeOut);

            if (!version) {
                throw new Error(`Version is empty: ${version}`);
            }
            console.info(`\n\tüì¶ Firmware version: ${version}`);
            return version;
        } catch (error) {
            console.error(error.message);
            throw new Error(`Firmware version not received. ${error}`);
        }
    }

    async function getFirmwaresVersions(timeOut = 2_000) {
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        // TODO: doplnit dal≈°√≠ moduly
        const tags = ['MOTOR', 'LOADCELL', 'POWER', 'MOTION', 'DSLR', 'FAN', 'EXP', 'MEMORY', 'REPORT', 'COMMAND']; // list of firmware tags
        const versions = {};
        try {
            for (const t of tags) {
                if (debugging) logMessage(` üì¢\tGet ${t} firmware version...`);
                let version = await getPromisedValue(`MISC GET LIBINFO ${t}`, /Firmware:\s*([^,]+)/, 1, timeOut);

                version = version || null;

                console.info(`\n\t\tüß© ${t} Firmware version: ${version}`);
                versions[t.toLowerCase()] = version;
            }
            return versions;
        } catch (error) {
            console.error(error.message);
            throw new Error(`Firmware version not received. ${error}`);
        }
    }


    async function getMachineName(timeOut = 2_000) {
        try {
            if (debugging) logMessage(" üì¢\tGet machine name...");
            const name = await getPromisedValue("MISC GET NAME", /Machine Name:\s*(.+)/, 1, timeOut);

            if (!name) {
                throw new Error(`Name is empty: ${name}`);
            }
            console.info(`\n\tüè∑Ô∏è Machine name: ${name}`);
            return name;
        } catch (error) {
            console.error(error.message);
            throw new Error(`Machine name not received. ${error}`);
        }
    }

    async function getMachineID(timeOut = 2_000) {
        try {
            if (debugging) logMessage(" üì¢\tGet machine ID...");
            const id = toNumber(await getPromisedValue("MISC GET MACHINE_ID", /Machine ID:\s*(.+)/, 1, timeOut), true);

            if (!isNum(id)) {
                throw new Error(`ID is not a number: ${id}`);
            }
            console.info("\n\tüÜî Machine ID:", id);
            return id;
        } catch (error) {
            console.error(error.message);
            throw new Error(`Machine ID not received. ${error}`);
        }
    }

    // === Measure Position ===
    async function measurePosition(timeOut = 2_000) {
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet position...");
            const position = toNumber(await getPromisedValue("MC GET POS", /^Motor position:\s(-?\d+(\.\d+)?)\smm$/, 1, timeOut), true);
            // const position = parseFloat(await getPromisedValue("MC GET POS", /S0:([+-]?\d+\.\d{4})/, 1, timeOut));

            if (!isNum(position)) {
                throw new Error(`Position is not a number: ${position}`);
            }
            console.info("\tüìå Current position:", position, "mm");
            return roundDecimalFast(position, precisionPosition);
        } catch (error) {
            console.error(error.message);
            throw new Error(`Position not received. ${error}`);
        }
    }

    // === Measure Position ===
    async function readLoadcell(loadcellID, timeOut = 2_000) {
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        const ldID = toInteger(loadcellID);
        try {
            if (debugging) logMessage(` üì¢\tGet Loadcell ${ldID} reading...`);

            if (!isNum(loadCellNum)) throw new Error(`Total Loadcell count is not defined: ${loadCellNum}`);
            if (!isNum(ldID) || (ldID < 0 || ldID > (loadCellNum - 1))) throw new Error(`Loadcell ID must be between 0 and ${loadCellNum - 1}: ${ldID} given.`);

            const force = toNumber(await getPromisedValue(`LC READ ${ldID}`, /.../, 1, timeOut), true);

            if (!isNum(force)) {
                throw new Error(`Load on Loadcell${ldID} is not a number: ${force}`);
            }
            return roundDecimalFast(force, precisionForce);
        } catch (error) {
            console.error(error.message);
            throw new Error(`Load on Loadcell${ldID} not received. ${error}`);
        }
    }

    async function readLoadcells(timeOut = 2_000) {
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        const forces = [];
        try {
            if (debugging) logMessage(" üì¢\tGet Loadcells readings...");

            if (!isNum(loadCellNum)) throw new Error(`Total Loadcell count is not defined: ${loadCellNum}`);
            for (let i = 0; i < loadCellNum; i++) {
                const force = await readLoadcell(i, timeOut);
                forces.push(force);
            }
            return forces;
        } catch (error) {
            console.error(error.message);
            throw new Error(`Load on Loadcells not received. ${error}`);
        }
    }

    async function isLoadcellPresent(loadcellID, timeOut = 2_000) {
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        try {
            const ldID = toInteger(loadcellID);
            if (debugging) logMessage(` üì¢\tCheck Loadcell ${ldID} presence...`);

            if (!isNum(loadCellNum)) throw new Error(`Total Loadcell count is not defined: ${loadCellNum}`);
            if (!isNum(ldID) || (ldID < 0 || ldID > (loadCellNum - 1))) throw new Error(`Loadcell ID must be between 0 and ${loadCellNum - 1}: ${ldID} given.`);

            const force = await getPromisedValue(`LC READ ${ldID}`, /.../, 1, timeOut);

            if (!(!isVal(force) || force === '0' || force === '-0')) {
                return true;
            }

            return false;
        } catch (error) {
            console.error(error.message);
            throw new Error(`Load on Loadcells not received ${error}`);
        }
    }

    async function isLoadcellsPresent(timeOut = 2_000) {
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        const isPresent = [];
        try {
            if (debugging) logMessage(" üì¢\tCheck Loadcells presence...");

            if (!isNum(loadCellNum)) throw new Error(`Total Loadcell count is not defined: ${loadCellNum}`);
            for (let i = 0; i < loadCellNum; i++) {
                const presence = await isLoadcellPresent(i, timeOut);
                isPresent.push(presence);
            }
            return isPresent;
        } catch (error) {
            console.error(error.message);
            throw new Error(`Load on Loadcells not received ${error}`);
        }
    }

    async function getCalibrationStatus(timeOut = 2_000) {
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet calibration status...");

            return await getPromisedValue("MC GET ISCALIBRATED", /^Motors calibrated:\s(Yes|No)$/, 1, timeOut) === "Yes";
            // return await getPromisedValue("MC GET ISCALIBRATED", /S0:([01])/, 1, timeOut) === "1";
        } catch (error) {
            console.error(error.message);
            throw new Error(`Calibration status not received. ${error}`);
        }
    }

    async function getSpeed(timeOut = 2_000) {
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet speed...");

            const speed = toNumber(await getPromisedValue("MC GET SPEED", /Motor speed:\s(-?\d+(\.\d+)?)\smm\/s/, 1, timeOut), true);
            // const speed = parseFloat(await getPromisedValue("MC GET SPEED", /S0:([+-]?\d+\.\d{4})/, 1, timeOut));
            if (!isNum(speed)) {
                throw new Error(`Speed is not a number: ${speed}`);
            }
            console.info("\n\tüöÖ Current speed:", speed, "mm/s");

            return roundDecimalFast(speed, precisionSpeed);
        } catch (error) {
            console.error(error.message);
            throw new Error(`Speed not received. ${error}`);
        }
    }


    async function getAcceleration(timeOut = 2_000) {
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet acceleration...");

            const acceleration = toNumber(await getPromisedValue("MC GET ACCEl", /Motor acceleration:\s(-?\d+(\.\d+)?)\smm\/s\^2/, 1, timeOut), true);
            // const acceleration = parseFloat(await getPromisedValue("MC GET ACCEl", /S0:([+-]?\d+\.\d{4})/, 1, timeOut));
            if (!isNum(acceleration)) {
                throw new Error(`Acceleration is not a number: ${acceleration}`);
            }
            console.info("\n\tüöù Current acceleration:", acceleration, "mm/s¬≤");

            return roundDecimalFast(acceleration, precisionAcceleration);
        } catch (error) {
            console.error(error.message);
            throw new Error(`Acceleration not received. ${error}`);
        }
    }

    async function isMoving(timeOut = 100) {
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet moving status...");

            return await getPromisedValue("MC GET RUNNING", /Motor running:\s[01]/, 1, timeOut) === "1";
            // return await getPromisedValue("MC GET RUNNING", /S0:([01])/, 1, timeOut) === "1";
        } catch (error) {
            console.error(error.message);
            throw new Error(`Moving status not received. ${error}`);
        }
    }

</script>

<script>

    let pendingDSLR = null; // Store DSLR event until the next data arrives
    let dataCount = null;
    let lastAcceptedTime = null;

    function timeStepCheck(previous, current, stepSize, tolerance = null) {
        if (!isNum(tolerance)) tolerance = (stepSize * 0.01); // set default tolerance to 2x 1% of step size

        // TODO: optimalizovat tolerance dle rychlosti zpracov√°n√≠ dat
        tolerance = clamp(roundDecimalFast(Math.abs(tolerance), 9), 0.0011, 0.1);

        const actualStep = current - previous;

        if (!((stepSize - tolerance) <= actualStep && actualStep <= (stepSize + tolerance))) {
            console.warn("‚ö†Ô∏è Step size mismatch:", {previous, current, actualStep, stepSize, tolerance});
            return previous + stepSize;
        }

        return current;
    }

    // TODO: - je to ≈°patnƒõ
    function timeStepCheckNEW(prev, curr, step, tol = step * 0.1) {
        if (curr >= prev) {
            const delta = curr - prev;
            const n = Math.round(delta / step);
            if (Math.abs(delta - n * step) <= Math.max(tol, step * 0.25)) {
                return prev + n * step; // posu≈à o cel√© n√°sobky kroku
            }
        }
        // fallback: vƒõ≈ô p≈ôijat√©mu ƒçasu, a≈• pozn√°≈° drift/drop
        return curr;
    }

    function interpolateDSLRDataNEW(dslrEvent, nextData, prevData) {
        if (!prevData || !nextData || !dslrEvent) {
            console.info("‚ö†Ô∏è No valid data for interpolation.");
            return null;
        }

        // TODO: zkontrolovat DSLR time relativnƒõ ke startu mƒõ≈ôen√≠
        const dslrTime = roundDecimalFast(dslrEvent.time - tareValues.time, precisionTime);
        const photoIndex = dslrEvent.photoIndex;

        if (!(prevData.time < nextData.time)) {
            console.error("‚ö†Ô∏è Not enough data for interpolation.");
            return null;
        }

        let interpolatedData;

        if (prevData.time <= dslrTime && dslrTime <= nextData.time) {
            const t1 = prevData.time, t2 = nextData.time;
            const factor = (dslrTime - t1) / (t2 - t1);

            const interpPos = roundDecimalFast(prevData.position + factor * (nextData.position - prevData.position), precisionPosition);
            const interpSpeed = roundDecimalFast(prevData.speed + factor * (nextData.speed - prevData.speed), precisionSpeed);

            const interpForce = prevData.force.map((v1, i) => {
                const v2 = nextData.force[i];
                if (isNum(v1) && isNum(v2)) return roundDecimalFast(v1 + factor * (v2 - v1), precisionForce);
                if (isNum(v1)) return v1;
                if (isNum(v2)) return v2;
                return null;
            });

            interpolatedData = {
                time: dslrTime,
                position: interpPos,
                speed: interpSpeed,
                force: interpForce,
                photoIndex
            };

        } else {
            console.warn("‚ö†Ô∏è DSLR time out of [prev,next] ‚Äî using midpoint.");
            const midT = roundDecimalFast((prevData.time + nextData.time) / 2, precisionTime);
            const midPos = roundDecimalFast((prevData.position + nextData.position) / 2, precisionPosition);
            const midSpeed = roundDecimalFast((prevData.speed + nextData.speed) / 2, precisionSpeed);
            const midForce = prevData.force.map((v1, i) => {
                const v2 = nextData.force[i];
                if (isNum(v1) && isNum(v2)) return roundDecimalFast((v1 + v2) / 2, precisionForce);
                return isNum(v1) ? v1 : (isNum(v2) ? v2 : null);
            });

            interpolatedData = {
                time: midT,
                position: midPos,
                speed: midSpeed,
                force: midForce,
                photoIndex
            };
        }

        console.info("üì∏ DSLR Interpolated Data @", interpolatedData.time);
        return interpolatedData;
    }


    // /////// Data Parsing /////////
    function interpolateDSLRData(dslrEvent, nextData, prevData) {
        if (!prevData || !nextData || !dslrEvent) {
            console.info("‚ö†Ô∏è No valid data for interpolation.");
            return;
        }

        const dslrTime = roundDecimalFast(dslrEvent.time - tareValues.time, precisionTime);

        const photoIndex = dslrEvent.photoIndex;

        // Ensure valid data for interpolation
        if (prevData.time >= nextData.time) {
            console.error("‚ö†Ô∏è Not enough data for interpolation.");
            return;
        }

        let interpolatedData;

        if ((prevData.time <= dslrTime) && (dslrTime <= nextData.time)) {
            // Linear interpolation factor
            const t1 = prevData.time, t2 = nextData.time;
            const factor = (dslrTime - t1) / (t2 - t1);

            const interpolatedPosition = roundDecimalFast(prevData.position + factor * (nextData.position - prevData.position), precisionPosition);
            const interpolatedSpeed = roundDecimalFast(prevData.speed + factor * (nextData.speed - prevData.speed), precisionSpeed);
            const interpolatedForce = prevData.force.map((f1, i) => {
                const f2 = nextData.force[i];
                if (isNum(f1) && isNum(f2)) return roundDecimalFast(f1 + factor * (f2 - f1), precisionForce);
                if (isNum(f1)) return f1;
                if (isNum(f2)) return f2;
                return null;
            });

            interpolatedData = {
                time: dslrTime,
                position: interpolatedPosition,
                speed: interpolatedSpeed,
                force: interpolatedForce,
                photoIndex: photoIndex // Store DSLR photo order
            };

        } else {
            console.error("‚ö†Ô∏è Invalid interpolation range.", {
                prevTime: prevData.time,
                dslrTime,
                nextTime: nextData.time
            });

            interpolatedData = {
                time: roundDecimalFast((prevData.time + nextData.time) / 2, precisionTime),
                position: roundDecimalFast((prevData.position + nextData.position) / 2, precisionPosition),
                speed: roundDecimalFast((prevData.speed + nextData.speed) / 2, precisionSpeed),
                force: prevData.force.map((val, i) => roundDecimalFast((val + nextData.force[i]) / 2, precisionForce)),
                photoIndex: photoIndex // Store DSLR photo order
            };
        }


        // Log interpolated data
        // logMeasurements(`${Math.round(dslrEvent.time * 10e6)},${(interpolatedPosition + tareValues.position).toFixed(4)},${interpolatedSpeed.toFixed(2)},${interpolatedForce[0].toFixed(2)},${interpolatedForce[1].toFixed(2)},${interpolatedForce[2].toFixed(2)},    ${photoIndex}`);
        addDataToLog(interpolatedData);

        updateChart(interpolatedData);

        //TODO: zv√°≈æit zda dƒõlat p≈ôid√°v√°n√≠ dat do pr≈Ømƒõr≈Ø:
        dataCount++;
        aggregatedDataBetweenSteps.push(interpolatedData);
        pendingDSLR = null;


        console.info("üì∏ DSLR Interpolated Data:", interpolatedData.time);
    }


    /**
     * Parses raw measurement data into a structured object.
     * @returns {Object} - Parsed data object containing time, position, value, and load values.
     * @param parsedDataList
     */
    function calculateAverageParsedData(parsedDataList) {
        const totalEntries = parsedDataList.length;

        if (totalEntries === 0) return {
            time: 0,
            position: 0,
            force: Array(catchVal(loadCellNum, 0, isNum)).fill(0)
        }; // Return zero values if no data

        let sumTime = 0;
        let sumPosition = 0;
        let sumForce = Array(catchVal(loadCellNum, 0, isNum)).fill(0); // Empty list of `force` values

        parsedDataList?.forEach(data => {
            sumTime += data.time;
            sumPosition += data.position;

            // Sum all values in `load` list
            data.force?.forEach((value, index) => {
                sumForce[index] += value;
            });
        });

        return {
            time: roundDecimalFast(sumTime / totalEntries, precisionTime),
            position: roundDecimalFast(sumPosition / totalEntries, precisionPosition),
            force: sumForce.map(value => roundDecimalFast(value / totalEntries, precisionForce)) // Average of `force` list values (per index)
        };
    }


    function parseData(dataString) {

        const parts = dataString.split(",");

        if (!parts || parts?.length !== measurementParts.length) {
            logMessage("üå°Ô∏è DS" + dataString);
            return {};
        } else {
            logMeasurements(dataString);
        }

        // Common parsing logic
        const timeRaw = sum1D(measurementParts.time?.map(idx => parseFloat(parts[idx]))) * timeConversionDATAC; // Convert microseconds to seconds
        const distRaw = sum1D(measurementParts.position?.map(idx => parseFloat(parts[idx]))); // Position value
        const speedRaw = sum1D(measurementParts.speed?.map(idx => parseFloat(parts[idx]))); // Speed value
        const forceRaw = measurementParts.force?.map((idx) => {
            const val = parts[idx];
            if (val === "0") return null;
            const num = parseFloat(val);
            return catchVal(num, null, isNum);
        }); // LoadCell values
        // const photoIndexRaw = isDef(measurementParts?.photoIndex) ? parseInt(parts[measurementParts?.photoIndex]) : null; // DSLR photo index

        return {
            time: catchVal(timeRaw, null, isNum),
            position: catchVal(distRaw, null, isNum),
            speed: catchVal(speedRaw, null, isNum),
            force: catchVal(forceRaw, null, isNonEmptyArr),
            // photoIndex: catchVal(photoIndexRaw, null, Number.isInteger)
        };
    }

    async function processMeasurements(dataString) {
        const newData = parseData(dataString);

        if (takeMeasurements) { // Handle takeMeasurements
            newData?.force?.forEach((value, index) => isNum(value) ? measureForces[index].push(value) : null);  // Collect force data for calibration
            return;
        }

        if (!takeMeasurements && !isExperimentRunning) {
            await updateChart(newData);
            return;
        }

        // Detect DSLR shoot event
        const DSLRPrefix = "LR shoot:";
        if (takePhotos && dataString.startsWith(DSLRPrefix)) {
            const [dslrTime, photoIndex] = dataString.split(":")[1].split(",");
            pendingDSLR = {time: parseFloat(dslrTime) * timeConversionDSLR, photoIndex: parseInt(photoIndex) - 1};
            logMeasurements("Photo" + dataString.substring(2));
            return;
        }

        // Handle regular data (not DSLR)
        if (!isNum(tareValues.time)) {
            tareValues.time = newData?.time;
            newData.time = 0.000_000;
        } else {
            // TODO => check if this is correct (step must be same), must be bigger than 0, process as UINT, process as FLOAT in export/saving and charts, BIGINT???
            const corrected = timeStepCheck(catchVal(lastAcceptedTime, parsedData.time, isNum), (newData?.time - tareValues.time), (dataInterval_us * timeConversionDATAC));
            newData.time = roundDecimalFast(corrected, precisionTime);

        }
        lastAcceptedTime = newData?.time;

        newData.position = roundDecimalFast((newData.position - tareValues.position) * displacementSignCorrection, precisionPosition);
        newData.speed = roundDecimalFast(newData.speed * displacementSignCorrection, precisionSpeed);
        // TODO: do only Present loadcellls
        newData.force = newData?.force?.map((value, index) => roundDecimalFast((value * loadSignCorrections[index]) - (tareValues.force[index] || 0), precisionForce));

        // If a pending DSLR timestamp exists, interpolate values
        if (takePhotos && pendingDSLR) {
            const clone = structuredClone(parsedData); // TODO: zkontrolovat zda to m√° smysl a funguje
            interpolateDSLRData(pendingDSLR, newData, clone);
        }

        if (!isNum(newData?.time) || !isNum(newData?.position)) {
            measurement_limits.invalid_data.counter++;

            if (measurement_limits.invalid_data.counter > measurement_limits.invalid_data.limit) {
                console.warn("‚ö†Ô∏è Invalid data received:", {time: newData?.time, position: newData?.position});
                endMeasuring(0, {
                    ednStatus: 'data error',
                    endText: "‚èπÔ∏è Movement stopped due to data error.",
                    command: "MC STOP"
                });
                document.documentElement.style.setProperty('--progressColor', 'var(--progressError-color)');
                UI.experimentStageLabel.textContent = `Error`;
            }
            return;
        } else {
            measurement_limits.invalid_data.counter = 0;
        }

        parsedData = newData;

        if (experimentDoubleSpeed === true && newData?.force?.some(value => isNum(value) && value >= initialForceLim_N)) {
            setSpeed(speedForward_mmps, false);
            experimentDoubleSpeed = false;
            document.documentElement.style.setProperty('--progressColor', 'var(--progressSecondary-color)');
            UI.experimentStageLabel.textContent = `Loading`;
        }

        // const sumForce = newData?.force?.reduce((acc, val) => acc + (isNum(val) ? val : 0), 0);
        // const sumForce = sumND(newData?.force); // TODO: check and optimize the speed of sum calculation

        if ((newData?.force?.some(value => isNum(value) && value >= stoppingForceLimit)) || (measurement_limits.over_limitForce.limit < 0)) {
            measurement_limits.over_limitForce.counter++;

            if (measurement_limits.over_limitForce.counter > measurement_limits.over_limitForce.limit) {
                if (experimentHoldConstantForce) {
                    checkSpeed = false; // disable speed check
                    measurement_limits.over_limitForce.limit = Number.NEGATIVE_INFINITY;

                    if (!isNum(timer)) {
                        timer = newData?.time;
                        document.documentElement.style.setProperty('--progressColor', 'var(--progressOnHold-color)');
                        UI.experimentStageLabel.textContent = `Holding`;
                    }

                    const forceHoldTimeMs = (newData?.time - timer) * 1_000;

                    if (forceHoldTimeMs >= holdForceTimeMs) {
                        endMeasuring(0, {
                            ednStatus: `hold force time limit [${forceHoldTimeMs / 1_000}s]`,
                            endText: `‚èπÔ∏è Experiment stopped due to hold force time limit (${stoppingForceLimit} N for ${forceHoldTimeMs / 1_000} s).`,
                            command: "MC STOP"
                        });

                    } else {
                        const sumF = sumND(newData?.force);
                        const v = pi.step(newData?.time, newData?.position, sumF);
                        // adjust speed according to PI controller to maintain constant force ...
                        if (isValidInputNum(v)) {
                            await setSpeed(v, false);
                            sendCommandGeneral(displacementSignCorrection === 1 ? "MC END" : "MC HOME");
                        }
                        // ... or stop if invalid, negative or zero
                        else await sendCommandGeneral("MC STOP");
                    }

                } else {
                    endMeasuring(0, {
                        ednStatus: 'force limit',
                        endText: `‚èπÔ∏è Movement stopped due to force limit (${stoppingForceLimit} N).`,
                        command: "MC STOP"
                    });
                    document.documentElement.style.setProperty('--progressColor', 'var(--progressStoppedcolor)');
                    UI.experimentStageLabel.textContent = `Stopped`;
                }
            }

        } else {
            measurement_limits.over_limitForce.counter = 0;
            timer = null;
        }


        // Handle speed checks and experiment stopping
        if (checkSpeed && (newData?.speed < (1 / 1e2) && newData?.time > 1)) { // speedVal < 0.01 m/s <= speed value is limited to 2 decimal places // (timeVal - tareValues.time) > 1 second => handled in 'timeStepCheck'
            measurement_limits.zero_speed.counter++;

            if (measurement_limits.zero_speed.counter > measurement_limits.zero_speed.limit) {
                endMeasuring(Math.max(delayMsAfterEndMeasurement / 2, 10), {
                    ednStatus: 'zero speed',
                    endText: "üõë Experiment stopped due to zero speed.",
                    command: takePhotos ? "DSLR STOP CYCLIC" : '',
                });
                document.documentElement.style.setProperty('--progressColor', 'var(--progressStoppedcolor)');
                UI.experimentStageLabel.textContent = `Stopped`;
            }
        } else {
            measurement_limits.zero_speed.counter = 0;
        }


        // Handle LoadCell limit checks
        for (let i = 0; i < catchVal(loadCellNum, 0, isNum); i++) {
            const currForce = newData?.force[i];
            if (isNum(currForce)) {
                if (!isNum(maxForces[i]) || currForce > maxForces[i]) maxForces[i] = currForce;
                if (isNum(maxForces[i])) {
                    if ((maxForces[i] - currForce) > (Math.abs(maxForces[i]) * forceLimitDropPercent) && (maxForces[i] - currForce) > forceLimitDropValue) {
                        endMeasuring(50, {
                            ednStatus: `loadCell[${i + 1}] drop`,
                            endText: `üõë Experiment stopped due to LoadCell ${i + 1} drop:\n\tPercentage: ${(maxForces[i] - currForce)} > ${(Math.abs(maxForces[i]) * forceLimitDropPercent)} and Absolute: ${maxForces[i] - currForce} > ${forceLimitDropValue}.`,
                            command: "MC STOP",
                        });
                        if (takePhotos) setTimeout(() => sendCommandGeneral("DSLR STOP CYCLIC"), 30); // small delay to allow data processing
                        break; // Stop checking other LoadCells if one fails
                    }
                }
            }
        }

        addDataToLog(newData);

        // Update Progress Bar
        let progressValue;
        progressValue = progressCalculate(newData[expControl], experimentEndLimits[expControl]);

        if (isNum(progressValue) && progressValue >= 100) {
            if (experimentProgress < 100) {
                const delayMs = endMeasurement ? 0 : delayMsAfterEndMeasurement;
                endMeasuring(delayMs, {
                    overRide: true,
                    ednStatus: 'end position',
                    endText: "üèÅ Experiment finished.",
                });
                if (takePhotos) setTimeout(() => sendCommandGeneral("DSLR STOP CYCLIC"), 30); // small delay to allow data processing
            }
        }
        experimentProgress = progressValue;

        // Live chart update
        dataCount++;
        aggregatedDataBetweenSteps.push(newData);
        if (liveUpdate) {
            if (dataChartInterval === 1) {
                await updateChart(newData);
            } else if (dataCount % dataChartInterval === 0) {
                await updateChart(calculateAverageParsedData(aggregatedDataBetweenSteps));
            }
        }
        if (dataCount % dataChartInterval === 0) {
            aggregatedDataBetweenSteps = [];
        }
    }


    /////////////////////////////////////////////////////////////////

</script>


<script>
    function renderLoadcells(n) {
        const container = $ID('machSettings');
        container.innerHTML = '';

        const frag = $FRAG();

        // --- √∫vodn√≠ (neƒç√≠slovan√°) dvojice ---
        const baseCap = $MAKE('div');
        baseCap.className = 'input-group';
        baseCap.dataset.systemLevel = '0-2';
        baseCap.innerHTML = `
      <label for="inputLoadcellCapacity">
        Loadcell Capacity<span class="units-text"></span>:
      </label>
      <input
        data-input-type="intInput"
        type="number"
        id="inputLoadcellCapacity"
        value="0"
        step="any"
        min="0"
        max="100000000"
        data-unit="kg"
        data-essence="scale, conversion">
    `;

        const baseOut = $MAKE('div');
        baseOut.className = 'input-group';
        baseOut.dataset.systemLevel = '1-2';
        baseOut.innerHTML = `
      <label for="inputLoadcellOutput">
        Loadcell Rated Output<span class="units-text"></span>:
      </label>
      <input
        data-input-type="floatInput2"
        type="number"
        id="inputLoadcellOutput"
        value="2.0"
        step="any"
        min="0"
        max="100000000"
        data-unit="mV/V"
        data-essence="voltage, ratio, scale, conversion">
    `;

        frag.appendChild(baseCap);
        frag.appendChild(baseOut);

        // --- oƒç√≠slovan√© dvojice 1..N ---
        for (let i = 1; i <= n; i++) {
            const cap = $MAKE('div');
            cap.className = 'input-group';
            cap.dataset.systemLevel = '2';
            cap.innerHTML = `
        <label for="inputLoadcellCapacity${i}">
          <b>Loadcell</b> <b style="color: var(--text-info-3-color);">${i}</b>
          Capacity <span class="units-text"></span>:
        </label>
        <input
          data-input-type="intInput"
          type="number"
          id="inputLoadcellCapacity${i}"
          value="0"
          step="any"
          min="0"
          max="100000000"
          data-unit="kg"
          data-essence="scale, conversion">
      `;

            const out = $MAKE('div');
            out.className = 'input-group';
            out.dataset.systemLevel = '2';
            out.innerHTML = `
        <label for="inputLoadcellOutput${i}">
          <b>Loadcell</b> <b style="color: var(--text-info-3-color);">${i}</b>
          Rated Output <span class="units-text"></span>:
        </label>
        <input
          data-input-type="floatInput"
          type="number"
          id="inputLoadcellOutput${i}"
          value="2.0"
          step="any"
          min="0"
          max="100000000"
          data-unit="mV/V"
          data-essence="voltage, ratio, scale, conversion">
      `;

            frag.appendChild(cap);
            frag.appendChild(out);
        }

        container.appendChild(frag);
    }
</script>

<script>

    (function ensureBlinkStyles() {
        if ($ID('blink-border-style')) return;
        const style = $MAKE('style');
        style.id = 'blink-border-style';
        style.textContent = `
    .blink-border-on {
      border-color: orange !important;
      background-color: Moccasin !important;
      /* border-width: 3px !important; */
      /* volitelnƒõ: transition: none !important;  // aby neprobƒõhly CSS p≈ôechody */
    }
  `;
        document.head.appendChild(style);
    })();

    // Glob√°ln√≠ (nebo modulov√°) mapa bƒõ≈æ√≠c√≠ch blik√°n√≠ pro konkr√©tn√≠ elementy
    const _blinkLocks = new WeakMap();

    /**
     * Kr√°tk√© "bliknut√≠" r√°meƒçku libovoln√©ho elementu.
     * - target: Element nebo CSS selektor
     * - options:
     *   - color           (default: 'orange')
     *   - backgroundOn    (default: 'Moccasin')
     *   - blinks          (default: 4)   // kolikr√°t blikne
     *   - interval        (default: 200) // ms mezi stavy
     *   - borderWidthOn   (default: null) // nap≈ô. '3px'
     *   - restart         (default: false) // kdy≈æ u≈æ bƒõ≈æ√≠, restartuje
     * @returns {boolean} true = spu≈°tƒõno; false = ignorov√°no (u≈æ bƒõ≈æelo a restart=false / chyb√≠ element)
     */
    async function blinkBorder(target, options = {}) {
        if (!allLoaded) return;
        const el = typeof target === 'string' ? $(target) : target;
        if (!el) return false;

        const {
            color = 'orange',
            backgroundOn = 'Moccasin',
            blinks = 4,
            interval = 200,
            borderWidthOn = null,
            restart = false,
        } = options;

        // prevent-spam: pokud u≈æ bƒõ≈æ√≠
        const running = _blinkLocks.get(el);
        if (running) {
            if (!restart) return false;
            clearInterval(running.id);
            running.restore?.();
            _blinkLocks.delete(el);
        }

        // Snapshot p≈Øvodn√≠ho vizu√°ln√≠ho stavu
        const cs = getComputedStyle(el);
        const original = {
            borderColor: cs.borderColor,
            borderWidth: cs.borderWidth,
            backgroundColor: cs.backgroundColor,
            transition: el.style.transition,
        };

        let ticks = 0;
        let on = false;

        const restore = () => {
            // vypnout p≈ôechody, tvrdƒõ vr√°tit, a zase zapnout
            el.style.transition = 'none';
            void el.offsetWidth; // reflow
            el.style.borderColor = original.borderColor;
            el.style.borderWidth = original.borderWidth;
            el.style.backgroundColor = original.backgroundColor;
            void el.offsetWidth; // reflow
            el.style.transition = original.transition;
            _blinkLocks.delete(el);
        };

        const id = setInterval(() => {
            // kdy≈æ element zmiz√≠ z DOMu, ukliƒè
            if (!document.contains(el)) {
                clearInterval(id);
                restore();
                return;
            }

            on = !on;
            if (on) {
                el.style.borderColor = color;
                if (borderWidthOn) el.style.borderWidth = borderWidthOn;
                el.style.backgroundColor = backgroundOn;
            } else {
                el.style.borderColor = original.borderColor;
                el.style.borderWidth = original.borderWidth;
                el.style.backgroundColor = original.backgroundColor;
            }

            ticks++;
            if (ticks >= blinks * 2) {
                clearInterval(id);
                restore(); // ‚Üê po dobƒõhnut√≠ v≈ædy stejn√© barvy jako na zaƒç√°tku
            }
        }, interval + 50);

        _blinkLocks.set(el, {id, restore});
        return true;
    }

    // Volitelnƒõ: ruƒçn√≠ ukonƒçen√≠/obnova
    blinkBorder.stop = function (target) {
        const el = typeof target === 'string' ? $(target) : target;
        if (!el) return false;
        const running = _blinkLocks.get(el);
        if (!running) return false;
        clearInterval(running.id);
        running.restore?.();
        _blinkLocks.delete(el);
        return true;
    };


</script>

<script>
    function collectExpSettings(selector, schema = null) {
        if (isEmptyStr(selector)) return [];
        const nodes = Array.from($$(selector));
        const inputs = {};

        for (const el of nodes) {
            const key = el.dataset.key || el.name || el.id; // preferuj data-key
            if (!key) continue;

            let val;
            if (el.type === "checkbox") val = !!el.checked;
            else if (el.type === "number") val = el.value === "" ? null : +el.value;
            else if (el.tagName === "SELECT") val = el.value;
            else val = el.value;

            const essence = (el?.tagName === "SELECT") ? ((el.selectedOptions[0]?.dataset.essence) ? el.selectedOptions[0]?.dataset.essence : el?.dataset.essence) : el?.dataset.essence;


            inputs[key] = {
                value: isInvalidValue(val) ? "N/A" : (isStr(val) ? val.replace('‚àû', "Inf").replace('¬±', '') : val), // null pro pr√°zdn√©/invalidn√≠ hodnoty
                type: el.type || el.tagName.toLowerCase(),         // nap≈ô. "number", "checkbox", "text", "select"
                label: el.dataset.label || el.placeholder || key,  // volitelnƒõ pro hezƒç√≠ zobrazen√≠
                classes: el.className || null,                     // volitelnƒõ pro dal≈°√≠ filtrov√°n√≠

                extra: {
                    unit: el.dataset.unit || null,  // jednotka
                    essence: essence || null, // nap≈ô. "force", "disp", "stress", "modulus", "area", "iy", "hardness"
                    description: el.dataset.description || null, // voliteln√Ω popis
                }
            };
        }

        return {
            selector: selector,
            schema: schema,
            version: 1,
            timestamp: new Date().toISOString(),
            inputs,
        };
    }

    async function restoreExpSettingsToUI(settings, {
        customSelector = undefined,
        customKey = undefined,
        fireEvents = false,
    } = {}) {

        const keys = [];
        if (customKey) {
            keys.push(String(customKey));
        } else {
            if (settings?.generalSettings) keys.push('generalSettings');
            if (settings?.machineSettings) keys.push('machineSettings');
            if (settings?.deviceSettings) keys.push('deviceSettings');
            if (settings?.chartSettings) keys.push('chartSettings');
            if (settings?.expSettings) keys.push('expSettings');
            if (settings?.calcSettings) keys.push('calcSettings');
        }

        const results = [];
        for (const key of keys) {
            if (!settings[key]) continue;
            const r = await restoreSettingsToUI(settings[key], {customSelector, fireEvents});
            results.push({key, ...r});
        }

        const ok = results.some(r => r.ok);
        const summary = results.reduce((acc, r) => {
            acc.tried += 1;
            acc.ok |= r.ok;
            acc.totalNodes += r.foundNodes || 0;
            acc.applied += r.appliedCount || 0;
            acc.missingKeys += (r.missingKeys?.length || 0);
            return acc;
        }, {tried: 0, ok: false, totalNodes: 0, applied: 0, missingKeys: 0});

        return {ok, results, summary};
    }

    const setElValue = (el, val, fireEvents = true, fire = null) => {
        const tag = el.tagName.toLowerCase();
        const type = (el.type || "").toLowerCase();

        if (isVoid(fire)) fire = (el) => {
            if (!fireEvents) return;
            el.dispatchEvent(new Event("input", {bubbles: true}));
            el.dispatchEvent(new Event("change", {bubbles: true}));
            el.dispatchEvent(new Event("blur", {bubbles: true}));
        };

        if (type === "checkbox") {
            el.checked = !!val;
            fire(el);
            return true;
        }
        if (type === "radio" && el.name) {
            $$(`input[type="radio"][name="${CSS.escape(el.name)}"]`)
                ?.forEach(r => {
                    r.checked = (String(r.value) === String(val));
                    fire(r);
                });
            return true;
        }
        if (tag === "select") {
            if (el.multiple && isArr(val)) {
                const set = new Set(val.map(String));
                Array.from(el.options)?.forEach(opt => {
                    opt.selected = set.has(String(opt.value));
                });
            } else {
                el.value = val || "";
            }
            fire(el);
            return true;
        }
        if (type === "number" || type === "range") {
            let v = val;
            if (typeof v === "string" && v.includes(",")) v = v.replace(",", ".");
            if (!isNonEmptyStr(v)) el.value = "";
            else if (Number.isFinite(+v)) ("valueAsNumber" in el) ? el.valueAsNumber = +v : el.value = String(+v);
            else el.value = "";
            fire(el);
            return true;
        }
        el.value = (val || "");
        fire(el);
        return true;
    };

    async function restoreSettingsToUI(settings, {
        customSelector = undefined,
        fireEvents = false,
    } = {}) {

        const report = {
            ok: false,
            selector: null,
            foundNodes: 0,
            appliedCount: 0,
            missingKeys: [],
            unusedEls: [],
            details: [] // {key, found, applied, reason}
        };

        let selector = customSelector;
        if (!settings?.inputs) {
            report.details.push({key: null, found: 0, applied: false, reason: 'no-inputs'});
            return report;
        }
        if (!customSelector || isEmptyStr(customSelector)) selector = settings.selector;
        report.selector = selector;
        if (!selector || isEmptyStr(selector)) {
            report.details.push({key: null, found: 0, applied: false, reason: 'no-selector'});
            return report;
        }

        const nodes = Array.from($$(selector));
        report.foundNodes = nodes.length;
        if (!nodes.length) {
            report.details.push({key: null, found: 0, applied: false, reason: 'no-nodes'});
            return report;
        }

        // index dle data-key | name | id
        const index = new Map();
        for (const el of nodes) {
            const key = el.dataset.key || el.name || el.id;
            if (!key) {
                report.unusedEls.push(el);
                continue;
            }
            (index.get(key) || index.set(key, []).get(key)).push(el);
        }

        const fire = (el) => {
            if (!fireEvents) return;
            el.dispatchEvent(new Event("input", {bubbles: true}));
            el.dispatchEvent(new Event("change", {bubbles: true}));
            el.dispatchEvent(new Event("blur", {bubbles: true}));
        };


        // aplikuj hodnoty
        for (const [key, meta] of Object.entries(settings.inputs)) {
            const els = index.get(key);
            if (!els?.length) {
                report.missingKeys.push(key);
                report.details.push({key, found: 0, applied: false, reason: 'no-match'});
                continue;
            }

            try {
                if (els[0].type === "radio") {
                    setElValue(els[0], meta.value, fireEvents, fire);
                } else if (els[0].tagName.toLowerCase() === "select" && els[0].multiple) {
                    setElValue(els[0], isArr(meta.value) ? meta.value : [meta.value], fireEvents, fire);
                } else {
                    setElValue(els[0], meta.value, fireEvents, fire);
                }
                report.appliedCount += 1;
                report.details.push({key, found: els.length, applied: true});
            } catch (e) {
                report.details.push({key, found: els.length, applied: false, reason: String(e?.message || e)});
            }
        }

        report.ok = report.appliedCount > 0;
        return report;
    }

    async function applyCsvToUI(csvText, opts) {
        const settings = await parseSettingsFromCsv(csvText);
        if (!settings) return {ok: false, reason: 'parse-failed', settings: null, results: []};
        const res = await restoreExpSettingsToUI(settings, opts); // { ok, results, summary }
        return {ok: !!res.ok, settings, ...res};
    }

    async function processFile(file) {
        const text = await file.text();
        const res = await applyCsvToUI(text, {fireEvents: true});

        const nameEl = $ID("loadedFileName");

        if (res.ok) {
            nameEl.textContent = `‚úÖ Loaded: ${file.name} ‚Äî applied ${res.summary.applied} fields`;
            console.groupCollapsed(`‚úîÔ∏è Settings applied (${file.name})`);
            console.table(res.results.map(r => ({
                key: r.key,
                selector: r.selector,
                nodes: r.foundNodes,
                applied: r.appliedCount,
                missingKeys: r.missingKeys.length
            })));
            res.results?.forEach(r => {
                if (r.missingKeys.length) {
                    console.groupCollapsed(`‚ö†Ô∏è Missing keys in ${r.key}`);
                    console.info(r.missingKeys);
                    console.groupEnd();
                }
            });
            console.groupEnd();
        } else {
            nameEl.textContent = `‚ö†Ô∏è In file ${file.name} are no settings meta data`;
            console.warn('\nDetails:', res);
            alert("‚ö†Ô∏è In file are missing or are invalid meta data: (##MOIRA_EMETA=...).");
        }
    }

    // ===== Ovl√°dac√≠ logika tlaƒç√≠tka =====
    const btnLoadCSV = $ID("btnLoadSettings");
    const inputLoadCSV = $ID("appFileInput");

    btnLoadCSV.addEventListener("click", async () => {
        if (isExperimentRunning) return;
        if ("showOpenFilePicker" in window) {
            try {
                const [handle] = await window.showOpenFilePicker({
                    types: [{description: "CSV", accept: {"text/csv": [".csv"]}}],
                    excludeAcceptAllOption: false,
                    multiple: false
                });
                const file = await handle.getFile();
                await processFile(file);
                return;
            } catch (e) {
                if (e?.name === "AbortError") return; // u≈æivatel zru≈°il
                console.warn("showOpenFilePicker failed, falling back to <input type=file>:", e);
            }
        }
        // fallback
        inputLoadCSV.click();
    });

    inputLoadCSV.addEventListener("change", async (e) => {
        if (isExperimentRunning) return;
        const file = e.target.files?.[0];
        if (!file) return;
        await processFile(file);
        inputLoadCSV.value = ""; // reset pro dal≈°√≠ v√Ωbƒõr stejn√©ho souboru
    });


    // --- gzip / gunzip (preferuj nativn√≠ streamy; fallback pako) ---
    async function gzipBytes(u8) {
        if (typeof CompressionStream !== "undefined") {
            const stream = new Blob([u8]).stream().pipeThrough(new CompressionStream("gzip"));
            const buf = await new Response(stream).arrayBuffer();
            return new Uint8Array(buf);
        } else if (self.pako?.gzip) {
            // level 6 je rychl√° a rozumnƒõ kompaktn√≠ volba
            return self.pako.gzip(u8, {level: 6});
        }
        throw new Error("No gzip available (CompressionStream/pako).");
    }

    function looksLikeGzip(u8) {
        return u8 && u8.length >= 2 && u8[0] === 0x1f && u8[1] === 0x8b;
    }

    async function gunzipBytes(u8) {
        if (!looksLikeGzip(u8)) throw new Error("Data do not look like gzip format.");
        if (typeof DecompressionStream !== "undefined") {
            const stream = new Blob([u8]).stream()
                .pipeThrough(new DecompressionStream("gzip"));
            const buf = await new Response(stream).arrayBuffer();
            return new Uint8Array(buf);
        } else if (self.pako?.ungzip) {
            return self.pako.ungzip(u8); // pako fallback
        }
        throw new Error("No gunzip available (DecompressionStream/pako).");
    }

    // --- tvorba preambule (vybere krat≈°√≠ z gzip/plain) ---
    async function settingsToCsvPreamble(settings) {
        const json = JSON.stringify(settings);
        const plainB64 = u8ToB64(txtE.encode(json));

        let gzipB64 = null;
        try {
            const gz = await gzipBytes(txtE.encode(json));
            gzipB64 = u8ToB64(gz);
        } catch (err) {
            // nem√°me gzip => z≈Østaneme u plain
        }

        if (gzipB64 && gzipB64.length < plainB64.length) {
            return `##MOIRA_METAZ=${gzipB64}`;
        } else {
            return `##MOIRA_METAP=${plainB64}`;
        }
    }

    // --- ƒçten√≠ preambule z 1. ≈ô√°dku ---
    async function readSettingsFromPreamble(line) {
        // odstra≈à BOM na zaƒç√°tku, kdyby se vyskytl
        line = line.replace(/^\uFEFF/, "");

        if (line.startsWith("##MOIRA_METAZ=")) {
            const b64 = line.slice("##MOIRA_METAZ=".length).trim();
            const u8 = b64ToU8(b64);
            const unz = await gunzipBytes(u8);
            return JSON.parse(txtD.decode(unz));
        }
        if (line.startsWith("##MOIRA_METAP=")) {
            const b64 = line.slice("##MOIRA_METAP=".length).trim();
            const json = txtD.decode(b64ToU8(b64));
            return JSON.parse(json);
        }
        throw new Error("Unknown MOIRA_META prefix.");
    }

    // --- parsing z cel√©ho CSV textu (vr√°t√≠ objekt nebo null) ---
    async function parseSettingsFromCsv(csvData) {
        if (!isNotEmpty(csvData)) return null;

        let firstLine;
        if (isStr(csvData)) {
            // vezmi jen prvn√≠ ≈ô√°dku; split(limit=1) vrac√≠ pole => [0]
            firstLine = (csvData.split(/\r?\n/, 1)[0] || "");
        } else if (isArr(csvData)) {
            firstLine = (csvData[0] || "");
        } else {
            return null;
        }

        firstLine = firstLine.replace(/^\uFEFF/, "").trim();

        // rozpoznej prefix a zbytek jako Base64
        const m = firstLine.match(/^##MOIRA_META([ZP])=([A-Za-z0-9+/=]+)\s*$/);
        if (!m) return null;

        try {
            return await readSettingsFromPreamble(firstLine);
        } catch (e) {
            console.error("‚ùå Invalid settings JSON in MOIRA_META:", e);
            return null;
        }
    }

</script>


<script>
    // /////// Saving Log to File /////////

    /**
     * Saves the stored log entries from IndexedDB to a downloadable CSV file.
     */
    // Event listener for the save button
    $$(".saveDataBtns")?.forEach(btn => btn?.addEventListener("click", saveCSV));


    let handFolderSelect = false;

    function toggleDirectorySelector() {
        handFolderSelect = !handFolderSelect;
    }

    async function saveCSV() {
        if (isExperimentRunning) return;
        console.info("\nüíæ Saving data to CSV file...");

        let dirHandle = null;
        // Delimiter for CSV file "\t" = tab, "," = comma, ";" = semicolon
        const delimiterSymbolVal = await $ID("delimiterSymbol").value || "Option-Semicolon";
        let delimiter = await (delimiterSymbolVal === "Option-Comma" ? "," : delimiterSymbolVal === "Option-Semicolon" ? ";" : delimiterSymbolVal === "Option-Tab" ? "\t" : delimiterSymbolVal === "Option-Space" ? " " : ";") || ";";
        // Decimal symbol for CSV file "." = dot, "," = comma
        const decimalSymbol = await ($ID("decimalSymbol").value === "Option-Comma" ? "," : ".") || ".";

        // 6 of random symbols that are unlikely to be in the data
        const delimiterPlaceHolder = "¬ß" + Math.random().toString(36).substring(2, 4) + Math.random().toString(36).substring(2, 4) + Math.random().toString(36).substring(2, 4) + "¬ß";

        if (decimalSymbol === "," && delimiter === ",") delimiter = ";"; // If comma is selected as decimal symbol, use semicolon as delimiter to avoid conflicts


        const expNum = parseInt($ID("experimentCount").value.trim()) || 0;
        const experimentName = $ID("experimentName").value.trim();
        const experimentDesc = $ID("experimentDesc").value.replaceAll(/(\r\n|\n|\r)/gm, " ").trim();

        handFolderSelect = $ID("storagePath").checked || false;

        if (!experimentName) {
            alert("Unable to save the data.\n    Please enter the experiment type.");
            return;
        }

        let experimentCount
        if (expNum) {
            experimentCount = `_${expNum.toString().padStart(3, "0")}`;
        } else {
            experimentCount = "";
        }
        const fileName = `${experimentName}${experimentCount}.csv`;

        let fileHandle;
        if (handFolderSelect) {
            try {
                dirHandle = await window.showDirectoryPicker(); // User selects a folder
            } catch (error) {
                console.error("‚ùå Folder selection canceled or error occurred:", error);
                return;
            }
            fileHandle = await dirHandle.getFileHandle(fileName, {create: true});

        } else {
            fileHandle = {name: `${fileName}`}; // Simulated save outside File System Access API
        }

        let transaction = db.transaction(STORE_NAME, "readonly");
        let store = transaction.objectStore(STORE_NAME);
        let request = store.getAll();

        // Helper rounding functions
        const getRoundVal = (x, dec, decSym) => getCustomStrValue(x, dec, decSym, false, true, "");

        const rTime = (num) => getRoundVal(num, precisionTime, decimalSymbol);
        const rDist = (num) => getRoundVal(num, precisionPosition, decimalSymbol);
        const rForce = (num) => getRoundVal(num, precisionForce, decimalSymbol);
        const rSpeed = (num) => getRoundVal(num, precisionSpeed, decimalSymbol);
        const rPhoto = (num) => getRoundVal(num, 0, decimalSymbol);

        request.onsuccess = async function () {
            let dataEntries = request.result;

            if (!dataEntries || dataEntries.length === 0) {
                console.warn("\n‚ö†Ô∏è No data to save.");
                alert("‚ö†Ô∏è No data to save. Ensure experiment has been run.");
                return;
            }
            const experimentInfo = dataEntries[0];

            dataEntries.shift(); // Skip the first entry (initial values)

            const settings = experimentInfo || {};
            settings.id = undefined; // Remove id from metadata

            // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            settings.headerVersion = 1;
            settings.columns = 6;
            settings.skipRows = 6;
            // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

            settings.calcSettings = collectExpSettings(".calcInput", "Moira-calc-settings") || {};
            settings.decimalSymbol = decimalSymbol;
            settings.delimiter = delimiter;

            let content = '';

            const dateFormat = getLocaleOrder();

            const basicInfo = [
                `Date [${dateFormat.date} ${dateFormat.time}]:`, experimentInfo.experimentDate,
                'Experiment type:', experimentInfo.experimentLabel,
                'Experiment end:', experimentInfo.endStatus,
                'Loading speed (mm/s):', experimentInfo.loadSpeed,
                'Load distance (mm):', experimentInfo.loadDistance,
                'Loadcell capacity (kg):', experimentInfo.loadcellCapacity.join('/'),
                'Software version:', `v${experimentInfo.appSoftWare}`,
                'Firmware version:', `v${experimentInfo.machineFirmware}`,
            ];

            const head = [
                'Time [s]', 'Displacement [mm]', 'Speed [mm/s]', ...experimentInfo.loadcellCapacity.map((cap, idx) => `Force ${idx + 1} [N]`), 'Photo Index'
            ];


            content += (await settingsToCsvPreamble(settings)).replace(/ /g, "").replace(/^\uFEFF/, "");
            content += '\n';
            content += `\n${basicInfo.join(delimiterPlaceHolder)}`;
            content += `\nDescription:${delimiterPlaceHolder}${experimentDesc}`;
            content += '\n';
            content += `\n${head.join(delimiterPlaceHolder)}`;


            if (delimiter === ",") experimentDesc.replaceAll(",", ".");
            // Remove delimiter from description to avoid confusion in space-delimited files (CSV)
            if (delimiter === " ") {
                content = content.replaceAll(/ /g, "_");
            } else {
                content = content.replaceAll(delimiter, "|");

            }

            content = content.replaceAll(delimiterPlaceHolder, delimiter); // Replace placeholder with actual delimiter

            dataEntries?.forEach(entry => {
                const dataRow = [rTime(entry.time), rDist(entry.position), rSpeed(entry.speed), ...entry.force.map(rForce), rPhoto(entry.photoIndex)];
                if (dataRow.some(d => d !== "")) content += `\n${dataRow.join(delimiter)}`; // Only add rows with at least one non-empty value
            });

            if (handFolderSelect) {
                // Save the file to the selected folder using File System Access API
                const writable = await fileHandle.createWritable();
                await writable.write(`\uFEFF${content}`); // Add BOM for correct UTF-8 encoding
                await writable.close();
            } else {
                // Simulated file download (browsers don't allow direct writes)
                const blob = new Blob([`\uFEFF${content}`], {type: "text/csv;charset=utf-8"});
                const link = $MAKE("a");
                link.href = URL.createObjectURL(blob);
                link.download = fileHandle.name.split("/").pop();
                link.click();
            }

            if (expNum) {
                $ID("experimentCount").value = expNum + 1;
                $ID("experimentCount")?.dispatchEvent(new Event("change", {bubbles: true}));
            }

            console.info(`‚úÖ Data saved to file: ${fileName}`);

            // Clear IndexedDB after saving
            let deleteTransaction = db.transaction(STORE_NAME, "readwrite");
            let deleteStore = deleteTransaction.objectStore(STORE_NAME);
            deleteStore.clear().onsuccess = () => console.info("üóëÔ∏è Data from IndexedDB cleared after saving.");
        };
    }

</script>

<script>


    async function getCSVData(csvData, fileOptions = {}, fileName = '') {
        if (!isNonEmptyStr(csvData)) return null; //  || isNonEmptyArr(csvData)
        if (!isNonEmptyObj(fileOptions)) return null;

        function setupParsers(head, fileSet, outputs) {
            // --- sanity checks ---
            if (!isStr(head)) {
                console.warn("\n‚ö†Ô∏è Cannot setup parsers, head is not an array.");
                return {};
            }
            if (!fileSet || !fileSet.delimiter) {
                console.warn("\n‚ö†Ô∏è Cannot setup parsers, missing delimiter or fileSet.");
                return {};
            }
            if (!fileSet.dataTypes) fileSet.dataTypes = {};

            // --- helpers ---
            const getUnitFromHeader = (header) => {
                if (isEmptyStr(header)) return null;
                // nech√°v√°m tv≈Øj vzor; p≈ô√≠padnƒõ roz≈°√≠≈ôit o ƒç√≠slice, lom√≠tka apod.
                const match = String(header).match(/[(\[]\s*([a-zA-Z%ŒºŒºmNnkgkPaasS]+)\s*[)\]]/);
                return match ? match[1] : null;
            };

            // --- 1) hlaviƒçka ---
            const headerParts = head.split(fileSet.delimiter).map(s => String(s).trim());
            const headerUnits = headerParts.map(part => getUnitFromHeader(part) || '');

            // mapa synonym z outputs[*].key (ƒç√°rkami oddƒõlen√©)
            const types = Object.keys(outputs || {});
            const keysByType = Object.fromEntries(
                types.map(t => [
                    t,
                    String(outputs[t]?.key || t)
                        .toLowerCase()
                        .split(',')
                        .map(s => s.trim())
                        .filter(Boolean),
                ])
            );

            // pro ka≈æd√Ω sloupec rozhodni typ dle substring≈Ø
            const headerTypes = headerParts.map(part => {
                const p = String(part).toLowerCase();
                for (const t of types) {
                    if (keysByType[t].some(k => k && p.includes(k))) return t;
                }
                return null;
            });

            // --- 2) dopl≈à/nen√°silnƒõ nastav fileSet.dataTypes[*] ---
            function ensureType(t) {
                const prev = fileSet.dataTypes[t] || {};
                const outCfgUnit = outputs[t]?.unit || '';

                // 2.1 Indexy
                let indexes = isArr(prev.indexes) && prev.indexes.length > 0
                    ? prev.indexes.slice() // respektuj p≈ôedem zadan√© indexy
                    : headerTypes
                        .map((tt, i) => (tt === t ? i : -1))
                        .filter(i => i >= 0);

                // 2.2 C√≠lov√° jednotka (preferuj u≈æ d≈ô√≠v nastavenou)
                const targetUnit = isNonEmptyStr(prev.unit) ? prev.unit : outCfgUnit;

                // 2.3 Udr≈æ jednotn√Ω "fromUnit" pro 1 spoleƒçn√Ω conversion
                let fromUnit = '';
                if (!isNonEmptyArr(prev.indexes) && isNonEmptyArr(indexes)) {
                    if (targetUnit) {
                        // najdi prvn√≠ jednotku mezi kandid√°ty
                        for (const i of indexes) {
                            if (headerUnits[i]) {
                                fromUnit = headerUnits[i];
                                break;
                            }
                        }
                        if (fromUnit) {
                            // filtruj jen na sloupce se shodn√Ωm fromUnit
                            indexes = indexes.filter(i => (headerUnits[i] || '') === fromUnit);
                        }
                    } else {
                        // bez targetUnit ‚Äì dr≈æ jednotnost dle prvn√≠ nalezen√© (nebo pr√°zdn√©)
                        fromUnit = headerUnits[indexes[0]] || '';
                        indexes = indexes.filter(i => (headerUnits[i] || '') === fromUnit);
                    }
                } else if (isNonEmptyArr(prev.indexes)) {
                    // indexy d√°ny u≈æivatelem ‚Üí odvoƒè fromUnit (pokud jde)
                    const i0 = prev.indexes[0];
                    if (Number.isInteger(i0) && i0 >= 0 && i0 < headerUnits.length) {
                        fromUnit = headerUnits[i0] || '';
                    }
                }

                // 2.4 Konverze (preferuj p≈ôedvyplnƒõnou)
                let conversion = isDef(prev.conversion) ? toNumber(prev.conversion) : undefined;
                if (isVoid(conversion) || !isNum(conversion)) {
                    if (targetUnit && fromUnit) {
                        try {
                            conversion = convertUnits(1, fromUnit, targetUnit) || 1;
                        } catch (_) {
                            conversion = 1;
                        }
                    } else {
                        conversion = 1;
                    }
                }

                // 2.5 Z√°pis (zachovej p≈ô√≠padn√© dal≈°√≠ kl√≠ƒçe v prev)
                fileSet.dataTypes[t] = {
                    ...prev,
                    indexes: isNonEmptyArr(prev.indexes) ? prev.indexes : indexes,
                    unit: isNonEmptyStr(prev.unit) ? prev.unit : targetUnit,
                    conversion,
                };
            }

            for (const t of types) ensureType(t);

            // --- 3) gettery (p≈ôesnost z outputs[*].precision) ---
            const getters = {};
            for (const t of types) {
                const precision = outputs[t]?.precision ?? 12;

                getters[t] = (entry) => {
                    const spec = fileSet.dataTypes[t];
                    if (!spec || !isNonEmptyArr(spec.indexes)) return 0;

                    const convRaw = toNumber(spec.conversion, true);
                    const conv = Number.isFinite(convRaw) ? convRaw : 1;

                    // vezmi prvn√≠ nenulovou / ƒç√≠selnou hodnotu
                    for (let i = 0; i < spec.indexes.length; i++) {
                        const idx = spec.indexes[i];
                        const vRaw = toNumber(entry[idx], true);
                        const v = Number.isFinite(vRaw) ? vRaw : 0;
                        if (v !== 0) {
                            return roundDecimalFast(v * conv, precision);
                        }
                    }
                    return 0;
                };

                // metadata/utility metody (ne-s√©riovateln√© a bezpeƒçn√©)
                Object.defineProperties(getters[t], {
                    indexes: {
                        value: () => (fileSet.dataTypes?.[t]?.indexes ? [...fileSet.dataTypes[t].indexes] : []),
                        enumerable: false
                    },
                    count: {
                        value: () => (fileSet.dataTypes?.[t]?.indexes?.length ?? 0),
                        enumerable: false
                    },
                    unit: {
                        value: () => (fileSet.dataTypes?.[t]?.unit ?? ''),
                        enumerable: false
                    },
                    conv: {
                        value: () => {
                            const c = toNumber(fileSet.dataTypes?.[t]?.conversion, false);
                            return Number.isFinite(c) ? c : (fileSet.dataTypes?.[t]?.conversion ?? 1);
                        },
                        enumerable: false
                    }
                });
            }


            return getters;
        }

        const getDelimiter = (rows, minParts = 3) => {
            const testLine = rows[Math.ceil(2 * rows.length / 3)]; // data line of CSV file
            let delimiter = null; // Delimiter of data in a a CSV file

            for (const separator of delimiters) {
                const parts = testLine.split(separator);
                if (parts.length >= minParts) {
                    delimiter = separator;
                    break; // Found the delimiter
                }
            }

            return delimiter;
        };

        // ===== Main parsing logic =====

        fileName = String(fileName).trim() || 'Unknown File';

        const delimiters = [";", ",", "\t", " "];
        const preferFoundDelimiter = false;

        let fileType = null;
        let fileVersion = null;
        let preambleMetaData = null;
        const fileOpts = {
            delimiter: null,
            skipRows: 0,
            columns: null,
            dataTypes: {},
            dataLength: null,
        }; // Options for parsing the file


        const csvText = csvData.replace(/\r\n?/g, "\n");

        const rows = csvText.split("\n").map(r => r.trim()); // Split text into lines

        const dataRows = rows.map(r => r.toLowerCase()); // Split text into lines

        if (dataRows.length === 0) {
            console.warn(`CSV file '${fileName}' is empty.`);
            return null;
        }


        if (dataRows[0].startsWith("##moira")) {
            // MOIRA file
            fileType = "moira";
            console.info(`üìÅ Processing MOIRA file: ${fileName}`);

            preambleMetaData = await parseSettingsFromCsv(rows[0]) || {};

            if (!isNonEmptyObj(preambleMetaData)) {
                console.warn(`‚ùå Invalid or missing MOIRA meta data in file: ${fileName}`);
                return null;
            }

            fileVersion = preambleMetaData?.version || 0;

            fileOpts.delimiter = preambleMetaData?.delimiter || ";";
            if (preambleMetaData?.headerVersion === 1) fileOpts.skipRows = preambleMetaData?.skipRows; // (Experiment settings) // (Empty) // (Info) // (Description) // (Empty) // (Header)
            fileOpts.columns = preambleMetaData?.columns;


            const precisions = preambleMetaData?.precisions || {};
            Object.keys(fileOptions)?.forEach(key => {
                const n = toRounds(precisions[key]);
                if (isDef(n) && isNum(n)) fileOptions[key].precision = clamp(Math.abs(n), 0, 12);
            });
        } else if (dataRows[0].startsWith("date:")) {

            // MOIRA LEGACY file
            fileType = "moira_legacy";
            console.info(`üìÅ Processing MOIRA legacy file: ${fileName}`);

            fileOpts.delimiter = ";";
            fileOpts.skipRows = 3; // (Info) // (Description) // (Header)
            fileOpts.columns = 6;
        } else if (dataRows[0].startsWith("timestamp_us")) {

            // MATLAB file
            fileType = "matlab";
            console.info(`üìÅ Processing MATLAB file: ${fileName}`);

            fileOpts.delimiter = ";";
            fileOpts.skipRows = 1;  // (Header)
            fileOpts.columns = 5;
            fileOpts['dataTypes']['time']['conversion'] = 1e-6; // Convert time from microseconds to seconds
        } else {
            // Unknown file type
            fileType = "unknown";
            console.info(`üìÅ Processing unknown format file: ${fileName}`);

            // find first row that starts with text 'time'
            // const headerRowIndex = rows.findIndex(row => row.trim().startsWith("time"));
            // fileOpts.skipRows = headerRowIndex !== -1 ? headerRowIndex : 0;
            // fileOpts.columns = 4;

            // let maxTries = 50;
            // let validRowFound = false;
            //
            // while (maxTries-- > 0 && rows.length > 0) {
            //     const firstRow = rows[0];
            //     const values = firstRow.slice(0, 6).map(val => parseFloat(val));
            //
            //     if (!firstRow || values.length < 6) {
            //         rows.shift();
            //         continue;
            //     }
            //
            //     const allValid = values.every(val => isNum(val));
            //
            //     if (allValid) {
            //         validRowFound = true;
            //         break; // Found a valid row
            //     } else {
            //         rows.shift(); // Remove the first row
            //     }
            // }
            //
            // if (!validRowFound) {
            //     logMessage(`‚ùå No valid data found in file: ${file.name}`);
            //     console.warn("\n‚ùå No valid data found in file:", file.name);
            //     return null;
            // }

            console.info(`‚ùå Skipping unknown file: ${fileName}`);
            return null;
        }


        if (dataRows.length <= fileOpts.skipRows) {  // Skip if the file has no data
            logMessage(`‚ùå Not enough data in file: ${fileName}`);
            console.warn(`\n‚ùå Not enough data in file: ${fileName}`);
            console.info(`‚ùå Skipping empty or invalid file: ${fileName}`);
            return null;
        }

        const foundDelimiter = getDelimiter(rows, fileOpts.columns);

        if (foundDelimiter !== fileOpts.delimiter) {
            logMessage(`‚ùå Unexpected delimiter in file: ${fileName}. Expected '${fileOpts.delimiter}', but found '${foundDelimiter || "none"}'.`);
            console.warn(`\n‚ùå Unexpected delimiter in file: ${fileName}. Expected '${fileOpts.delimiter}', but found '${foundDelimiter || "none"}'.`);

            if (!preferFoundDelimiter) {
                console.info(`‚ùå Skipping file due to delimiter mismatch: ${fileName}`);
                return null;
            }
            fileOpts.delimiter = foundDelimiter;
        }

        if (!fileOpts.delimiter) {
            logMessage(`‚ùå Delimiter not found in file: ${fileName}`);
            console.warn(`\n‚ùå Delimiter not found in file: ${fileName}`);
            console.info(`‚ùå Skipping file due to missing delimiter: ${fileName}`);
            return null;
        }


        const header = dataRows[fileOpts.skipRows - 1] || ''; // Header row based on skipRows

        const getters = setupParsers(header, fileOpts, fileOptions);

        if (Object.keys(fileOptions).some(k => !getters[k] || getters[k].count() === 0)) {
            logMessage(`‚ùå Cannot parse required data columns in file: ${fileName}. Check the delimiter and file format.`);
            console.warn(`\n‚ùå Cannot parse required data columns in file: ${fileName}. Check the delimiter and file format.`);
            return null;
        }

        let err = false;
        for (const key of Object.keys(fileOptions)) {
            if (isDef(fileOptions[key].columnLimit) && (getters[key].count() > fileOptions[key].columnLimit)) {
                logMessage(`‚úñÔ∏è Invalid number of columns for '${key}' in file: ${fileName}. Expected ${fileOptions[key].columnLimit}, but found ${getters[key].count()}.`);
                console.warn(`\n‚úñÔ∏è Invalid number of columns for '${key}' in file: ${fileName}. Expected ${fileOptions[key].columnLimit}, but found ${getters[key].count()}.`);
                err = true;
            }
        }
        if (err) {
            logMessage(`‚ùå Skipping file due to invalid column counts: ${fileName}`);
            console.info(`‚ùå Skipping file due to invalid column counts: ${fileName}`);
            return null;
        }


        const dataFiltered = dataRows.slice(fileOpts.skipRows).filter(r => r.length > 0); // Remove header rows and remove empty ones

        fileOpts.dataLength = dataFiltered.length;

        const data = dataFiltered.map(row => row.split(fileOpts.delimiter)); // Parse CSV lines into an array

        const OutputData = {preamble: preambleMetaData || {}, fileType, fileVersion, fileOptions: fileOpts, data: {}};


        for (const key of Object.keys(fileOptions)) {
            OutputData.data[key] = data.map(cells => getters[key](cells));
            if (!OutputData.data[key].some(val => isNum(val))) OutputData.data[key] = null; // If no numeric data found, set to empty array
        }


        return OutputData;
    }


</script>

<script>

    function waitForXLSX() {
        return new Promise((resolve, reject) => {
            const ok = () => window.XLSX ? resolve() : setTimeout(ok, 50);
            ok();
            setTimeout(() => reject(new Error("XLSX failed to load")), 5_000);
        });
    }


    function setMattesColumnWidths(ws) {
        if (!ws['!ref']) return;
        const rng = XLSX.utils.decode_range(ws['!ref']);
        const cols = [];
        for (let c = rng.s.c; c <= rng.e.c; c++) {
            // ka≈æd√° sekce m√° 5 sloupc≈Ø: 0..3 data, 4 mezera
            const inSection = c % 5;
            cols[c] = {wch: (inSection === 4 ? 6 : 12)};
        }
        ws['!cols'] = cols;
    }

    function setSamplesColumnWidths(ws) {
        if (!ws['!ref']) return;
        const rng = XLSX.utils.decode_range(ws['!ref']);
        const cols = [];
        for (let c = rng.s.c; c <= rng.e.c; c++) {
            cols[c] = {wch: c === 0 ? 15 : (c === 2 ? 5 : 8)};
        }
        ws['!cols'] = cols;
    }

    // --- helpers pro Rich Text (subscript) ---
    // parts: [{text:"F"}, {text:"max", sub:true}, {text:"(N)"}]
    function setRich(ws, r, c, parts) {
        const addr = XLSX.utils.encode_cell({r, c});
        const text = parts.map(p => String(p.text ?? "")).join("");

        if (!ws[addr]) ws[addr] = {t: "s"};

        // nastav plain text + rich runs
        ws[addr].t = "s";
        ws[addr].v = text;          // <<< D≈ÆLE≈ΩIT√â (fallback + nƒõkter√© buildy to vy≈æaduj√≠)
        ws[addr].r = parts.map(p => {
            const run = {t: String(p.text ?? "")};
            if (p.sub) run.s = {vertAlign: "subscript"};  // spodn√≠ index
            return run;
        });

        // volitelnƒõ zarovn√°n√≠ a zalomen√≠
        ws[addr].s = ws[addr].s || {};
        ws[addr].s.alignment = {horizontal: "center", vertical: "center", wrapText: true};
    }

    function setRichBaseSub(ws, r, c, base, sub, suffix = "") {
        const parts = [{text: base}, {text: sub, sub: true}];
        if (suffix) parts.push({text: suffix});
        setRich(ws, r, c, parts);
    }


    function ensureRefFromAoa(ws, aoa) {
        if (!ws['!ref']) {
            const rows = aoa.length;
            const cols = (aoa[0] || []).length;
            if (rows && cols) {
                ws['!ref'] = XLSX.utils.encode_range({
                    s: {r: 0, c: 0},
                    e: {r: rows - 1, c: cols - 1}
                });
            }
        }
    }


    async function convertCSVtoXLSX_MATTES() {
        if (isExperimentRunning) return;
        try {
            await waitForXLSX();
        } catch (e) {
            alert("‚ùå Failed to load XLSX library. Please check the logs and your internet connection and try again.");
            return;
        }

        const input = $MAKE('input');

        const mattesMaxLines = 20_000; // Maximum number of lines in one file

        input.type = 'file';
        input.accept = '.csv';
        input.multiple = true; // Allow multiple file selection
        input.onchange = async function (event) {
            let files = Array.from(event.target.files); // Convert FileList to Array
            if (!files.length) {
                console.warn("\n‚ùå No files selected.");
                alert("‚ùå No files were selected. Please select one or more CSV files and try again.");
                return;
            } else {
                files.sort((a, b) => {
                    let nameA = a.name.toLowerCase();
                    let nameB = b.name.toLowerCase();

                    // Regular expression to extract the base name and optional index
                    let regex = /(.*?)(?:\s\((\d+)\))?\.csv$/;

                    let matchA = nameA.match(regex);
                    let matchB = nameB.match(regex);

                    if (!matchA || !matchB) return 0; // Skip if no match

                    let baseA = matchA[1]; // Base name
                    let indexA = matchA[2] ? parseInt(matchA[2]) : -1; // Index (if present) or -1

                    let baseB = matchB[1];
                    let indexB = matchB[2] ? parseInt(matchB[2]) : -1;

                    // Sort by base name first
                    if (baseA !== baseB) return baseA.localeCompare(baseB);

                    // Sort by index if base names are the same
                    if (indexA === -1) return -1;
                    if (indexB === -1) return 1;

                    // Sort by index
                    return indexA - indexB;
                });

                console.info("üìÇ Sorted files:", files.map(f => f.name)); // Log sorted file names
            }

            const measurementName = files[0].name.replace(/\.csv$/, "").replace(/\s*\(\d+\)\s*$/, "").replace(/^(.*)_(\d+)$/, "$1").trim(); // Measurement name
            let wb = XLSX.utils.book_new(); // Create a new Excel workbook
            let sheetName = ("P-" + measurementName).slice(0, (31 - 8)); // Sheet name

            // ==================== FILES LIST ==================== //

            // TODO: lep≈°√≠ n√°zev promƒõnn√©
            const resultsHead = ["File Order", "File name", "Experiment type", "Material",
                "b (mm)", "h (mm)", "L (mm)", "E (MPa)", "f_m (MPa)",
                "F_max (N)", "w_Fmax (mm)", "œÉ_max (MPa)",
                "F_T (N)", "h_D (mm)", "H_BW (-)"];

            const resultsData = [resultsHead]; // Third sheet data

            // ================== LOADING DATA ================== //

            const formattedData = []; // First sheet data  -   Array to store ALL formatted measurement data
            let columnOffset = 0; // Column shift for each section


            // ================== SAMPLES TABLE ================== //


            const samplesTable = [
                ["Code", "Method", "W", "Number", "Dimensions, weight, before drying", "", "", "", "Dimensions, weight, after drying", "", "", "", "lo \n(mm)"], // row 0
                ["", "", "", "", "hw", "lw", "ww", "mw", "h0", "l0", "w0", "m0", ""], // row 1
                ["", "", "", "", "height \n(mm)", "length \n(mm)", "width \n(mm)", "(g)", "height \n(mm)", "length \n(mm)", "width \n(mm)", "(g)", ""] // row 2
            ];// Second sheet data

            const outputsOpts = {
                time: {key: 'time', unit: 's', precision: 12, columnLimit: 1},
                position: {key: 'dist, disp, position', unit: 'mm', precision: 12, columnLimit: 1},
                force: {key: 'force, load', unit: 'N', precision: 12, columnLimit: null},
            };


            const getMetaValue = (metaData, key, unit = null) => {
                if (!isObj(metaData)) return "";

                if (metaData.hasOwnProperty(key)) {
                    let value = metaData[key]?.value || "";
                    if (!hasValue(value)) return "";

                    const valUnit = metaData[key].unit || null;
                    if (isNonEmptyStr(unit) && isNonEmptyStr(valUnit)) value = convertUnits(value, valUnit, unit);

                    return catchVal(value, "", not(isInvalidValue));
                }
                return "";
            };

            // ≈°√≠≈ôky sloupc≈Ø podle d√©lky hlaviƒçek
            const PAD = 2;      // rezerva, a≈• to nen√≠ nalepen√©
            const MIN = 6;      // minim√°ln√≠ ≈°√≠≈ôka

            function fitToCols(rows, {pad = 2, min = 6} = {}) {
                const cols = rows[0]?.length ?? 0;
                const out = Array.from({length: cols}, () => ({wch: min}));
                for (let c = 0; c < cols; c++) {
                    let maxLen = 0;
                    for (let r = 0; r < rows.length; r++) {
                        const v = rows[r][c];
                        const s = isVoid(v) ? "" : String(v);
                        if (s.length > maxLen) maxLen = s.length;
                    }
                    out[c].wch = Math.max(min, maxLen + pad);
                }
                return out;
            }

            function setNumFmt(colIndex, fmt, data, ws) {
                for (let r = 1; r < data.length; r++) {
                    const addr = XLSX.utils.encode_cell({r, c: colIndex});
                    const cell = ws[addr];
                    if (cell && typeof cell.v === 'number') cell.z = fmt; // nap≈ô. "0.00"
                }
            }


            // ----------------- LOOPING THROW CSV FILES ----------------- //
            let fileCount = 0;
            for (let file of files) {
                fileCount++;
                const raw = await file.text();

                const csvData = await getCSVData(raw, outputsOpts, file.name) || {};

                const {
                    preamble: preambleMetaData = {},
                    fileType,
                    fileOptions: fileOptionsUsed = {},
                    data: parsedData = {}
                } = csvData;


                if (!csvData) {
                    logMessage(`‚ùå Failed to parse file: ${file.name}`);
                    console.warn("\n‚ùå Failed to parse file:", file.name);
                    fileCount--;
                    continue;
                }

                const samplesInfo = {
                    method: 3,  // Method (place 3)
                    W: 0,       // W (place 0)
                    hw: "",
                    lw: "",
                    ww: "",
                    mw: "",
                    h0: "",
                    l0: "",
                    w0: "",
                    m0: "",
                    lo: "",     // lo (empty)
                }; // Sample information

                const expResults = {
                    experimentType: "", // Experiment type
                    material: "",       // Material
                    b: "",              // b (mm)
                    h: "",              // h (mm)
                    L: "",              // L (mm)
                    E: "",              // E (MPa)
                    f_m: "",            // f_m (MPa)
                    F_max: "",          // F_max (N)
                    w_Fmax: "",         // w_Fmax (mm)
                    sigma_max: "",      // œÉ_max (MPa)
                    F_T: "",            // F_T (N)
                    h_D: "",            // h_D (mm)
                    H_BW: ""            // H_BW (-)
                }; // Experiment results


                switch (fileType) {
                    case "moira":
                        const calcSettingsInputs = await preambleMetaData.calcSettings.inputs || {};

                        const expInfoV = await preambleMetaData.expSettings?.version || 0;
                        if (expInfoV >= 1) {
                            expResults.experimentType = await preambleMetaData?.experimentLabel || "";
                            expResults.material = getMetaValue(calcSettingsInputs, "inputMaterialName");
                            expResults.b = getMetaValue(calcSettingsInputs, "inputWidth", "mm");
                            expResults.h = getMetaValue(calcSettingsInputs, "inputHeight", "mm");
                            expResults.L = getMetaValue(calcSettingsInputs, "inputLength", "mm");
                            expResults.E = getMetaValue(calcSettingsInputs, "outputModulus", "MPa");
                            expResults.f_m = getMetaValue(calcSettingsInputs, "outputFlexStrength", "MPa");
                            expResults.F_max = getMetaValue(calcSettingsInputs, "outputForceMax", "N");
                            expResults.w_Fmax = getMetaValue(calcSettingsInputs, "outputDisp", "mm");
                            expResults.sigma_max = getMetaValue(calcSettingsInputs, "outputMaxStress", "MPa");
                            expResults.F_T = getMetaValue(calcSettingsInputs, "inputTargetForce", "N");
                            expResults.h_D = getMetaValue(calcSettingsInputs, "inputIndDepth", "mm");
                            expResults.H_BW = getMetaValue(calcSettingsInputs, "outputHardness");
                        }

                        const calcInfoV = await preambleMetaData.calcSettings?.version || 0;
                        if (calcInfoV >= 1) {
                            samplesInfo.hw = getMetaValue(calcSettingsInputs, "inputHeight_BeforeDrying", "mm");
                            samplesInfo.lw = getMetaValue(calcSettingsInputs, "inputLength_BeforeDrying", "mm");
                            samplesInfo.ww = getMetaValue(calcSettingsInputs, "inputWidth_BeforeDrying", "mm");
                            samplesInfo.mx = getMetaValue(calcSettingsInputs, "inputWeight_BeforeDrying", "g");
                            samplesInfo.h0 = getMetaValue(calcSettingsInputs, "inputHeight_AfterDrying", "mm");
                            samplesInfo.l0 = getMetaValue(calcSettingsInputs, "inputLength_AfterDrying", "mm");
                            samplesInfo.w0 = getMetaValue(calcSettingsInputs, "inputWidth_AfterDrying", "mm");
                            samplesInfo.m0 = getMetaValue(calcSettingsInputs, "inputWeight_AfterDrying", "g");
                        }

                        break;

                    case "moira-legacy":
                        break;

                    case "matlab":
                        break;

                    case "unknown":
                    default:
                        fileCount--;
                        continue;
                }

                const dataLength = fileOptionsUsed.dataLength; // Number of rows in one file


                if (dataLength === 0) {
                    logMessage(`‚ùå No data found in file: ${file.name}`);
                    console.warn("\n‚ùå No data found in file:", file.name);
                    fileCount--;
                    continue;
                }


                if (dataLength > mattesMaxLines) {
                    let step;
                    if (dataLength - (mattesMaxLines * 0.01) > mattesMaxLines) {
                        Object.entries(parsedData).forEach(([key, arr]) => {
                            parsedData[key] = arr.slice(0, mattesMaxLines);
                        });
                    } else {
                        // Data (rows) reduction
                        step = Math.ceil(dataLength / mattesMaxLines);
                        Object.entries(parsedData).forEach(([key, arr]) => {
                            parsedData[key] = arr.filter((_, index) => index % step === 0);
                        });
                    }
                    const newDataSize = parsedData[Object.keys(parsedData)[0]]?.length || 0;

                    logMessage(`‚ùó Too many lines in file: ${file.name} (${dataLength} > ${mattesMaxLines})\n\tData (rows) reduction: ${dataLength} -> ${newDataSize} lines\n${step ? '\tData step:' + String(step) : ''}`);
                    console.info(`‚ùó Too many lines in file: ${file.name} (${dataLength} > ${mattesMaxLines})\n\tData (rows) reduction: ${dataLength} -> ${newDataSize} lines\n${step ? '\tData step:' + String(step) : ''}`);
                }

                const dataSize = parsedData[Object.keys(parsedData)[0]]?.length || 0;


                console.info(file.name, ": üìä Rows in file:", dataLength, "üì¶ Rows to process:", dataSize);


                // ==================== FILES LIST ==================== //

                resultsData.push([
                    fileCount,
                    file.name.replace(/\.csv$/i, ""),
                    expResults.experimentType,
                    expResults.material,
                    expResults.b,
                    expResults.h,
                    expResults.L,
                    expResults.E,
                    expResults.f_m,
                    expResults.F_max,
                    expResults.w_Fmax,
                    expResults.sigma_max,
                    expResults.F_T,
                    expResults.h_D,
                    expResults.H_BW,
                ]);


                // ================== SAMPLES TABLE ================== //

                samplesTable.push([
                    file.name.replace(/\.csv$/i, ""),   // Code
                    samplesInfo.method,                 // Method (place 3)
                    samplesInfo.W,                      // W (place 0)
                    fileCount,                          // Number (file count)
                    samplesInfo.hw, samplesInfo.lw,     // hw, lw,
                    samplesInfo.ww, samplesInfo.mx,     // ww, mw
                    samplesInfo.h0, samplesInfo.l0,     // h0, l0,
                    samplesInfo.w0, samplesInfo.m0,     // w0, m0
                    samplesInfo.lo                      // lo (empty)
                ]);


                const getTime = (i) => isNonEmptyArr(i) ? i.map(idx => parsedData.time[idx]) : (isNum(i) ? parsedData.time[i] : null);
                const getPosition = (i) => isNonEmptyArr(i) ? i.map(idx => parsedData.position[idx]) : (isNum(i) ? parsedData.position[i] : null);
                const getForce = (i) => isNonEmptyArr(i) ? i.map(idx => parsedData.force[idx]) : (isNum(i) ? parsedData.force[i] : null);

                // ================== LOADING DATA ================== //
                // let firstShiftAbove1 = null; // Track first shift where force > 1 N (for deformation calculation)
                const firstTime = getTime(0); // First time value
                const firstShift = getPosition(0); // First shift value
                const firstForce = getForce(0); // First force value

                // Define headers for this section
                let sectionHeader1 = [], sectionHeader2 = [], sectionHeader3 = [], sectionHeader4 = [];
                sectionHeader1[columnOffset] = fileCount; // Section number
                sectionHeader2[columnOffset] = "Measured values from testing machine";
                sectionHeader3[columnOffset] = "Time";
                sectionHeader3[columnOffset + 1] = "Total distance covered by loading pin";
                sectionHeader3[columnOffset + 2] = "Force";
                sectionHeader3[columnOffset + 3] = "Deformation from F > 1N";
                sectionHeader4[columnOffset] = outputsOpts.time.unit;
                sectionHeader4[columnOffset + 1] = outputsOpts.position.unit;
                sectionHeader4[columnOffset + 2] = outputsOpts.force.unit;
                sectionHeader4[columnOffset + 3] = outputsOpts.position.unit;

                // Ensure headers are fully added for every section
                if (formattedData.length === 0) {
                    formattedData.push(sectionHeader1, sectionHeader2, sectionHeader3, sectionHeader4);
                } else {
                    formattedData[0][columnOffset] = sectionHeader1[columnOffset];
                    formattedData[1][columnOffset] = sectionHeader2[columnOffset];
                    formattedData[2][columnOffset] = sectionHeader3[columnOffset];
                    formattedData[3][columnOffset] = sectionHeader4[columnOffset];

                    // Ensure other section headers also extend fully in the new columns
                    for (let i = 0; i < 4; i++) {
                        for (let j = 1; j <= 3; j++) {
                            formattedData[i][columnOffset + j] = [sectionHeader1, sectionHeader2, sectionHeader3, sectionHeader4][i][columnOffset + j];
                        }
                    }
                }

                // Add data to the section
                for (let rowIndex = 0; rowIndex < dataSize; rowIndex++) {
                    const dataRow = formattedData[rowIndex + 3] || [];

                    const time = (getTime(rowIndex) - firstTime) || 0; // Time (s)

                    const force = (getForce(rowIndex) - firstForce) || 0; // Force sum

                    // if (isVoid(firstShiftAbove1) && force >= 1) firstShiftAbove1 = shift; // Save first shift above 1 N

                    const shift = (getPosition(rowIndex) - firstShift) || 0; // Displacement (mm)

                    // deformation = isVoid(firstShiftAbove1) ? 0 : (shift - firstShiftAbove1); // Calculate deformation
                    const deformation = shift; // Calculate deformation

                    dataRow[columnOffset] = time;
                    dataRow[columnOffset + 1] = shift;
                    dataRow[columnOffset + 2] = force;
                    dataRow[columnOffset + 3] = deformation;

                    formattedData[rowIndex + 3] = dataRow;
                }

                columnOffset += 5; // Shift by 4 columns + 1 empty column
            }


            if (fileCount === 0 || !isNotEmpty(formattedData)) {
                console.error("\n‚ùå No valid files were processed.");
                alert("‚ùå No valid files were processed. Please check the file formats and try again.");
                return;
            }

            // Create the first sheet with data
            const wsMattes = await XLSX.utils.aoa_to_sheet(formattedData); // Convert data to Excel sheet
            wsMattes["!merges"] = (wsMattes['!merges'] || []);
            // Create the second with file order index
            const wsSamples = await XLSX.utils.aoa_to_sheet(samplesTable, {raw: true});  // Convert data to Excel sheet
            ensureRefFromAoa(wsSamples, samplesTable);
            wsSamples["!merges"] = (wsSamples['!merges'] || []); // Merge cells
            // Create the third sheet with file order index
            const wsResults = await XLSX.utils.aoa_to_sheet(resultsData);  // Convert data to Excel sheet
            ensureRefFromAoa(wsResults, resultsData);


            // wsSamples rich-text
            setRichBaseSub(wsSamples, 1, 4, "h", "w");
            setRichBaseSub(wsSamples, 1, 5, "l", "w");
            setRichBaseSub(wsSamples, 1, 6, "w", "w");
            setRichBaseSub(wsSamples, 1, 7, "m", "w");
            setRichBaseSub(wsSamples, 1, 8, "h", "0");
            setRichBaseSub(wsSamples, 1, 9, "l", "0");
            setRichBaseSub(wsSamples, 1, 10, "w", "0");
            setRichBaseSub(wsSamples, 1, 11, "m", "0");
            setRichBaseSub(wsSamples, 0, 12, "l", "o", "\n(mm)");


            // wsResults rich-text (HEAD)
            setRich(wsResults, 0, 8, [{text: "f"}, {text: "m", sub: true}, {text: " (MPa)"}]);
            setRich(wsResults, 0, 9, [{text: "F"}, {text: "max", sub: true}, {text: " (N)"}]);
            setRich(wsResults, 0, 10, [{text: "w"}, {text: "Fmax", sub: true}, {text: " (mm)"}]);
            setRich(wsResults, 0, 11, [{text: "œÉ"}, {text: "max", sub: true}, {text: " (MPa)"}]);
            setRich(wsResults, 0, 12, [{text: "F"}, {text: "T", sub: true}, {text: " (N)"}]);
            setRich(wsResults, 0, 13, [{text: "h"}, {text: "D", sub: true}, {text: " (mm)"}]);
            setRich(wsResults, 0, 14, [{text: "H"}, {text: "BW", sub: true}, {text: " (-)"}]);


            // console.info('WS Results J1 =', wsResults[XLSX.utils.encode_cell({r: 0, c: 9})]);


            columnOffset = 0; // Column shift for each section
            for (let f = 0; f < fileCount; f++) {
                wsMattes["!merges"].push({
                    s: {r: 0, c: columnOffset}, e: {r: 0, c: columnOffset + 3} // merge 'fileCount' over 4 columns in line 0
                });
                wsMattes["!merges"].push({
                    s: {r: 1, c: columnOffset}, e: {r: 1, c: columnOffset + 3} // merge "Measured values from testing machine" over 4 columns in line 1
                });
                columnOffset += 5; // Shift by 4 columns + 1 empty column
            }


            wsSamples['!merges'].push(
                {s: {r: 0, c: 0}, e: {r: 2, c: 0}}, // Code
                {s: {r: 0, c: 1}, e: {r: 2, c: 1}}, // Method
                {s: {r: 0, c: 2}, e: {r: 2, c: 2}}, // W
                {s: {r: 0, c: 3}, e: {r: 2, c: 3}}, // Number
                {s: {r: 0, c: 4}, e: {r: 0, c: 7}}, // Dimensions before drying
                {s: {r: 0, c: 8}, e: {r: 0, c: 11}}, // Dimensions after drying
                {s: {r: 0, c: 12}, e: {r: 2, c: 12}} // lo (mm)
            );


            const range = XLSX.utils.decode_range(wsSamples['!ref']); // Get table size

            for (let R = range.s.r; R <= range.e.r; ++R) {
                for (let C = range.s.c; C <= range.e.c; ++C) {
                    const cellAddress = XLSX.utils.encode_cell({r: R, c: C});
                    const cell = wsSamples[cellAddress];
                    if (!cell) continue; // Empty cells

                    cell.s = cell.s || {};

                    // Set cell style
                    cell.s = {
                        font: {
                            bold: R <= 2 // First three line in Bold text (0,1,2)
                        },
                        border: {
                            top: {style: "thin", color: {auto: 1}},
                            bottom: {style: "thin", color: {auto: 1}},
                            left: {style: "thin", color: {auto: 1}},
                            right: {style: "thin", color: {auto: 1}}
                        }
                    };


                    cell.s.alignment = {
                        horizontal: "center",
                        vertical: "center"
                    };

                    // Bold text for the first three lines if the cell is not empty
                    if (R <= 2) {
                        cell.s.font = {bold: true};
                    }
                }
            }

            wsResults['!ref'] = XLSX.utils.encode_range(
                {s: {r: 0, c: 0}, e: {r: resultsData.length - 1, c: resultsHead.length - 1}}
            );

            // autofilter p≈ôes hlaviƒçku
            // wsResults['!autofilter'] = {ref: XLSX.utils.encode_range(0, 0, resultsData.length - 1, HEAD.length - 1)};


            setMattesColumnWidths(wsMattes);

            columnOffset = 0; // Column shift for each section
            for (let f = 0; f < fileCount; f++) {
                setNumFmt(columnOffset, "0.000000", formattedData, wsMattes);       // time (s)
                setNumFmt(columnOffset + 1, "0.0000", formattedData, wsMattes);       // position (mm)
                setNumFmt(columnOffset + 2, "0.00", formattedData, wsMattes);         // force (N)
                setNumFmt(columnOffset + 3, "0.0000", formattedData, wsMattes);       // deformation (mm)

                columnOffset += 5; // Shift by 4 columns + 1 empty column
            }


            setSamplesColumnWidths(wsSamples);

            setNumFmt(4, "0.00", samplesTable, wsSamples);       // hw (mm)
            setNumFmt(5, "0.0", samplesTable, wsSamples);        // lw (mm)
            setNumFmt(6, "0.00", samplesTable, wsSamples);       // ww (mm)
            setNumFmt(7, "0.000", samplesTable, wsSamples);      // mw (g)
            setNumFmt(8, "0.00", samplesTable, wsSamples);       // h0 (mm)
            setNumFmt(9, "0.0", samplesTable, wsSamples);        // l0 (mm)
            setNumFmt(10, "0.00", samplesTable, wsSamples);      // w0 (mm)
            setNumFmt(11, "0.000", samplesTable, wsSamples);     // m0 (g)


            wsResults['!cols'] = fitToCols(resultsData, {pad: PAD, min: MIN}); // wsResults['!cols'] = HEAD.map(h => ({wch: Math.max(MIN, h.length + PAD)}));


            setNumFmt(4, "0.00", resultsData, wsResults);      // b (mm)
            setNumFmt(5, "0.00", resultsData, wsResults);      // h (mm)
            setNumFmt(6, "0.00", resultsData, wsResults);      // L (mm)
            setNumFmt(7, "0.000", resultsData, wsResults);     // E (MPa)
            setNumFmt(8, "0.000", resultsData, wsResults);     // f_m (MPa)
            setNumFmt(9, "0.00", resultsData, wsResults);      // F_max (N)
            setNumFmt(10, "0.00", resultsData, wsResults);      // w_Fmax (mm)
            setNumFmt(11, "0.000", resultsData, wsResults);    // œÉ_max (MPa)
            setNumFmt(12, "0.00", resultsData, wsResults);     // F_T (N)
            setNumFmt(13, "0.00", resultsData, wsResults);     // h_D (mm)
            setNumFmt(14, "0.000", resultsData, wsResults);    // H_BW (-)


            XLSX.utils.book_append_sheet(wb, wsMattes, sheetName); // Append a sheet to workbook

            XLSX.utils.book_append_sheet(wb, wsSamples, (sheetName + "-objects").slice(0, 31)); // Append a sheet to workbook

            XLSX.utils.book_append_sheet(wb, wsResults, "File Order"); // Append a sheet to workbook

            // Save the file
            XLSX.writeFile(wb, `${measurementName.slice(0, 31)}.xlsx`);
            console.info("‚úÖ Excel file created.");
        };

        input.click(); // Open the file selection dialog
    }
</script>


<script>

    /**
     * Opens a serial port for communication.
     *  SerialPort => comPort - The selected serial port.
     */
    let machineFirmware = "";
    let machineName = "";
    let machineID = "";
    let fingerprint = null;

    const thymosFingerprints = [
        // "6790:29987",   // Thymos ESP32-S3
        // "6790:29986",   // Thymos ESP32-C3
        // "6790:29985",   // Thymos ESP32-C6
        "12346:4097",      // Thymos ESP32-S2   //  ‚âà "0x303a:0x1001"
    ];
    let useFilteredPort = true;
    let usePortAutoConnect = true;

    let tryCount = 0;

    // /////// Serial Connection Handling /////////

    UI.USB.addEventListener("click", async () => startSerial());

    /**
     * Starts the Serial (USB) connection by opening the database and initiating the connection.
     */
    async function startSerial(userRequest = true) {
        if (!('serial' in navigator)) {
            alert('This broswer do not support serialPorts, try using Chrome/Edge.');
            return;
        }

        if (isConnected) {
            console.info("Already connected, disconnecting...");
            await disconnectSerial();
        } else {
            console.info("üöÄ Starting application...");
            await connectSerial(userRequest);

        }

    }

    /////////////////////////////////////////////////////////////////

    const serialFunctionGetPorts = async () => {
        try {
            const ports = await navigator.serial?.getPorts();
            return ports.length ? ports : null;
        } catch (error) {
            console.error("Error getting serial ports:", error);
            return null;
        }
    };

    const serialFunctionRequestPort = async () => {
        try {
            return await navigator.serial?.requestPort(
                {
                    // Example: 'xx:yy' => usbVendorId: xx, usbProductId: yy
                    filters: useFilteredPort ? [
                        ...thymosFingerprints.map(fp => {
                            const [vendorId, productId] = fp.split(":").map(id => parseInt(id, 16));
                            return {usbVendorId: vendorId, usbProductId: productId};
                        })
                    ] : []
                }
            );
        } catch (error) {
            if (error.name === "NotFoundError") {
                console.warn("\n‚ö†Ô∏è No port selected.");
                await logMessage("\n‚ö†Ô∏è No port selected.");
                return null;
            } else {
                throw new Error(`Error requesting serial port: ${error.message}`);
            }
        }
    };


    function checkAllPorts() {
        let thymosPorts = [];
        navigator.serial?.getPorts().then(ports => {
            ports?.forEach(port => {
                if (port.manufacturer === "Thymos") {
                    thymosPorts.push(port);
                }
            });


            return thymosPorts
        }).catch(_ => {
            return null
        });
    }


    // /////// Serial (USB) Connection to ESP /////////

    /**
     * Establishes a connection with the ESP device via USB.
     */
    async function connectSerial(userRequest = true) {
        let serialComPort = null;
        await updateConnectionStatus("connecting", "USB");
        try {
            let ports = null;

            if (usePortAutoConnect) {
                ports = await serialFunctionGetPorts();
                console.info("üîç Searching for available ports...");
            }


            if (isArr(ports) && ports.length === 1) {
                serialComPort = ports[0];
                console.info("\t... Only one port found.");

            } else {
                let founds = false;

                if (isArr(ports) && ports.length > 1) {
                    console.info("Multiple ports found. Select one.");

                    // serialComPort = checkAllPorts();

                    for (let port of ports) {
                        await closePort(port);
                    }
                    founds = true;
                }

                if (userRequest) {
                    if (!serialPort) serialComPort = await serialFunctionRequestPort();
                }

                if (isVoid(serialComPort)) {
                    if (userRequest) {
                        // console.info("\t\t‚ö†Ô∏è No port selected. Connecting canceled.");
                        // await logMessage("\n\t\t‚ö†Ô∏è No port selected. Connecting canceled.");
                    } else {
                        if (founds) {
                            console.info("‚ö†Ô∏è Multiple ports found, please select one.");
                            await logMessage("\n‚ö†Ô∏è Multiple ports found, please select one.");
                        } else {
                            console.info("\n\t‚ùé No previously connected devices found.");
                            await logMessage("\n‚ùé No previously connected devices found.");
                        }
                    }

                    console.info("üîå Connecting canceled.");
                    await disconnectSerial({override: true});
                    return;
                }
            }

            if (!serialComPort) throw new Error("No serial port available.");


            await openPort(serialComPort);

        } catch (error) {

            await handleError(error, "connectSerial");
            isConnected = false;
            activeWatchDog = false;
            await disconnectSerial({override: true});
        }
    }

    async function openPort(comPort, retry = false) {
        try {
            activeWatchDog = false;

            if (!comPort) {
                console.error("‚ö†Ô∏è No available port.");
                await logMessage("\n‚ö†Ô∏è No available port.");
                return;
            }


            // TODO opravit funkci na odpojov√°n√≠ viz n√≠≈æe + opravit reconnect/disconnect v n√°vaznosti na restartov√°n√≠ za≈ô√≠zen√≠.

            // Get the writer and reader for the port after opening
            const err = await closeComPort();
            if (isNonEmptyObj(err)) {
                console.error("‚ö†Ô∏è Error closing existing port before opening a new one:", err);
            }
            await closePort(comPort, {verbose: false});

            const {usbVendorId, usbProductId} = comPort?.getInfo() ?? {};
            fingerprint = `${Number(usbVendorId)?.toString(16) ?? 'N/A'}:${Number(usbProductId)?.toString(16) ?? 'N/A'}`;

            console.info("üë£ Port Fingerprint:\n\t\tusbVendorId:", usbVendorId, "\n\t\tusbProductId:", usbProductId);

            localStorage.setItem("lastFingerprint", fingerprint);

            serialPort = comPort;


            console.info("üîå Opening new port...");
            await comPort.open({
                baudRate: parseInt($ID("inputNumBaudRate").value)
            });

            serialWriter = comPort.writable.getWriter(); // üî•  writer
            serialReader = comPort.readable.getReader(); // üî•  reader

            isConnected = true;

            await sendCommandGeneral("DATAC 0"); // Stop data collection

            readSerial();

            await checkSerialSignals(comPort);

            await setSerialSignals(comPort, true, false); // Set DTR to true and RTS to false

            await logMessage("\n");

            await sendCommandGeneral("MC STOP"); // Stop movement
            await sendCommandGeneral("MC ENDSTOPS ENABLE");
            await sendCommandGeneral("DSLR STOP CYCLIC"); // Stop DSLR cyclic
            await sendCommandGeneral(`DATA SET INTERVAL ${clamp(getInputNumDefAbsInt("inputAppInterval", 1), (debugging ? 1 : maxDataPointsIdle * 1_000), (5 * 1_000 * 1_000))}`); // Stop data collection


            await logMessage("\n");

            await sendCommandGeneral(`MISC SET WATCHDOG_ENABLED ${0}`);
            await sendCommandGeneral(`MISC SET WATCHDOG_INTERVAL ${WATCHDOG_INTERVAL_MS}`);

            await sendCommandGeneral(`MISC SET USB_CHECK_ENABLED ${1}`);
            await sendCommandGeneral(`MISC SET USB_CHECK_INTERVAL ${Math.ceil(clamp(WATCHDOG_INTERVAL_MS * 0.9, 150, 1_000))}`);

            await logMessage("\n");


            // TODO: put this to separate function 'HANDSHAKE()'
            try {
                machineName = (await getMachineName())?.trim() || "";
            } catch (e) {
                machineName = null;
                console.error('Name error:', e);
            }
            try {
                machineID = await getMachineID() || "";
            } catch (e) {
                machineID = null;
                console.error('ID error:', e);
            }
            try {
                machineFirmware = (await getFirmwareVersion())?.toLowerCase().trim() || "";
            } catch (e) {
                machineFirmware = null;
                console.error('Firmware error:', e);
            }

            if (!(isOk(machineFirmware) && isOk(machineName) && isOk(machineID))) {
                if (debugging) console.warn("Firmware, Name or ID not read correctly, retrying...");
                if (debugging) console.info(`\nFirmware:  ${machineFirmware} = ${isOk(machineFirmware)}\nName:  ${machineName} = ${isOk(machineName)}\nID:  ${machineID} = ${isOk(machineID)}\n`);

                // start reconnect procedure
                if (tryCount === 0) {
                    tryCount++;
                    alert("\n‚ö†Ô∏è Device did not respond correctly.\n\n   FIRST TRY: rebooting and retrying...\n\n   CLICK OK AND PLEASE WAIT...");
                    await sendCommandGeneral("MISC REBOOT");
                    await logMessage("\n‚ö†Ô∏è Device did not respond correctly, rebooting and retrying...\n");
                    await logMessage("   Rebooting via Command.\n");
                    throw new Error("Device not responding");

                } else if (tryCount === 1) {
                    tryCount++;
                    alert("\n‚ö†Ô∏è Device did not respond correctly.\n\n   SECOND TRY: rebooting and retrying...\n\n   CLICK OK AND PLEASE WAIT...");
                    await logMessage("\n‚ö†Ô∏è Device did not respond correctly, rebooting and retrying...\n");
                    await logMessage("   Rebooting via DTR toggle.\n");
                    await setSerialSignals(comPort, false, false, false); // Set DTR to false
                    await sleep(250);
                    await setSerialSignals(comPort, true, false, false); // Set DTR to true
                    await sleep(2_500);
                    throw new Error("Device not responding");

                } else {
                    console.error("Device not responding after multiple attempts.");
                    await logMessage("\n‚ùå Failed to connect after multiple attempts. Please check the device.\n");
                    alert("\n‚ùå Failed to connect after multiple attempts.\n\n   PLEASE CHECK THE DEVICE.\n");
                    // reconnectAttempts = 1_000; // TODO: or show error and block further retries
                    await disconnectSerial({override: true});
                    return;
                }
            }


            await updateConnectionStatus("connected", "USB");
            await logMessage("\n‚úÖ Connected to ESP via USB\n");

            tryCount = 0;
            reconnectAttempts = 0;

            // TODO: implement Name-based/ID-based (reconnection)
            const machName = machineName?.toLowerCase();
            if (!isOk(machName) || !isNonEmptyStr(machName) || machName.includes('unnamed')) {
                machineName = 'Thymos Device' + Math.random().toString(36).substring(2, 10);
                await setMachineName(machineName);
            }
            if (machineID === 0) {
                machineID = 1; // Math.ceil(Math.random() * 255);
                await setMachineID(machineID);
            }


            if (debugging) console.info(`\nü§ñ Machine Info:\n\tüìõ Name: ${machineName}\n\tüÜî ID: ${machineID}\n\tüì¶ Firmware: ${machineFirmware}\n`);

            $ID("inputMachineName").value = machineName;
            $ID("inputMachineID").value = machineID;

            // ovƒõ≈ôen√≠ kalibrace
            calibrationStatus = await getCalibrationStatus(2_000);

            await unlockMachineControls();

            if (calibrationStatus) await unlockMovement();
            else await lockMovementExcept(UI.calibrateBtn);

            const speed = (await getSpeed(2_000)) || 15;
            const acceleration = (await getAcceleration(2_000)) || 150;

            setSpeedAndAcceleration(speed, acceleration, true);


            const settingsElements = $$("input, select");
            const saveSelected = getInputValDef("inputUseMachineSettings", null)

            let userChoiceSave = null;
            let userChoiceLoad = null;

            if (saveSelected === 'ask' || saveSelected === 'none') {
                userChoiceLoad = confirm("\n‚úÖ Connected successfully!\n\nDo you want to load the previous settings for this device?\n\n   CLICK 'OK' TO LOAD SETTINGS\nCLICK 'CANCEL' TO KEEP CURRENT SETTINGS");
                userChoiceSave = confirm("\n‚úÖ Connected successfully!\n\nDo you want to keep saving current settings for this device?\n\n   CLICK 'OK' TO SAVE SETTINGS ON DISCONNECT\nCLICK 'CANCEL' TO NOT SAVE SETTINGS");
            }

            if (saveSelected === 'yes_save' || saveSelected === 'no_save' || userChoiceSave === true) storageKey = `${storageKeyBase}_${machineName}[${machineID}]`.trim().replaceAll(" ", "_");
            else storageKey = storageKeyIdle;

            // TODO: zdvojen√© (respektive ztrojen√©) pos√≠l√°n√≠ rychlosti a zrychlen√≠, vy≈ôe≈°it t≈ôeba pomoc√≠ lep≈°√≠ho pou≈æit√≠ 'isConnected' nebo jinou logikou
            if (saveSelected === 'yes_save' || saveSelected === 'yes_not' || userChoiceLoad === true) await loadInputsFromLocalStorage(settingsElements, storageKey);
            // TODO: implement that specific element in App settings section (like 'systemLevelSelect', language, ...) are saved to specific 'storageKeySys' => not tied to machine
            await saveAllInputsToLocalStorage(settingsElements, storageKey);

        } catch (error) {
            activeWatchDog = false;
            if (!(error.name === "InvalidStateError" && retry)) {
                await disconnectSerial({override: true});
                await handleError(error, "openPort");
            }
        }
    }


    async function checkSerialSignals(port) {
        if (!port) return;

        try {
            const signals = await port?.getSignals();
            console.info("üì° Serial port signals...");
            console.info("\tüö¶ Signals:", signals);
        } catch (error) {
            console.error("‚ùå Error reading serial signals:", error);
        }
    }


    async function setSerialSignals(port, dtrState, rtsState, brkState) {
        if (!port) return;

        try {
            await port?.setSignals({
                dataTerminalReady: dtrState,
                requestToSend: rtsState,
                break: brkState
            });

            console.info("‚úÖ DTR:", dtrState, "RTS:", rtsState, "BRK:", brkState);
        } catch (error) {
            console.error("‚ùå Error setting serial signals:", error);
        }
    }


    /**
     * Disconnects from the ESP device via USB.
     */
    async function disconnectSerial({override = false, verbose = true} = {}) {
        const wasConnected = isConnected;
        if (!override && !isConnected) {
            console.warn("\n‚ö†Ô∏è Port is not connected.");
            return;
        }

        updateConnectionStatus("disconnecting");

        try {
            try {
                if (isExperimentRunning) endMeasuring(0, {
                    overRide: true,
                    ednStatus: 'disconnected',
                    endText: "üöß Experiment stopped due to disconnect"
                });

            } catch (error) {
                if (debugging) console.warn("\n‚ö†Ô∏è Error stopping data collection:", error);
            }

            await endedMoving();

            // Stop data reading before releasing the reader
            await closeComPort({override: override, verbose: verbose});

            if (wasConnected && verbose) await logMessage("‚úñÔ∏è Disconnected from ESP\n\n");

            console.info("‚úÖ Disconnected successfully.");
        } catch (error) {
            console.error("‚ùå disconnectSerial error:", error);
        } finally {
            cancelAllPending();
            activeWatchDog = false;
            machineOccupation = false;
            isExperimentRunning = false;
            await flushDB();
            await resetValues();
            await updateConnectionStatus("disconnected");
            await lockMachineControls();
        }
    }

    async function closePort(port, {reader = null, writer = null, verbose = false} = {}) {
        if (!port) return;

        const info = (() => {
            try {
                return port?.getInfo();
            } catch {
                return {};
            }
        })();
        if (verbose) console.info("\t‚öì Closing port...", info);

        // 1) Ukonƒçit ƒçten√≠
        try {
            // Preferuj p≈ôedan√©ho readera; jinak pokud je stream locked, pokus se ho uvolnit
            if (reader) {
                try {
                    await reader.cancel();
                } catch {
                }
                try {
                    reader.releaseLock();
                } catch {
                }
                if (verbose) console.info("\t\tüìç Reader canceled & released.");
            } else if (port.readable?.locked) {
                // Nƒõkdo jin√Ω dr≈æ√≠ lock ‚Äì posledn√≠ mo≈ænost√≠ je vytvo≈ôit doƒçasn√©ho readera a hned ho zru≈°it
                const tmp = port.readable.getReader();
                try {
                    await tmp.cancel();
                } catch {
                }
                try {
                    tmp.releaseLock();
                } catch {
                }
                if (verbose) console.info("\tüìç Forced-canceled locked readable.");
            }
        } catch (err) {
            console.warn("‚ö†Ô∏è Error handling reader", info, ":", err);
        }

        // 2) Ukonƒçit z√°pis
        try {
            if (writer) {
                try {
                    await writer.close();
                } catch {/* m≈Ø≈æe b√Ωt u≈æ zav≈ôen√Ω */
                }
                try {
                    writer.releaseLock();
                } catch {
                }
                if (verbose) console.info("\t\tüìç Writer closed & released.");
            } else if (port.writable?.locked) {
                const tmpW = port.writable.getWriter();
                try {
                    await tmpW.close();
                } catch {
                }
                try {
                    tmpW.releaseLock();
                } catch {
                }
                if (verbose) console.info("\tüìç Forced-closed locked writable.");
            }
        } catch (err) {
            console.warn("‚ö†Ô∏è Error handling writer", info, ":", err);
        }

        // 3) Zav≈ô√≠t port
        try {
            try {
                await port.close();
            } catch (e) {
            }
            if (verbose) console.info("\tüìç Port closed.");
        } catch (err) {
            console.warn("‚ö†Ô∏è Error closing port", info, ":", err);
        }
    }


    async function closeComPort({override = false, verbose = true} = {}) {
        const errors = {};

        // 1) Reader
        try {
            if (serialReader) {
                try {
                    await serialReader.cancel();
                } catch {
                }
                try {
                    serialReader.releaseLock();
                } catch {
                }
                if (verbose) console.info("\t‚õèÔ∏è Released Reader...");
            }
        } catch (error) {
            console.warn("‚ö†Ô∏è Error releasing reader:", error);
            errors.reader = error;
        } finally {
            serialReader = null;
        }

        // 2) Writer
        try {
            if (serialWriter) {
                try {
                    await serialWriter.close();
                } catch {
                }
                try {
                    serialWriter.releaseLock();
                } catch {
                }
                if (verbose) console.info("\t‚õèÔ∏è Released Writer...");
            }
        } catch (error) {
            console.warn("‚ö†Ô∏è Error releasing writer:", error);
            errors.writer = error;
        } finally {
            serialWriter = null;
        }

        // 3) Port
        try {
            if (serialPort) {
                // Pokud nƒõkde z≈Østal lock, pokus se ho vynutit
                if (serialPort.readable?.locked) {
                    const r = serialPort.readable.getReader();
                    try {
                        await r.cancel();
                    } catch {
                    }
                    try {
                        r.releaseLock();
                    } catch {
                    }
                }
                if (serialPort.writable?.locked) {
                    const w = serialPort.writable.getWriter();
                    try {
                        await w.close();
                    } catch {
                    }
                    try {
                        w.releaseLock();
                    } catch {
                    }
                }

                if (override || serialPort) {
                    try {
                        await serialPort.close();
                    } catch {
                    }
                    if (verbose) console.info("\t‚õèÔ∏è Closed Serial Port...");
                }
            }
        } catch (error) {
            console.warn("‚ö†Ô∏è Error closing serial port:", error);
            errors.port = error;
        } finally {
            serialPort = null;
        }

        isConnected = false;

        return errors;
    }


    // /////// Reading Data from ESP /////////

    /**
     * Reads incoming data from the ESP device over a serial connection.
     */
    async function readSerial() {
        let buffer = "";
        const decoder = txtD ?? new TextDecoder(); // pokud pou≈æ√≠v√°≈° glob√°ln√≠ txtD, klidnƒõ ho nech

        if (!serialPort?.readable) {
            await logMessage("\n‚ùå Port is unavailable.\n");
            return;
        }

        // Tady u≈æ P≈òEDPOKL√ÅD√ÅME, ≈æe serialReader existuje z openPort()
        if (!serialReader) {
            // fallback, kdyby p≈ôece jen nebyl
            serialReader = serialPort.readable.getReader();
        }

        try {
            while (isConnected) {
                const {value, done} = await serialReader.read();
                if (done) break;

                buffer += decoder.decode(value, {stream: true});

                const lastNewline = buffer.lastIndexOf("\n");
                if (lastNewline !== -1) {
                    const dataChunk = buffer.slice(0, lastNewline).split("\n");
                    buffer = buffer.slice(lastNewline + 1);
                    await handleIncomingChunkQueued(dataChunk);
                }
            }
        } catch (error) {
            activeWatchDog = false;
            await handleError(error, "readSerial");
        } finally {
            // doflushnout p≈ô√≠padn√Ω zbytek (pokud to d√°v√° smysl pro tv≈Øj protokol)
            const tail = decoder.decode();
            if (tail) {
                buffer += tail;
                const lines = buffer.split("\n");
                if (lines.length) await handleIncomingChunkQueued(lines);
            }

            // Bezpeƒçn√© ukonƒçen√≠ readeru
            if (serialReader) {
                try {
                    await serialReader.cancel();
                } catch {
                }
                try {
                    serialReader.releaseLock();
                } catch {
                }
            }

            await logMessage("\n‚úÖ Reading stopped.\n");
        }
    }


    async function findPreferredPortIndex(showMessage = false) {
        if (!fingerprint) {
            console.warn("\n‚ö†Ô∏è No fingerprint available.");
            return null;
        }
        const ports = await navigator.serial?.getPorts();

        for (let i = 0; i < ports.length; i++) {
            const info = ports[i]?.getInfo();
            const currentFingerprint = `${info.usbVendorId}:${info.usbProductId}`;
            if (currentFingerprint === fingerprint) {
                console.info("‚úÖ Matched port at index:", i);
                return ports[i];
            }
        }

        if (showMessage) {
            console.warn("\n‚ö†Ô∏è No matching port found.");
            await logMessage("\n‚ö†Ô∏è No matching port found.");
        }
        return null;
    }

    async function attemptReconnect() {
        console.info("%c\nüîÑ Attempting to reconnect...", "color: blue; font-weight: bold;");

        if (isConnected || isReconnecting) {
            console.warn("\nüöß Reconnect aborted - Already connected or disconnect was expected.");
            return;
        }

        if (reconnectAttempts >= maxReconnectAttempts) {
            console.warn("\n‚ö†Ô∏è Stopping auto-reconnect. Maximum attempts reached.");
            await logMessage("\n‚ö†Ô∏è Stopping auto-reconnect.\n");
            isReconnecting = false;
            await disconnectSerial();
            await resetValues();
            return;
        }

        // Reset the connection status
        // await serialReader.cancel();
        // await serialReader.releaseLock();
        // await serialPort.close();
        // serialReader = null;
        // serialPort = null;

        isConnected = false;
        await disconnectSerial({override: true, verbose: false});


        activeWatchDog = false;
        isReconnecting = true;
        reconnectAttempts++;
        await updateConnectionStatus("reconnecting");
        await logMessage(`\nüîÑ Attempting reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);

        try {

            // TODO: implement also using machine name
            const port = await findPreferredPortIndex();

            if (port) {
                serialPort = port; // Update the serialPort reference
                await openPort(port, true);
            }


            if (isConnected) {
                console.info("‚úÖ Reconnected successfully!");
                isReconnecting = false;
                await updateConnectionStatus("connected");
                await logMessage("‚úÖ Reconnected successfully!\n");
                await unlockMachineControls();
            } else {
                throw new Error("Reconnect failed: not connected after openPort");
            }
        } catch (error) {
            console.warn("\n‚ö†Ô∏è Reconnection failed:", error);
            await logMessage("\n‚ùå Reconnection failed: " + error.message);

            if (reconnectAttempts < maxReconnectAttempts) {
                setTimeout(() => {
                    isReconnecting = false; // Allow another reconnection attempt
                    attemptReconnect();
                }, 3_000);
            } else {
                console.warn("\n‚ö†Ô∏è Max reconnect attempts reached. Reconnecting stoped.");
                await logMessage("\n‚ùå Max reconnect attempts reached. Reconnecting stopped.\n");
                await resetValues();
                isReconnecting = false;
            }
        }
    }


    /////////////////////////////////////////////////////////////////

</script>

<script type="text/plain">

    // Jednor√°zovƒõ nƒõkde po kliknut√≠ u≈æivatele ‚Äì udƒõlen√≠ opr√°vnƒõn√≠ (nen√≠ nutn√© opakovat poka≈æd√©)
    async function grantSerialOnce() {
        if (!('serial' in navigator)) throw new Error('Web Serial nen√≠ podporov√°n');
        try {
            await navigator.serial.requestPort();
        } catch { /* u≈æivatel zru≈°il */
        }
    }

    // Setup "devicechange" pro seriov√© porty
    function setupSerialDeviceChange({onChange} = {}) {
        if (!('serial' in navigator)) throw new Error('Web Serial nen√≠ podporov√°n');

        // aktu√°ln√≠ povolen√© porty (po reloadu se vr√°t√≠ ty, kter√© u≈æ maj√≠ opr√°vnƒõn√≠)
        let known = new Set();

        // pomocn√° funkce pro stabiln√≠ ID portu
        const portId = async (port) => {
            // getInfo() vrac√≠ nap≈ô. { usbVendorId, usbProductId } pro USB-CDC; BT apod. m≈Ø≈æe b√Ωt pr√°zdn√©
            const info = port.getInfo() || {};
            // nƒõkter√© platformy maj√≠ jen mƒõn√≠c√≠ se COM jm√©no; jako fallback pou≈æijeme String(port)
            return JSON.stringify({
                usbVendorId: info.usbVendorId,
                usbProductId: info.usbProductId,
                fallback: String(port)
            });
        };

        async function snapshotAndNotify() {
            const ports = await navigator.serial.getPorts();
            const next = new Set(await Promise.all(ports.map(portId)));

            // diff
            const added = [];
            const removed = [];
            for (const id of next) if (!known.has(id)) added.push(id);
            for (const id of known) if (!next.has(id)) removed.push(id);

            if ((added.length || removed.length) && typeof onChange === 'function') {
                onChange({added, removed, ports});
            }
            known = next;
        }

        // poƒç√°teƒçn√≠ snapshot
        snapshotAndNotify();

        // hotplug eventy (funguj√≠ i kdy≈æ port je≈°tƒõ nem√° povolen√≠; k otev≈ôen√≠ bude≈° stejnƒõ pot≈ôebovat requestPort)
        navigator.serial.addEventListener('connect', snapshotAndNotify);
        navigator.serial.addEventListener('disconnect', snapshotAndNotify);

        // // voliteln√Ω polling jako z√°loha (nƒõkdy ovladaƒç nepropaguje eventy spolehlivƒõ)
        // const interval = setInterval(snapshotAndNotify, 10_000);
        //
        // // vrat√≠ teardown
        // return () => {
        //     clearInterval(interval);
        //     navigator.serial.removeEventListener('connect', snapshotAndNotify);
        //     navigator.serial.removeEventListener('disconnect', snapshotAndNotify);
        // };
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////////

    // P≈ô√≠klad pou≈æit√≠:

    // po udƒõlen√≠ opr√°vnƒõn√≠ (staƒç√≠ jednou v historii webu na dan√©m p≈Øvodu)
    grantSerialOnce(); // await grantSerialOnce();

    // pak kdekoli:
    // const stop = setupSerialDeviceChange({
    //     onChange: ({added, removed, ports}) => {
    //         console.info('P≈ôid√°no:', added, 'Odebr√°no:', removed);
    //         // tady si m≈Ø≈æe≈° aktualizovat UI; 'ports' je aktu√°ln√≠ pole NavigatorSerialPort
    //     }
    // });
    setupSerialDeviceChange({
        onChange: ({added, removed, ports}) => {
            console.info('\nP≈ôid√°no:\n', added, '\n\nOdebr√°no:\n', removed);
            // tady si m≈Ø≈æe≈° aktualizovat UI; 'ports' je aktu√°ln√≠ pole NavigatorSerialPort
        }
    })

    // a≈æ nebude≈° cht√≠t poslouchat:
    // stop();
    //     navigator.serial.removeEventListener('connect', snapshotAndNotify);
    //     navigator.serial.removeEventListener('disconnect', snapshotAndNotify);

</script>


<script type="text/plain">
    // Web Serial API - connect / disconnect eventy
    if ('serial' in navigator) {
        (async () => {
            const ports = await navigator.serial.getPorts();
            for (const port of ports) onConnect('serial', port);
        })();

        navigator.serial.addEventListener('connect', e => {
            const port = e?.target;
            console.info('%c\n\tSerial connect:', "color: red; font-size: 13px; font-style: italic; font-weight: bold;", port?.getInfo());
            console.info(port);
            console.info(e);
            onConnect('serial', port);
        });
        navigator.serial.addEventListener('disconnect', e => {
            const port = e?.target;
            console.info('%c\n\tSerial disconnect:', "color: red; font-size: 13px; font-style: italic; font-weight: bold;", port?.getInfo());
            console.info(port);
            console.info(e);
            onDisconnect('serial', port);
        });
    }

    function onConnect(type, port) { /* ‚Ä¶ */
        switch (type) {
            case 'serial':
                onSerialConnect(port);
                break;
        }
    }

    function onDisconnect(type, port) { /* ‚Ä¶ */
        switch (type) {
            case 'serial':
                onSerialDisconnect(port);
                break;
        }
    }

    function onSerialConnect(port) { /* ‚Ä¶ */
    }

    function onSerialDisconnect(port) { /* ‚Ä¶ */
    }

    // TODO: implement automatic reconnect when the device is reconnected to the computer
    const autoConnectSetting = $ID("inputAutoConnect")?.value || 'never';
    if (autoConnectSetting === 'always' || autoConnectSetting === 'during') await startSerial(false);
    else if (autoConnectSetting === 'ask') if (confirm("The device was connected. Do you want to connect?")) await startSerial(true);

</script>


<script>

    function resetValues() {
        parsedData = {
            time: null,
            position: null,
            speed: null,
            force: Array(catchVal(loadCellNum, 0, isNum)).fill(null),
            photoIndex: null
        };
        measurementParts = measurementPartDefault;
        liveUpdate = false

        isExperimentRunning = false;
        machineOccupation = false;
        UI.loadingLogContainer.style.background = "#323232";

        experimentEndLimits = {position: null, force: null, time: null};
        expControl = '';
        pendingDSLR = null;
        dataCount = null;
        maxForces = Array(catchVal(loadCellNum, 0, isNum)).fill(null);
        measureForces = Array(catchVal(loadCellNum, 0, isNum)).fill(null).map(() => []);
        tareValues.force = Array(catchVal(loadCellNum, 0, isNum)).fill(0);
        tareValues.position = null;
        tareValues.time = null;
        lastAcceptedTime = null;
        aggregatedDataBetweenSteps = [];
        Object.values(measurement_limits).forEach(v => {
            v.counter = 0;
            v.limit = null;
        });
        endMeasurement = false;
        clearTimeout(endMeasurementCounter)
        endMeasurementCounter = null;
        checkSpeed = true;


        displacementSignCorrection = 0;
        loadSignCorrections = Array(catchVal(loadCellNum, 0, isNum)).fill(0);

        loadcellErrRate = null;
        measurementErrRate = null;
        totalErrRate = null;

        calibrationStatus = false;

        activeWatchDog = false;

        isConnected = false;
        serialPort = null;
        serialReader = null;
        serialWriter = null;


        storageKey = storageKeyIdle;
        machineFirmware = "";
        machineName = "";
        machineID = "";
        // fingerprint = null;
        // tryCount = 0;
        // reconnectAttempts = 0;
    }

    async function clearAndResetAll() {
        console.clear();
        if (liveUpdate) await chartUpdate();
        await clearCharts();
        await clearDatabase();
        await clearConsoleLog();


        // Remove all other saved data from local storage
        Object.keys(localStorage).forEach(key => (key.startsWith(storageKeyBase)) ? localStorage.removeItem(key) : null);


        if (serialPort) await setSerialSignals(serialPort, true, true);
        await disconnectSerial();


        timeData = [];
        positionData = [];
        forceData = Array(catchVal(loadCellNum, 0, isNum)).fill(null).map(() => []);
        photoData = [];

        reconnectAttempts = 0;

        // Experiment parameters
        // --------------------------------
        speedForward_mmps = 0;
        currentSpeed = null;
        currentAcceleration = null;
        takePhotos = false;
        dataInterval_us = null;
        initialForceLim_N = null;
        experimentDoubleSpeed = false;
        experimentHoldConstantForce = false;
        stoppingForceLimit = null;
        holdForceTimeMs = null;
        presentLoadcells = [];
        checkSpeed = true;
        timer = null;
        // --------------------------------

        window.location.reload();
    }
</script>

<script>

    unlockMachineControls();

    UI.connectBtns?.forEach(btn => btn.classList.add('disabled'));

    // #TODO do better disabling of elements //////////////////////////////////////////////////
    $$('.prohibited')?.forEach(element => {
        element.readOnly = true;

        element.addEventListener("selectstart", async (e) => e.preventDefault());
        element.addEventListener("mousedown", async (e) => e.preventDefault());
        element.addEventListener("keydown", async (e) => e.preventDefault());
    })


    // /////// Page Initialization /////////

    /**
     * Runs when the page loads.
     * - Logs a message to the console.
     * - Loads available commands from the JSON file.
     */
    window.onload = async () => {
        console.info("Page loaded");
        await openDB();
        // await loadCommands();
    };


    // ===============================================
    // -------------------- Init --------------------
    // ===============================================

    document.addEventListener("DOMContentLoaded", function () {
        if (!isNum(loadCellNum)) throw new Error(`Total Loadcell count is not defined: ${loadCellNum}`);

        // start at top of page
        try {
            history.scrollRestoration = 'manual';
        } catch {
        }
        window.scrollTo(0, 0);
        document.body.style.overflowY = "hidden";

        Notification.requestPermission().then(permission => {
            if (permission === "granted") {
                notificationsAllowed = true;
            }
        });


        renderLoadcells(loadCellNum);

        const levelElements = $$('[data-system-level]');
        $ID('systemLevelSelect').addEventListener('change', (event) => {
            const selectedLevel = event.target.value;
            switch (selectedLevel) {
                case 'basic':
                    systemLevel = 0;
                    break;
                case 'standard':
                    systemLevel = 1;
                    break;
                case 'advanced':
                    systemLevel = 2;
                    break;
                case 'expert':
                    systemLevel = 3;
                    break;
                case 'admin':
                    systemLevel = 4;
                    break;
                case 'developer':
                    systemLevel = 5;
                    break;
                case 'god':
                    systemLevel = 6;
                    break;
                default:
                    systemLevel = 0;
            }

            console.info(`\n\t‚öôÔ∏è Selected System-level: ${selectedLevel} (${systemLevel})`);

            levelElements.forEach(el => {

                const elVal = el.getAttribute('data-system-level').toLowerCase().trim();

                const elLevel = elVal.split('-');
                const valLevel = parseInt(elLevel[0]);
                const valLevelTop = catchVal(parseInt(elLevel[1]), Number.POSITIVE_INFINITY, isNum);

                const visible = (elLevel[0] === 'all' || !(valLevel <= systemLevel && systemLevel < valLevelTop));

                el.classList.toggle((elVal.endsWith('v') ? 'invisible' : 'undisplayed'), visible);
            });

            window.dispatchEvent(new Event('resize'));
        });


        $ID('inputStopForce')?.addEventListener('change', async (event) => applyAdjust('inputTargetForce', event.target.value));

        if (exists("inputLoadingTime")) adjustSet('inputLoadingTime', 15);
        if (exists("inputIndDiameter")) adjustSet('inputIndDiameter', 10);

        bindRecalcOnInputs();

        (() => {
            const allButtons = $$('button');

            allButtons?.forEach(button => {
                // block right-click context menu on buttons
                button.addEventListener('contextmenu', event => event.preventDefault());
            });
        })();


        const optionsElements = $$("input, select");

        // Listen for changes in all inputs
        optionsElements?.forEach(input => {
            if (isVoid(input.dataset.system) || input.dataset.system === "0" || input.dataset.system === "false") {
                input.addEventListener("change", async (event) => saveInputToLocalStorage(event));
            }
        });


        [...optionsElements].filter(el => el.matches('[id][data-unit]'))?.forEach((input) => {
            updateUnitsLabel(input);

            // Use examples:
            //      <input id="a" data-unit="m/s^2">
            //      <!-- -> (m/s<sup>2</sup>) -->
            //
            //      <input id="b" data-unit="CO_2">
            //      <!-- -> (CO<sub>2</sub>) -->
            //
            //      <input id="c" data-unit="10^{‚àí3} mol¬∑L^{‚àí1}">
            //      <!-- -> (10<sup>‚àí3</sup> mol¬∑L<sup>‚àí1</sup>) -->
            //
            //      <input id="d" data-unit="[sup]2[/sup]¬∑m">
            //      <!-- -> (<sup>2</sup>¬∑m) -->
            //
            //      <!-- pokud chce≈° ps√°t p≈ô√≠mo HTML, v atributu pou≈æij entity: -->
            //      <input id="e" data-unit="m/s&lt;sup&gt;2&lt;/sup&gt;">
            //      <!-- -> (m/s<sup>2</sup>) -->

            // Pokud by se data-unit mƒõnilo dynamicky, hl√≠dej zmƒõnu atributu:
            const mo = new MutationObserver((muts) => {
                for (const m of muts) {
                    if (m.type === 'attributes' && m.attributeName === 'data-unit') {
                        updateUnitsLabel(input);
                    }
                }
            });
            mo.observe(input, {attributes: true, attributeFilter: ['data-unit']});
        });

        // Initialization of uPlot charts
        timeChart = createChart("timeChart", ["Time (s)", "Force 1", "Force 2", "Force 3"], "Force-Time Graph", "Time [s]", "Force [N]");
        positionChart = createChart("positionChart", ["Position (mm)", "Force 1", "Force 2", "Force 3"], "Force-Position Graph", "Position [mm]", "Force [N]");


        $ID("experimentName")?.addEventListener("change", async (event) => {
            const countInput = $ID("experimentCount");
            if (countInput && countInput.value !== '1') {
                blinkBorder(countInput, {restart: true});
                countInput.value = 1;
            }
            await updateLogById(0, {experimentName: event.target.value.trim()});
        });

        $ID("experimentCount")?.addEventListener("change", async (event) => {
            blinkBorder(event.target, {
                restart: true,
                color: '#2196F3',
                backgroundOn: '#a7e7ff',
                blinks: 2,
            });
        });

        $ID("experimentDesc")?.addEventListener("change", async (event) => {
            await updateLogById(0, {experimentDescription: event.target.value.trim()});
        });

        // === Experiment Data Saving ===
        $ID("startExperiment")?.addEventListener('click', async () => startExperiment());

        $ID("stopMachine")?.addEventListener('click', async () => stopMachine('user'));

        $ID("inputLoadLimitDropPercent")?.addEventListener('change', async (event) => {
            // forceLimitDropPercent = parseFloat(event.target.value) / 100;
        });
        $ID("inputLoadLimitDropValue")?.addEventListener('change', async (event) => {
            // forceLimitDropValue = parseFloat(event.target.value);
        });

        $ID("inputTakePhotos")?.addEventListener('change', async (event) => {
            const photosInput = $ID("inputPhotoInterval");
            const photosLabel = $(`label[for="inputPhotoInterval"]`);
            if (event.target.checked) {
                // disable photo interval input
                photosInput.classList.remove("disabled");
                photosInput.readOnly = false;
                photosInput.tabIndex = 1;

                // disable photo interval input label
                photosLabel.classList.remove("disabled");
            } else {
                // disable photo interval input
                photosInput.classList.add("disabled");
                photosInput.readOnly = true;
                photosInput.tabIndex = -1;

                // disable photo interval input label
                photosLabel.classList.add("disabled");
            }
        });

        $ID("inputDoCycles")?.addEventListener('change', async (event) => {
            const cyclesInput = $ID("inputCycles");
            const cyclesLabel = $(`label[for="inputCycles"]`);
            if (event.target.checked) {
                // disable photo interval input
                cyclesInput.classList.remove("disabled");
                cyclesInput.readOnly = false;
                cyclesInput.tabIndex = 1;

                // disable photo interval input label
                cyclesLabel.classList.remove("disabled");
            } else {
                // disable photo interval input
                cyclesInput.classList.add("disabled");
               cyclesInput.readOnly = true;
                cyclesInput.tabIndex = -1;

                // disable photo interval input label
                cyclesLabel.classList.add("disabled");
            }
        });

        $ID("clearChartBtn")?.addEventListener("click", async () => clearCharts());

        // TODO:  $$$("saveChartBtn")?.addEventListener("click", async () => saveChartsAsPNG());

        $ID("refreshChartBtn")?.addEventListener("click", async () => refreshCharts());

        $ID("convertCSV")?.addEventListener("click", async () => convertCSVtoXLSX_MATTES());

        $ID("clearCalculationsButton")?.addEventListener("click", async () => clearCalculations());

        $ID("darkModeButton")?.addEventListener("click", async () => toggleDarkMode());

        // Open in current tab:     window.location.href = 'about.html'
        // Open in new tab:         window.open('about.html', '_blank', 'noopener,noreferrer')
        // Open in new window:      window.open('about.html', '_blank', 'noopener,noreferrer,width=800,height=600')

        $ID("aboutButton")?.addEventListener("click", async () => window.open('about.html', '_blank', 'noopener,noreferrer'));

        $ID("updateMachButton")?.addEventListener("click", async () => {
            await disconnectSerial({override: true});
            window.location.href = 'espUpdate/update.html';
        });

        $ID("rebootButton")?.addEventListener("click", async () => await sendCommandGeneral("MISC REBOOT"));

        $ID("clearStorageButton")?.addEventListener("click", async () => {
            if (confirm("‚ö†Ô∏è This will clear all settings and disconnect from the machine.\n\n     Are you sure?")) {
                clearLocalStorage();
            }
        });

        $ID("clearAllButton")?.addEventListener("click", async () => {
            if (confirm("‚ö†Ô∏è This will clear all Data and disconnect from the machine.\n\n     Are you sure?")) {
                await clearAndResetAll();
            }
        });

        $ID("exportSettingButton")?.addEventListener("click", async () => exportSettings());

        $ID("importSettingButton")?.addEventListener("click", async () => importSettings());

        $ID("toggleLineLockBtn")?.addEventListener("click", async () => lineConsoleLock());

        $ID("clearRegularLog")?.addEventListener("click", async () => clearConsoleLog());

        // TODO: $$$("saveRegularLog")?.addEventListener("click", async () => saveLogAsText());

        const machNameInput = $ID("inputMachineName");
        const machIDInput = $ID("inputMachineID");
        $ID("sendMachineNameBtn")?.addEventListener("click", async () => setMachineName(getInputValDef(machNameInput, '')));
        $ID("sendMachineIDBtn")?.addEventListener("click", async () => setMachineID(getInputValDef(machIDInput, '')));

        machNameInput?.addEventListener("change", async (event) => {
            const val = event.target.value.trim();
            if (val === '') {
                if (isOk(machineName)) event.target.value = machineName;
                return;
            }
            if (isNonEmptyStr(val) && isOk(val)) {
                event.target.value = val;
                await sleep(3_500);
                if (isOk(machineName)) event.target.value = machineName;
            }
        });
        machIDInput?.addEventListener("change", async (event) => {
            const val = event.target.value.trim();
            if (val === '') {
                if (isOk(machineID)) event.target.value = machineID;
                return;
            }
            const num = clamp(toInteger(val), 1, 255);
            if (isNum(num)) {
                event.target.value = num;
                await sleep(3_500);
                if (isOk(machineID)) event.target.value = machineID;
            }
        });


        machNameInput?.addEventListener("keydown", async (event) => {
            if (event.key === "Enter") {
                await setMachineName(getInputValDef(machNameInput, ''));
            }
        });

        machIDInput?.addEventListener("keydown", async (event) => {
            if (event.key === "Enter") {
                await setMachineID(getInputValDef(machIDInput, ''));
            }
        });


        function attachHoldHandlers(element, onStart) {
            let isHolding = false;

            const start = async () => {
                if (isHolding) return;
                isHolding = true;
                lockMovementExcept(element);  // zamkni v≈°e krom pr√°vƒõ dr≈æn√©ho
                await beganMoving();          // spust√≠ watchdog
                onStart();
            };

            const stop = async () => {
                if (!isHolding) return;
                isHolding = false;
                await softStopMachine();          // po pu≈°tƒõn√≠ zastav a ukonƒçi pohyb
            };

            // My≈°
            element.addEventListener("mousedown", start);
            element.addEventListener("mouseup", stop);
            element.addEventListener("mouseleave", () => {
                if (isHolding) stop();
            });

            // Dotyk
            element.addEventListener("touchstart", start, {passive: true});
            element.addEventListener("touchend", stop);
            element.addEventListener("touchcancel", stop);
        }


        attachHoldHandlers(UI.moveUpBtn, async () => sendMoveCommand("MC HOME")); // TODO: probl√©m s rychlostmi na konci
        attachHoldHandlers(UI.moveDownBtn, async () => sendMoveCommand("MC END")); // TODO: probl√©m s rychlostmi na konci

        $ID("returnPositionExperimentBtn").addEventListener('click', async () => moveToOriginalPosition());

        UI.moveUp50Btn.addEventListener("click", async () => moveBy(-50));  // TODO: probl√©m s rychlostmi na konci a zrychlen√≠m
        UI.moveDown50Btn.addEventListener("click", async () => moveBy(50));  // TODO: probl√©m s rychlostmi na konci a zrychlen√≠m


        UI.calibrateBtn.addEventListener("click", async () => {
            calibrationStatus = false;
            await lockMovement();

            await sendCommandGeneral('MC ENDSTOPS ENABLE');
            await sendCommandGeneral('MISC SET WATCHDOG_ENABLED 0');
            await sendCommandGeneral('MC CALIBRATE');

            let confirmCalibrationCount = 0;
            // maximal 1 minute
            const maxConfirmCalCount = 60 / 2.5;

            while (!calibrationStatus) {
                await sleep(2_500);
                calibrationStatus = await getCalibrationStatus(500);
                if (!isConnected) {
                    calibrationStatus = false;
                    console.warn("\n‚ö†Ô∏è Serial connection lost during calibration.");
                    await logMessage("‚ö†Ô∏è Serial connection lost during calibration.");
                    break;
                }
                if (confirmCalibrationCount > maxConfirmCalCount) {
                    calibrationStatus = false;
                    await logMessage("‚ùå Calibration timeout reached. Please check the machine.\n\tMotors are not calibrated.");
                    console.error("‚ùå Calibration timeout. Please check the machine.\n\tMotors are not calibrated.");
                    break;
                }
                confirmCalibrationCount++;
            }
            if (calibrationStatus) await unlockMovement();
            if (!calibrationStatus) await lockMovementExcept(UI.calibrateBtn);
        });


        // Set both elements' limits to match
        [[UI.speedSlider, UI.speedLabel], [UI.accelerationSlider, UI.accelerationLabel]]?.forEach(pair => {
            pair[1].min = pair[0].min;
            pair[1].max = pair[0].max;
            pair[1].value = pair[0].value;
            pair[1].step = pair[0].step;

            pair[1].dispatchEvent(new Event("input", {bubbles: true}));
        });

        $$('.sliderInputLabel')?.forEach(input => {
            input.addEventListener("change", (event) => {
                checkInput(event.target, 'floatInput', 2);
                const slider = $ID(event.target.id.replaceAll("label", "movement"));
                const value = parseFloat(event.target.value).toFixed(2); // Round to 2 decimal places
                if (slider) {
                    slider.value = value;
                    event.target.value = value; // Update the input value to match the slider
                    slider.dispatchEvent(new Event("change", {bubbles: true})); // Trigger input event to update the slider
                }
            });
        });

        // Attaches validation checks to numeric inputs
        $$("input[type=number]")?.forEach(input => {
            input.addEventListener("change", async (event) => {
                checkInput(event.target, event.target.dataset.inputType);
            });
            input.addEventListener("keydown", async (event) => {
                if (event.key === "Enter") {
                    checkInput(event.target, event.target.dataset.inputType);
                    event.target.blur();
                }
            });
        });

        const decSymbolElement = $ID('decimalSymbol');
        const delimSymbolElement = $ID('delimiterSymbol');

        decSymbolElement.addEventListener("change", (event) => {
            const isValueComma = event.target.value === "Option-Comma";
            const currentValue = delimSymbolElement.value;
            const commaOptions = $$('option[value="Option-Comma"]', delimSymbolElement);
            if (isValueComma) {
                commaOptions?.forEach(o => o.disabled = true);
            } else {
                commaOptions?.forEach(o => o.disabled = false);
            }
            if (isValueComma === currentValue) {
                delimSymbolElement.value = "Option-Semicolon";
                delimSymbolElement.dispatchEvent(new Event("change", {bubbles: true}));
            }
        });
        delimSymbolElement.addEventListener("change", (event) => {
            const isValueComma = event.target.value === "Option-Comma";
            const currentValue = decSymbolElement.value;
            const commaOptions = $$('option[value="Option-Comma"]', decSymbolElement);
            if (isValueComma) {
                commaOptions?.forEach(o => o.disabled = true);
            } else {
                commaOptions?.forEach(o => o.disabled = false);
            }
            if (isValueComma === currentValue) {
                decSymbolElement.value = "Option-Dot";
                decSymbolElement.dispatchEvent(new Event("change", {bubbles: true}));
            }
        });


        // Sliders
        UI.speedSlider.addEventListener("input", () => {
            currentSpeed = roundDecimalFast(getInputNumDef(UI.speedSlider.value, 15), precisionSpeedSystem);
            UI.speedLabel.value = `${currentSpeed.toFixed(precisionSpeedSystem)}`;
        });
        UI.speedSlider.addEventListener("change", async () => isConnected ? sendCommandGeneral(`MC SET SPEEDMM ${UI.speedSlider.value}`) : null);

        UI.accelerationSlider.addEventListener("input", () => {
            currentAcceleration = roundDecimalFast(getInputNumDef(UI.accelerationSlider.value, 150), precisionAccelerationSystem);
            UI.accelerationLabel.value = currentAcceleration.toFixed(precisionAccelerationSystem);
        });
        UI.accelerationSlider.addEventListener("change", async () => isConnected ? sendCommandGeneral(`MC SET ACCELMM ${UI.accelerationSlider.value}`) : null);

        // pouze ty .data-eq, kter√© maj√≠ data-eq-type
        const experiment_result_elements = $$("[data-eq-type]");
        $ID("experimentTypeDropdown")?.addEventListener("change", async (event) => {
            // vyt√°hne typ ze suffixu hodnoty (oddƒõlovaƒçe - _ / mezera)
            const typeFrom = s =>
                (String(s || '').toLowerCase().match(/(?:^|[-_\/\s])(inb|hbr|flx)$/)?.[1]) || '';

            // rozparsuje data-eq-type na inkluze/exkluze; podporuje "HB,IB", "HB|IB", "HB IB", "HB/IB", "-HBR"
            const parseEqRule = attr => {
                const tokens = String(attr || '')
                    .split(/[,\s;|/]+/)
                    .map(t => t.trim().toLowerCase())
                    .filter(Boolean);

                const includes = new Set();
                const excludes = new Set();

                for (const t of tokens) {
                    if (t.startsWith('-')) {
                        const x = t.slice(1).trim();
                        if (x) excludes.add(x);
                    } else {
                        includes.add(t);
                    }
                }
                return {includes, excludes};
            };

            // vyhodnot√≠ shodu se zvolen√Ωm typem
            const matchesRule = (rule, selType) => {
                const hasIncl = rule.includes.size > 0;
                const hasExcl = rule.excludes.size > 0;

                if (hasIncl) {
                    return rule.includes.has(selType);
                }
                if (hasExcl) {
                    return !rule.excludes.has(selType);
                }

                return true; // Empty rule matches all
            };

            const selectedValue = (event.target.value || '').toLowerCase();
            const selectedType = typeFrom(selectedValue); // "inb" | "hbr" | "flx" | ""


            experiment_result_elements?.forEach(el => {
                const rule = parseEqRule(el.dataset.eqType);
                const isType = matchesRule(rule, selectedType);

                el.classList.toggle('undisplayed', !isType);

                if (!isType) {
                    $$('input', el)?.forEach(input => {
                        // input.value = '';
                        input.dispatchEvent(new Event("change", {bubbles: true}));
                    });
                }
            });
            // ------------------------------------------------------------------------

            requestAnimationFrame(() => {
                controlContainerWidth($ID("resultsContainer"));
            });
        });


        saveAllInputsToLocalStorage(optionsElements, storageKeyDefaults);


        // Load saved data when the page loads
        loadInputsFromLocalStorage(optionsElements, storageKeyDefaults);

        pageLoaded = true;

        setTimeout(() => window.dispatchEvent(new Event('resize', {bubbles: true})), 0);

        onLoad();
    });


    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////


    // /////// Checking for Existing Log Entries /////////

    /**
     * Checks if there are existing log entries in IndexedDB.
     * If logs exist, prompts the user to either save or delete them.
     */
    async function onLoad() {
        pageLoadTimeout = 0;

        const waitTime = 300;
        while (!(pageLoaded && dataLoaded)) {
            await sleep(waitTime);
            pageLoadTimeout += waitTime;
            if (pageLoadTimeout > 10_000) break;
        }

        if (pageLoaded && dataLoaded) {
            recomputeAll();


            const preloadScreen = $ID("preloadScreen");
            const autoConnectSetting = $ID("inputAutoConnect")?.value || 'never';

            if (autoConnectSetting === 'always' || autoConnectSetting === 'beginning') await startSerial(false);
            else await updateConnectionStatus("disconnected");

            if (timeData.length > 1) {
                console.info("\t\n‚ÑπÔ∏è %cPrevious log loaded.", "color: #0078d7; font-style: italic; font-weight: normal;");
                await logMessage("\n‚ÑπÔ∏è Found previous unsaved logged data.\n");
                alert("\n‚ÑπÔ∏è Found previous unsaved logged data.\n     It has been successfully loaded into the charts.\n\n     You can now save it as a CSV file if desired.");
                await sleep(15);
            } else {
                console.info("\t\nüÜï %cNo previous log found.", "color: #0078d7; font-style: italic; font-weight: normal;");
                $ID("experimentName").value = "";
                $ID("experimentDesc").value = "";
                await clearCalculations();
            }

            allLoaded = true;


            preloadScreen?.getBoundingClientRect(); // force reflow
            preloadScreen.style.opacity = "0";
            document.body.style.overflowY = "auto";


            preloadScreen?.addEventListener('transitionend', async () => {

                preloadScreen?.remove();

                await sleep(500);
                if (autoConnectSetting === 'ask') if (confirm('Machine found. Do you want to connect?')) await startSerial(false);

            }, {once: true});

        }
    }

    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////


</script>

<script type="text/plain">
    const overlay = document.getElementById('preloadScreen');
    window.addEventListener('load', () => {
      overlay.style.opacity = '0';
      overlay.addEventListener('transitionend', () => {
        // a≈æ teƒè (nebo rovnou remove()):
        overlay.style.pointerEvents = 'none';
        overlay.remove(); // voliteln√©
      }, { once: true });
    });
</script>

</body>
</html>
