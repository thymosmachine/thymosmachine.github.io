<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Moira controller</title>

    <!--<meta name="site-root" content="/project/">-->
    <!--<html data-root="/projekt/">-->
    <!--<base href="/project/">-->
    <base href="./"/>

    <!--
          __  __       _                          __ _
         |  \/  |     (_)                        / _| |
         | \  / | ___  _ _ __ __ _     ___  ___ | |_| |___      ____ _ _ __ ___
         | |\/| |/ _ \| | '__/ _` |   / __|/ _ \|  _| __\ \ /\ / / _` | '__/ _ \
         | |  | | (_) | | | | (_| |   \__ \ (_) | | | |_ \ V  V / (_| | | |  __/
         |_|  |_|\___/|_|_|  \__,_|   |___/\___/|_|  \__| \_/\_/ \__,_|_|  \___|


    -->
    <!-- https://patorjk.com/software/taag/#p=display&f=Big -->


    <script>
        const softwareVersion = "0.0.2.7";
        const softwareDate = "31.10.2025";

        // Initial title
        const initialTitle = 'ŒúŒø·øñœÅŒ±‚ÄáController‚Äá-‚ÄáThymos';


        document.title = initialTitle;

        // Clear console - Fresh start
        console.clear();
        console.info(`%c\n\nMoira Controller - Thymos\n`, "color: #007bff; font-size: 20px; font-weight: bold;");
        console.info(`%c\n\nVersion: ${softwareVersion} , Release-date: ${softwareDate}\n\nApp initialization: ${(new Date().toLocaleString()).replaceAll(". ", ".")}\n`, "color: gray; font-size: 12px; font-weight: normal;");


        fetch("./files/shared-header.html")
            .then(res => res.text())
            .then(html => document.head.insertAdjacentHTML("beforeend", html));
    </script>

    <!-- External libraries: -->
    <!-- uPlot -->
    <link rel="stylesheet" href="packages/external/uplot/uPlot.min.css"> <!-- Add uPlot CSS for styling -->
    <script defer src="packages/external/uplot/uPlot.iife.min.js"></script> <!-- Add uPlot JavaScript -->

    <!-- XLSX -->
    <script async src="packages/external/xlsx/xlsx.full.min.js"></script> <!-- Add XLSX (MS Excel) JavaScript -->
    <!--    <script async src="https://unpkg.com/xlsx-js-style/dist/xlsx.bundle.js"></script>-->

    <!-- ZIP -->
    <!--    <script async src="packages/external/zip/jszip.min.js"></script> &lt;!&ndash; Add JSZip JavaScript &ndash;&gt;-->
    <script async src="packages/external/zip/pako.min.js"></script> <!-- Add Pako JavaScript (for DEFLATE) -->

    <!-- KaTeX -->
    <!-- source: "https://cdn.jsdelivr.net/npm/katex@0.16.9/" -->
    <link rel="stylesheet" href="packages/external/katex/katex.min.css">
    <script defer src="packages/external/katex/katex.min.js"></script>
    <script defer src="packages/external/katex/auto-render.min.js"></script>
    <script>
        // automatic rendering: inline \( ‚Ä¶ \) a $ ‚Ä¶ $, block \[ ‚Ä¶ \]
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\(", right: "\\)", display: false},
                    // {left: "$", right: "$", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ],
                ignoredTags: ["script", "noscript", "style", "textarea", "pre", "code", "kbd", "samp"],
                ignoredClasses: ["katex", "katex-display", "no-math"],
            });
        });
    </script>


    <script>
        function unblockDebugging(unBlock = true) {
            // console.ignoredYellowBox = unBlock ? [] : ['Remote debugger'];
            // console.disableYellowBox = !unBlock;
            console.info(`%c\nDebug mode ${unBlock ? 'ON' : 'OFF'}`, "color: orange; font-size: 16px; font-weight: bold;");

            const debugWrapper = document.getElementById('debuggingWrapper');
            debugWrapper.style.display = unBlock ? 'flex' : 'none';
            document.querySelector('html').style.background = unBlock ? 'lightcoral' : 'none';


            if (unBlock) {
                // load 'scripts/testingScript.js'
                const script = document.createElement('script');
                script.src = './scripts/testingScript.js';
                script.type = 'text/javascript';
                script.type = 'text/javascript';
                document.head.appendChild(script);

            } else {
                // remove testingScript.js if exists
                const existingScript = document.querySelector('script[src="./scripts/testingScript.js"]');
                if (existingScript) {
                    existingScript.remove();
                }

                // go through all localStorage that start with 'storageKeyBase', and change 'systemLevel' to 'expert' if it's higher
                const selectorId = 'systemLevelSelect';
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(storageKeyBase)) {
                        try {
                            const data = JSON.parse(localStorage.getItem(key));
                            if (data && data[selectorId]) {
                                const levels = ['operator', 'admin', 'service', 'developer', 'god'];
                                const element = $ID(selectorId);
                                if (levels.some(level => level === data[selectorId])) {
                                    const level = 'expert';
                                    data[selectorId] = level;
                                    element.value = level;
                                    localStorage.setItem(key, JSON.stringify(data));
                                    console.info(`%c\nSystem level downgraded to ' ${level}' in localStorage key: ${key}`, "color: orange; font-size: 12px;");
                                    element.dispatchEvent(new Event('change', {bubbles: true}));
                                }
                            }
                        } catch (e) {
                            // ignore JSON parse errors
                        }
                    }
                }
            }

            const systemLevelSelect = $ID('systemLevelSelect');
            if (systemLevelSelect) {
                systemLevelSelect.querySelectorAll('option')?.forEach(option => {
                    if (option.value === 'operator') {
                        option.disabled = !unBlock;
                    } else if (option.value === 'admin') {
                        option.disabled = !unBlock;
                    } else if (option.value === 'service') {
                        option.disabled = !unBlock;
                    } else if (option.value === 'developer') {
                        option.disabled = !unBlock;
                    } else if (option.value === 'god') {
                        option.disabled = !unBlock;
                    }
                });
            }


            debugging = unBlock;
        }


        /**
         * Try to load "debug.txt" (or any URL) and evaluate if the content is "true".
         * - File do not exist / 404 / error -> false
         * - Content after trimming is "y", "yes", "true" (case-insensitive) -> true
         * - Else -> false
         */
        async function checkDebugFlag(url = './files/debug.txt', {timeoutMs = 5_000, bustCache = true} = {}) {
            // Timeout p≈ôes AbortController (protection against hanging requests)
            const controller = new AbortController();
            const t = setTimeout(() => controller.abort(), timeoutMs);

            // Optionally bust cache by adding a query parameter
            const finalUrl = bustCache ? `${url}${url.includes('?') ? '&' : '?'}_=${Date.now()}` : url;

            try {
                const res = await fetch(finalUrl, {
                    method: 'GET',
                    cache: 'no-store', // 'no-store' ensures we don't get a cached response
                    headers: {'Accept': 'text/plain'},
                    signal: controller.signal
                });

                if (!res.ok) {
                    // nap≈ô. 404 -> false
                    return false;
                }

                let text = await res.text();
                clearTimeout(t);

                // Delete BOM, trim whitespace
                text = text.replace(/^\uFEFF/, '').trim().toLowerCase();

                // true/TRUE/True atd.
                return text === 'true' || text === 'y' || text === 'yes';
            } catch (err) {
                // network error, timeout, CORS atp. -> false
                clearTimeout(t);
                return false;
            }
        }

        let debugging = false;

        (async () =>
                debugging = await checkDebugFlag() // find "debug.txt" in the main directory
        )().then(() =>
            window.addEventListener('load', () =>
                unblockDebugging(debugging)
            ));


    </script>

    <!--    <script type="text/plain" src="./scripts/appState.js"></script>-->

    <script>
        Object.defineProperty(window, "softwareVersion", {
            value: softwareVersion,
            writable: false,
            configurable: false,
            enumerable: true
        });

        async function hasInternet(timeout = 3000) {
            const ctrl = new AbortController();
            const t = setTimeout(() => ctrl.abort(), timeout);
            try {
                const res = await fetch(`./files/ping.txt?ts=${Date.now()}`, {
                    method: 'HEAD',
                    cache: 'no-store',
                    signal: ctrl.signal
                });
                return res.ok;
            } catch (err) {
                return false;
            } finally {
                clearTimeout(t);
            }
        }

        // try {
        //     // Check if the File System Access API is supported
        //     if ('showDirectoryPicker' in window) {
        //         console.info("‚úÖ File System Access API is supported.");
        //     } else {
        //         console.error("‚õî File System Access API is not supported.");
        //     }
        // } catch (error) {
        //     console.error("‚õî Error checking File System Access API support:", error);
        // }

        function compareVersions(versionA, versionB) {
            if (versionA.startsWith('v')) versionA = versionA.slice(1);
            if (versionB.startsWith('v')) versionB = versionB.slice(1);
            const a = versionA.trim().split('.').map(Number);
            const b = versionB.trim().split('.').map(Number);
            const maxLength = Math.max(a.length, b.length);

            for (let i = 0; i < maxLength; i++) {
                const numA = a[i] || 0; // missing parts are treated as 0
                const numB = b[i] || 0;

                if (numA > numB) return 1;  // A is newer
                if (numA < numB) return -1; // B is newer
            }
            return 0; // Versions are equal
        }

        let reallyOnline;


        async function loadCurrentVersion() {
            if (!reallyOnline) return;

            try {
                // Try to load the latest version of the app from the latest.txt [server]
                fetch(`./files/latest.txt?ts=${Date.now()}`, {
                    cache: "no-store"
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error("Network response was not ok");
                        }
                        return response.text();
                    })
                    .then(data => {
                        // Trim the data to remove any extra spaces or newlines and take the first line
                        const latestVersion = data.split("\n")[0].trim();
                        const appStatus = compareVersions(softwareVersion, latestVersion);

                        if (appStatus === 0) {
                            console.info("%c\n\tüîß\tApp is upto date!", "color: blue; font-weight: bold;");
                        } else if (appStatus === 1) {
                            console.warn("%c\n\tüîß\tAvailable version is older than App!", "color: red; font-weight: bold;");
                        } else {
                            console.info("%c\n\tüîß\tNew version is available!", "color: orange; font-weight: bold;");
                        }

                        if (appStatus !== 0) {
                            document.getElementById("updateHeader").style.visibility = "visible";
                            document.getElementById("updateHeaderVersion").innerText = `[from: v${softwareVersion} to v${latestVersion}]`;
                        }
                    })
                    .catch(error => {
                        console.error("‚õî Error fetching latest version:", error);
                    });
            } catch (error) {
                console.error("‚õî Error checking File System Access API support:", error);
            }
        }

        // is online?
        document.addEventListener("DOMContentLoaded", async () => { // TODO: do async or window.onload ?
            reallyOnline = await hasInternet();
            if (reallyOnline) {
                console.info("%cüì∂ Ping successful. User is Online! üåê", "color: blue; font-weight: bold;");

                document.getElementById("softwareInfo").innerText = `v${softwareVersion} , ${softwareDate}`;

                await loadCurrentVersion();
            } else {
                console.info("%cüì¥ Offline.", "color: gray; font-weight: bold;");
            }
        });
    </script>


    <style>
        :root {
            --blue-dark-color: #004aa6;
            --blue-color: #007bff;
            --blue-lighter-color: #2196F3;
            --blue-light-color: #4CA2FF;
            --blue-lighest-color: #4bbae0;
            --green-color: #28a745;
            --green-light-color: #68C17C;
            --green-lighter-color: #90EE90;
            --red-color: #dc3545;
            --red-light-color: #E6717C;
            --red-lighter-color: #FFB6C1FF;
            --yellow-color: #FFD580;
            --orange-color: #ffc107;
            --darkorange-color: #FF8C00;
            --cyan-color: #17a2b8;
            --cyan-light-color: #3FC1E8;
            --cyan-lighter-color: #87CEEB;
            --purple-color: #6f42c1;
            --purple-light-color: #9B59B6;
            --purple-lighter-color: #D2B4DE;
            --pink-color: #e83e8c;
            --pink-light-color: #FF69B4;
            --pink-lighter-color: #FFB6C1;
            --light-color: #f8f9fa;
            --mid-color: #e9ecef;
            --mid-dark-color: #adb5bd;
            --dark-color: #ced4da;
            --dark-light-color: #495057;
            --darker-color: #343a40;
            --gray-color: #6c757d;


            --progressPrimary-color: linear-gradient(to right, var(--cyan-lighter-color), var(--cyan-light-color), var(--cyan-color)); /* Blue color for secondary progress */
            --progressSecondary-color: linear-gradient(to right, var(--purple-lighter-color), var(--purple-light-color), var(--purple-color)); /* Blue color for primary progress */
            --progressOnHold-color: linear-gradient(to right, var(--blue-light-color), var(--blue-lighter-color), var(--blue-color), var(--blue-dark-color)); /* Green color for completed progress */
            --progressDone-color: linear-gradient(to right, var(--green-lighter-color), var(--green-light-color), var(--green-color)); /* Green color for completed progress */
            --progressStoppedcolor: linear-gradient(to right, var(--yellow-color), var(--orange-color), var(--darkorange-color)); /* Green color for ongoing progress */
            --progressError-color: linear-gradient(to right, var(--red-lighter-color), var(--red-light-color), var(--red-color)); /* Red color for error progress */

            --progressColor: var(--progressPrimary-color); /* --blue-color // --orange-color  ///   linear-gradient(to right, #FFD580, #FF8C00) */

            --radius: 10px;

            --inputLabelWidth: 275px;
            --inputMinWidth: 230px;
            --gap: 10px;
        }


        html * { /* TODO: move to individual elements to not over-spam it */
            transition: color 0.3s, background 0.3s, background-color 0.3s, border-color 0.3s, box-shadow 0.3s;
            will-change: color, background, background-color, border-color, box-shadow; /* Optimize effects */
            /*scroll-behavior: smooth;*/
        }

        body[data-theme="light"] {
            --page-bg: white;
            --color-bg: var(--mid-color);
            --containers-bg: var(--dark-color);

            --chart-text: black;
            --charts-bg: #e6e6e6;
            --charts-bg-active: white;
            --chart-border: lightgray;

            --text-color: black;
            --text-info-1-color: var(--blue-lighter-color);
            --text-info-2-color: var(--blue-dark-color);
            --text-info-3-color: var(--blue-dark-color);

            --slider-bg: #ddd;
            --slider-fg: var(--blue-color);
            --slider-btn: var(--blue-dark-color);
            --input-bg: white;
            --button-color: #f0f0f0;
            --button2-color: var(--blue-color);
            --logBtn-bg: var(--gray-color);
            --border-color: darkgray;
            --headerPanel-color: darkgray;
            --progress-bg: #eee;

            --regular-log-color: darkgray;
            --loading-log-color: #323232;
            --command-log-color: #f5f5f5;


            --startEpx-bg: lightblue;
            --startEpx-color: var(--blue-color);
            --stopEpx-bg: lightpink;
            --stopEpx-color: var(--red-color);
            --returnEpx-bg: lightgray;
            --returnEpx-color: black;

            --error-color: var(--red-color);
            --warning-color: var(--darkorange-color);

            --logo-main: var(--blue-color);
            --logo-second: var(--page-bg);

            --highligth: rgba(255, 255, 255, 0.5);
            --shadow: rgba(0, 0, 0, 0.2);
        }

        body[data-theme="dark"] {
            /*--page-bg: var(--darker-color);*/
            /*--color-bg: var(--dark-light-color);*/
            /*--containers-bg: var(--gray-color);*/
            /*--charts-bg: var(--gray-color);*/
            /*--charts-bg-active: var(--mid-dark-color);*/
            /*--text-color: white;*/
            /*--slider-bg: var(--mid-dark-color);*/
            /*--input-bg: var(--mid-dark-color);*/
            /*--button-color: var(--mid-dark-color);*/
            /*--button2-color: var(--blue-color);*/
            /*--logBtn-bg: var(--dark-light-color);*/
            /*--border-color: var(--gray-color);*/
            /*--headerPanel-color: var(--gray-color);*/

            --page-bg: #181818;
            --color-bg: #212121;
            --containers-bg: #303030;

            --chart-text: black;
            --charts-bg: #262626;
            --charts-bg-active: #353535;
            --chart-border: #4e4e4e;

            --text-color: #b4b4b4;
            --text-info-1-color: #4e4e4e;
            --text-info-2-color: black;
            --text-info-3-color: var(--blue-lighest-color);

            --slider-bg: #4e4e4e;
            --slider-fg: #303030;
            --slider-btn: #212121;
            --input-bg: #4e4e4e;
            --button-color: #4e4e4e;
            --button2-color: var(--dark-light-color);
            --logBtn-bg: var(--dark-light-color);
            --border-color: #303030;
            --headerPanel-color: var(--gray-color);
            --progress-bg: var(--gray-color);

            --regular-log-color: #4e4e4e;
            --loading-log-color: #181818;
            --command-log-color: #212121;

            --startEpx-bg: var(--blue-light-color);
            --startEpx-color: lightblue;
            --stopEpx-bg: var(--red-light-color);
            --stopEpx-color: lightpink;
            --returnEpx-bg: var(--gray-color);
            --returnEpx-color: #181818;

            --error-color: var(--red-color);
            --warning-color: var(--darkorange-color);

            --logo-main: var(--blue-light-color);
            --logo-second: var(--page-bg);

            --highligth: rgba(255, 255, 255, 0.2);
            --shadow: rgba(0, 0, 0, 0.4);
        }

        body[data-system-level="god"] {
            --logo-main: var(--orange-color);
            --logo-second: var(--page-bg);
        }

        body[data-system-level="developer"] {
            --logo-main: var(--purple-light-color);
            --logo-second: var(--page-bg);
        }

        body[data-system-level="service"] {
            --logo-main: var(--cyan-color);
            --logo-second: var(--page-bg);
        }

        body[data-system-level="operator"] {
            --logo-main: var(--pink-color);
            --logo-second: var(--page-bg);
        }

        body[data-system-level="admin"] {
            --logo-main: var(--red-color);
            --logo-second: var(--page-bg);
        }

        body[data-theme="light"] {
            --logo-bg: var(--logo-second);
            --logo-fg: var(--logo-main);
            --logo-text: var(--logo-main);

        }

        body[data-theme="dark"] {
            --logo-bg: var(--logo-main);
            --logo-fg: var(--logo-second);
            --logo-text: var(--logo-main);
        }

        /* General styling for the body */
        body {
            font-family: Arial, sans-serif;
            min-width: 730px;
            padding: 5px 20px 10px;
            border-radius: 1em;
            background: var(--page-bg);
            color: var(--text-color);
            overflow-x: hidden;
            overflow-y: hidden;
            margin: 10px;
        }

        *:disabled {
            background-color: #f0f0f0;
            color: #888;
            cursor: not-allowed;
        }

        .u {
            text-decoration: underline;
            text-underline-offset: 0.1em; /* offset from text */
            text-decoration-thickness: 0.1em; /* line thickness */
            text-decoration-color: color-mix(in srgb, var(--text-color), white 50%); /* line color */
            text-decoration-skip-ink: auto; /* avoid descenders from letters */
        }

        .err {
            color: var(--error-color) !important;
        }

        .warn {
            color: var(--warning-color) !important;
        }

        .insetShadow {
            box-shadow: inset 2px 2px 3px rgba(0, 0, 0, 0.2), inset -2px -2px 5px rgba(0, 0, 0, 0.15);
        }

        .outsetShadow {
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.15), 0 0 5px rgba(0, 0, 0, 0.35);
        }

        /* Button styling for spacing and cursor behavior */
        button {
            padding: 5px;
            cursor: pointer;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            font-size: 14px;
            background: var(--button-color);

            color: color-mix(in srgb, var(--text-color) 10%, black);

            box-shadow: inset 2px 2px 5px var(--highligth), inset -2px -2px 3px var(--shadow);

            will-change: filter, transform, background, color, box-shadow, border; /* Optimize for hover/active effects */
            transition: filter 0.2s, transform 0.2s, background 0.3s, color 0.3s, box-shadow 0.3s, border 0.3s;
        }

        /* When the button is hovered */
        button:not(:disabled):hover {
            filter: brightness(1.15); /* 15% brighter */
            transform: scale(1.05); /* Slightly larger */
            z-index: 4;
        }

        /* When the button is clicked */
        button:not(:disabled):active {
            filter: brightness(0.85); /* 15% darker */
            transform: scale(0.95); /* Slightly smaller */
            box-shadow: inset 2px 2px 3px rgba(0, 0, 0, 0.35), inset -2px -2px 3px rgba(0, 0, 0, 0.2);
        }

        /* Styling for textAreas used for user input */
        textarea {
            resize: none; /* Disables resizing */
            overflow: auto;
            border: none;
        }

        input, select, .textareaWrapper {
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 0 6px;
        }

        input:not([type="checkbox"]), select, textarea {
            background: var(--input-bg);
            min-height: 34px;
            box-sizing: border-box;

            font-family: Arial, sans-serif;
            font-size: 13px;
            font-weight: normal;

            color: var(--text-color);
            box-shadow: inset 2px 2px 3px rgba(0, 0, 0, 0.15), inset -2px -2px 3px rgba(0, 0, 0, 0.1);
        }

        input[type="checkbox"] {
            accent-color: var(--blue-color);
        }

        label {
            pointer-events: none; /* makes labels unselectable */
        }

        pre {
            white-space: pre-wrap; /* Preserves \n and multiple spaces, but allows wrapping */
            overflow-wrap: break-word; /* Primarily breaks at spaces, long words only when necessary */
            word-break: normal; /* Don't break words unnecessarily (let CJK behave normally) */
            hyphens: auto; /* optional: adds hyphenation */
        }

        .textareaWrapper {
            display: flex;
            background: var(--input-bg);
            width: -webkit-fill-available;
            height: min-content;
            padding: 4px;
            overflow: hidden;
            box-shadow: inset 2px 2px 3px rgba(0, 0, 0, 0.15), inset -2px -2px 3px rgba(0, 0, 0, 0.1);
        }

        .textareaWrapper:not(:disabled):focus-within {
            outline: 2px solid black;
            outline-offset: -2px;
            box-shadow: 0 0 0 1px var(--input-bg);
        }

        .textareaWrapper textarea {
            width: 100%;
            padding: 3px 7px;
            box-shadow: none;
            background: transparent;
        }

        .textareaWrapper textarea:not(:disabled):focus {
            outline: none;
        }

        /* Disabled elements styling */
        .prohibited, .disabled, .prohibited *, .disabled * {
            cursor: not-allowed !important;
            -webkit-user-select: none !important; /* Safari */
            -moz-user-select: none !important; /* Firefox */
            -ms-user-select: none !important; /* IE/Edge */
            user-select: none !important; /* Disables text selection */
            pointer-events: none !important; /* Prevents interaction */
            outline: none !important;
        }

        .prohibited, .disabled {
            opacity: 0.5;
        }

        .undisplayed {
            display: none !important;
        }

        .invisible {
            visibility: hidden !important;
        }


        .sizeableContainer {
            overflow: hidden;
            content-visibility: auto;

            display: block;
            width: 95%;
            padding: 5px 15px 20px 15px;
            justify-self: center;
            justify-content: center;

            max-height: 0;
            opacity: 0;
            transition: max-height 0.5s ease, opacity 0.45s; /* Animation */
            will-change: display, max-height, opacity, visibility, content-visibility, overflow; /* Optimize for animations */
        }

        .input-group {
            display: inline-flex;
            gap: var(--gap); /* Space between inputs and labels */
            white-space: nowrap; /* Prevents wrapping */
            padding-left: 20px;
            align-items: center;
            width: calc(var(--inputLabelWidth) + var(--inputMinWidth) + var(--gap)); /* Total width of the group */
            will-change: display, visibility; /* Optimize for show/hide */
        }

        .input-group label {
            flex-shrink: 0; /* Prevents shrinking */
            text-align: right;
            width: var(--inputLabelWidth); /* Label width */
            white-space: normal; /* Allows wrapping if necessary */
        }

        .input-group input {
            height: 25px;
        }

        .input-group input[type="number"], .input-group input[type="text"], .input-group select {
            flex-grow: 1; /* Input will grow if there is space */
            justify-self: left;
            width: -webkit-fill-available;
        }

        input[type="checkbox"] {
            transform: scale(1.5); /* Scale the checkbox to 1.5 */
            margin: 5px; /* Space around the checkbox */
            width: 16px;
            height: 16px;
            aspect-ratio: 1/1; /* Keep it square */
        }

        .input-group select {
            font-family: monospace;
            font-weight: bold;
            font-size: 16px;
        }

        h3 {
            position: relative;
            margin-top: 20px;
            margin-bottom: 5px;
            align-self: flex-start;
        }

        h4 {
            position: relative;
            margin-top: 5px;
            margin-bottom: 5px;
        }


        hr {
            width: 100%;
            margin: 20px auto;
            border: 1px solid gray;
        }


        .headerContainer {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            gap: var(--gap);
        }

        #nameHeader {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: var(--gap);
            margin-bottom: 5px;
        }

        #updateHeader {
            visibility: hidden;

            font-weight: bold;
            display: flex;
            flex-direction: column;
            color: var(--headerPanel-color);
            font-size: 12px;
            text-align: right;
        }

        .statusContainer {
            gap: var(--gap);
            display: flex;
            flex-wrap: wrap;
            justify-self: center;
            justify-content: center;
            align-items: center;
            flex-direction: column;

            background: var(--color-bg);
            padding: 10px 20px;
            border-radius: var(--radius);
        }

        .graphContainer {
            display: flex;
            width: 100%;
            max-width: 1600px;
            flex-direction: column;
            margin-top: 50px;
            margin-bottom: 50px;
            align-items: center;
            justify-self: center;
            padding: 20px;
            background: var(--color-bg);
            border-radius: 10px;
        }

        .sectionTitle {
            margin-top: 0;
        }

        .inlineDiv {
            display: inline-flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: calc(var(--gap) * 2.5);
        }

        .inlineDiv .inlineDiv {
            gap: calc(var(--gap));
        }

        #inputNumBaudRate {
            padding: 5px;
            width: 140px;
            height: 50px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        #connectionStatus {
            font-weight: bold;
            color: gray;
        }

        .graphBtnWrapper {
            display: flex;
            gap: var(--gap);
        }

        .connectBtn {
            padding: 5px 20px;
            height: 50px;
            width: 180px;
            min-width: 160px;
            will-change: display, visibility; /* Optimize for show/hide */
        }

        .btnGraph {
            display: flex;
            min-width: 100px;
            height: 50px;
            padding: 20px;
            align-items: center;
            justify-content: center;
        }

        #thymosLogo {
            width: 50px;
            height: 50px;
        }

        #chartsWrapper {
            width: 100%;
            min-height: min-content;
            gap: 20px;

            color: var(--chart-text);
            background: var(--charts-bg);
            border-radius: 10px;
            border: 2px solid var(--chart-border);
            padding: 1em 0.5em 2em;
            margin: 15px 0 10px;
        }

        #chartsContainer, #chartsInfoContainer {
            display: flex;
            justify-content: space-between;
            width: 100%;
            min-height: min-content;
            gap: 20px;
        }

        #chartsInfoContainer {
            margin-top: calc(3 * var(--gap));
            justify-content: space-around;
        }


        .chart {
            width: 49%;
            height: 400px;
        }

        /*.chartWrapper {*/
        /*    display: flex;*/
        /*    width: 49%;*/
        /*    height: fit-content;*/
        /*    flex-direction: column;*/
        /*    gap: max(calc(var(--gap) * 2.5), 25px);*/
        /*    justify-content: center;*/
        /*    align-items: center;*/
        /*}*/

        /*.chart {*/
        /*    display: flex;*/
        /*    width: 100%;*/
        /*    height: fit-content;*/
        /*    max-height: 400px;*/
        /*}*/


        #controlContainer {
            display: inline-flex;
            flex-wrap: wrap;
            column-gap: 30px;
            width: 100%;
            justify-content: center;
        }

        .controlBtn.moveBtnLeft, .controlBtn.moveBtnRight {
            position: relative;
            touch-action: none;
            background: var(--button2-color);
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
            justify-content: center;
            border-radius: 50vh 0 0 50vh;
            min-width: 0;
            width: 100px;
            height: 50px;
            border: none;
            transform: translateX(1px);
            z-index: 3;

            box-shadow: inset 2px 2px 5px var(--highligth), inset 0 -2px 3px var(--shadow);
        }

        #moveMachineUP {
            padding-top: .2rem; /* smaller in top */
            padding-bottom: .8rem; /* larger at bottom */
        }

        #moveMachineDOWN {
            padding-top: .6rem; /* larger on top */
            padding-bottom: .4rem; /* smaller at bottom */
        }


        .controlBtn.moveBtnRight {
            border-radius: 0 50vh 50vh 0;
            font-size: 16px;
            width: 65px;
            font-style: italic;
            transform: translateX(-1px);
            z-index: 2;

            box-shadow: inset 0 2px 5px var(--highligth), inset -2px -2px 3px var(--shadow);
        }


        .movementWrapper {
            /*background: var(--button2-color);*/
            border-radius: 50vh;
            position: relative;
            display: flex;
        }

        .controlBtn.moveBtnRight:not(:disabled):hover {
            transform: scale(1.05) translateX(calc((65px * (0.05 / 2))));
        }

        .controlBtn.moveBtnLeft:not(:disabled):hover {
            transform: scale(1.05) translateX(calc((100px * (-0.05 / 2)) + 2px));
        }

        .controlBtn.moveBtnRight:not(:disabled):active {
            transform: scale(0.9) translateX(calc((65px * (-0.1 / 2)) - 1px));
        }

        .controlBtn.moveBtnLeft:not(:disabled):active {
            transform: scale(0.9) translateX(calc((100px * (0.05 / 2)) + 5px));
        }


        /* vertical line left from 10% to 90% height */
        .movementWrapper::before {
            content: "";
            position: absolute;
            left: calc(100px - 1px / 2); /* exactly on the left edge */
            top: 15%;
            bottom: 15%; /* => height = 70 % */
            width: 3px; /* line width */
            background: var(--text-info-2-color); /* or #0ea5e9 */
            border-radius: 2px; /* nice ending */
            pointer-events: none;
            z-index: 6;
        }


        .controllerBtn {
            touch-action: none;
            background: var(--button2-color);
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            justify-content: center;
            border-radius: var(--radius);
            border: none;
        }

        .machineControlContainer {
            display: flex;
            flex-direction: column;
            width: fit-content;
            gap: 15px;
            align-items: center;
            justify-content: center;
            margin-top: 20px;

            background: var(--containers-bg);
            border-radius: var(--radius);
            padding: 20px;
        }

        .btnControlWrapper {
            display: flex;
            flex-direction: row;
            width: 100%;
            gap: var(--gap);
            align-items: center;
            justify-content: left;
        }

        .controlBtn {
            display: flex;
            height: 50px;
            width: clamp(100px, 170px, 200px);
            padding: 20px;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            will-change: display, visibility; /* Optimize for show/hide */
        }

        #startExperiment {
            background: var(--startEpx-bg);
            color: var(--startEpx-color);
            border-color: color-mix(in srgb, var(--startEpx-color) 30%, transparent);
            min-width: fit-content;
        }

        #stopMachine {
            background: var(--stopEpx-bg);
            color: var(--stopEpx-color);
            border-color: color-mix(in srgb, var(--stopEpx-color) 30%, transparent);
            min-width: fit-content;
        }

        #returnPositionExperimentBtn {
            background: var(--returnEpx-bg);
            color: var(--returnEpx-color);
            border-color: color-mix(in srgb, var(--returnEpx-color) 30%, transparent);
            min-width: 210px;
        }

        #experimentProgress {
            flex-grow: 1;
            max-width: 460px;
            min-width: 50px;
            height: 15px;
            appearance: none; /* reset of style */
        }

        /* For Chrome, Edge (outer frame of progressbar) */
        progress::-webkit-progress-bar {
            background-color: var(--progress-bg); /* background color */
            border-radius: calc(15px / 2); /* roundness to 50% */
            border: 1px solid var(--border-color);
            box-shadow: inset 2px 2px 3px var(--shadow);
            transition: background 0.3s ease;
            overflow: hidden;
        }

        /* For Chrome, Edge (internal infill part of progressbar) */
        progress::-webkit-progress-value {
            background: var(--progressColor); /* infill color */
            box-shadow: inset 2px 2px 3px var(--shadow);
            border-radius: calc(15px / 2);
            transition: background 0.3s ease;
            overflow: hidden;
        }

        /* For Firefox (internal infill part of progressbar) */
        progress::-moz-progress-bar {
            background: var(--progressColor); /* infill color */
            box-shadow: inset 2px 2px 3px var(--shadow);
            border-radius: calc(15px / 2);
            transition: background 0.3s ease;
            overflow: hidden;
        }

        #experimentProgressLabel {
            font-size: 15px;
            display: inline-block;
            min-width: 65px; /* or fixed width */
            text-align: center; /* optional */
        }

        #progressWrapper {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--gap);
            flex-grow: 1;
            width: 100%;
            min-width: 50px;
            padding-left: 5px;
        }

        .experimentContainer {
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: var(--gap);
            left: 0;
            justify-self: center;
            align-items: center;
            width: 100%;
            max-width: 1300px;

            background: var(--color-bg);
            border-radius: var(--radius);
        }

        .appSelector {
            min-width: 200px;
            width: max-content;
            height: 50px;
        }

        #experimentInputsContainer {
            display: grid;
            grid-template-columns: max-content minmax(min-content, 1fr) min-content;
            grid-auto-rows: auto;
            max-width: 1200px;
            width: 100%;
            min-width: 300px;
            gap: var(--gap);
            justify-items: left;
        }

        #experimentName, #experimentCount {
            flex-grow: 1;
            /*height: 24px;*/
            height: 44px;
            padding: 0 10px;
            /*background: lightgray;*/
        }

        #experimentCount {
            max-width: 65px;
            box-sizing: border-box; /* THIS IS THE MAGIC */
        }

        #convertCSV {
            height: 56px;
        }

        #experimentDesc {
            height: 46px;
        }

        #experimentBtnsWrapper {
            display: flex;
            width: fit-content;
            flex-direction: column;
            gap: var(--gap);
        }

        #saveDataBtn {
            width: 150px;
            height: 44px;
        }

        #convertCSV {
            width: 150px;
        }

        .openingContainer {
            position: relative;
            display: flex;
            align-items: flex-start;
            width: 100%;
            background: var(--containers-bg);
            border-radius: calc(1px + 10px);
            border: 1px solid var(--border-color);
        }

        .openingContainerBtn {
            padding: 10px;
        }

        .inputsContainer, #machSettings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(calc(var(--inputLabelWidth) + var(--inputMinWidth) + var(--gap) + 20px + 5px), 1fr)); /* Dynamic grid */
            grid-auto-rows: auto;
            overflow: hidden;
            width: -webkit-fill-available;
            gap: var(--gap);
            justify-items: center;
        }

        /* prvek p≈ôes celou ≈°√≠≈ôku gridu v obou kontejnerech */
        .inputsContainer > #machSettings {
            grid-column: 1 / -1; /* od prvn√≠ho po posledn√≠ sloupec */
            max-width: 100%;
        }

        .inputsContainer .katex-display {
            margin: 0;
        }

        .katex-display, .katex-display * {
            transition: none !important;
        }


        .inputsContainer button {
            width: 80%;
            max-width: 200px;
        }


        .autoGrid {
            grid-template-columns: repeat(auto-fit, minmax(max-content, 1fr));
            grid-auto-rows: auto;
            justify-items: center;
        }

        .innerInputLabel {
            min-width: fit-content;
            width: 125px !important;
        }

        .innerInput {
            min-width: 25px;
        }

        #inputInitialForceLabel {
            width: 100px;
        }

        #clearStorageButton {
            padding: 20px;
        }

        #regularLog, #loadingLog, #commandInput {
            padding: 10px;
        }

        #consoleWrapper {
            display: grid;
            grid-template-columns: 1fr;
            grid-auto-rows: auto;
            gap: var(--gap);
            width: 100%;
            padding-top: 15px;
        }

        #regularLogWrapper {
            min-width: 300px;
            width: 100%;
            flex-grow: 1;
            height: 200px;
            background: var(--regular-log-color);
            border: 2px solid var(--regular-log-color);
            margin: 0;
            border-radius: 10px;
            overflow: hidden;
            font-size: 12px;
        }

        #regularLog {
            width: -webkit-fill-available;
            height: -webkit-fill-available;
            overflow-y: auto;
            box-sizing: border-box;
            margin: 0;
        }

        #loadingLog {
            width: 100%;
            min-width: 300px;
            height: 80px;
            background: var(--loading-log-color);
            border-radius: 10px;
            margin: 0;
        }

        .logContainer {
            display: flex;
            width: 100%;
            flex-direction: row;
            gap: var(--gap);
        }

        .logBtn {
            height: -webkit-fill-available;
            min-width: 150px;
            background: var(--logBtn-bg);
            color: white;
        }

        #commandInput {
            width: 100%;
            min-width: 300px;
            height: 40px;
            border: none;
            background: var(--command-log-color);
            border-radius: 10px;

            padding: 7px 10px;
            font-size: 16px;
            font-family: monospace;

        }

        input[type="range"] {
            accent-color: #007bff; /* zmƒõna barvy na modrou (nov√© prohl√≠≈æeƒçe) */
            box-shadow: inset 2px 2px 5px var(--highligth), inset -2px -2px 3px var(--shadow);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: var(--slider-bg);
            border-radius: 3px;
            outline: none;
            /*border: none;*/
        }

        /* Styl pro slider track (Chrome, Safari) */
        input[type="range"]::-webkit-slider-runnable-track {
            background: var(--slider-fg);
            height: 6px;
            border-radius: 2px;
        }

        /* Styl pro slider thumb (Chrome, Safari) */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 25%;
            background: var(--slider-btn);
            cursor: pointer;
            margin-top: -5px;
        }

        /* Firefox: track */
        input[type="range"]::-moz-range-track {
            /*background: #007bff;*/
            height: 6px;
            border-radius: 3px;
        }

        /* Firefox: thumb */
        input[type="range"]::-moz-range-thumb {
            background: var(--slider-btn);
            height: 16px;
            width: 16px;
            border-radius: 25%;
            cursor: pointer;
        }

        .sliderInputLabel {
            display: flex;
            align-items: center;
            min-width: 1.5em;
            max-width: 4.5em;
            border: 1px solid transparent;
            font-size: 16px !important;
            text-align: right !important;
            color: var(--text-info-2-color) !important;
            font-weight: bold !important;
            background: none !important;
            box-shadow: none !important;
        }

        .sliderInputLabel:not(:disabled):hover {
            cursor: pointer;
            color: var(--text-info-2-color) !important;;
            background: var(--input-bg) !important;
            border: 1px solid var(--border-color);
        }


        .sliderInputLabel:not(:disabled):focus {
            outline: none;
            color: var(--text-color) !important;;
            background: var(--input-bg) !important;
            border: 1px solid var(--text-info-2-color);
        }

        .sliderInputLabel::-webkit-outer-spin-button,
        .sliderInputLabel::-webkit-inner-spin-button {
            -webkit-appearance: none;
        }

        #positionWrapper {
            width: 0.1rem; /* tlou≈°≈•ka ƒç√°ry */
            height: 14px;
            background: black;
            opacity: 65%;
            border-radius: 2px;
            pointer-events: none;
            z-index: 5;
        }

        button {
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important; /* Safari */
            -moz-user-select: none !important; /* Firefox */
            -ms-user-select: none !important; /* IE/Edge */
            user-select: none !important;
        }

        .units-text {
            font-size: 14px;
            color: #4f4f4f;
        }


    </style>


    <style>
        /* ========== BASE: shared wrapper of action pills ========== */
        .action-wrap, .copy-wrap { /* '.copy-wrap' left for backward compatibility */
            position: relative;
            display: inline-flex;
            flex-grow: 1;
            max-width: 230px;
            will-change: display, visibility, opacity; /* Optimize for show/hide */
        }

        .action-wrap {
            will-change: box-shadow;
        }

        /* Base of pills (copy / set) */
        .action-pill,
        .copy-pill, .adjust-pill { /* compatibility: copy/adjust made from action-pill */
            height: clamp(24px, 80%, 40px) !important;
            aspect-ratio: 1/1 !important;
            width: auto !important;

            position: absolute;
            top: 50%;
            right: 5px;
            transform: translateY(-50%) !important;
            z-index: 9999;

            border: 0;
            padding: 6px;
            border-radius: 9999px;

            background: rgba(255, 255, 255, .55);
            -webkit-backdrop-filter: blur(6px);
            backdrop-filter: blur(6px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, .1);

            cursor: pointer;
            line-height: 0;

            opacity: 0;
            pointer-events: none;

            will-change: display, opacity, background, transform;
            transition: opacity .15s ease, display .15s ease, background .2s ease, transform .1s ease;
        }

        .action-pill:hover {
            background: rgba(255, 255, 255, .7);
            transform: translateY(-50%) !important;
        }

        .action-pill:active {
            transform: scale(.95) translateY(calc(-50% + 1px)) translateX(1px) !important;
        }

        .action-wrap:hover .action-pill,
        .action-pill.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .action-pill.hidden {
            display: none !important;
        }

        /* Icons inside pills (deff: hide or show) */
        .action-pill svg {
            display: none;
            width: 100%;
            height: 100%;
        }

        /* COPY: gray/OK/ERR */
        .copy-pill[data-state="idle"] .icon-copy {
            display: block;
            stroke: #6b7280;
        }

        .copy-pill[data-state="ok"] .icon-check {
            display: block;
            stroke: #22c55e;
        }

        .copy-pill[data-state="err"] .icon-x {
            display: block;
            stroke: #ef4444;
        }

        /* ADJUST: gray/OK/ERR */
        .adjust-pill[data-state="idle"] .icon-wand {
            display: block;
            stroke: #3b82f6;
        }


        .adjust-pill[data-state="set"] .icon-wand {
            display: block;
            stroke: #6b7280;
        }

        .adjust-pill[data-state="diff"] .icon-wand {
            display: block;
            stroke: #ff8c00;
        }

        .adjust-pill[data-state="ok"] .icon-check {
            display: block;
            stroke: #22c55e;
        }

        .adjust-pill[data-state="err"] .icon-x {
            display: block;
            stroke: #ef4444;
        }

        /* Visual feedback inside the wrapper on hover (only when not focused/action) */
        .action-wrap:hover > .copyableInput:not(:focus):not(.action-ok):not(.action-err) {
            outline: none;
            box-shadow: inset 0 0 0 2px #3b82f6;
            transition: box-shadow .1s ease;
        }

        .action-wrap.has-auto:hover > .adjustableInput:not(:focus):not(.action-ok):not(.action-err) {
            outline: none;
            box-shadow: inset 0 0 0 2px #6b7280;
            transition: box-shadow .1s ease;
        }

        /* post-action */
        .action-wrap > .action-ok {
            outline: none;
            box-shadow: inset 0 0 0 2px #22c55e;
            transition: box-shadow .1s ease;
        }

        .action-wrap > .action-err {
            outline: none;
            box-shadow: inset 0 0 0 2px #ef4444;
            transition: box-shadow .1s ease;
        }

        /* Helper utility */
        .data-eq {
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
    </style>

    <style>
        @media (max-width: 989px) {
            label[for="movementSpeed"], label[for="movementAcceleration"] {
                min-width: 120px !important;
            }
        }

        @media (max-width: 1178px) {
            #controlContainerExp {
                max-width: 100% !important;
            }

            #controlContainerMove {
                width: 100% !important;
            }
        }
    </style>

    <style>
        #preloadScreen {
            position: fixed;
            inset: 0; /* top:0; right:0; bottom:0; left:0 */
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-flow: column;
            gap: 5%;
            background: #181818;
            justify-content: center;
            align-items: center;
            z-index: 999;
            -webkit-user-select: none !important; /* Safari */
            -moz-user-select: none !important; /* Firefox */
            -ms-user-select: none !important; /* IE/Edge */
            user-select: none !important; /* Disables text selection */
            pointer-events: auto; /* Prevents interaction */
            color: lightgray;
            font-weight: bold;
            text-align: center;
            font-size: 2em;
            content-visibility: auto;
            opacity: 1;
            will-change: display, opacity, visibility;
            transition: opacity 0.5s;
        }

        .loading {
            display: inline-flex;
            align-items: center;
            gap: 1.2rem;
            font: 1.2em/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        }

        .svg-spinner {
            width: 1em;
            height: auto;
            aspect-ratio: 1/1;

            transform-box: fill-box; /* Firefoxu */
            will-change: transform; /* optimize for animation, creates own layer */
            animation: spin .8s linear infinite;
            transform-origin: center; /* rotate around center */
        }

        @keyframes spin {
            to {
                transform: rotate(1turn);
            }
        }

        /* Respekt k omezen√≠ pohybu */
        @media (prefers-reduced-motion: reduce) {
            .svg-spinner {
                animation: none;
            }
        }
    </style>

</head>

<body>


<div id="preloadScreen"
     tabindex="-1">
    <noscript>
        <div style="color: red;">
            JavaScript is disabled in your browser. Please enable it to use this application.
        </div>
    </noscript>

    <svg style="width:10%; height: auto; aspect-ratio: 1/1" viewBox="0 0 177.81437 177.9034"
         xmlns="http://www.w3.org/2000/svg">
        <g transform="translate(225.12939,129.3157)">
            <path fill="lightgray" stroke="lightgray" stroke-width="4.63292"
                  d="m -183.53862,7.9393313 0.37992,-28.6806303c -3.46806,-0.838763 -6.47358,-2.670752 -8.82206,-5.154387 -3.35392,-3.546427 -5.32276,-8.431072 -5.32276,-13.618672v -30.30165c 0,-9.89763 4.27076,-21.98757 12.85714,-30.761632 6.93867,-7.09086 16.65032,-12.05614 29.13465,-12.05614h 67.983775l 11.83638,83.692256 -18.4011,0.0017v 60.189316l -3.79175,0.439257c -0.15191,0.02838 -53.466715,6.885861 -53.466715,-57.521684h 8.55402c 0,44.888568 29.48901,49.136615 40.15129,49.207313v -60.833856h 17.131595l -9.42174,-66.617732h -60.575755c -9.92062,0 -17.59527,3.90532 -23.05376,9.483912 -6.93498,7.08604 -10.38374,16.82239 -10.38374,24.78041v 30.30165c 0,2.99757 1.10511,5.78559 2.98196,7.77034 1.70875,1.80842 4.10749,2.95469 6.91965,2.95469h 4.31732l -0.4861,36.8294603 -8.52222,-0.102216 z"
            />
            <path fill="lightgray" stroke="lightgray" stroke-width="4.63292"
                  d="m -115.91317,-44.595488c 5.72369,0 10.36216,-4.63847 10.36216,-10.36102 0,-5.72256 -4.63847,-10.3613 -10.36216,-10.3613 -5.72255,0 -10.36102,4.63874 -10.36102,10.3613 0,5.72255 4.63847,10.36102 10.36102,10.36102"
            />
        </g>
    </svg>

    <!--  Rotating loading element   -->
    <div class="loading" role="status" aria-live="polite" aria-label="Loading">
        <svg class="svg-spinner" viewBox="0 0 24 24" width="16" height="16" aria-hidden="true">
            <circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="3" opacity=".25"/>
            <path d="M22 12a10 10 0 0 1-10 10" fill="none" stroke="currentColor" stroke-width="3"
                  stroke-linecap="round"></path>
        </svg>
        <span class="label">Loading...</span>
    </div>

</div>

<main id="app">
    <header class="headerContainer">

        <div id="nameHeader">
            <svg id="thymosLogo" class="custom-icon" viewBox="0 0 177.81437 177.9034"
                 xmlns="http://www.w3.org/2000/svg">
                <style>
                    .rect-bg {
                        fill: var(--logo-bg, white);
                        stroke: var(--logo-bg, white);
                    }

                    .dot-shape, .main-shape {
                        fill: var(--logo-fg, black);
                        stroke: var(--logo-fg, black);
                    }
                </style>

                <g transform="translate(225.12939,129.3157)">
                    <rect class="rect-bg" width="130.01212" height="130.01208" x="-201.22827" y="-105.37005"
                          ry="9.1106987" rx="9.4112854" stroke-width="47.8913"/>
                    <path class="main-shape" stroke-width="4.63292"
                          d="m -183.53862,7.9393313 0.37992,-28.6806303c -3.46806,-0.838763 -6.47358,-2.670752 -8.82206,-5.154387 -3.35392,-3.546427 -5.32276,-8.431072 -5.32276,-13.618672v -30.30165c 0,-9.89763 4.27076,-21.98757 12.85714,-30.761632 6.93867,-7.09086 16.65032,-12.05614 29.13465,-12.05614h 67.983775l 11.83638,83.692256 -18.4011,0.0017v 60.189316l -3.79175,0.439257c -0.15191,0.02838 -53.466715,6.885861 -53.466715,-57.521684h 8.55402c 0,44.888568 29.48901,49.136615 40.15129,49.207313v -60.833856h 17.131595l -9.42174,-66.617732h -60.575755c -9.92062,0 -17.59527,3.90532 -23.05376,9.483912 -6.93498,7.08604 -10.38374,16.82239 -10.38374,24.78041v 30.30165c 0,2.99757 1.10511,5.78559 2.98196,7.77034 1.70875,1.80842 4.10749,2.95469 6.91965,2.95469h 4.31732l -0.4861,36.8294603 -8.52222,-0.102216 z"
                    />
                    <path class="dot-shape" stroke-width="4.63292"
                          d="m -115.91317,-44.595488c 5.72369,0 10.36216,-4.63847 10.36216,-10.36102 0,-5.72256 -4.63847,-10.3613 -10.36216,-10.3613 -5.72255,0 -10.36102,4.63874 -10.36102,10.3613 0,5.72255 4.63847,10.36102 10.36102,10.36102"
                    />
                </g>
            </svg>

            <div style="display: flex; flex-direction: column; align-content: space-between;">
                <div style="border-bottom: 2px solid var(--headerPanel-color); margin-bottom: 1px;"><span
                        style="font-weight: bolder; font-size: 24px;"><span
                        style="color: var(--logo-text); text-decoration: none;">THYMOS</span> - ŒúŒø·øñœÅŒ± controller</span>
                </div>
                <span id="softwareInfo"
                      style="color: var(--headerPanel-color); font-size: 12px;">v0.0.0.0, 00.00.0000</span>
            </div>
        </div>
        <div id="updateHeader">
            <a style="font-size: 22px; color: darkorange;">Upgrade available</a>
            <a id="updateHeaderVersion" style="color: coral; font-size: 12px;">[from: v0.0.0 to v0.0.0]</a>
            (press 'F5')
        </div>
    </header>

    <section class="statusContainer outsetShadow">
        <!-- Connection Section -->
        <div class="inlineDiv" style="    flex-wrap: wrap;">
            <div class="inlineDiv" style="width: max-content">
                <button id="connectBtnSerial" class="connectBtn" data-connection-type="serial"
                        title="Connect to the Thymos machine by selecting USB port.">
                    üîå Connect via<br>USB
                </button>
                <div class="inlineDiv connectElement" data-system-level="300">
                    <label for="inputNumBaudRate">Baud-Rate:</label>
                    <input data-input-type="intInput" type="number" id="inputNumBaudRate"
                           placeholder="Baud-Rate" value="921600" min="1" max="921600" step="100">
                </div>
            </div>
            <div class="inlineDiv" data-system-level="500">
                <button id="connectBtnBluetooth" class="connectBtn" data-connection-type="bluetooth"
                        title="Connect to the Thymos machine via Bluetooth.">
                    üì∂ Connect via<br>Bluetooth
                </button>
            </div>
            <div class="inlineDiv" data-system-level="600">
                <button id="connectBtnWiFi" class="connectBtn" data-connection-type="wifi"
                        title="Connect to the Thymos machine via Wi-Fi.">
                    üåê Connect via<br>Wi-Fi
                </button>
            </div>
        </div>
        <div id="connectionStatus"> üî¥ Disconnected</div>
    </section>

    <section id="debuggingWrapper" style="display: none;     flex-wrap: wrap; width: 100%; gap: 20px; margin-top: 20px; justify-content: center; align-items: center;
                border-radius: 1em; padding: 10px; background: lightpink; box-sizing: border-box;">
        <button onclick="clearClassDeclarations('.disabled')"
                style="box-sizing: border-box; justify-self: center; width: 100px; height: 100px;">
            ‚úñÔ∏è<br>Delete 'Disabled' Class
        </button>
        <button onclick="clearClassDeclarations('.prohibited')"
                style="box-sizing: border-box; justify-self: center; width: 100px; height: 100px;">
            ‚ùå<br>Delete 'Prohibited' Class
        </button>
        <button onclick="sendCommandGeneral('mc service')"
                style="font-weight: bold; box-sizing: border-box; justify-self: center; width: 150px; height: 100px; background: #ff8c00; color:white">
            üõ†Ô∏è<br>Service Mode<br><em style="font-weight: normal;">(MC SERVICE)</em>
        </button>
        <button onclick="sendCommandGeneral('datac')"
                style="font-weight: bold; box-sizing: border-box; justify-self: center; width: 150px; height: 100px; background: #2196F3; color:white">
            üìä<br>Data Measurement<br><em style="font-weight: normal;">(DATAC)</em>
        </button>
        <button onclick="sendCommandGeneral('mc moveto mach 0')"
                style="font-weight: bold; box-sizing: border-box; justify-self: center; width: 150px; height: 100px; background: #607d8b; color:white">
            ‚¨ÖÔ∏è<br>Move to 0 mm
        </button>
        <button onclick="sendCommandGeneral('mc moveto mach 300')"
                style="font-weight: bold; box-sizing: border-box; justify-self: center; width: 150px; height: 100px; background: #607d8b; color:white">
            ‚û°Ô∏è<br>Move to 300 mm
        </button>
        <button onclick="testFce()"
                style="font-weight: bold; box-sizing: border-box; justify-self: center; width: 150px; height: 100px; background: #4CAF50; color:white">
            üß™<br>Run Test Sequence
        </button>
        <button onclick="unblockDebugging(false)"
                style="font-weight: bold; box-sizing: border-box; justify-self: center; width: 150px; height: 100px; background: #de364c; color:white">
            üõë<br>End Testing
        </button>

        <pre id="brailleOut"
             style="font-weight: normal; border: 2px solid black; min-width: 50px; max-width: 200px; height: 100px; font-size: 16px; letter-spacing: 0;"></pre>


        <label for="testInput"></label>
        <input id="testInput" data-system="skip"
               type="number" inputmode="decimal" step="any"
               style="font-weight: normal; border: 2px solid black; min-width: 50px; max-width: 200px; height: 100px; font-size: 16px; letter-spacing: 0;"
               placeholder="Type here..."/>
    </section>

    <!-- Graph Display Section -->

    <section class="graphContainer outsetShadow">
        <h3 class="sectionTitle">üìà Graphs:</h3>
        <nav class="graphBtnWrapper" data-system-level="100">
            <button class="btnGraph" id="toggleLiveGraph"> ‚èØÔ∏è Activate Charts</button>
            <button id="clearChartBtn" class="btnGraph">üßπ Clear Charts</button>
            <button id="reloadChartBtn" class="btnGraph">üîÑ Reload Charts</button>
        </nav>


        <article id="chartsWrapper" class="outsetShadow">
            <div id="chartsContainer">
                <div id="timeChart" class="chart"></div>
                <div id="positionChart" class="chart"></div>
            </div>
            <div id="chartsInfoContainer" style="display: none;">
                <div style="display: inline-block; gap: 10px;"><a>Min/Max:</a>
                    <div style="display: inline-block;">
                        <span style="color: #000000;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="display: inline-flex; min-width: 30px;  justify-content: center;">mm</span>
                    </div>
                    <div style="display: inline-block;">
                        <span style="color: #FF3330;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="color: #2196F3;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="color: #4CAF50;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="display: inline-flex; min-width: 30px;  justify-content: center;">N</span>
                    </div>
                </div>
                <div style="display: inline-block; gap: 10px;"><a>Min/Max:</a>
                    <div style="display: inline-block;">
                        <span style="color: #000000;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="display: inline-flex; min-width: 30px;  justify-content: center;">mm</span>
                    </div>
                    <div style="display: inline-block;">
                        <span style="color: #FF3330;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="color: #2196F3;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="color: #4CAF50;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="display: inline-flex; min-width: 30px;  justify-content: center;">N</span>
                    </div>
                </div>
            </div>
        </article>

        <hr>

        <!-- Progress Bar -->
        <h3 class="sectionTitle">üíª Control Panel:</h3>
        <article style="gap:15px; display: flex; flex-direction: column;">
            <div id="controlContainer">
                <nav id="controlContainerExp" class="machineControlContainer outsetShadow"
                     style="max-width: calc(1065px - 30px - 205px); width: 100%;">
                    <div class="btnControlWrapper">
                        <!-- Start Experiment Button -->
                        <button id="startExperiment" class="controlBtn movementControlElement machineControlElement">
                            ‚ö°<br>Start Experiment
                        </button>

                        <!-- Stop Experiment Button -->
                        <button id="stopMachine" class="controlBtn machineControlElement">üõë<br>Stop Machine</button>

                        <!-- Return to the original position Button -->
                        <div style="display: inline-flex; gap: var(--gap);">
                            <button id="returnPositionExperimentBtn"
                                    class="controlBtn movementControlElement machineControlElement">‚Ü©Ô∏è Return to start
                                position
                            </button>

                            <!-- Automatic returning to the original position Checkmark -->
                            <div style="
            display: inline-flex;
            gap: var(--gap);
            padding-left: var(--gap);
            align-items: center;
            justify-content: center;"
                                 data-eq-type="-InB">
                                <label id="autoReturnPositionExperimentLabel" for="autoReturnPositionExperiment">‚ÜïÔ∏è
                                    Final
                                    Auto-positioning:</label>
                                <input type="checkbox" id="autoReturnPositionExperiment" value="returnToStartPosition"
                                       data-essence="switch, command, control, position">
                            </div>
                        </div>
                    </div>

                    <!-- Experiment Progress -->
                    <div id="progressWrapper">
                        <div style="flex-grow: 1; display: flex; align-items: center; gap: 10px; max-width: 640px;">
                            <label for="experimentProgress">Experiment Progress:</label>
                            <progress id="experimentProgress" value="0" max="100"></progress>
                            <span id="experimentProgressLabel"></span>
                        </div>
                        <div style="width: 135px;">
                            <b>Stage:</b>
                            <span id="experimentStage">None</span>
                        </div>
                    </div>
                </nav>

                <nav id="controlContainerMove" class="machineControlContainer outsetShadow">
                    <div class="movementWrapper movementControlElement machineControlElement">
                        <button id="moveMachineUP" class="controlBtn moveBtnLeft">ü¢Å</button>
                        <button id="moveUp50" class="controlBtn moveBtnRight">50<br>(mm)</button>
                    </div>

                    <div class="movementWrapper movementControlElement machineControlElement">
                        <button id="moveMachineDOWN" class="controlBtn moveBtnLeft">ü¢É</button>
                        <button id="moveDown50" class="controlBtn moveBtnRight">50<br>(mm)</button>
                    </div>

                </nav>
            </div>
            <nav class="outsetShadow"
                 style="display: flex;     flex-wrap: wrap; flex-direction: row; background: var(--containers-bg); padding: 10px 20px; border-radius: 10px; justify-content: space-between; gap: 10%; font-weight: bold; color: var(--text-info-2-color);">
                <div class="movementControlElement machineControlElement"
                     style="display: flex; flex-direction: row; flex-grow: 1; align-items: center; gap: 10px;">
                    <label for="movementSpeed" style="min-width: max-content; font-weight: normal; color: black;">‚ñ∂Ô∏è
                        Speed:</label>
                    <input type="range" id="movementSpeed" min="0.01" max="25" value="15" step="0.01"
                           data-system="skip"
                           style="height: 10px; flex-direction: row; flex-grow: 1; border-radius: var(--radius); touch-action: none;">
                    <label for="labelSpeed"></label>
                    <div style="display: inline-flex; min-width: fit-content; width: 100%; max-width: 130px; gap: .2em; align-items: center;">
                        <input type="number"
                               data-system="skip"
                               placeholder="Num."
                               id="labelSpeed"
                               class="sliderInputLabel"><span>mm/s</span>
                    </div>
                </div>
                <div class="movementControlElement machineControlElement"
                     style="display: flex; flex-direction: row; flex-grow: 1; align-items: center; gap: 10px;">
                    <label for="movementAcceleration" style="min-width: max-content; font-weight: normal; color: black;"
                    >‚è© Acceleration:</label>
                    <input type="range" id="movementAcceleration" min="10" max="200" value="100" step="0.01"
                           data-system="skip"
                           style="height: 10px; flex-direction: row; flex-grow: 1; border-radius: var(--radius); touch-action: none;">
                    <label for="labelAcceleration"></label>
                    <div style="display: inline-flex; min-width: fit-content; width: 100%;  max-width: 130px;  gap: .2em; align-items: center;">
                        <input type="number"
                               data-system="skip"
                               placeholder="Num."
                               id="labelAcceleration"
                               class="sliderInputLabel"><span>mm/s<sup style="font-size: 65%;">2</sup></span></div>
                </div>
            </nav>

            <nav class="outsetShadow"
                 style="display: flex;     flex-wrap: wrap; flex-direction: row; background: var(--containers-bg); padding: 10px 20px; gap:10px; border-radius: 10px; justify-content: space-between; font-weight: bold; color:  var(--text-info-2-color);">
                <div style="display: flex; flex-direction: row; align-items: center; gap: 40px;" class="prohibited">
                    <div style="display: flex; flex-direction: row; align-items: center; gap: 10px;">
                    <span id=""
                          style="min-width: 50px; text-align: right; color:black;  opacity: 65%;">Position: </span>
                        <span id=""
                              style="color: var(--text-info-1-color); min-width: 50px; text-align: right;">000.00</span>
                        <div id="positionWrapper"></div>
                        <span id="" style="min-width: 60px; text-align: right;">¬±000.00</span>
                        <a>mm</a>
                    </div>
                    <div style="display: flex; flex-direction: row; align-items: center; gap: 10px;">
                        <label for="moveToInput"
                               style="min-width: max-content; font-weight: normal; color: var(--text-info-2-color);">
                            Move to (mm):
                        </label>
                        <input type="number" id="moveToInput" min="0" max="450" step="0.01" placeholder="0.00 mm"
                               style="height: 10px; flex-direction: row; flex-grow: 1; border-radius: var(--radius); touch-action: none;">
                    </div>
                    <button id="moveToBtn"
                            class="movementControlElement machineControlElement controlBtn controllerBtn">‚û°Ô∏è Move
                    </button>

                </div>
                <button id="setUserZeroBtn"
                        class="movementControlElement machineControlElement controlBtn controllerBtn prohibited">üéØ Set
                    Zero
                </button>
                <button id="calibrateBtn" class="movementControlElement machineControlElement controlBtn controllerBtn">
                    üìè
                    Calibrate
                </button>
            </nav>
        </article>
    </section>


    <section class="experimentContainer outsetShadow">
        <h3>üìù Experiment options:</h3>
        <article id="experimentInputsContainer">

            <label for="experimentName">üß™ Experiment Name:</label>
            <div style="display: flex; width: 100%; gap: var(--gap);">
                <input type="text" id="experimentName" placeholder="Experiment name (mandatory) ..."
                       data-system="skip">
                <label for="experimentCount">üî¢ Experiment count:</label>
                <input type="number" id="experimentCount" placeholder="Num ..."
                       data-input-type="intInput" data-system="skip"
                       value="1" step="1" min="1" max="999">
            </div>

            <button id="saveDataBtn" class="saveDataBtns controlElement">üíæ Save single CSV</button>

            <label for="experimentDesc">üìÑ Experiment description:</label>
            <div class="textareaWrapper">
                <textarea id="experimentDesc" placeholder="Short description of the experiment (optional)..."
                          data-system="skip"></textarea>
            </div>

            <button id="convertCSV" class="controlElement">
                üìä Convert CSV files to XLSX (MATTES)
            </button>

            <label for="storagePath">üìÅ Handpick the folder:</label>
            <div style="align-items: center; display: flex; gap: var(--gap);">
                <input type="checkbox" id="storagePath" value="customDirectory" data-essence="switch, directory"
                       onchange="toggleDirectorySelector()"> (Default folder: Downloads)
            </div>

            <div>
                <button type="button" id="btnLoadSettings" class="controlElement">üóÉÔ∏è Load experiment data (CSV)</button>
                <div hidden>
                    <span id="loadedFileName" aria-live="polite"></span>
                    <input type="file" id="appFileInput" accept=".csv,text/csv">
                </div>
            </div>
        </article>


        <!--            <div id="experimentBtnsWrapper">-->


        <!--            </div>-->

        <h3>üìë Experiment Results:</h3>
        <section class="openingContainer insetShadow">
            <button id="resultsContainerOpenBtn" class="openingContainerBtn">üîΩ</button>
            <div id="resultsContainer" class="sizeableContainer controlElement">
                <h4>‚úèÔ∏è Calculation inputs:</h4>
                <article class="inputsContainer">
                    <div class="input-group data-eq">
                        <label for="inputTareForce">Taring Force \( F_{\mathrm{Tare}} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="number" id="inputTareForce" class="adjustableInput calcInput"
                               data-default-value="0" value="0" step="any" data-unit="N" data-essence="force">
                    </div>

                    <div class="input-group data-eq">
                        <label for="inputTareDisp">Taring Displacement \( w_{\mathrm{Tare}} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="number" id="inputTareDisp" class="adjustableInput calcInput"
                               data-default-value="0" value="0" step="any" data-unit="mm" data-essence="position">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx, InB, HBr">
                        <label for="inputForce">Force \( F \)<span class="units-text"></span>: </label>
                        <input type="number" id="inputForce" class="adjustableInput calcInput"
                               value="" step="any" data-unit="N" data-essence="force">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="inputTargetForce">Target force \( F_{T} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="number" id="inputTargetForce" class="adjustableInput calcInput"
                               step="any" data-unit="N" data-essence="force">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx">
                        <label for="inputDisp">Displacement \( w \) at \( F \)<span class="units-text"></span>:
                        </label>
                        <input type="number" id="inputDisp" class="adjustableInput calcInput"
                               value="" step="any" data-unit="mm" data-essence="position">
                    </div>


                    <div class="input-group data-eq" data-eq-type="Flx, InB">
                        <label for="inputCSWidth">Cross-section width \( b \)<span class="units-text"></span>:
                        </label>
                        <input type="number" id="inputCSWidth" class="adjustableInput calcInput"
                               value="" step="any" data-unit="mm"
                               data-essence="dimension, cross-section">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx">
                        <label for="inputCSHeight">Cross-section height \( h \)<span class="units-text"></span>:
                        </label>
                        <input type="number" id="inputCSHeight" class="adjustableInput calcInput"
                               value="" step="any" data-unit="mm"
                               data-essence="dimension, cross-section">
                    </div>

                    <div class="input-group data-eq" data-eq-type="InB">
                        <label for="inputCSLength">Cross-section length \( l \)<span class="units-text"></span>:
                        </label>
                        <input type="number" id="inputCSLength" class="adjustableInput calcInput"
                               value="" step="any" data-unit="mm"
                               data-essence="dimension, cross-section">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx">
                        <label for="inputSpan">Span \( L \)<span class="units-text"></span>: </label>
                        <input type="number" id="inputSpan" class="adjustableInput calcInput"
                               value="" step="any" data-unit="mm" data-essence="dimension">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="inputIndDiameter">Diameter of Indenter <b>‚åÄ</b> \( D \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="number" id="inputIndDiameter" class="adjustableInput calcInput"
                               step="any" data-unit="mm" data-essence="dimension">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="inputLoadingTime">Target loading time \( t_{T} \)<span class="units-text"></span>:
                        </label>
                        <input type="number" id="inputLoadingTime" class="adjustableInput calcInput"
                               step="any" data-unit="s" data-essence="time">
                    </div>

                    <div class="input-group data-eq">
                        <label for="inputMaterialName"><a class="u">Material name</a><span
                                class="units-text"> (text)</span>:
                        </label>
                        <input type="text" id="inputMaterialName" class="adjustableInput calcInput"
                               step="any" data-essence="label">
                    </div>
                </article>

                <div data-eq-type="Flx" style="display: inline-flex; width: 100%">
                    <hr style="width: 85% ; margin: 50px auto 10px;">
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(500px, 1fr)); gap: 20px;">

                    <article style="display: flex; flex-direction: column; gap: 10px;">
                        <h4 data-eq-type="Flx" style="margin-left: 10%;">‚òî <a class="u"> Before drying</a>:</h4>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputCSWidth_BeforeDrying">Cross-section width \( b_{w} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputCSWidth_BeforeDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension, cross-section">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputCSHeight_BeforeDrying">Cross-section height \( h_{w} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputCSHeight_BeforeDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension, cross-section">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputLength_BeforeDrying">Length \( L_{w} \)<span class="units-text"></span>:
                            </label>
                            <input type="number" id="inputLength_BeforeDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputWeight_BeforeDrying">Cross-section weight \( m_{w} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputWeight_BeforeDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="g"
                                   data-essence="weight">
                        </div>

                    </article>
                    <article style="display: flex; flex-direction: column; gap: 10px;" data-system-level="300">
                        <h4 data-eq-type="Flx" style="margin-left: 10%;">üåÇ <a class="u"> After drying</a>:</h4>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputCSWidth_AfterDrying">Cross-section width \( b_{0} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputCSWidth_AfterDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension, cross-section">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputCSHeight_AfterDrying">Cross-section height \( h_{0} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputCSHeight_AfterDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension, cross-section">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputLength_AfterDrying">Length \( L_{0} \)<span class="units-text"></span>:
                            </label>
                            <input type="number" id="inputLength_AfterDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputWeight_AfterDrying">Cross-section weight \( m_{0} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputWeight_AfterDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="g"
                                   data-essence="weight">
                        </div>

                    </article>
                </div>

                <hr data-system-level="100">

                <h4 data-system-level="100">üî£ Equations:</h4>
                <article class="inputsContainer" data-system-level="100"
                         style="grid-template-columns: repeat(auto-fit, minmax(430px, 1fr)); padding-left: 50px; gap: 25px 10px;">
                    <span class="data-eq">
                        \[
                        F_{i} = F_{j} - F_{\mathrm{Tare}}
                        \]
                    </span>
                    <span class="data-eq">
                        \[
                        w_{i} = w_{j} - w_{\mathrm{Tare}}
                        \]
                    </span>
                    <span class="data-eq" data-eq-type="Flx">
                        \[
                        I_{y} = \frac{1}{12} \cdot b \cdot h^{3}
                        \]
                    </span>
                    <span class="data-eq" data-eq-type="Flx">
                        \[
                        E = \frac{F\,L^{3}}{48\,I_{y}\,w}
                        \]
                    </span>
                    <span class="data-eq" data-eq-type="InB">
                        \[
                        A = b \cdot h
                        \]
                    </span>
                    <span class="data-eq" data-eq-type="InB">
                        \[ \sigma_{\mathrm{max}} = \dfrac{F_{\mathrm{max}}}{A} \]
                    </span>
                    <span class="data-eq" data-eq-type="HBr">
                        \[
                        d_{D} = 2\cdot\sqrt{\,h_{D}\,(2D - h_{D})\,}
                        \]
                    </span>
                    <span class="data-eq" data-eq-type="HBr">
                        \[
                        H_{BW} = \frac{2F}{\pi D\left( D - \sqrt{D^{2} - d^{2}} \right)}
                        \]
                    </span>
                    <span class="data-eq" data-eq-type="HBr">
                        \[
                        v_{T} = \frac{\Delta w_{T}}{t_{T}}
                        \]
                    </span>
                </article>

                <hr data-system-level="100">

                <h4 data-system-level="100">üìú Interim results:</h4>
                <article id="interimCalcWrapper" class="inputsContainer" data-system-level="100">

                    <div class="input-group data-eq" data-eq-type="Flx">
                        <label for="outputIy">Moment of Inertia \( I_{y} \)<span
                                class="units-text"></span>: </label>
                        <input type="text" id="outputIy" class="adjustableInput calcInput"
                               data-input-type="floatInput, customNumber" data-system="skip" data-unit="mm^4"
                               data-essence="dimension, cross-section, moment-of-inertia">
                    </div>

                    <div class="input-group data-eq" data-eq-type="InB">
                        <label for="outputArea">Cross-section Area \( A \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="text" id="outputArea" class="adjustableInput calcInput"
                               data-input-type="floatInput, customNumber" data-system="skip" data-unit="mm^2"
                               data-essence="dimension, cross-section, area">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="outputDepthInd">Depth of indentation \( h_{D} \)<span class="units-text"></span>:
                        </label>
                        <input type="text" id="outputDepthInd" class="adjustableInput calcInput"
                               data-input-type="floatInput, customNumber" data-system="skip" data-unit="mm"
                               data-essence="position">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="outputDiameterInd">Diameter of indentation <b>‚åÄ</b> \( d_{D} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="text" id="outputDiameterInd" class="adjustableInput calcInput"
                               data-input-type="floatInput, customNumber" data-system="skip" data-unit="mm"
                               data-essence="dimension">
                    </div>

                </article>

                <hr>

                <h4>üìê Calculated values:</h4>
                <article class="inputsContainer">
                    <div class="input-group data-eq" data-eq-type="-HBr">
                        <label for="outputForceMax">Max Force \( F_{\mathrm{max}} \)<span class="units-text"></span>:
                        </label>
                        <input type="text" id="outputForceMax" class="copyableInput calcInput" readonly
                               data-system="skip" data-unit="N" data-essence="force">
                    </div>

                    <div class="input-group data-eq" data-eq-type="-HBr">
                        <label for="outputDisp">Displacement \( w_{F_{\mathrm{max}}} \) at \( F_{\mathrm{max}} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="text" id="outputDisp" class="copyableInput calcInput" readonly
                               data-system="skip" data-unit="mm" data-essence="position">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx">
                        <label for="outputModulus">Young's Module \( E \)<span class="units-text"></span>:
                        </label>
                        <input type="text" id="outputModulus" class="copyableInput calcInput" readonly
                               data-system="skip" data-unit="MPa" data-essence="result, modulus">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx">
                        <label for="outputFlexStrength">Maximal Flexural strength \( f_{m} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="text" id="outputFlexStrength" class="copyableInput calcInput" readonly
                               data-system="skip" data-unit="MPa" data-essence="result, strength">
                    </div>

                    <div class="input-group data-eq" data-eq-type="InB">
                        <label for="outputMaxStress">Max Stress \( \sigma_{\mathrm{max}} \)<span
                                class="units-text"></span>: </label>
                        <input type="text" id="outputMaxStress" class="copyableInput calcInput" readonly
                               data-system="skip" data-unit="MPa" data-essence="result, stress">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="inputTargetDisp">Displacement \( w_{T} \) at Target force<span
                                class="units-text"></span>:
                        </label>
                        <input type="text" id="inputTargetDisp" class="copyableInput calcInput" readonly
                               data-system="skip" data-unit="mm" data-essence="position">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="outputHardness">Hardness (Brinell) \( H_{\mathrm{BW}} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="text" id="outputHardness" class="copyableInput calcInput" readonly
                               data-system="skip" data-unit="-" data-essence="result, hardness, ratio">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="outputLoadingSpeed">Loading speed \( v_{T} \)<span class="units-text"></span>:
                        </label>
                        <input type="text" id="outputLoadingSpeed" class="copyableInput calcInput" readonly
                               data-system="skip" data-unit="mm/s" data-essence="speed">
                    </div>
                </article>

                <hr style="width: 85% ; margin: 30px auto 15px;">
                <div id="saveCalcDataBtnWrapper"
                     style="display: flex; gap: calc(2 * var(--gap)); justify-content: center;">
                    <button class="controlBtn saveDataBtns controlElement">
                        üíæ Save data<br>(CSV)
                    </button>
                    <button id="recomputeAllBtn" class="controlBtn" data-system-level="100">
                        üßÆ Recompute<br>All
                    </button>
                    <button id="clearCalculationsButton" class="controlBtn" data-system-level="100">
                        üßº Clear<br>calculations
                    </button>
                </div>
            </div>
        </section>


        <!-- Experiment Parameter Inputs -->
        <h3>‚öôÔ∏è Settings:</h3>
        <section class="openingContainer insetShadow">
            <button id="settingsContainerOpenBtn" class="openingContainerBtn">üîΩ</button>
            <div id="settingsContainer" class="sizeableContainer">

                <article id="loadingSettingsSection">
                    <h4>üõ†Ô∏è Loading settings:</h4>
                    <div class="inputsContainer">
                        <div class="input-group">
                            <label for="inputDistance">Distance<span class="units-text"></span>: </label>
                            <input data-input-type="floatInput" type="number" id="inputDistance" class="expInput"
                                   value="20" min="0.01" step="any" max="100000000" data-unit="mm"
                                   data-essence="position" required>
                        </div>

                        <div class="input-group">
                            <label for="experimentTypeDropdown">Experiment type: </label>
                            <select id="experimentTypeDropdown" class="expInput" required>
                                <option value="none" hidden>
                                    &nbsp;‚¨ú&nbsp;No selection
                                </option>
                                <option value="Option-UP-POS-BASIC" data-essence="move_up">
                                    &nbsp;UP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üî∫
                                </option>
                                <option value="Option-UP-POS-Ten" disabled data-essence="tensile">
                                    &nbsp;TENSION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚è´
                                </option>
                                <option value="Option-UP-POS-InB" data-essence="internal_bond">
                                    &nbsp;INTERNAL BOND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚è´
                                </option>
                                <option value="Option-DOWN-POS-BASIC" data-essence="move_down" selected>
                                    &nbsp;DOWN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üîª
                                </option>
                                <option value="Option-UP-POS-Com" disabled data-essence="compression">
                                    &nbsp;COMPRESION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚è¨
                                </option>
                                <option value="Option-DOWN-POS-Flx" data-essence="flexural">
                                    &nbsp;FLEXURAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚è¨
                                </option>
                                <option value="Option-DOWN-POS-HBr" data-essence="hardness_br">
                                    &nbsp;HARDNESS (Brinell)&nbsp;‚è¨
                                </option>
                            </select>
                        </div>

                        <div class="input-group">
                            <label for="inputLoadLimitDropPercent">Force drop limit<span class="units-text"></span>:
                            </label>
                            <input data-input-type="floatInput" type="number" id="inputLoadLimitDropPercent"
                                   class="expInput" value="30" min="0" max="1000000" data-unit="%"
                                   data-essence="ratio" required>
                            <!-- % ‚Ä∞ -->
                        </div>


                        <div class="input-group">
                            <label for="inputTakePhotos">Take photos: </label>
                            <input type="checkbox" id="inputTakePhotos" class="expInput" value="takePhotos"
                                   data-essence="switch">
                            <label id="inputPhotoIntervalLabel" class="innerInputLabel" for="inputPhotoInterval">Photo
                                Interval<span class="units-text"></span>: </label>
                            <input data-input-type="floatInput" type="number" id="inputPhotoInterval"
                                   class="expInput innerInput"
                                   value="1" min="0" step="any" max="120000000"
                                   data-unit="s" data-essence="time" required>
                        </div>


                        <div class="input-group">
                            <label for="inputLoadLimitDropValue">Force drop limit<span class="units-text"></span>:
                            </label>
                            <input data-input-type="floatInput" type="number" id="inputLoadLimitDropValue"
                                   class="expInput"
                                   value="5" min="0" step="any" max="100000000" data-unit="N"
                                   data-essence="ratio, force" required>
                        </div>


                        <div class="input-group">
                            <label for="inputSpeedForward">Loading speed<span class="units-text"></span>: </label>
                            <input data-input-type="floatInput" type="number" id="inputSpeedForward" class="expInput"
                                   value="0.5" min="0.01" step="any" max="25" data-unit="mm/s"
                                   data-essence="speed" required>
                        </div>

                        <div class="input-group">
                            <label for="inputDataInterval">Data Interval<span class="units-text"></span>: </label>
                            <input data-input-type="intInput" type="number" id="inputDataInterval" class="expInput"
                                   value="30000" min="10000" step="any" max="100000000" data-unit="¬µs"
                                   data-essence="time" required>
                        </div>

                        <div class="input-group" data-eq-type="InB, HBr">
                            <label id="inputInitialSpeedLabel" for="inputInitialSpeed">Initial speed<span
                                    class="units-text"></span>:</label>
                            <input data-input-type="floatInput" type="number"
                                   id="inputInitialSpeed" class="expInput" style="max-width: 60px; min-width: 25px;"
                                   value="1" min="0.01" step="any" max="25" data-unit="mm/s"
                                   data-essence="speed" required>
                            <label id="inputInitialForceLabel" for="inputInitialForce"
                                   style="min-width: max-content;">Force lim.
                                <span class="units-text"></span>:</label>
                            <input data-input-type="floatInput" type="number"
                                   id="inputInitialForce" class="expInput" style="max-width: 50px; min-width: 25px;"
                                   value="1" min="0" step="any" max="100000000" data-unit="N"
                                   data-essence="force" required>
                        </div>

                        <div class="input-group" data-eq-type="HBr">
                            <label id="inputStopForceLabel" for="inputStopForce">Stopping Force Limit<span
                                    class="units-text"></span>: </label>
                            <input data-input-type="floatInput" type="number" id="inputStopForce" class="expInput"
                                   value="1000" min="0" step="any" max="100000000" data-unit="N" data-essence="force"
                                   list="stopForces" placeholder="Select or type..." required>

                            <datalist id="stopForces">
                                <option value="1000">
                                <option value="500">
                                <option value="100">
                            </datalist>
                        </div>

                        <div class="input-group" data-eq-type="HBr">
                            <label id="inputEndDelayLabel" for="inputEndDelay">End load delay<span
                                    class="units-text"></span>: </label>
                            <input data-input-type="floatInput" type="number" id="inputEndDelay" class="expInput"
                                   value="25" min="0" step="any" max="120000000" data-unit="s"
                                   data-essence="time" required>
                        </div>

                        <div class="input-group" data-eq-type="HBr" data-system-level="0-200">
                            <label id="inputResponseCoefPILabel" for="inputResponseCoefPI">Responsiveness coefficient
                                \( [PI] \)<span
                                        class="units-text"></span>: </label>
                            <input data-input-type="floatInput" type="number" id="inputResponseCoefPI" class="expInput"
                                   value="0.5" min="0" step="any" max="10" data-unit="-"
                                   data-essence="coefficient, ratio" required>
                        </div>
                        <div class="input-group" data-eq-type="HBr" data-system-level="200">
                            <label id="inputResponseCoefKpLabel" for="inputResponseCoefKp">Responsiveness coefficient
                                \( [K_{p}] \)<span
                                        class="units-text"></span>: </label>
                            <input data-input-type="floatInput" type="number" id="inputResponseCoefKp" class="expInput"
                                   value="0.5" min="0" step="any" max="10" data-unit="-"
                                   data-essence="coefficient, ratio" required>
                        </div>
                        <div class="input-group" data-eq-type="HBr" data-system-level="200">
                            <label id="inputResponseCoefKiLabel" for="inputResponseCoefKi">Responsiveness coefficient
                                \( [K_{i}] \)<span
                                        class="units-text"></span>: </label>
                            <input data-input-type="floatInput" type="number" id="inputResponseCoefKi" class="expInput"
                                   value="0.5" min="0" step="any" max="10" data-unit="-"
                                   data-essence="coefficient, ratio" required>
                        </div>

                        <div class="input-group" data-eq-type="HBr" data-system-level="300">
                            <label id="inputResponseCoefMinSLabel" for="inputResponseCoefMinS">Responsiveness min Speed
                                <span class="units-text"></span>: </label>
                            <input data-input-type="floatInput" type="number" id="inputResponseCoefMinS"
                                   class="expInput"
                                   value="0.005" min="0" step="any" max="25" data-unit="mm/s"
                                   data-essence="coefficient, speed, limit, minimal" required>
                        </div>
                        <div class="input-group" data-eq-type="HBr" data-system-level="300">
                            <label id="inputResponseCoefMaxSLabel" for="inputResponseCoefMaxS">Responsiveness max Speed
                                <span class="units-text"></span>: </label>
                            <input data-input-type="floatInput" type="number" id="inputResponseCoefMaxS"
                                   class="expInput"
                                   value="15" min="0" step="any" max="25" data-unit="mm/s"
                                   data-essence="coefficient, speed, limit, maximal" required>
                        </div>
                        <div class="input-group" data-eq-type="HBr" data-system-level="300">
                            <label id="inputResponseCoefAccelLabel" for="inputResponseCoefAccel">Responsiveness max
                                Accel.<span class="units-text"></span>: </label>
                            <input data-input-type="floatInput" type="number" id="inputResponseCoefAccel"
                                   class="expInput"
                                   value="50" min="0" step="any" max="200" data-unit="mm/s^2"
                                   data-essence="coefficient, acceleration, limit, maximal" required>
                        </div>


                        <div class="input-group" data-eq-type="-Flx, -InB,-HBr">
                            <label for="inputDoCycles">Do cycles: </label>
                            <input type="checkbox" id="inputDoCycles" class="expInput" value="doCycles"
                                   data-essence="switch" required>
                            <label id="inputCyclesLabel" class="innerInputLabel" for="inputCycles">Cycles<span
                                    class="units-text"></span>: </label>
                            <input type="text" id="inputCycles" class="expInput innerInput"
                                   min="0" max="Infinity" value="1" data-unit="-"
                                   data-input-type="intInput, customNumber" data-essence="count" required>
                        </div>
                    </div>
                </article>

                <hr>

                <article id="machineSettingsSection">
                    <h4>üìü Machine settings:</h4>
                    <div class="inputsContainer">
                        <div id="machSettings">
                            <!-- Machine settings (LoadCells) will be dynamically inserted here -->
                        </div>

                        <div class="input-group machineControlElement" data-system-level="100">
                            <label for="inputMachineName" style="min-width: max-content;">Machine name:</label>
                            <div style="display: flex; gap: 0;">
                                <input data-input-type="intInput" type="text" id="inputMachineName"
                                       placeholder="My Machine Name" value="" data-system="skip"
                                       data-essence="identification"
                                       style="height: 40px; width: 200px; border-bottom-right-radius: 0; border-top-right-radius: 0; border-right: 0 solid transparent;">
                                <button id="sendMachineNameBtn"
                                        style="height: 40px; width: 30px; border-bottom-left-radius: 0; border-top-left-radius: 0;">
                                    ‚ñ∂ <!-- ‚Üµ‚èé‚éÜ -->
                                </button>
                            </div>
                        </div>


                        <div class="input-group machineControlElement" data-system-level="400">
                            <label for="inputMachineID" style="min-width: max-content;">Machine ID:</label>
                            <div style="display: flex; gap: 0;">
                                <input data-input-type="intInput" type="text" id="inputMachineID"
                                       placeholder="My Machine ID" value="" data-system="skip"
                                       data-essence="identification"
                                       style="height: 40px; width: 200px; border-bottom-right-radius: 0; border-top-right-radius: 0; border-right: 0 solid transparent;">
                                <button id="sendMachineIDBtn"
                                        style="height: 40px; width: 30px; border-bottom-left-radius: 0; border-top-left-radius: 0;">
                                    ‚ñ∂ <!-- ‚Üµ‚èé‚éÜ -->
                                </button>
                            </div>
                        </div>
                    </div>
                </article>

                <hr>

                <article id="appSettingsSection">
                    <h4>üì∫ App settings:</h4>
                    <div class="inputsContainer autoGrid">
                        <div class="input-group controlElement">
                            <label for="systemLevelSelect">System Level: </label>
                            <select id="systemLevelSelect" class="appSelector" data-system="app" required>
                                <option value="none" hidden>&nbsp;‚¨ú&nbsp;No selection</option>
                                <option value="remote" hidden>
                                    &nbsp;üëΩ&nbsp;Remote
                                </option>
                                <option value="publuc" hidden>
                                    &nbsp;üÖøÔ∏è&nbsp;Public
                                </option>
                                <option value="guest" hidden>
                                    &nbsp;‚ûø&nbsp;Guest
                                </option>
                                <option value="restricted" hidden>
                                    &nbsp;‚¨õ&nbsp;Restricted
                                </option>
                                <option value="protected" hidden>
                                    &nbsp;üî≥&nbsp;Protected
                                </option>
                                <option value="limited" hidden>
                                    &nbsp;üî≤&nbsp;Limited
                                </option>
                                <option value="minimal" disabled> <!--TODO: implement-->
                                    &nbsp;‚èπÔ∏è&nbsp;Minimal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(üîú)
                                </option>
                                <option value="basic" selected>
                                    &nbsp;üü¶&nbsp;Basic
                                </option>
                                <option value="standard">
                                    &nbsp;üü©&nbsp;Standard
                                </option>
                                <option value="advanced">
                                    &nbsp;üü®&nbsp;Advanced
                                </option>
                                <option value="expert">
                                    &nbsp;üüß&nbsp;Expert
                                </option>
                                <option value="admin" disabled>
                                    &nbsp;üü•&nbsp;Administrator&nbsp;(üó∫Ô∏è)
                                </option>
                                <option value="operator" disabled>
                                    &nbsp;üÖæÔ∏è&nbsp;Operator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(üó∫Ô∏è)
                                </option>
                                <option value="emergency" disabled>
                                    &nbsp;üü™&nbsp;Emergency&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(üõ†Ô∏è)
                                </option>

                                <option value="user" disabled> <!--TODO: implement-->
                                    &nbsp;üÜî&nbsp;Logged User&nbsp;&nbsp;&nbsp;(üöß)
                                </option>
                                <option value="support" disabled>
                                    &nbsp;‚òØÔ∏è&nbsp;Support&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(üó∫Ô∏è)
                                </option>
                                <option value="service" disabled>
                                    &nbsp;‚öïÔ∏è&nbsp;Service&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(‚è≥)
                                </option>
                                <option value="developer" disabled>
                                    &nbsp;‚öõÔ∏è&nbsp;Developer
                                </option>
                                <option value="god" disabled>
                                    &nbsp;‚ôæÔ∏è&nbsp;God Mode
                                </option>
                            </select>
                        </div>

                        <div class="input-group controlElement" data-system-level="400">
                            <label for="inputAppInterval" style="min-width: max-content;">Data Interval:</label>
                            <input data-input-type="intInput" type="number" id="inputAppInterval" data-system="app"
                                   value="50000" min="1" step="any" max="100000000" data-unit="¬µs" data-essence="time"
                                   style="height: 50px; width: 200px;">
                        </div>

                        <div class="input-group">
                            <label for="languageSelect">App Language: </label>
                            <select id="languageSelect" class="appSelector" data-system="app">
                                <option value="none" hidden>&nbsp;‚¨ú&nbsp;No selection</option>
                                <option value="en" selected>&nbsp;English&nbsp;&nbsp;&nbsp;&nbsp;üá¨üáß</option>
                                <option value="cs" hidden>&nbsp;ƒåe≈°tina&nbsp;&nbsp;&nbsp;&nbsp;üá®üáø</option>
                                <option value="de" hidden>&nbsp;Deutsch&nbsp;&nbsp;&nbsp;&nbsp;üá©üá™</option>
                                <option value="es" hidden>&nbsp;Espa√±ol&nbsp;&nbsp;&nbsp;&nbsp;üá™üá∏</option>
                                <option value="pt" hidden>&nbsp;Portugu√™s&nbsp;&nbsp;üáµüáπ</option>
                                <option value="fr" hidden>&nbsp;Fran√ßais&nbsp;&nbsp;&nbsp;üá´üá∑</option>
                                <option value="it" hidden>&nbsp;Italiano&nbsp;&nbsp;&nbsp;üáÆüáπ</option>
                                <option value="ru" hidden>&nbsp;–†—É—Å—Å–∫–∏–π&nbsp;&nbsp;&nbsp;&nbsp;üá∑üá∫</option>
                                <option value="ja" hidden>&nbsp;Êó•Êú¨Ë™û&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üáØüáµ</option>
                                <option value="ko" hidden>&nbsp;ÌïúÍµ≠Ïñ¥&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üá∞üá∑</option>
                                <option value="zh" hidden>&nbsp;‰∏≠Êñá&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üá®üá≥
                                </option>
                                <option value="en" disabled>&nbsp;Custom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üè≥Ô∏è‚Äç</option>
                            </select>
                        </div>

                        <div class="input-group" data-system-level="100">
                            <label for="inputAutoConnect">Automatically connect to the machine: </label>
                            <select id="inputAutoConnect" class="appSelector" data-system="app">
                                <option value="none" hidden>&nbsp;‚¨ú&nbsp;No selection</option>
                                <option value="never" title="Don't connect to the device automatically">
                                    &nbsp;‚ùå&nbsp;Never
                                </option>
                                <option value="beginning"
                                        title="Connect to the device automatically on the start-up of the app">
                                    &nbsp;üåü&nbsp;Beginning
                                </option>
                                <option value="during"
                                        title="Connect to the device automatically at any point of time during the session">
                                    &nbsp;‚è≥&nbsp;During
                                </option>
                                <option value="ask"
                                        title="Always ask if connect to the device at any point of time during the session">
                                    &nbsp;‚ùî&nbsp;Ask
                                </option>
                                <option value="always"
                                        title="Always connect to the device automatically at any point of time during the session"
                                        selected>
                                    &nbsp;‚úÖ&nbsp;Always
                                </option>
                            </select>
                        </div>

                        <!-- TODO: add that this and some other settings are tight to the Different storage 'System'  -->
                        <div class="input-group" data-system-level="200">
                            <label for="inputUseMachineSettings">
                                Apply machine settings on connect:
                            </label>
                            <select id="inputUseMachineSettings" class="appSelector" data-system="app">
                                <option value="none" hidden>&nbsp;‚¨ú&nbsp;No selection</option>
                                <option value="no_not" title="Keep current and don't save to machine">
                                    &nbsp;‚ùå&nbsp;No&nbsp;&nbsp;(keep)
                                </option>
                                <option value="no_save" title="Keep current and save to machine">
                                    &nbsp;‚úñÔ∏è&nbsp;No&nbsp;&nbsp;(keep & save)
                                </option>
                                <option value="ask" title="Ask what to do">
                                    &nbsp;‚ùî&nbsp;Ask
                                </option>
                                <option value="yes_save" title="Overwrite current and save to machine" selected>
                                    &nbsp;‚úÖ&nbsp;Yes&nbsp;(load & save)
                                </option>
                                <option value="yes_not" title="Overwrite current and don't save to machine">
                                    &nbsp;‚òëÔ∏è&nbsp;Yes&nbsp;(load & keep)
                                </option>
                            </select>
                        </div>

                        <div class="input-group" data-system-level="200">
                            <label for="decimalSymbol" style="min-width: max-content;">CSV Decimal Symbol: </label>
                            <select id="decimalSymbol" class="appSelector" data-system="app">
                                <option value="none" hidden>&nbsp;‚¨ú&nbsp;No selection</option>
                                <option value="Option-Dot" selected>&nbsp;Dot&nbsp;&nbsp;&nbsp;( . )&nbsp;</option>
                                <option value="Option-Comma">&nbsp;Comma&nbsp;( , )&nbsp;</option>
                            </select>
                        </div>

                        <div class="input-group" data-system-level="200">
                            <label for="delimiterSymbol" style="min-width: max-content;">CSV Delimiter Symbol: </label>
                            <select id="delimiterSymbol" class="appSelector" data-system="app">
                                <option value="none" hidden>&nbsp;‚¨ú&nbsp;No selection</option>
                                <option value="Option-Semicolon" selected>
                                    &nbsp;Semicolon&nbsp;( ; )&nbsp;
                                </option>
                                <option value="Option-Comma">
                                    &nbsp;Comma&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( , )&nbsp;
                                </option>
                                <option value="Option-Space">
                                    &nbsp;Space&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( _ )&nbsp;
                                </option>
                                <option value="Option-Tab">
                                    &nbsp;Tab&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( \t )&nbsp;
                                </option>                                <!-- ‚Üπ, ‚á•, ‚ÆÇ -->
                            </select>
                        </div>

                        <div class="input-group">
                            <label for="inputAutoSave">
                                Save data to CSV automatically:
                            </label>
                            <select id="inputAutoSave" class="appSelector" data-system="app">
                                <option value="none" hidden>&nbsp;‚¨ú&nbsp;No selection</option>
                                <option value="Option-Never" title="Save data only by 'save' buttons" selected>
                                    &nbsp;‚ùå&nbsp;Never
                                </option>
                                <option value="Option-Before" title="Save data before the start of the next Experiment">
                                    &nbsp;‚èÆÔ∏è&nbsp;Before
                                </option>
                                <option value="Option-After" title="Save data right at the end of the Experiment">
                                    &nbsp;‚è≠Ô∏è&nbsp;After
                                </option>
                            </select>
                        </div>

                        <div class="input-group">
                            <label for="inputClearCalculations">
                                Clear calculation inputs at the start of each experiment:
                            </label>
                            <input type="checkbox" id="inputClearCalculations" value="clearCalc" data-system="app"
                                   data-essence="switch" checked>
                        </div>

                        <div class="input-group" data-system-level="100">
                            <label for="inputLockInterimCalculations">
                                Lock interim calculations inputs:
                            </label>
                            <input type="checkbox" id="inputLockInterimCalculations" value="lockInterimCalc"
                                   data-system="app" data-essence="switch" checked>
                        </div>

                        <div class="input-group" data-system-level="800">
                            <label for="inputRawConnection">
                                Raw connection:
                            </label>
                            <input type="checkbox" id="inputRawConnection" value="rawConnection"
                                   data-system="skip" data-essence="switch">
                        </div>

                        <button id="darkModeButton" class="controlBtn">
                            üåô Dark mode
                        </button>

                        <button id="reportButton" class="controlBtn controlElement prohibited"
                                style="color: var(--stopEpx-color);">
                            üêû Report bug
                        </button>

                        <button id="clearAllButton" class="controlBtn controlElement" data-system-level="400"
                                style="color: var(--stopEpx-color);">
                            üóëÔ∏è Clear All Data
                        </button>

                        <div style="padding: 0; margin: 0; display: flex; gap: 0;" data-system-level="200">
                            <button id="exportSettingButton" class="controlBtn controlElement"
                                    style="width: 100px; border-bottom-right-radius: 0; border-top-right-radius: 0; border-right: 0 solid transparent;  color: var(--text-info-3-color); font-size: 12px;">
                                ‚ÜóÔ∏è Export settings <!-- üìÅüì§ -->
                            </button>
                            <button id="importSettingButton" class="controlBtn controlElement"
                                    style="width: 100px; border-bottom-left-radius: 0; border-top-left-radius: 0; border-left: 0 solid transparent;  color: var(--text-info-3-color); font-size: 12px;">
                                ‚ÜòÔ∏è Import settings <!-- üìÇ üì• -->
                            </button>
                        </div>

                        <button id="aboutButton" class="controlBtn"
                                style="color: var(--text-info-3-color);">
                            ‚ÑπÔ∏è About app
                        </button>

                        <button id="updateMachButton" class="controlBtn controlElement"
                                data-system-level="100"
                                style="color: var(--text-info-3-color);">
                            ‚¨ÜÔ∏è Update device firmware
                        </button>


                        <button id="rebootButton" class="controlBtn controlElement machineControlElement"
                                data-system-level="100"
                                style="color: var(--text-info-3-color);">
                            üîÇ Reboot device
                        </button>

                        <button id="clearStorageButton" class="controlBtn controlElement"
                                style="color: var(--text-info-3-color);">
                            üîÅ Reset app
                        </button>
                    </div>
                </article>
            </div>
        </section>

        <!-- Device Console Output Section -->
        <h3>üìã Device Console:</h3>
        <section class="openingContainer insetShadow">
            <button id="consoleContainerOpenBtn" class="openingContainerBtn">üîΩ</button>
            <div id="consoleContainer" class="sizeableContainer">
                <div id="consoleWrapper">

                    <div class="logContainer">
                        <div id="regularLogWrapper">
                            <pre id="regularLog"></pre>
                        </div>

                        <div style="display: flex; gap: var(--gap); flex-flow: column;" data-system-level="200">
                            <button id="toggleScrollBtn" class="logBtn" data-system-level="200">
                                üìå Auto-scroll: ON
                            </button>

                            <button id="toggleLineLockBtn" class="logBtn prohibited" data-system-level="300">
                                üîí Fix Scroll: ON
                            </button>
                        </div>
                    </div>

                    <div class="logContainer">
                        <pre id="loadingLog"></pre>

                        <button id="clearRegularLog" class="logBtn" data-system-level="100">
                            üóëÔ∏è Clear Log
                        </button>
                    </div>

                    <div id="consoleLineWrapper" class="logContainer machineControlElement controlElement"
                         data-system-level="100">
                        <div style="height: 40px; width: 100%">
                            <label for="commandInput"></label>
                            <textarea id="commandInput" placeholder="Enter command..."></textarea>
                        </div>

                        <button style="height: 40px; min-height: 40px; max-height: 40px;" id="sendButton"
                                class="logBtn">
                            üì° Send Command
                        </button>
                    </div>

                </div>
            </div>
        </section>

    </section>
</main>


<script>
    // On/Off warning on page close/reload/navigation
    let warnOnClose = false;


    function bindCloseHandler() {

        // Prevent native reload/close dialog (show warning)
        window.addEventListener('beforeunload', (e) => {
            if (warnOnClose && !debugging) {
                e.preventDefault();
                // Standard: most browsers ignore custom text
                e.returnValue = '';
            }
        });

        // Capture keys that normally cause reload/close/close-tab
        window.addEventListener('keydown', (e) => {
            // F5 (116), Ctrl+R, Ctrl+F5, Ctrl+W, Ctrl+F4, Ctrl+Shift+R, Meta(Command)+R
            if ((warnOnClose && !debugging) &&
                (
                    e.key === 'F5' ||
                    (e.ctrlKey && e.key.toLowerCase() === 'r') ||
                    (e.metaKey && e.key.toLowerCase() === 'r') ||
                    (e.ctrlKey && e.key.toLowerCase() === 'w') ||
                    (e.ctrlKey && e.key === 'F4')
                )) {
                e.preventDefault();
                // en: Instead of reloading, you can show your own warning

                if (confirm('Are you sure you want to leave this page? Make sure to finish all tasks, stop machine and save your data before leaving.')) {
                    // allow reload/close
                    window.location.reload();
                }
            }
        });

        // Capture clicks on links that could leave the page
        document.addEventListener('click', (e) => {
            if (warnOnClose && !debugging) {
                const a = e.target.closest && e.target.closest('a[href]');
                if (!a) return;
                const href = a.getAttribute('href');
                // Ignore internal anchors and javascript links
                if (href && !href.startsWith('#') && !href.startsWith('javascript:')) {
                    e.preventDefault();
                    if (confirm('Are you sure you want to leave this page? Make sure to finish all tasks, stop machine and save your data before leaving.')) {
                        // allow navigation
                        window.location.href = href;
                    }
                }
            }
        });

        // Push state / back button trap (back-button). Helps to prevent accidental navigation away.
        history.pushState({page: 1}, '', '');
        window.addEventListener('popstate', (event) => {
            // We push state again and show warning
            history.pushState({page: 1}, '', '');
            if (warnOnClose && !debugging) {
                if (confirm('Are you sure you want to leave this page? Make sure to finish all tasks, stop machine and save your data before leaving.')) {
                    // optionally allow navigation
                    history.back();
                }
            }
        });

        // // Function to allow temporary disabling of the protection (constructive UX)
        // function allowCloseTemporarily(action) {
        //     warnOnClose = false;
        //     try {
        //         action();
        //     } finally {
        //         warnOnClose = true;
        //     }
        // }
        //
        // // Utility: "Safe Exit" button in UI (e.g. UI button)
        // async function safeExit() {
        //     // finish flush / save state
        //     await saveStateToServerOrLocal();
        //     allowCloseTemporarily(() => window.close());
        // }
        //
        // async function saveStateToServerOrLocal() {
        //     // Implement state storage (localStorage / server call)
        //     try {
        //         localStorage.setItem('myAppSavedAt', new Date().toISOString());
        //         // or await fetch('/save', {method:'POST', body:...})
        //     } catch (e) {
        //         console.warn("Save failed", e);
        //     }
        // }
    }
</script>

<script>

    // serviceWorkerRegistration();
    //
    // async function serviceWorkerRegistration() {
    //
    //     if ('serviceWorker' in navigator) {
    //         console.info('‚òëÔ∏è Service Worker is supported.');
    //
    //         navigator.serviceWorker.getRegistration()
    //             .then(reg => {
    //                 const match = reg && reg.active && reg.active.scriptURL.includes('service-worker.js');
    //
    //                 if (match) {
    //                     // serviceWorkerRegistrationStatus = true;
    //                     console.info('‚úÖ Service worker is registered:', reg);
    //                 } else {
    //                     navigator.serviceWorker.register('service-worker.js').then(function (registration) {
    //                         console.info('üÜï Service Worker was registered', registration);
    //                     }).catch(function (error) {
    //                         console.info('‚ùå Registration failed.', error);
    //                     });
    //                 }
    //             })
    //             .catch(err => {
    //                 console.error('‚ö†Ô∏è Error checking service worker registration:', err);
    //             });
    //     } else {
    //         console.info('üö´ Service Worker is not supported.');
    //     }
    //
    //     await sleep(10);  // Stop
    //
    //     // console.info(serviceWorkerRegistrationStatus);
    //     // if (!serviceWorkerRegistrationStatus) window.location.reload();
    // }

    // Unregister all service workers
    async function unregisterServiceWorkers() {
        if ('serviceWorker' in navigator) {
            const registrations = await navigator.serviceWorker.getRegistrations();
            for (let registration of registrations) {
                await registration.unregister();
                console.info('Service worker unregistered:', registration);
            }
        }
    }

    unregisterServiceWorkers();

</script>

<script>

    // =====================================================================
    // ====================      HELPERS      ==============================
    // =====================================================================


    // -------------------- Helper DOM utilities --------------------
    const $ = (sel, root = null) => (root || document).querySelector(String(sel));
    const $$ = (sel, root = null) => {
        root = root || document;
        let els = root.querySelectorAll(String(sel));
        if (els.length === 0 && !String(sel).startsWith('.')) els = root.querySelectorAll('.' + String(sel));
        if (els.length === 0) els = catchVal($ID(String(sel)), [], not(isVoid));
        return els;
    }
    const $ID = (id) => document.getElementById(String(id));

    const $NAME = (name, root = null) => (root || document).getElementsByName(String(name));
    const $$CLS = (cls, root = null) => (root || document).getElementsByClassName(String(cls));
    const $$TAG = (tag, root = null) => (root || document).getElementsByTagName(String(tag));
    const $MAKE = (tag, root = null) => (root || document).createElement(String(tag));
    const $MAKE_NS = (tag, ns, root = null) => (root || document).createElementNS(String(ns), String(tag));
    const $FRAG = (root = null) => (root || document).createDocumentFragment();

    const exists = (id) => !!getElement(id);


    // 1) Basic type checks
    const isNumber = (x) => typeof x === 'number';
    const isBigInt = (x) => typeof x === 'bigint';
    const isBool = (x) => typeof x === 'boolean';
    const isFunc = (x) => typeof x === 'function';

    const isStr = (x) => typeof x === 'string';
    const isEmptyStr = (x) => isStr(x) && x.trim() === '';
    const isNonEmptyStr = (x) => isStr(x) && x.trim() !== '';
    const joinStrs = (...strs) => {
        let result = '';
        strs.forEach(s => {
            if (isStr(s)) {
                result += s;
            }
        });
        return result;
    };

    const isArr = (x) => Array.isArray(x);
    const isEmptyArr = (x) => isArr(x) && x.length === 0;
    const isNonEmptyArr = (x) => isArr(x) && x.length > 0;
    const joinArrs = (...arrs) => {
        const result = [];
        arrs.forEach(arr => {
            if (isArr(arr)) {
                result.push(...arr);
            }
        });
        return result;
    };

    const isDict = (x) => (
        isObj(x) &&
        (Object.getPrototypeOf(x) === Object.prototype ||
            Object.getPrototypeOf(x) === null)
    );
    const isEmptyDict = (x) => isDict(x) && Object.keys(x).length === 0;
    const isNonEmptyDict = (x) => isDict(x) && Object.keys(x).length > 0;
    const joinDict = (...objs) => {
        const result = {};
        objs.forEach(o => {
            if (isDict(o)) {
                Object.assign(result, o);
            }
        });
        return result;
    };

    const isObj = (x) => isDef(x) && typeof x === 'object';
    const isEmptyObj = (x) => isObj(x) && Object.keys(x).length === 0;
    const isNonEmptyObj = (x) => isObj(x) && Object.keys(x).length > 0;
    const joinObjs = (...objs) => {
        const result = {};
        objs.forEach(o => {
            if (isDef(o) && isObj(o)) Object.assign(result, o);
        });
        return result;
    };

    const isDate = (x) => x instanceof Date && !Number.isNaN(x.getTime());
    const isRegExp = (x) => x instanceof RegExp;
    const isSymbol = (x) => typeof x === 'symbol';
    const isUndefined = (x) => x === undefined || typeof x === 'undefined';
    const isNull = (x) => x === null;
    const isDef = (x) => !isUndefined(x) && !isNull(x);
    const isVoid = (x) => isUndefined(x) || isNull(x);

    const isMap = (x) => x instanceof Map;
    const isWeakMap = (x) => x instanceof WeakMap;
    const isMAP = (x) => isDef(x) && (isMap(x) || isWeakMap(x));
    const isEmptyMAP = (x) => isMAP(x) && x.size === 0;
    const isNonEmptyMAP = (x) => isMAP(x) && x.size > 0;
    const joinMAPs = (...maps) => {
        const result = new Map();
        maps.forEach(m => {
            if (isMap(m)) {
                for (let [key, value] of m.entries()) {
                    result.set(key, value);
                }
            }
        });
        return result;
    };

    const isSet = (x) => x instanceof Set;
    const isWeakSet = (x) => x instanceof WeakSet;
    const isSET = (x) => isDef(x) && (isSet(x) || isWeakSet(x));
    const isEmptySET = (x) => isSET(x) && x.size === 0;
    const isNonEmptySET = (x) => isSET(x) && x.size > 0;
    const joinSETs = (...sets) => {
        const result = new Set();
        sets.forEach(s => {
            if (isSet(s)) {
                for (let value of s.values()) {
                    result.add(value);
                }
            }
        });
        return result;
    };

    // === UZLY / DOKUMENTY ===
    const isDocument = (x) =>
        !isUndefined(Document) && x instanceof Document;

    const isElement = (x) =>               // jak√Ωkoli DOM element (vƒç. SVG/MathML)
        !isUndefined(Element) && x instanceof Element;

    const isHTMLElement = (x) =>           // pouze HTML elementy
        !isUndefined(HTMLElement) && x instanceof HTMLElement;

    // alternativnƒõ p≈ôes nodeType (funguje i cross-realm):
    const isElementNode = (x) => x?.nodeType === Node.ELEMENT_NODE;     // Node.ELEMENT_NODE === 1
    const isDocumentNode = (x) => x?.nodeType === Node.DOCUMENT_NODE;   // Node.DOCUMENT_NODE === 9

    // Pr√°zdnost elementu podle elementov√Ωch dƒõt√≠:
    const isEmptyHTMLElement = (x) => isHTMLElement(x) && x.childElementCount === 0;
    const isNonEmptyHTMLElement = (x) => isHTMLElement(x) && x.childElementCount > 0;

    // Pokud chce≈° br√°t v potaz i textov√© uzly:
    const hasAnyChildNodes = (x) => isElement(x) && x.hasChildNodes();


    // === KOLEKCE ===
    const isCollection = (x) =>
        !isUndefined(HTMLCollection) && x instanceof HTMLCollection;

    const isNodeList = (x) =>
        !isUndefined(NodeList) && x instanceof NodeList;

    // Obecn√° DOM kolekce (m√° .length a .item):
    const isDomCollectionLike = (x) =>
        isDef(x) && isNumber(x.length) && isFunc(x.item);

    const isEmptyCollection = (x) => (isCollection(x) || isDomCollectionLike(x)) && x.length === 0;
    const isNonEmptyCollection = (x) => (isCollection(x) || isDomCollectionLike(x)) && x.length > 0;

    const isEmptyNodeList = (x) => isNodeList(x) && x.length === 0;
    const isNonEmptyNodeList = (x) => isNodeList(x) && x.length > 0;

    // ‚ÄûJoin‚Äú helpery ‚Äì konvertuj√≠ do bƒõ≈æn√©ho pole
    const joinElements = (...collections) => {
        const result = [];
        collections.forEach(col => {
            if (isCollection(col) || isDomCollectionLike(col)) result.push(...Array.from(col));
        });
        return result;
    };

    const joinNodes = (...nodeLists) => {
        const result = [];
        nodeLists.forEach(nl => {
            if (isNodeList(nl)) result.push(...Array.from(nl));
        });
        return result;
    };

    // element ‚Äûpr√°zdn√Ω‚Äú jen pokud nem√° ≈æ√°dn√© elementov√© d√≠tƒõ ani non-whitespace text
    const isVisuallyEmptyElement = (el) => {
        if (!isElement(el)) return false;
        if (el.childElementCount > 0) return false;
        // obsahuje jen whitespace?
        const txt = el.textContent ?? '';
        return txt.trim() === '';
    };

    const isIterable = (x) => isDef(x) && isFunc(x?.[Symbol.iterator]);

    // --- SAME TYPE / INSTANCE / LENGTH ---

    // stejn√© typeof (pozor: [] i null jsou 'object', ale null jsme vy≈ôadili v isDef checku)
    const checkAllSameType = (...xs) => {
        if (xs.length === 0) return true;
        const firstType = typeof xs[0];
        return xs.every(v => typeof v === firstType);
    };

    // stejn√© ‚Äût≈ô√≠dy‚Äú (= shodn√Ω [[Prototype]])
    const checkAllSameInstance = (...xs) => {
        if (!xs.every(v => isObj(v))) return null; // trinary v√Ωsledek z≈Øst√°v√°
        const firstProto = Object.getPrototypeOf(xs[0]);
        return xs.every(v => Object.getPrototypeOf(v) === firstProto);
    };

    // unifikovan√° ‚Äûd√©lka‚Äú nap≈ô√≠ƒç typy (array/string ‚Üí length; Map/Set ‚Üí size; plain object ‚Üí keys)
    const getLen = (v) => {
        if (v == null) return undefined;
        if (isStr(v) || isArr(v)) return v.length;
        if (isMap(v) || isSet(v)) return v.size;
        if (isWeakMap(v) || isWeakSet(v)) return undefined;
        if (isDict(v)) return Object.keys(v).length;
        if (v && isNumber(v.length)) return v.length; // NodeList, HTMLCollection apod.
        return undefined;
    };

    const checkAllSameLength = (...xs) => {
        if (xs.length === 0) return true;
        const first = getLen(xs[0]);
        if (isVoid(first)) return null; // ‚Äûnem√° d√©lku‚Äú
        return xs.every(v => getLen(v) === first);
    };

    const checkAllSameTypeAndLength = (...xs) => {
        const sameType = checkAllSameType(...xs);
        if (!sameType) return false;
        return checkAllSameLength(...xs); // true/false/null
    };

    const checkAllSameInstanceAndLength = (...xs) => {
        const sameInst = checkAllSameInstance(...xs);
        if (sameInst !== true) return sameInst; // false nebo null
        return checkAllSameLength(...xs);
    };

    // --- JOIN ---

    // Slouƒç√≠ pouze objekty; pokud nejsou stejn√©ho typeof (typicky ‚Äûobject‚Äú), vr√°t√≠ null
    const joinAny = (...xs) => {
        if (!xs.every(isObj)) return null;
        if (!checkAllSameType(...xs)) return null; // u objekt≈Ø to bude 'object' (OK)
        return joinObjs(...xs);
    };

    const joinAll = (...xs) => {
        const result = [];
        xs.forEach(v => {
            if (isDef(v)) result.push(v);
        });
        return result;
    };

    const isValid = (x) => isDef(x) && !Number.isNaN(x);                        // all except undefined, null and NaN
    const isNumSafe = (x) => isFiniteNumber(x, false);                          // only Finite numbers
    const isVal = (x) => isNumSafe(x) || !isEmptyStr(x);                        // only Finite numbers or non-empty strings
    const isAny = (x) => isNotEmpty(x) && x !== false;                          // all except undefined, null and NaN + false
    const isOk = (x) => isAny(x) && !isInvalidValue(x, {considerFalse: true});  // all except undefined, null, NaN and false + invalid values

    const not = (fn) => {
        return function (...args) {
            return !fn.apply(this, args);
        }
    };

    const getElement = (id) => {
        return isElement(id) ? id : $ID(String(id));
    }

    const getElementValue = (id) => {
        const el = getElement(id);
        if (!isElement(el)) return null;
        return catchVal(el?.value?.trim(), null, isNonEmptyStr);
    }

    const getInputVal = (id) => {
        if (isFiniteNumber(id)) return id;
        const el = getElement(id);
        if (!isElement(el)) return null;

        let val = null;
        if (!isUnavailable(el)) val = catchVal(el?.value?.trim(), null, isNonEmptyStr); // TODO: el.disabled, el.hidden
        if (isNotEmpty(val)) return val;

        if (debugging) console.info('Getting default value for', el.id);

        if (el.dataset.hasOwnProperty('defaultValue')) return el.dataset.defaultValue;

        const defaultVal = JSON.parse(localStorage.getItem(storageKeyDefaults))[el.id] || null;
        if (isNotEmpty(defaultVal)) return defaultVal;

        return null;
    }


    const getInputValDef = (id, d = null) =>
        catchVal(getInputVal(id), d, isNotEmpty);

    const getInputNum = (id) =>
        toNumber((isFiniteNumeric(id) ? id : getInputValDef(id, NaN)), true);

    const getInputNumDef = (id_x, d = NaN) =>
        catchVal(getInputNum(id_x), d, isNumSafe);

    const getInputNumDefAbsFlt = (id_x, d = NaN) =>
        Math.abs(getInputNumDef(id_x, d));

    const getInputNumDefAbsInt = (id_x, d = NaN) =>
        Math.round(getInputNumDefAbsFlt(id_x, d));

    const isValidInputNum = (x) =>
        isFiniteNumber(x, false) && x > 0;

    const catchVal = (val, def, cond = isOk) =>
        (isFunc(cond) ? cond(val) : isOk(cond)) ? val : def;

    const isNumberOrBigInt = (x) =>
        isNumber(x) || isBigInt(x);

    const isInfinity = (x) => {
        const v = toNumber(x);
        return v === Number.POSITIVE_INFINITY || v === Number.NEGATIVE_INFINITY;
    };

    const isPositive = (x, includeZero = false) => {
        const v = toNumber(x);
        return isNumberOrInfinity(v) && (includeZero ? v >= 0 : v > 0);
    };

    const isNegative = (x, includeZero = false) => {
        const v = toNumber(x);
        return isNumberOrInfinity(v) && (includeZero ? v <= 0 : v < 0);
    };

    const isZero = (x) => toNumber(x) === 0 || !isNotEmpty(x);

    const isNumberOrInfinity = (x, bigInt = true) =>
        (isNumber(x) && !Number.isNaN(x)) || (bigInt && isBigInt(x)); // true i pro ¬±Infinity

    const isFiniteNumber = (x, bigInt = true) =>
        (isNumber(x) && Number.isFinite(x)) || (bigInt && isBigInt(x));

    const isFiniteInteger = (x, bigInt = true) =>
        (isNumber(x) && Number.isInteger(x)) || (bigInt && isBigInt(x));

    // 2) Parsing string to number (support for comma as decimal point)
    const toNumber = (x, all = true) => {
        if (isNumber(x)) return x;
        if (isBigInt(x)) return Number(x); // Number(x) for big Ints - watch precision
        return strToNumber(x, all); // if (isStr(x))
    };
    const toNumeric = (x, all = true) => {
        if (isNumberOrBigInt(x)) return x;
        return strToNumber(x, all); // if (isStr(x))
    };

    const toRounds = (x, digits = 0, way = 'round') => {
        const n = toNumber(x, true);
        if (!isNumberOrInfinity(n)) return NaN; // NaN/¬±Infinity
        if (!isNonEmptyStr(way)) way = 'round';         // default
        way = way.toLowerCase().trim();

        if (way === 'round' || way === 'auto') {

            if (!Number.isFinite(n)) return n; // ¬±Infinity

            digits = Math.min(Math.abs(Math.round(toNumber(digits, true))), maxPrecision);

            if (!isFiniteInteger(digits)) return NaN;
            return roundDecimalFast(n, digits);
        }
        if (way === 'ceil' || way === 'up') return Math.ceil(n);
        if (way === 'floor' || way === 'down') return Math.floor(n);
        if (way === 'trunc' || way === 'drop') return Math.trunc(n);
        return NaN;
    };

    const toInteger = (x, way = 'drop', bigInt = false) => {
        if (isNumber(x) && Number.isInteger(x)) return x;
        if (bigInt && isBigInt(x)) return x;

        if (!isNonEmptyStr(way)) way = 'drop'; // default
        const n = toRounds(x, 0, way);

        if (Number.isInteger(n)) return n;

        return NaN;
    };

    const strToNumber = (x, all = false) => {
        if (isStr(x)) {
            const s = x.toLowerCase().trim();
            if (s === '') return NaN;
            const n = s.replaceAll(',', '.').replaceAll('¬±', ' ').replaceAll('+', ' ').replace(/[‚Äì‚Äî‚àí]/g, '-').replaceAll('- ', '-');
            if (n.includes('-inf') || n.includes('-‚àû') || n.includes('-Íùè') || n.includes('-·Äë')) return Number.NEGATIVE_INFINITY;
            if (n.includes('inf') || n.includes('‚àû') || n.includes('Íùè') || n.includes('·Äë')) return Number.POSITIVE_INFINITY;

            return all ? parseFloat(n) : Number(n);
        }
        return NaN;
    };

    // 3) ‚ÄûIs it numeric‚Äú (including ¬±Infinity)
    const isNumericOrInfinity = (x) => {
        if (isNumberOrInfinity(x)) return true; // true also for ¬±Infinity
        const n = toNumeric(x, true);
        return !Number.isNaN(n); // true also for ¬±Infinity
    };

    // 4) ‚ÄûIs it finite numeric‚Äú (no NaN/¬±Infinity)
    const isFiniteNumeric = (x) => {
        if (isFiniteNumber(x, true)) return true;
        const n = toNumeric(x, true);
        return Number.isFinite(n);
    };

    // (optional) "can be reasonably used as a number" ‚Äì alias:
    const isAnyFiniteNumeric = (x) => {
        if (isFiniteNumber(x, true)) return true;
        const n = toNumeric(x, true);
        if (isBigInt(n)) return true; // BigInt is OK
        return Number.isFinite(n);
    };

    const isTypedArray = (x) => !isUndefined(ArrayBuffer) && ArrayBuffer.isView?.(x) && !(x instanceof DataView);

    const isArrayBuffer = (x) => !isUndefined(ArrayBuffer) && x instanceof ArrayBuffer;

    const isDataView = (x) => !isUndefined(DataView) && x instanceof DataView;

    // 5) ‚ÄûHas value‚Äú ‚Äì if you need it separately (0 and 'false' passes, null/undef/"" do not)
    const hasValue = (x) => isDef(x) && (isNumberOrInfinity(x) || isBool(x) || isNonEmptyStr(x));

    // Variant that does NOT consider false/true as "having value"
    const hasValueButNotBoolean = (x) => hasValue(x) && !isBool(x) && x?.toLowerCase().trim() !== 'false' && x?.toLowerCase().trim() !== 'true';

    const isNotEmpty = (x) => {
        // Null/undefined
        if (isVoid(x)) return false;

        // Numbers and Bigints
        if (isNumberOrInfinity(x)) return true;         // 0, ¬±Infinity passes, 0n and big values pass (not NaN)

        // Primitives / functions
        if (isStr(x)) return isNonEmptyStr(x);
        if (isBool(x)) return true;                     // false and true passes
        if (isFunc(x)) return true;
        if (isSymbol(x)) return true;

        // Arrays
        if (isArr(x)) return isNonEmptyArr(x);
        // Plain objects (dict)
        if (isDict(x)) return isNonEmptyDict(x);

        // Map/Set
        if (isMap(x) || isSet(x)) return x.size > 0;

        // Weak collections - cannot be checked for emptiness
        if (isWeakMap(x) || isWeakSet(x)) return null;  // null = unknown ‚âà false; (or true/false according to the use-case)

        // Binary / typed
        if (isTypedArray(x)) return x.length > 0;
        if (isArrayBuffer(x)) return x.byteLength > 0;
        if (isDataView(x)) return x.byteLength > 0;

        // Special objects
        if (isDate(x)) return true;                     // valid Date = ‚Äûhas value‚Äú
        if (isRegExp(x)) return true;

        // DOM nodes
        if (isElement(x)) return true;
        if (isDocument(x)) return true;                 // (now true) optionally could check for content

        // DOM collections
        if (isNodeList(x)) return isNonEmptyNodeList(x);
        if (isCollection(x)) return isNonEmptyCollection(x);
        if (isDomCollectionLike(x)) return x.length > 0;

        // Other objects
        if (isObj(x)) return isNonEmptyObj(x);

        return false;
    };


    const isInvalidValue = (x, {considerFalse = true, additionSet = [], use_extended = false} = {}) => {
        if (!hasValue(x)) return true; // null/undef/empty => only Numbers, bools and non-empty strings pass

        const BAD_basic = new Set([
            'nil', 'null', 'nullable', 'nullptr',
            'errno', 'error', 'err', 'error 404',
            'none', 'no', 'n/o', 'not', 'nothing', 'never',
            'nan', 'nat', 'n/a', 'na', 'n/d', 'nd',
            'undefined', 'empty', 'missing', 'void', 'voided', 'forgotten', 'out',
            'val', 'inv', 'invalid', 'not valid', 'disabled', 'expired', 'cancelled', 'not applicable', 'deleted', 'del',
            '‚Åø/‚Çê', '‚êÄ', '‚ê§', '‚ê°',
            'x', '‚úñ', '‚úñÔ∏è', '‚ùå',
            '!', '‚Äº',
            '?', '‚Åá',
            '‚ÄΩ', '!?', '?!',
        ]);

        const BAD_extended = new Set([
            '„éÅ',
            '√ó', '‚ï≥', '‚òì', '‚úï', '‚úó', '‚úò', '‚®â', '‚®Ø', 'üóô', 'üó¥', 'üó∂', 'üû©',
            '‚ùé', '‚òí', '‚ÆΩ', 'üóµ', 'üó∑', '‚ä†', '‚åß', 'üù±',
            '‚Ææ', '‚Æø', '‚äó', '‚®Ç', '‚≠ô',
            '‚ö†Ô∏é', '‚ö†', '‚ö†Ô∏è',
            '‚õî', '‚äò', 'üö´',
            '«É', '‚ùï', '‚ùó', '‚ù¢', 'Íúù', '·µé·µé',
            '‚Åâ', '‚Åà', 'üôπ', 'üô∫', 'üôª',
            'Ôπñ', '‚ùî', '‚ùì', '‚ç∞', 'ÔøΩ', '‚Øë', '¬ø', '‚∏Æ', 'Ô∏ñ', 'Ôºü',
            'üõë', '‚≠ïÔ∏è', 'üö®', 'üí•', 'üöß', 'üÜò', 'üÖæÔ∏è', '4Ô∏è‚É£0Ô∏è‚É£4Ô∏è‚É£', '‚Å¥‚Å∞‚Å¥',
            'Ôøº',
        ]);


        const norm = v => String(v || '')
            .normalize('NFKD')
            .replace(/\p{Diacritic}/gu, '') // remove diacritics
            .replace(/[.,]/g, '')           // remove dots and commas
            .replace(/\\/g, '/')            // replace \ for /
            .replace(/\s+/g, ' ')           // normalize spaces (simple spaces only)
            .trim()
            .toLowerCase();


        if (use_extended) for (const v of BAD_extended) BAD_basic.add(norm(v));
        if (considerFalse) BAD_basic.add('false');

        if (isNonEmptyArr(additionSet)) for (const v of additionSet) BAD_basic.add(norm(v));

        return BAD_basic.has(norm(x));
    }

    const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    const checkArray = (arr) => {
        if (!isNotEmpty(arr)) return null;
        return isNodeList(arr) ? Array.from(arr) : (isArr(arr) ? arr : [arr]);
    }

    const checkObject = (obj) => {
        if (!isNotEmpty(obj)) return null;
        if (isDict(obj)) return obj;
        if (isArr(obj)) {
            const res = {};
            for (let i = 0; i < obj.length; i++) {
                res[i] = obj[i];
            }
            return res;
        }
        if (isStr(obj) || isNumberOrInfinity(obj) || isBool(obj)) {
            return {0: obj};
        }
        return null;
    }

    const decimalSymbol = (num, symbol = '.') => {
        if (!isAnyFiniteNumeric(num)) return "N/A";
        if (!isFiniteNumber(num, true)) num = String(num);
        const s = String(num);
        return symbol === '.' ? s : s.replace('.', symbol);
    };

    const getValue = (x, dec = "none", strOut = false) => {
        const def = strOut ? "N/A" : NaN;

        if (!isNumericOrInfinity(x)) return def;

        // 1) Convert input to number (your toNumber supports comma etc.)
        let n = toNumeric(x, true);

        if (strOut && isBigInt(n)) n = Number(n);

        if (isVoid(dec) || dec === "none" || isBigInt(n)) {
            // no 'dec' -> return: 'n'
            return strOut ? String(n) : n;
        }

        // 2) evaluate decimal places only once
        if (!isAnyFiniteNumeric(dec)) return def;
        const d = clamp(Math.abs(toInteger(dec, "round", false)), 0, maxPrecision);

        if (d < 0 || !isNumSafe(d)) return def; // invalid 'dec' -> return: NaN/"N/A"

        // 3) round and return
        return strOut ? n.toFixed(d) : roundDecimalFast(n, d);
    };

    // Safe coercion to BigInt (accepts number/BigInt/string with number)
    const toBigInt = (x) => {
        if (isBigInt(x)) return x;
        let n = toNumber(x, true);
        if (!isFiniteNumber(n, true)) return NaN;
        if (!isFiniteInteger(n)) n = Math.round(n);
        try {
            return BigInt(n);
        } catch (e) {
            return NaN;
        }
    };

    // Clip to n bits (e.g., 64-bit unsigned ID)
    const toUintN = (n, b) => BigInt.asUintN(n, toBigInt(b));
    // Clip to n bits signed (e.g., 64-bit signed int)
    const toIntN = (n, b) => BigInt.asIntN(n, toBigInt(b));

    const decimalToHex = (num) => {
        if (!isFiniteInteger(num) || num < 0) return "N/A";
        return "0x" + Number(num).toString(16).toUpperCase();
    };
    const decimalToBinary = (num) => {
        if (!isFiniteInteger(num) || num < 0) return "N/A";
        return "0b" + Number(num).toString(2);
    };
    const binaryToDecimal = (str) => {
        if (!isStr(str)) return NaN;
        const s = str.trim();
        if (!/^0b[01]+$/i.test(s)) return NaN;
        return parseInt(s.slice(2), 2);
    };
    const hexToDecimal = (str) => {
        if (!isStr(str)) return NaN;
        const s = str.trim();
        if (!/^0x[0-9a-f]+$/i.test(s)) return NaN;
        return parseInt(s.slice(2), 16);
    };


    const getNumValue = (x, dec = "none") => getValue(x, dec, false);
    const getStrFixedValue = (x, dec = "none") => getValue(x, dec, true);
    const getStrValue = (x, dec = "none") => ((n => Number.isNaN(n) ? "N/A" : String(n))(getNumValue(x, dec)));
    const getCustomStrValue = (x, dec = "none", decSym = '.', writeSign = false, fixed = false, customError = "N/A") => {
        const v = fixed ? getStrFixedValue(x, dec) : getStrValue(x, dec);
        if (v === "N/A") return customError;
        let s = v;
        if (!(v === "Infinity" || v === "-Infinity")) s = decimalSymbol(v, decSym);
        s = s.replace('Infinity', '‚àû');
        if (writeSign && !s.startsWith('-')) {
            if (roundDecimalFast(strToNumber(v), 12) === 0) {
                s = '¬±' + s;
            } else {
                s = '+' + s;
            }
        }
        return s;
    };

    function roundDecimalFast(num, decimalPlace) {
        const p = Math.pow(10, clamp(decimalPlace || 0, 0, maxPrecision));
        return Math.round(num * p) / p;
    }

    const arrayWrapper = (arr, func, args) => {
        // console.log(arrayWrapper([0.000, "0", 454214878181871n, 0n, "0n", "900800700600500400300200100", "   -45   ", "   +45   ", "   ¬±45¬±45   ", 488.45, "100.005  ", "100. 005  ", "12,34", "  56.78  ", "text", null, undefined, {}, [], "NaN", "Infinity", "-Infinity"], getCustomStrValue, [12, '.', false, true]));
        if ((!arr && arr !== 0) || !func) return null;
        if (!isFunc(func)) return null;
        arr = checkArray(arr);
        if (!isNonEmptyArr(arr)) return null;
        args = checkArray(args);
        const res = [];
        for (let i = 0; i < arr.length; i++) {
            res.push(func(arr[i], ...args));
        }
        return res;
    }

    const objectWrapper = (obj, func, args) => {
        if ((!obj && obj !== 0) || !func) return null;
        if (!isFunc(func)) return null;
        obj = checkObject(obj);
        if (!isNonEmptyDict(obj)) return null;
        args = checkArray(args);
        const res = {};
        for (const key in obj) {
            if (Object.hasOwnProperty.call(obj, key)) {
                res[key] = func(obj[key], ...args);
            }
        }
        return res;
    }

    // =====================================================================
    // S T A T   &   E X T R E M A   U T I L S   (2D, ragged-friendly)
    // =====================================================================

    // ---------- internal helpers ----------
    /** Normalize input to 2D field of rows; empty -> [] */
    const normalize2D = (input) => {
        const outer = checkArray(input);
        if (!isNonEmptyArr(outer)) return [];
        return outer.map(r => {
            const row = checkArray(r);
            return !isNonEmptyArr(row) ? [] : row;
        });
    };

    /** D√©lka nejdel≈°√≠ho ≈ô√°dku */
    const rowsMaxLen = (rows) => rows.reduce((m, r) => Math.max(m, r.length), 0);

    /** Vyta≈æen√≠ sloupce j jako pole (m≈Ø≈æe obsahovat undefined) */
    const getCol = (rows, j) => rows.map(r => r[j]);

    /** Vr√°t√≠ pouze koneƒçn√° ƒç√≠sla (toNumber(..., true)); ostatn√≠ vyhod√≠ */
    const valuesFinite = (list) => {
        const arr = checkArray(list);
        if (!isNonEmptyArr(arr)) return [];
        const out = [];
        for (const v of arr) {
            const n = toNumber(v, true);
            if (Number.isFinite(n)) out.push(n);
        }
        return out;
    };

    /** Aplikaƒçn√≠ kostra: vezme 1D oper√°tor a aplikuje ho po dimenzi (0/1/2) */
    const aggregateND = (input, dim, op1D) => { // Dim = 0 -> global; 1 -> by cols; 2 -> by rows
        const rows = normalize2D(input);

        if (dim === 0 || (isStr(dim) && dim.includes("glob")) || isVoid(dim)) {
            const flat = [];
            for (const r of rows) flat.push(...r);
            return op1D(flat);
        }
        if (dim === 1 || (isStr(dim) && dim.includes("col"))) return rows.map(r => op1D(r));
        if (dim === 2 || (isStr(dim) && dim.includes("row"))) {
            const W = rowsMaxLen(rows);
            const out = new Array(W);
            for (let j = 0; j < W; j++) out[j] = op1D(getCol(rows, j));
            return out;
        }
        return NaN;
    };

    /** Glob√°ln√≠ argmin/argmax v 2D -> [rowIdx, colIdx] nebo NaN */
    const argExtremum2D = (rows, acceptInf, isMin) => {
        let best = isMin ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
        let bi = -1, bj = -1, seen = false;
        for (let i = 0; i < rows.length; i++) {
            const r = rows[i];
            for (let j = 0; j < r.length; j++) {
                const n = toNumber(r[j], true);
                const ok = acceptInf ? !Number.isNaN(n) : Number.isFinite(n);
                if (!ok) continue;
                if ((isMin && n < best) || (!isMin && n > best)) {
                    best = n;
                    bi = i;
                    bj = j;
                    seen = true;
                }
            }
        }
        return seen ? [bi, bj] : NaN;
    };

    // ---------- 1D oper√°tory ----------
    const sum1D = (list) => {
        if (isNumSafe(list)) return list;
        const v = valuesFinite(list);
        if (!v.length) return NaN;
        let s = 0;
        for (let i = 0; i < v.length; i++) s += v[i];
        return s;
    };

    const mean1D = (list) => {
        if (isNumSafe(list)) return list;
        const v = valuesFinite(list);
        return v.length ? sum1D(v) / v.length : NaN;
    };

    const median1D = (list) => {
        if (isNumSafe(list)) return list;
        const v = valuesFinite(list);
        if (!v.length) return NaN;
        v.sort((a, b) => a - b);
        const m = Math.floor(v.length / 2);
        return v.length % 2 ? v[m] : (v[m - 1] + v[m]) / 2;
    };

    /** Smƒõrodatn√° odchylka; sample=true -> Bessel (N-1), jinak populace (N) */
    const std1D = (list, sample = false) => {
        if (isNumSafe(list)) return list;
        const v = valuesFinite(list);
        const n = v.length;
        if (!n || (sample && n < 2)) return NaN;

        let sum = 0;
        for (let i = 0; i < n; i++) sum += v[i];
        const mu = sum / n;

        let acc = 0;
        for (let i = 0; i < n; i++) {
            const d = v[i] - mu;
            acc += d * d;
        }
        const denom = sample ? (n - 1) : n;
        return Math.sqrt(acc / denom);
    };

    // ---------- 1D extr√©my (sjednocen√©) ----------
    /** Hodnota extr√©mu v 1D podle which='min'|'max' */
    const extremum1DValue = (arr, which = 'min', acceptInf = false) => {
        if (!isArr(arr) || arr.length === 0) return NaN;
        let best = which === 'min' ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
        let seen = false;
        for (const v of arr) {
            const n = toNumber(v, true);
            if (Number.isNaN(n)) continue;
            if ((which === 'min' && n < best) || (which === 'max' && n > best)) {
                best = n;
                seen = true;
            }
        }
        if (!seen) return NaN;
        return acceptInf ? best : (Number.isFinite(best) ? best : NaN);
    };

    /** Index extr√©mu v 1D podle which='min'|'max' */
    const extremum1DIndex = (arr, which = 'min', acceptInf = false) => {
        if (!isArr(arr) || arr.length === 0) return NaN;
        let best = which === 'min' ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
        let idx = -1;
        for (let i = 0; i < arr.length; i++) {
            const n = toNumber(arr[i], true);
            if (Number.isNaN(n)) continue;
            if ((which === 'min' && n < best) || (which === 'max' && n > best)) {
                best = n;
                idx = i;
            }
        }
        return acceptInf ? idx : (Number.isFinite(best) ? idx : NaN);
    };

    // ---------- ND extr√©my (sjednocen√©) ----------
    const extremumND = (input, dim = 0, which = 'min', acceptInf = false) =>
        aggregateND(input, dim, (list) => extremum1DValue(list, which, acceptInf));

    const extremumNDIdx = (input, dim = 0, which = 'min', acceptInf = false) => {
        const rows = normalize2D(input);

        if (dim === 0 || isVoid(dim)) {
            return argExtremum2D(rows, acceptInf, which === 'min');
        }
        if (dim === 1) {
            return rows.map(r => extremum1DIndex(r, which, acceptInf));
        }
        if (dim === 2) {
            const W = rowsMaxLen(rows);
            const out = new Array(W);
            for (let j = 0; j < W; j++) {
                out[j] = extremum1DIndex(getCol(rows, j), which, acceptInf);
            }
            return out;
        }
        return NaN;
    };

    const extremumNDWithIdx = (input, dim = 0, which = 'min', acceptInf = false) => {
        const rows = normalize2D(input);
        const idx = extremumNDIdx(rows, dim, which, acceptInf);
        if (Number.isNaN(idx)) return {value: NaN, index: NaN};

        if (dim === 0 || isVoid(dim)) {
            const [i, j] = idx;
            return {value: toNumber(rows[i]?.[j], true), index: [i, j]};
        }

        if (dim === 1) {
            const values = rows.map((r, i) => {
                const j = idx[i];
                return Number.isFinite(j) ? toNumber(r[j], true) : NaN;
            });
            return {value: values, index: idx};
        }

        if (dim === 2) {
            const W = rowsMaxLen(rows);
            const values = new Array(W);
            for (let j = 0; j < W; j++) {
                const i = idx[j];
                values[j] = Number.isFinite(i) ? toNumber(rows[i]?.[j], true) : NaN;
            }
            return {value: values, index: idx};
        }

        return {value: NaN, index: NaN};
    };

    // Najde indexy a hodnoty prvk≈Ø nejbl√≠≈æe k c√≠lov√© hodnotƒõ (1D pole).
    // Vrac√≠ { indexes: number[], values: number[], distance: number }.
    // Pokud nic validn√≠ho, vrac√≠ { indexes: NaN, values: NaN, distance: NaN }.
    const nearest1D = (list, target) => {
        const arr = checkArray(list);
        if (!isNonEmptyArr(arr)) return {indexes: NaN, values: NaN, distance: NaN};

        const t = toNumber(target, true);
        if (Number.isNaN(t)) return {indexes: NaN, values: NaN, distance: NaN};

        // Speci√°l: kdy≈æ c√≠l je +‚àû/-‚àû, smysluplnƒõ zvol√≠me extr√©m
        if (t === Number.POSITIVE_INFINITY || t === Number.NEGATIVE_INFINITY) {
            const which = t === Number.POSITIVE_INFINITY ? 'max' : 'min';
            // najdi extr√©mn√≠ hodnotu (koneƒçnou, pokud existuje)
            let bestVal = extremum1DValue(arr, which, /*acceptInf*/ true);
            if (Number.isNaN(bestVal)) return {indexes: NaN, values: NaN, distance: NaN};

            // seber v≈°echny indexy s touto hodnotou
            const indexes = [];
            const values = [];
            for (let i = 0; i < arr.length; i++) {
                const n = toNumber(arr[i], true);
                if (Object.is(n, bestVal) || (Number.isFinite(n) && Number.isFinite(bestVal) && n === bestVal)) {
                    indexes.push(i);
                    values.push(n);
                }
            }
            return {indexes, values, distance: Math.abs(bestVal - t)}; // bude Infinity u koneƒçn√Ωch bestVal proti ¬±‚àû
        }

        // Bƒõ≈æn√Ω p≈ô√≠pad: koneƒçn√Ω c√≠l
        const EPS = 1e-12;
        let bestDist = Number.POSITIVE_INFINITY;
        let indexes = [];
        let values = [];

        for (let i = 0; i < arr.length; i++) {
            const n = toNumber(arr[i], true);
            if (!Number.isFinite(n)) continue;

            const d = Math.abs(n - t);
            if (d + EPS < bestDist) {        // lep≈°√≠ kandid√°t
                bestDist = d;
                indexes = [i];
                values = [n];
            } else if (Math.abs(d - bestDist) <= EPS) { // stejnƒõ bl√≠zko ‚Üí p≈ôidej
                indexes.push(i);
                values.push(n);
            }
        }

        if (!indexes.length) return {indexes: NaN, values: NaN, distance: NaN};
        return {indexes, values, distance: bestDist};
    };

    const findFirstHigher = (arr, limit) => {
        for (let i = 0; i < arr.length; i++) {
            const n = toNumber(arr[i], true);
            if (Number.isFinite(n) && n >= limit) {
                return i;
            }
        }
    }

    const findTargetForce = (arr_F, arr_W, target_F) => {
        const idx = findFirstHigher(arr_F, target_F);
        if (idx < 1) return [arr_F[0], 0];
        return [linearInterpolation(arr_F[idx], arr_W[idx], arr_F[idx - 1], arr_W[idx - 1], target_F), idx];
    }

    const is1D = (input) => {
        const arr = checkArray(input);
        if (!isNonEmptyArr(arr)) return false;
        return arr.every(v => !isArr(v));
        // for (const v of arr) {
        //     if (isArr(v)) return false;
        // }
        // return true;
    }


    // ---------- ND oprators ----------
    // TODO: opravit check 1D => 2 pak u 1D dƒõl√° global, v√Ωsledek je pole s jedn√≠m prvkem ƒçili vstup
    // Dim = 0 -> global; 1 -> by cols; 2 -> by rows
    const sumND = (input, dim = 0) => aggregateND(input, dim, sum1D);
    const meanND = (input, dim = 0) => aggregateND(input, dim, mean1D);
    const medianND = (input, dim = 0) => aggregateND(input, dim, median1D);
    const stdND = (input, dim = 0) => aggregateND(input, dim, (list) => std1D(list, false)); // stdND: sample = false ‚Üí populace; true ‚Üí v√Ωbƒõr (N-1)
    const stdNDsample = (input, dim = 0) => aggregateND(input, dim, (list) => std1D(list, true)); // Alias pokud chce≈° v√Ωslovnƒõ ‚Äûsample‚Äú signaturu
    const nearestND = (input, dim = 0, target) => aggregateND(input, dim, (list) => nearest1D(list, target));

    // ---------- aliasy ‚Äûmin/max‚Äú pro pohodl√≠ a kompatibilitu ----------
    const minND = (input, dim = 0, acceptInf = false) => extremumND(input, dim, 'min', acceptInf);
    const maxND = (input, dim = 0, acceptInf = false) => extremumND(input, dim, 'max', acceptInf);
    const minNDIdx = (input, dim = 0, acceptInf = false) => extremumNDIdx(input, dim, 'min', acceptInf);
    const maxNDIdx = (input, dim = 0, acceptInf = false) => extremumNDIdx(input, dim, 'max', acceptInf);
    const minNDWithIdx = (input, dim = 0, acceptInf = false) => extremumNDWithIdx(input, dim, 'min', acceptInf);
    const maxNDWithIdx = (input, dim = 0, acceptInf = false) => extremumNDWithIdx(input, dim, 'max', acceptInf);

    const nearest = (arr, target) => nearest1D(arr, target);
    const minimum = (arr, acceptInf = false) => extremum1DValue(arr, 'min', acceptInf);
    const maximum = (arr, acceptInf = false) => extremum1DValue(arr, 'max', acceptInf);
    const minimumIdx = (arr, acceptInf = false) => extremum1DIndex(arr, 'min', acceptInf);
    const maximumIdx = (arr, acceptInf = false) => extremum1DIndex(arr, 'max', acceptInf);


    const invLerp = (a, b, x) => (x - a) / (b - a);
    const lerp = (start, end, t) => start + t * (end - start);
    const mapLetp = (a1, b1, a2, b2, c1) => lerp(a2, b2, invLerp(a1, b1, c1));


    const linearInterpolation = (a1, a2, b1, b2, c1) => {
        if (a1 === b1) return a2; // Avoid division by zero
        return mapLetp(a1, b1, a2, b2, c1);
    }

    // UTF-8 <-> Base64 helpers bez unescape/escape:
    const u8ToB64 = (u8) => {
        let s = "";
        for (let i = 0; i < u8.length; i++) s += String.fromCharCode(u8[i]);
        return btoa(s);
    };
    const b64ToU8 = (b64) => {
        const bin = atob(b64);
        const u8 = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
        return u8;
    };

    // =====================================================================

    const txtE = new TextEncoder();
    const txtD = new TextDecoder();

    // =====================================================================

    const isSkippable = (el) => {
        const datasetSys = el?.dataset.system;
        const elType = el?.type;
        return (
            !isElement(el) ||
            elType === 'file' ||
            elType === 'password' ||
            (
                isNonEmptyStr(datasetSys) &&
                (
                    datasetSys === '-1' ||
                    datasetSys === 'skip' ||
                    datasetSys === 'none' ||
                    datasetSys === 'null' ||
                    datasetSys === 'false'
                )
            )
        );
    };


    function isHidden(el) {
        el = getElement(el);
        if (!isElement(el)) return null;

        // nen√≠ v DOM
        if (!el.isConnected) return true;

        // atribut [hidden] na nƒõm nebo na libovoln√©m p≈ôedku
        if (el.closest('[hidden]')) return true; // el.hasAttribute('hidden') , el.hidden

        // dataset 'data-hidden="true"' na nƒõm nebo p≈ôedc√≠ch
        if (el.closest('[data-hidden="true"]')) return true;

        // tvoje "custom" t≈ô√≠dy na nƒõm nebo p≈ôedc√≠ch
        if (el.closest('.undisplayed, .invisible')) return true;

        // display:none (nebo mimo DOM) ‚Üí nem√° layout ‚Üí ≈æ√°dn√© rects
        if (el.getClientRects().length === 0) return true;

        // visibility je dƒõdiƒçn√° ‚Äì zkontroluj sebe i p≈ôedky
        for (let node = el; node && node.nodeType === 1; node = node.parentElement) {
            const cs = getComputedStyle(node);
            if (cs.visibility === 'hidden' || cs.visibility === 'collapse') return true;
            if (cs.display === 'none') return true; // (redundantn√≠ k getClientRects, ale explicitn√≠)
        }

        return false;
    }

    function isDisabled(el, opts = {}) {
        const {
            includeInert = true,        // [inert] na p≈ôedc√≠ch
            includeClasses = true,      // .disabled/.prohibited na prvku/p≈ôedc√≠ch
            includeDataset = true,      // [data-disabled="true"] na prvku/p≈ôedc√≠ch
            includeAttribute = true,    // atribut isDisabled/aria-disabled,  na prvku
            checkPointerEvents = false, // volitelnƒõ pova≈æovat pointer-events:none jako "disabled"
        } = opts;

        el = getElement(el);
        if (!isElement(el)) return false;

        // 1) Nativn√≠ disabled logika (vƒçetnƒõ <fieldset disabled> a :disabled)
        //    :disabled funguje pro nativn√≠ ovl√°dac√≠ prvky (button, input, select, textarea, option, optgroup, fieldset)
        if (isFunc(el.matches) && el.matches(':disabled')) return true;
        if (el.hasAttribute('disabled')) return true; // pro jistotu i mimo :disabled

        // 2) ARIA a inert (dƒõd√≠ se p≈ôes p≈ôedky)
        if (includeDataset && el.closest('[data-disabled="true"]') || el.closest('[data-disabled="1"]')) return true;
        if (includeInert && el.closest('[inert]')) return true;

        if (includeAttribute && (el.closest('[isDisabled="true"]') || el.closest('[isDisabled="1"]'))) return true;
        if (includeAttribute && (el.closest('[aria-disabled="true"]') || el.closest('[aria-disabled="1"]'))) return true;

        // 3) Tvoje ‚Äúsoft‚Äù disabled t≈ô√≠dy/flagy na prvku nebo p≈ôedc√≠ch
        if (includeClasses && el.closest('.disabled, .prohibited')) return true;

        // 4) (Volitelnƒõ) stylov√© znep≈ô√≠stupnƒõn√≠
        if (checkPointerEvents) {
            for (let node = el; node && node.nodeType === 1; node = node.parentElement) {
                if (getComputedStyle(node).pointerEvents === 'none') return true;
            }
        }

        return false;
    }

    const isUnavailable = (el) => {
        el = getElement(el);
        if (!isElement(el)) return true;
        const hidden = isHidden(el);
        const disabled = isDisabled(el);
        return hidden || disabled;
    };

    const setDisabled = (el, disabled = true) => {
        el = getElement(el);
        if (!isElement(el)) return false;
        if (disabled) {
            // el.setAttribute('disabled', 'true');
            // el.setAttribute('area-disabled', 'true');
            el.setAttribute('isDisabled', 'true');
        } else {
            // el.removeAttribute('disabled');
            el.removeAttribute('isDisabled');
        }
        return true;
    };

    // =====================================================================


    function getLocaleOrder(locales = null, {
        timeZone = undefined,           // nech pr√°zdn√© pro aktu√°ln√≠ z√≥nu
        force24h = false                // true => vynut√≠ 24h (H), i kdy≈æ je locale 12h
    } = {}) {
        const opts = {
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            timeZone
        };

        if (isVoid(locales)) {
            locales = navigator.languages && navigator.languages.length ? navigator.languages : [navigator.language || 'en-US'];
        }

        // vytvo≈ô form√°tovaƒç a p≈ôeƒçti meta
        const dtf = new Intl.DateTimeFormat(locales, opts);
        const ro = dtf.resolvedOptions();

        // zji≈°tƒõn√≠, zda je 12h form√°t (nebo vynucenƒõ 24h)
        const is12h = !force24h && (ro.hour12 === true || /^h1[12]$/.test(ro.hourCycle || ""));
        const hourSymbol = is12h ? "h" : "H";

        // pou≈æij ‚Äûrozli≈°iteln√©‚Äú datum/ƒças (kv≈Øli po≈ôad√≠ je jedno, ale a≈• jsou ƒç√≠sla jasn√°)
        const d = new Date(Date.UTC(2001, 10, 21, 13, 14, 15)); // 21.11.2001 13:14:15

        // rozpitvej form√°t na ƒç√°sti
        const parts = dtf.formatToParts(d);

        // poskl√°dej po≈ôad√≠
        const mapDate = {day: "D", month: "M", year: "Y"};
        const mapTime = {hour: hourSymbol, minute: "m", second: "s"};

        const dateOrder = parts
            .filter(p => p.type === "day" || p.type === "month" || p.type === "year")
            .map(p => mapDate[p.type])
            .join(",");

        const timeOrder = parts
            .filter(p => p.type === "hour" || p.type === "minute" || p.type === "second")
            .map(p => mapTime[p.type])
            .join(",");

        const hasDayPeriod = parts.some(p => p.type === "dayPeriod");

        return {
            locale: ro.locale,                 // skuteƒçnƒõ pou≈æit√Ω locale (po fallbacku)
            date: dateOrder || null,           // nap≈ô. "D,M,Y" | "M,D,Y" | "Y,M,D"
            time: hasDayPeriod ? `${timeOrder},a` : timeOrder, // nap≈ô. "H,m,s" nebo "h,m,s,a"
            hourCycle: ro.hourCycle || (is12h ? "h12" : "h23"),
        };
    }

    // =====================================================================

    function progressCalculate(current, end) {
        if (!isFiniteNumber(current) || !isFiniteNumber(end) || end === 0) return NaN;
        let progress = clamp((current / end) * 100, 0, 100);
        return roundDecimalFast(progress, 6);
    }

</script>

<script>

    // ==========================
    // Jednotky, prefixy, parser
    // ==========================

    // --- Rozmƒõry a operace ---
    const ZERO = [0, 0, 0, 0, 0, 0, 0]; // L, M, T, I, Œò, N, J
    const DIMS = {L: 0, M: 1, T: 2, I: 3, Th: 4, N: 5, J: 6};

    const dim = (...d) => d;
    const addDim = (a, b) => a.map((v, i) => v + b[i]);
    const mulDim = (a, k) => a.map(v => v * k);
    const sameDim = (a, b) => a.every((v, i) => v === b[i]);

    // --- SI p≈ôedpony (vƒç. '¬µ' a fallback 'u') ---
    const PREFIX = new Map(Object.entries({
        Y: 1e24, Z: 1e21, E: 1e18, P: 1e15, T: 1e12, G: 1e9, M: 1e6,
        k: 1e3, h: 1e2, da: 1e1,
        d: 1e-1, c: 1e-2, m: 1e-3, u: 1e-6, '¬µ': 1e-6,
        n: 1e-9, p: 1e-12, f: 1e-15, a: 1e-18, z: 1e-21, y: 1e-24
    }));

    // --- Textov√© p≈ôedpony (slova) ‚Üí symbol p≈ôedpony ---
    const TEXT_PREFIX_ALIASES = new Map(Object.entries({
        yotta: 'Y', zetta: 'Z', exa: 'E', peta: 'P', tera: 'T',
        giga: 'G', mega: 'M', kilo: 'k', hecto: 'h', deka: 'da', deca: 'da',
        deci: 'd', centi: 'c', milli: 'm', micro: 'u', nano: 'n',
        pico: 'p', femto: 'f', atto: 'a', zepto: 'z', yocto: 'y'
    }));

    // --- Datab√°ze jednotek ---
    const UNITS = new Map(); // sym -> { dim, factor }
    const def = (sym, dimv, factor = 1) => UNITS.set(sym, {dim: dimv, factor});

    /* Z√°kladn√≠ SI + p√°r bƒõ≈æn√Ωch */
    def('m', dim(1, 0, 0, 0, 0, 0, 0));
    def('s', dim(0, 0, 1, 0, 0, 0, 0));
    def('A', dim(0, 0, 0, 1, 0, 0, 0));
    def('K', dim(0, 0, 0, 0, 1, 0, 0));
    def('mol', dim(0, 0, 0, 0, 0, 1, 0));
    def('cd', dim(0, 0, 0, 0, 0, 0, 1));

    def('kg', dim(0, 1, 0, 0, 0, 0, 0), 1);
    def('g', dim(0, 1, 0, 0, 0, 0, 0), 1e-3); // 1 g = 1e-3 kg

    // ƒåasov√© zkratky
    def('min', dim(0, 0, 1, 0, 0, 0, 0), 60);
    def('h', dim(0, 0, 1, 0, 0, 0, 0), 3600);

    // Odvozen√© (faktor 1, jen dimenze)
    const mD = UNITS.get('m').dim;
    const sD = UNITS.get('s').dim;
    const AD = UNITS.get('A').dim;
    const kgD = UNITS.get('kg').dim;
    const cdD = UNITS.get('cd').dim;

    const HzD = mulDim(sD, -1);
    def('Hz', HzD, 1);

    const ND = addDim(kgD, addDim(mD, mulDim(sD, -2)));
    def('N', ND, 1);

    const PaD = addDim(ND, mulDim(mD, -2));
    def('Pa', PaD, 1);

    const JD = addDim(ND, mD);
    def('J', JD, 1);

    const WD = addDim(JD, mulDim(sD, -1));
    def('W', WD, 1);

    const VD = addDim(WD, mulDim(AD, -1));
    def('V', VD, 1);

    // C, F, Œ©/ohm, T, lx
    const CD = addDim(AD, sD);
    def('C', CD, 1);

    const FD = addDim(CD, mulDim(VD, -1));
    def('F', FD, 1);

    const OhmD = addDim(VD, mulDim(AD, -1));
    def('Œ©', OhmD, 1);
    def('ohm', OhmD, 1);
    def('Ohm', OhmD, 1);

    const TD = addDim(ND, addDim(mulDim(AD, -1), mulDim(mD, -1)));
    def('T', TD, 1);

    // Lux = cd / m^2
    const lxD = addDim(cdD, mulDim(mD, -2));
    def('lx', lxD, 1);

    // Bezrozmƒõrn√© pomocn√©
    def('1', ZERO.slice(), 1);
    def('%', ZERO.slice(), 0.01);
    def('‚Ä∞', ZERO.slice(), 0.001);
    def('ppm', ZERO.slice(), 1e-6);
    def('ppb', ZERO.slice(), 1e-9);

    // Den, t√Ωden, mƒõs√≠c(30d), rok(365d)
    const SECONDS_PER_DAY = 24 * 60 * 60;
    def('d', dim(0, 0, 1, 0, 0, 0, 0), SECONDS_PER_DAY);
    def('day', dim(0, 0, 1, 0, 0, 0, 0), SECONDS_PER_DAY);
    def('wk', dim(0, 0, 1, 0, 0, 0, 0), 7 * SECONDS_PER_DAY);
    def('week', dim(0, 0, 1, 0, 0, 0, 0), 7 * SECONDS_PER_DAY);
    def('mo', dim(0, 0, 1, 0, 0, 0, 0), 30 * SECONDS_PER_DAY);
    def('month', dim(0, 0, 1, 0, 0, 0, 0), 30 * SECONDS_PER_DAY);
    def('yr', dim(0, 0, 1, 0, 0, 0, 0), 365 * SECONDS_PER_DAY);
    def('year', dim(0, 0, 1, 0, 0, 0, 0), 365 * SECONDS_PER_DAY);

    // Teploty ‚Äì symbolick√©; afinn√≠ p≈ôevod ≈ôe≈°√≠ convertUnits
    def('degC', UNITS.get('K').dim, 1); // ¬∞C
    def('degF', UNITS.get('K').dim, 1); // ¬∞F

    // Seznam symbol≈Ø (nejdel≈°√≠ nap≈ôed)
    let UNIT_SYMBOLS = Array.from(UNITS.keys()).sort((a, b) => b.length - a.length);

    // --- Textov√© aliasy jednotek (plur√°ly, n√°zvy, p≈ôeklepy) ‚Üí kanonick√© symboly ---
    const TEXT_UNIT_ALIASES = new Map(Object.entries({
        // ƒças
        sec: 's', secs: 's', second: 's', seconds: 's',
        mins: 'min', minute: 'min', minutes: 'min',
        hr: 'h', hrs: 'h', hour: 'h', hours: 'h',
        day: 'd', days: 'd',
        wks: 'wk', week: 'wk', weeks: 'wk',
        mos: 'mo', month: 'mo', months: 'mo',
        yrs: 'yr', year: 'yr', years: 'yr',

        // d√©lka / hmota
        meter: 'm', meters: 'm', metre: 'm', metres: 'm',
        gram: 'g', grams: 'g',

        // z√°kladn√≠ SI
        ampere: 'A', amperes: 'A',
        kelvin: 'K',
        mole: 'mol', moles: 'mol',
        candela: 'cd',

        // odvozen√©
        newton: 'N', newtons: 'N',
        pascal: 'Pa', pascals: 'Pa',
        joule: 'J', joules: 'J',
        watt: 'W', watts: 'W',
        volt: 'V', volts: 'V',
        coulomb: 'C', coulombs: 'C',
        farad: 'F', farads: 'F',
        ohm: 'ohm', ohms: 'ohm', Ohm: 'ohm',
        tesla: 'T', teslas: 'T',
        lux: 'lx',

        // teploty (text)
        celsius: 'degC', 'degree celsius': 'degC', degreecelsius: 'degC', 'degrees celsius': 'degC',
        fahrenheit: 'degF', 'degree fahrenheit': 'degF', degreefahrenheit: 'degF', 'degrees fahrenheit': 'degF'
    }));

    const TEXT_UNIT_TYPO_ALIASES = new Map(Object.entries({
        secnd: 's', minut: 'min', houer: 'h',
        gramm: 'g',
        nevtonn: 'N', newtonn: 'N', newtons: 'N',
        pascalss: 'Pa', jouless: 'J', wattss: 'W', voltss: 'V',
        coulombss: 'C', faradss: 'F', teslass: 'T',
        luxx: 'lx', luxes: 'lx',
        metre: 'm', metres: 'm' // (duplicitnƒõ pro jistotu)
    }));

    // --- Normalizace vstupu p≈ôed parsov√°n√≠m ---
    // 1) nahrad√≠ ¬∞C/¬∞F ‚Üí degC/degF
    // 2) nahrad√≠ textov√© p≈ôedpony & jednotky & p≈ôeklepy
    // 3) slep√≠ "<prefix><mezera><unit>" ‚Üí "<prefix><unit>" (nap≈ô. "k m" ‚Üí "km")
    function normalizeUnitsString(input) {
        if (isVoid(input)) return input;
        let s = String(input);

        // ¬∞C / ¬∞F ‚Üí degC / degF
        s = s.replace(/¬∞\s*[cC]/g, 'degC')
            .replace(/¬∞\s*[fF]/g, 'degF');

        const replaceWordMap = (map) => {
            const keys = Array.from(map.keys()).sort((a, b) => b.length - a.length);
            for (const k of keys) {
                const re = new RegExp(`\\b${k}\\b`, 'gi');
                s = s.replace(re, map.get(k));
            }
        };

        // nejd≈ô√≠v slova-p≈ôedpony, pak jednotky a p≈ôeklepy
        replaceWordMap(TEXT_PREFIX_ALIASES);
        replaceWordMap(TEXT_UNIT_ALIASES);
        replaceWordMap(TEXT_UNIT_TYPO_ALIASES);

        // slep "prefix symbol"+"mezera"+"unit" ‚Üí "prefix+unit"
        const prefixSymbols = ['Y', 'Z', 'E', 'P', 'T', 'G', 'M', 'k', 'h', 'da', 'd', 'c', 'm', 'u', '¬µ', 'n', 'p', 'f', 'a', 'z', 'y'];
        for (const pre of prefixSymbols) {
            for (const u of UNIT_SYMBOLS) {
                if (u === 'kg') continue; // kg je speci√°l
                const re = new RegExp(`\\b${pre}\\s+${u}\\b`, 'g');
                s = s.replace(re, `${pre}${u}`);
            }
        }

        return s;
    }

    // --- Parser jednotkov√©ho v√Ωrazu ---
    function parseUnitExpr(input) {
        if (!input || String(input).trim() === '' || input === '1') {
            return {dim: ZERO.slice(), factor: 1};
        }

        // normalizace
        let s = normalizeUnitsString(input);

        s = String(s)
            .replace(/[¬∑‚ãÖ‚Ä¢√ó]/g, '*')
            .replace(/[‚Äì‚Äî‚àí]/g, '-')   // r≈Øzn√© minusy
            .replace(/\s+/g, '*')     // mezery jako n√°soben√≠
            .replace(/[()]/g, '');    // bez z√°vorek

        const parts = s.split('/');
        let acc = {dim: ZERO.slice(), factor: 1};

        parts.forEach((segment, idx) => {
            const sign = (idx === 0) ? +1 : -1; // ƒçitatel / jmenovatel
            const tokens = segment.split('*').filter(Boolean);
            tokens.forEach(tok => {
                const {dim, factor} = parseUnitToken(tok);
                acc.dim = addDim(acc.dim, mulDim(dim, sign));
                acc.factor *= Math.pow(factor, sign);
            });
        });

        return acc;
    }

    function parseUnitToken(tok) {
        let t = String(tok).trim();
        if (!t) throw new Error(`Invalid unit token: "${tok}"`);
        let exp = 1;

        // exponent ^{...} nebo ^...
        const mPow = t.match(/\^(?:\{([^}]+)}|(.+))$/);
        if (mPow) {
            const raw = (mPow[1] || mPow[2]).trim();
            exp = parseInt(raw, 10);
            t = t.slice(0, mPow.index);
            if (!Number.isInteger(exp)) throw new Error(`Invalid exponent: "${raw}"`);
        }

        // unicode mocniny
        t = t.replace(/¬≤/g, '^2').replace(/¬≥/g, '^3');
        if (exp === 0) return {dim: ZERO.slice(), factor: 1};
        if (t === '1') return {dim: ZERO.slice(), factor: 1};

        // speci√°l: "kg" ‚Äì nesm√≠ se rozpadnout na k + g
        if (t === 'kg') {
            return {dim: mulDim(UNITS.get('kg').dim, exp), factor: 1};
        }

        // nejdel≈°√≠ zn√°m√Ω symbol jednotky jako sufix
        const unit = UNIT_SYMBOLS.find(u => t.endsWith(u));
        if (!unit) throw new Error(`Unknown unit: "${t}"`);

        const base = UNITS.get(unit);
        if (!base) throw new Error(`Unit "${unit}" is not supported`);

        const prefixStr = t.slice(0, t.length - unit.length);
        let pf = 1;
        if (prefixStr) {
            pf = PREFIX.get(prefixStr);
            if (isVoid(pf) && prefixStr === 'da') pf = 10; // fallback
            if (isVoid(pf)) throw new Error(`Unknown prefix: "${prefixStr}" in "${tok}"`);
        }

        return {
            dim: mulDim(base.dim, exp),
            factor: Math.pow(base.factor * pf, exp)
        };
    }

    // --- Teplotn√≠ helpery (ƒçist√© teploty jen) ---
    const isPureTempUnit = (u) => {
        const s = String(u).trim();
        return s === 'K' || s === 'degC' || s === 'degF';
    };
    const toKelvin = (value, sym) => {
        switch (sym) {
            case 'K':
                return value;
            case 'degC':
                return value + 273.15;
            case 'degF':
                return (value - 32) * (5 / 9) + 273.15;
            default:
                throw new Error(`Unsupported temperature unit: ${sym}`);
        }
    };
    const fromKelvin = (valueK, sym) => {
        switch (sym) {
            case 'K':
                return valueK;
            case 'degC':
                return valueK - 273.15;
            case 'degF':
                return (valueK - 273.15) * (9 / 5) + 32;
            default:
                throw new Error(`Unsupported temperature unit: ${sym}`);
        }
    };

    // --- Ve≈ôejn√© API: konverze hodnoty mezi jednotkami ---
    function convertUnits(value, fromUnit, toUnit, {precision = maxPrecision} = {}) {
        const valNorm = toNumber(value);
        if (!isFiniteNumber(valNorm)) return NaN;

        const fNorm = normalizeUnitsString(fromUnit);
        const tNorm = normalizeUnitsString(toUnit);

        const fIsTemp = isPureTempUnit(fNorm);
        const tIsTemp = isPureTempUnit(tNorm);

        if (fIsTemp || tIsTemp) {
            // afinn√≠ p≈ôevod sm√≠ b√Ωt jen mezi ƒçist√Ωmi teplotami
            if (!(fIsTemp && tIsTemp)) {
                throw new Error(`Temperature units cannot be combined with other units: "${fromUnit}" ‚Üí "${toUnit}"`);
            }
            const k = toKelvin(valNorm, fNorm);
            return fromKelvin(k, tNorm);
        }

        const a = parseUnitExpr(fNorm);
        const b = parseUnitExpr(tNorm);
        if (!sameDim(a.dim, b.dim)) {
            throw new Error(`Noncompatible units: "${fromUnit}" vs "${toUnit}"`);
        }
        const precisionInt = catchVal(toInteger(precision), maxPrecision, Number.isInteger);
        return roundDecimalFast(valNorm * (a.factor / b.factor), precisionInt);
    }

    // ==========================
    // TESTY & V√ùPIS DO KONZOLE
    // ==========================
    // function runTests() {
    //     console.log('--- TEST: ¬∞C / ¬∞F / K ---');
    //     console.log('normalize "¬∞C" ->', normalizeUnitsString('¬∞C')); // oƒçek√°v√°me "degC"
    //     console.log('normalize "¬∞F" ->', normalizeUnitsString('¬∞F')); // oƒçek√°v√°me "degF');
    //
    //     const tC = 25;
    //     console.log(`25 ¬∞C -> K: `, convertUnits(tC, '¬∞C', 'K'));     // 298.15
    //     console.log(`25 ¬∞C -> ¬∞F:`, convertUnits(tC, '¬∞C', '¬∞F'));    // 77
    //     console.log(`300 K -> ¬∞C:`, convertUnits(300, 'K', 'degC'));  // 26.85
    //     console.log(`77 ¬∞F -> ¬∞C:`, convertUnits(77, 'degF', 'degC')); // 25
    //
    //     console.log('\n--- TEST: textov√© n√°zvy & p≈ôeklepy ---');
    //     console.log('normalize "seconds" ->', normalizeUnitsString('seconds')); // s
    //     console.log('normalize "metres"  ->', normalizeUnitsString('metres'));  // m
    //     console.log('normalize "gramm"   ->', normalizeUnitsString('gramm'));   // g
    //     console.log('normalize "nevtonn" ->', normalizeUnitsString('nevtonn')); // N
    //
    //     console.log('\n--- TEST: textov√© p≈ôedpony ---');
    //     console.log('normalize "kilo meter" ->', normalizeUnitsString('kilo meter')); // km
    //     console.log('parse "kilo meter / second" == "km/s":',
    //         JSON.stringify(parseUnitExpr('kilo meter / second')) === JSON.stringify(parseUnitExpr('km/s'))
    //     );
    //
    //     console.log('\n--- TEST: bƒõ≈æn√© SI konverze ---');
    //     console.log('1 km -> m:', convertUnits(1, 'km', 'm'));           // 1000
    //     console.log('500 g -> kg:', convertUnits(500, 'g', 'kg'));       // 0.5
    //     console.log('1 N¬∑m -> J:', convertUnits(1, 'N*m', 'J'));         // 1
    //     console.log('1 Pa -> N/m^2:', convertUnits(1, 'Pa', 'N/m^2'));   // 1
    //
    //     console.log('\n--- TEST: chybov√© stavy ---');
    //     try {
    //         console.log('degC/s ‚Üí K/s (nemƒõlo by proj√≠t):', convertUnits(1, 'degC/s', 'K/s'));
    //     } catch (e) {
    //         console.log('Oƒçek√°van√° chyba (afinn√≠ teplota v pomƒõru):', e.message);
    //     }
    //     try {
    //         console.log('nezn√°m√° jednotka:', convertUnits(1, 'smurf', 'm'));
    //     } catch (e) {
    //         console.log('Oƒçek√°van√° chyba (unknown unit):', e.message);
    //     }
    //
    //
    //     convertUnits(2, 'min', 's');             // 120
    //     convertUnits(1, 'h', 'min');             // 60
    //
    //     convertUnits(1, 'mV/V', '1');            // 0.001  (bezrozmƒõrn√©)
    //     convertUnits(1, 'mV/V', '%');            // 0.1    (%)
    //     convertUnits(2.5, 'mV/V', '‚Ä∞');          // 2.5    (promile)
    //     convertUnits(500, 'ppm', '%');           // 0.05
    //
    //     convertUnits(1, 'kŒ©', 'ohm');            // 1000
    //     convertUnits(1, 'mA', 'A');              // 0.001
    //     convertUnits(1, 'C', 'A*s');             // 1
    //     convertUnits(1, 'F', 'C/V');             // 1
    //     convertUnits(1, 'T', 'N/(A*m)');         // 1
    //     convertUnits(1, 'lx', 'cd/m^2');         // 1
    //
    //     convertUnits(2, 'mm/min', 'mm/s');
    //     convertUnits(2.5, 'mV/GV', 'GV/mV');
    //     convertUnits(4, 'mV/V', 'MV/GV');
    //     convertUnits(4, 'mV/V', 'GV/GV');
    //     convertUnits(4, 'mm^2', 'cm^2');
    //     convertUnits(4, '¬µm^4', 'm^4');
    //     convertUnits(4, '¬µm^4', 'm^4');
    //
    //     convertUnits(1, 'd', 's');           // 86400
    //     convertUnits(2, 'wk', 'd');          // 14 (2x 7)
    //     convertUnits(60, 'mo', 'd');         // 1800 (2 mƒõs√≠ce po 30 dnech)
    //     convertUnits(1, 'yr', 'h');          // 365 * 24 = 8760
    //     convertUnits(1, 'km/yr', 'm/d');      // ‚âà 0.27778 (beze zmƒõny)
    //     convertUnits(1, 'mm/wk', 'mm/day');   // 60
    //
    //     convertUnits(1, 'N', 'kg*m/s^2');     // 1
    //     convertUnits(10, 'N', 'kN');          // 0.01
    //
    //     convertUnits(1, 'J', 'N*m');          // 1
    //     convertUnits(1, 'J', 'kg*m^2/s^2');   // 1
    //     convertUnits(500, 'kJ', 'MJ');        // 0.5
    //
    //     convertUnits(1, 'W', 'J/s');          // 1
    //     convertUnits(2.5, 'kW', 'W');         // 2500
    //     convertUnits(1, 'W', 'kg*m^2/s^3');   // 1
    // }

</script>


<script>
    const expTypesLabels = {
        "": "No selection",
        "no_selection": "No selection",
        "none": "No selection",
        "move_up": "Move up",
        "move_down": "Move down",
        "load": "Load test",
        "unload": "Unload test",
        "hold": "Hold test",
        "static": "Static test",
        "dynamic": "Dynamic test",
        "fatigue": "Fatigue test",
        "creep": "Creep test",
        "impact": "Impact test",
        "tensile": "Tensile test",
        "internal_bond": "Internal bond test",
        "compression": "Compression test",
        "pressure": "Compression test",
        "flexural": "Flexural test",
        "bending": "Flexural test",
        "shear": "Shear test",
        "adhesion": "Adhesion test",
        "peel": "Peel test",
        "lap_shear": "Lap shear test",
        "punch_shear": "Punch shear test",
        "tear": "Tear test",
        "burst": "Burst test",
        "puncture": "Puncture test",
        "indentation": "Indentation test",
        "hardness": "Hardness test",
        "hardness_br": "Brinell hardness test",
        "hardness_vh": "Vickers hardness test",
        "hardness_hb": "Rockwell hardness test",
        "hardness_hr": "Rockwell hardness test",
        "hardness_hc": "Rockwell hardness test",
        "hardness_hd": "Rockwell hardness test",
        "hardness_hf": "Rockwell hardness test",
        "hardness_ho": "Rockwell hardness test",
        "hardness_hk": "Knoop hardness test",
        "other": "Other",
    };

    const maxPrecision = 16; // maximal precision for numbers in rounding
    const precisionTime = 6;
    const precisionPosition = 4;
    const precisionPositionSystem = precisionPosition;
    const precisionForce = 2;
    const precisionForceSystem = 4;
    const precisionSpeed = 2;
    const precisionSpeedSystem = 2;
    const precisionAcceleration = 4;
    const precisionAccelerationSystem = 2;

    const timeConversionDATAC = convertUnits(1, '¬µs', 's');     // convert (microseconds) to seconds
    const timeConversionDSLR = convertUnits(1, 'ms', 's');      // convert (milliseconds) to seconds
    const timeConversionSToMs = convertUnits(1, 's', 'ms');     // convert (seconds) to milliseconds

    const loadCellNumMax = 3; // maximal number of load cells supported
    const loadCellNum = loadCellNumMax; // TODO: for now constant, else (dynamic assignment based on machine capabilities)
</script>

<script>
    function bindCopyAdjustButtons() {
        /* ======= KONFIG ======= */
        const COPY_SELECTOR = '.copyableInput';
        const ADJUST_SELECTOR = '.adjustableInput';
        const LINGER_MS = 1_000; // jak dlouho z≈Østane pilulka viditeln√° po akci/opu≈°tƒõn√≠

        /* ======= POMOCN√â FUNKCE (bezpeƒçn√© fallbacky) ======= */
        const normalize = (v) => String(v || '').toLowerCase()
            .replaceAll('\\', '/').replaceAll('.', '').replaceAll(',', '').trim();

        /* ======= GLOB√ÅLN√ç EXKLUZIVITA POSLEDN√ç AKCE ======= */
        let currentActive = null; // { el, btn }

        const cancelFadeListener = (btn) => {
            if (btn._onFadeEnd) {
                btn.removeEventListener('transitionend', btn._onFadeEnd);
                btn._onFadeEnd = null;
            }
        };
        const cancelHideTimer = (btn) => {
            if (btn._hideTimer) {
                clearTimeout(btn._hideTimer);
                btn._hideTimer = null;
            }
        };
        const deactivateCurrent = () => {
            if (!currentActive) return;
            const {el, btn} = currentActive;
            cancelHideTimer(btn);
            cancelFadeListener(btn);
            el.classList.remove('action-ok', 'action-err');
            btn.classList.remove('visible');
            btn.dataset.state = 'idle';
            currentActive = null;
        };

        const setStateExclusive = (el, btn, state) => {
            if (!currentActive || currentActive.btn !== btn) {
                deactivateCurrent();
                currentActive = {el, btn};
            }
            cancelFadeListener(btn);
            btn.dataset.state = state;
            btn.classList.add('visible');
        };

        const checkAdjustBtn = (btn, wrap) => {
            if (!btn) return;
            if (!wrap || !wrap.classList.contains('has-auto')) return;
            if (btn.dataset.state === 'idle' || btn.dataset.state === 'set' || btn.dataset.state === 'diff') {
                const input = $(ADJUST_SELECTOR, wrap);
                if (!input) return;
                const id = input.id || normalize(input.name) || normalize(input.dataset.adjustId);
                if (!id) return;
                const inputValue = input.value;
                const autoValue = adjustRegistryAPI.get(id);
                if (hasValue(autoValue) && hasValue(inputValue)) {
                    if (toNumber(autoValue) === toNumber(inputValue)) {
                        btn.dataset.state = 'set'; // already set
                    } else {
                        btn.dataset.state = 'diff'; // can be set
                    }
                } else {
                    btn.dataset.state = 'idle'; // no auto-value
                }
            }
        };

        const showBtn = (btn, wrap) => {
            cancelHideTimer(btn);
            cancelFadeListener(btn);
            btn.classList.add('visible');
            checkAdjustBtn(btn, wrap);
        };

        const hideBtnLater = (btn) => {
            cancelHideTimer(btn);
            btn._hideTimer = setTimeout(() => {
                btn.classList.remove('visible');
                cancelFadeListener(btn);
                btn._onFadeEnd = (ev) => {
                    if (ev.propertyName === 'opacity') {
                        const op = getComputedStyle(btn).opacity;
                        if (op === '0') {
                            btn.dataset.state = 'idle';
                            cancelFadeListener(btn);
                        }
                    }
                };
                btn.addEventListener('transitionend', btn._onFadeEnd);
            }, LINGER_MS - 100);
        };

        // wand (idle)
        const iconWand = '<svg class="icon-wand" viewBox="0 0 24 24" fill="none" stroke-width="2.75" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"> <path stroke="none" d="M0 0h24v24H0z" fill="none"/> <path d="M4 8v-2a2 2 0 0 1 2 -2h2"/> <path d="M4 16v2a2 2 0 0 0 2 2h2"/> <path d="M16 4h2a2 2 0 0 1 2 2v2"/> <path d="M16 20h2a2 2 0 0 0 2 -2v-2"/> <path d="M9 16v-5.5a2 2 0 1 1 6 0v5.5"/> <path d="M9.5 13h5"/></svg>';
        // Copy (idle)
        const iconCopy = '<svg class="icon-copy" viewBox="0 0 24 24" fill="none" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"> <rect width="13" height="16" x="8" y="7" rx="1.5" ry="1.5"/> <path d="M 3,15.5 V 3.5 C 3,2.7 3.7,2 4.5,2 H 15"/></svg>';
        // check
        const iconOK = '<svg class="icon-check" viewBox="0 0 24 24" fill="none" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"> <path d="M 4.8,13.4 9,17.6 19.6,7"/> </svg>';
        // X
        const iconX = '<svg class="icon-x" viewBox="0 0 24 24" fill="none" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"> <path d="M6 6 L18 18 M18 6 L6 18"/> </svg>';


        /* ======= VYTVO≈òEN√ç WRAPPERU ======= */
        const ensureWrap = (el) => {
            const parent = el.parentElement;
            if (parent && (parent.classList.contains('action-wrap') || parent.classList.contains('copy-wrap'))) {
                // kompatibilita: pokud u≈æ existuje copy-wrap, pov√Ω≈°√≠me ho na action-wrap
                parent.classList.add('action-wrap');
                return parent;
            }
            const wrap = $MAKE('span');
            wrap.className = 'action-wrap';
            el.insertAdjacentElement('beforebegin', wrap);
            wrap.appendChild(el);
            return wrap;
        };

        /* ======= PILULKY ======= */
        const makeCopyButton = () => {
            const btn = $MAKE('button');
            btn.type = 'button';
            btn.className = 'action-pill copy-pill';
            btn.dataset.state = 'idle';
            btn.setAttribute('aria-label', 'Copy value to clipboard');
            btn.title = 'Copy value';
            btn.innerHTML = `${iconCopy} ${iconOK} ${iconX}`;
            return btn;
        };

        const makeAdjustButton = () => {
            const btn = $MAKE('button');
            btn.type = 'button';
            btn.className = 'action-pill adjust-pill';
            btn.dataset.state = 'idle';
            btn.setAttribute('aria-label', 'Automatically set value');
            btn.title = 'Set automatic value';
            btn.innerHTML = `${iconWand} ${iconOK} ${iconX}`;
            return btn;
        };

        /* ======= REGISTR AUTO-HODNOT ======= */
        const _registry = {};
        const ensureId = (el, prefix = 'adj') => {
            if (el.id && el.id.trim().length) return el.id;
            const auto = `${prefix}-${Math.random().toString(36).slice(2, 8)}`;
            el.id = auto;
            return auto;
        };

        // ve≈ôejn√© API
        const adjustRegistryAPI = {
            get(id) {
                return isElement(id) ? _registry[id.id] : _registry[id];
            },
            set(id, value) {
                if (isElement(id)) id = id.id;
                _registry[id] = value;
                refreshAdjustButtonsFor(id); // UI refresh jen pro dan√Ω input
            },
            all() {
                return Object.assign({}, _registry);
            }
        };
        window.adjustRegistry = adjustRegistryAPI;        // ƒçti/zapisuj p≈ôes metody

        window.adjustSet = (id, v) => {
            const el = getElement(id);
            const val = toNumber(v);

            if (!hasValue(el.value) && isNumSafe(val)) blinkBorder(el, {
                restart: true,
                color: '#2196F3',
                backgroundOn: '#a7e7ff',
                blinks: 3,
            });

            else if (isNumSafe(val) && val === toNumber(el.value)) blinkBorder(el, {
                restart: true,
                color: '#4CAF50',
                backgroundOn: '#a9ffa9',
                blinks: 3,
            });

            else if (isNumSafe(val) && val !== adjustGet(id)) blinkBorder(el, {restart: true});

            else if (!isNumSafe(val) && isNumSafe(adjustGet(id))) blinkBorder(el, {
                restart: true,
                color: '#DC143C',
                backgroundOn: '#ffaeb9',
                blinks: 3,
            });

            adjustRegistryAPI.set(id, val);
        };
        window.adjustGet = (id) => adjustRegistryAPI.get(id);
        window.adjustDel = (id) => {
            if (!isUndefined(adjustRegistryAPI.get(id))) {
                adjustRegistryAPI.set(id, NaN);
            }
        };

        /* ======= VAZBA ID -> tlaƒç√≠tko pro rychl√Ω refresh ======= */
        const idToAdjustBtn = new Map();

        const refreshAdjustButtonsFor = (id) => {
            const btn = idToAdjustBtn.get(id);
            if (!btn) return;
            const val = adjustRegistryAPI.get(id);
            const valid = !isInvalidValue(val, {considerFalse: false});

            const input = $ID(id);
            const wrap = input?.closest('.action-wrap');

            if (valid) {
                btn.classList.remove('hidden');
                wrap?.classList.add('has-auto');
                checkAdjustBtn(btn, wrap);
            } else {
                btn.classList.add('hidden');
                btn.dataset.state = 'idle';
                wrap?.classList.remove('has-auto');
            }
        };

        // window.adjustRefresh = () => idToAdjustBtn.forEach((_, id) => refreshAdjustButtonsFor(id));

        /* ======= KOP√çROVAC√ç LOGIKA ======= */
        const bindCopy = (wrap, el) => {
            const btn = makeCopyButton();
            wrap.appendChild(btn);

            const copyValue = async () => {
                let ok = false;
                const val = (el.value || el.textContent || '').toString().trim();
                try {
                    if (!hasValue(val)) throw new Error('Empty');
                    const testVal = normalize(val);
                    if (!isInvalidValue(testVal, {considerFalse: false})) {
                        await navigator.clipboard.writeText(val);
                        ok = true;
                    }
                } catch (err) {
                    try {
                        if (el.select) {
                            const s = el.selectionStart, e = el.selectionEnd;
                            el.focus();
                            el.select();
                            ok = document.execCommand('copy');
                            if ((isDef(s) && isDef(e)) && (s <= e) && e !== 0) {
                                el.setSelectionRange(s, e);
                                ok = true;
                            } else {
                                ok = false;
                            }
                            el.blur();
                        }
                    } catch (err) {
                        ok = false;
                    }
                } finally {
                    el.classList.remove('action-err', 'action-ok');
                    if (ok) {
                        el.classList.add('action-ok');
                        setStateExclusive(el, btn, 'ok');
                    } else {
                        el.classList.add('action-err');
                        setStateExclusive(el, btn, 'err');
                    }
                    setTimeout(() => {
                        el.classList.remove('action-ok', 'action-err');
                        btn.dataset.state = 'idle';
                    }, LINGER_MS);
                    hideBtnLater(btn);
                }
            };

            wrap.addEventListener('mouseenter', () => showBtn(btn, wrap));
            wrap.addEventListener('mouseleave', () => hideBtnLater(btn));
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                copyValue();
            });
            el.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || (e.ctrlKey && e.key.toLowerCase() === 'c')) {
                    e.preventDefault();
                    showBtn(btn, wrap);
                    copyValue();
                }
            });
        };

        /* ======= NASTAVOVAC√ç LOGIKA (.adjustableInput) ======= */
        const bindAdjust = (wrap, el) => {
            const id = ensureId(el);
            if (!(_registry).hasOwnProperty(id)) _registry[id] = NaN; // init registru

            const btn = makeAdjustButton();
            idToAdjustBtn.set(id, btn);
            wrap.appendChild(btn);

            el.addEventListener('input', () => checkAdjustBtn(btn, wrap));

            const applyValue = () => {
                const raw = adjustRegistryAPI.get(id);
                const valid = !isInvalidValue(raw, {considerFalse: false});
                if (!valid) {
                    // ikona se nem√° zobrazit ani nic vkl√°dat
                    btn.classList.add('hidden');
                    btn.dataset.state = 'idle';
                    return false;
                }
                const str = String(raw);
                // vlo≈æit
                try {
                    const prev = {s: el.selectionStart, e: el.selectionEnd};
                    el.value = str;
                    // vyvolat standardn√≠ eventy
                    el.dispatchEvent(new Event('input', {bubbles: true}));
                    el.dispatchEvent(new Event('change', {bubbles: true}));
                    // navr√°tit caret pokud d√°v√° smysl
                    if (isDef(prev.s) && isDef(prev.e) && el.setSelectionRange) {
                        const end = str.length;
                        el.setSelectionRange(end, end);
                    }
                    btn.dataset.state = 'set';
                    return true;
                } catch (err) {
                    return false;
                }
            };

            const doAdjust = () => {
                const ok = applyValue();
                el.classList.remove('action-ok', 'action-err');
                blinkBorder.stop(el);
                if (ok) {
                    el.classList.add('action-ok');
                    setStateExclusive(el, btn, 'ok');
                } else {
                    el.classList.add('action-err');
                    setStateExclusive(el, btn, 'err');
                }
                setTimeout(() => {
                    el.classList.remove('action-ok', 'action-err');
                    btn.dataset.state = 'idle';
                    refreshAdjustButtonsFor(id); // po animaci znovu zhodnotit viditelnost
                }, LINGER_MS);
                hideBtnLater(btn);
            };

            // poƒç√°teƒçn√≠ viditelnost dle registru
            refreshAdjustButtonsFor(id);

            // interakce
            wrap.addEventListener('mouseenter', () => showBtn(btn, wrap));
            wrap.addEventListener('mouseleave', () => hideBtnLater(btn));
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                doAdjust();
            });
            el.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    showBtn(btn, wrap);
                    doAdjust();
                }
            });
        };

        /* ======= SCAN & INIT ======= */
        const setupOne = (el) => {
            const wrap = ensureWrap(el);
            // Pokud je to copyable, p≈ôidej copy pilulku
            if (el.matches(COPY_SELECTOR) && !$('.copy-pill', wrap)) bindCopy(wrap, el);
            // Pokud je to adjustable, p≈ôidej adjust pilulku
            if (el.matches(ADJUST_SELECTOR) && !$('.adjust-pill', wrap)) bindAdjust(wrap, el);
        };

        const scan = () => {
            $$(`${COPY_SELECTOR}, ${ADJUST_SELECTOR}`)?.forEach(setupOne);
        };

        // Ve≈ôejn√© API pro dynamick√© DOM zmƒõny
        window.adjustScan = scan;

        // INIT
        scan();

    }
</script>

<script>
    // ===================================
    // ======= Calculation helpers =======

    const calc_val_tare = (x, x_tare = 0) => x - x_tare;
    const calc_area = (b, h) => b * h;
    const calc_moment_of_inertia = (b, h) => 1 / 12 * b * (h * h * h);
    const calc_flex_modulus = (L, I, F, w) => (F * (L * L * L)) / (48 * I * w);
    const calc_flex_strength = (F, L, b, h) => (3 * F * L) / (2 * b * (h * h));
    const calc_stress = (F, A) => F / A;
    const calc_speed = (d, t) => d / t;
    const calc_load_speed = (v_orig, t_orig, t_load) => v_orig * (t_orig / t_load);
    const calc_indentation_diameter = (h, D) => 2 * Math.sqrt(h * (D - h));
    const calc_hardness_brinell = (F, D, d) => (2 * F) / (Math.PI * D * (D - Math.sqrt((D * D) - (d * d))));

    // =====================================================================
    // =====================================================================


    // z√°pis do outputu jako ƒç√≠sla s fixn√≠ p≈ôesnost√≠
    const getFormat = (value, dec = 3) =>
        getCustomStrValue(value, String(dec), '.', false, false, "‚Åø/‚Çê");

    // ƒçten√≠ ƒç√≠sla z inputu p≈ôes tvoje utility
    const readNum = (id, positiveOnly = false) => { // TODO: use my previous element functions
        const el = getElement(id);
        if (!el) return NaN;
        const val = getNumValue(el.value, "none");  // umo≈æn√≠ ƒç√°rku, ¬±, apod.
        return !positiveOnly ? val : (val < 0 ? NaN : val);
    };

    // z√°pis do outputu jako ƒç√≠sla s fixn√≠ p≈ôesnost√≠
    const writeOut = (id, value, dec = 3, overCome = false) => {// TODO: use my previous element functions
        const el = getElement(id);
        if (!el) return;
        const currV = readNum(id);
        if (currV === value) return; // nic nep≈ôepisujeme
        if (overCome) el.value = value;
        else el.value = getFormat(value, dec);
    };

    const applyAdjust = (id, value) =>
        (exists(id) && adjustGet(id) !== value) ? adjustSet(id, (!isInvalidValue(value) ? value : NaN)) : null;

    const fillComputableInputs = (id, value, dec = 3, lock = false) => {
        const el = getElement(id);
        if (!el) return;
        const currV = readNum(el);
        const currA = adjustGet(el);
        if (lockInterim || (!isValid(currA) || currA === currV)) writeOut(el, value, dec);
        if (lockInterim) applyAdjust(el, NaN);
        else applyAdjust(el, value);
        el.readOnly = lockInterim || (lock && (isInvalidValue(value) || isInvalidValue(currV)));
    };

    // -------------------- Hlavn√≠ p≈ôepoƒçet --------------------
    function recomputeAllCalculations() {
        // TODO: handle recomputeAllCalculations spamming on connect and end of experiment
        if (isExperimentRunning || !(initialPageLoaded && initialDataLoaded)) return;

        if (debugging) console.log("%c\n\n\n\tRecomputing all calculations...\n\n\n", 'color: red; font-size: 14px; font-weight: bold;');

        calculateComputableInputs();

        // --- naƒçten√≠ spoleƒçn√Ωch vstup≈Ø (tare) ---
        const F_tare = readNum("inputTareForce");      // N
        const w_tare = readNum("inputTareDisp");       // mm

        // --- B/IB/HB spoleƒçn√© ---
        const F_raw = readNum("inputForce");           // N
        const w_raw = readNum("inputDisp");            // mm
        const F = calc_val_tare(F_raw, F_tare);
        const w = calc_val_tare(w_raw, w_tare);

        const expType = $ID("experimentTypeDropdown")?.value.toLowerCase();

        const isB = expType.endsWith("-flx");
        const isIB = expType.endsWith("-inb");
        const isHB = expType.endsWith("-hbr");

        if (!isB && !isIB && !isHB) return; // nic dal≈°√≠ho nep≈ôepoƒç√≠t√°me

        const b = readNum("inputCSWidth", true);   // mm
        const h = readNum("inputCSHeight", true);  // mm


        // -------------------- IB: pr≈Ø≈ôez + napƒõt√≠ --------------------
        if (isIB) {
            // A = b*h
            const l = readNum("inputCSLength", true);       // mm
            const A = roundDecimalFast(calc_area(b, l), 3); // mm^2
            fillComputableInputs("outputArea", A, 3);


            // œÉ_max = F / A
            const A_curr = readNum("outputArea");   // mm^2
            const sigma = calc_stress(F, A_curr);        // N/mm^2 = MPa
            writeOut("outputMaxStress", sigma, 3);

        }

        // -------------------- B: ohyb (I_y, E) --------------------
        if (isB) {
            const I = roundDecimalFast(calc_moment_of_inertia(b, h), 3); // mm^4
            fillComputableInputs("outputIy", I, 3);

            // Modulus: E = (F * L^3) / (48 * I * w)   (3-bodov√Ω ohyb uprost≈ôed)
            const I_curr = readNum("outputIy");         // mm^4
            const L = readNum("inputSpan", true);       // mm
            const E = calc_flex_modulus(L, I_curr, F, w);    // vych√°z√≠ v N/mm^2 = MPa
            writeOut("outputModulus", E, 3);


            // (Max strength) f_m = (3*F*L) / (2*b*h^2)
            const Fmax = readNum("outputForceMax"); // N
            const f_m = calc_flex_strength(Fmax, L, b, h) // N/mm^2 = MPa
            writeOut("outputFlexStrength", f_m, 3);

            const b_dry = readNum("inputCSWidth_BeforeDrying", true);     // mm
            applyAdjust('inputCSWidth', b_dry);
            applyAdjust('inputCSWidth_BeforeDrying', b);

            const h_dry = readNum("inputCSHeight_BeforeDrying", true);   // mm
            applyAdjust('inputCSHeight', h_dry);
            applyAdjust('inputCSHeight_BeforeDrying', h);

            // const L_dry = readNum("inputLength_BeforeDrying", true);       // mm
            // applyAdjust('inputSpan', L_dry);
            // applyAdjust('inputLength_BeforeDrying', L);
        } else {
            adjustDel('inputCSWidth');
            adjustDel('inputCSHeight');
            adjustDel('inputCSWidth_BeforeDrying');
            adjustDel('inputCSHeight_BeforeDrying');
            adjustDel('inputSpan');
        }

        // -------------------- HB: Brinell --------------------
        if (isHB) {
            const D = readNum("inputIndDiameter", true);   // mm (‚åÄ indenteru)
            const hD = readNum("outputDepthInd", true);    // mm (hloubka vtisku)

            // d = 2 * sqrt( h * (2r - h) )  ;  2r = D  ; d = 2 * sqrt( h * (D - h) )
            const d = calc_indentation_diameter(hD, D);

            const diameterInd = (hD > D / 2) ? NaN : roundDecimalFast(d, precisionPositionSystem);
            fillComputableInputs("outputDiameterInd", diameterInd, precisionPositionSystem);

            // HB = (2*F) / (œÄ*D*(D - sqrt(D^2 - d^2)))
            const HBr = calc_hardness_brinell(F, D, d);
            writeOut("outputHardness", (hD > D / 2) ? NaN : HBr, 4);
        }
    }

    // -------------------- Event wiring --------------------
    function bindRecalcOnInputs() {
        if (!exists("experimentTypeDropdown")) return;

        // jak√Ωkoli input/number v bloc√≠ch s class .data-eq spust√≠ p≈ôepoƒçet
        const inputs = $$('.data-eq .adjustableInput'); //  input[type="number"]
        inputs?.forEach((el) => {
            // "input" je plynulej≈°√≠; "change" je a≈æ po opu≈°tƒõn√≠ pole. D√°me oboje.
            el.addEventListener('input', async () => recomputeAllCalculations());
        });

        $ID('experimentTypeDropdown')?.addEventListener('change', async () => recomputeAllCalculations());
    }

    function calculateComputableInputs() {
        const forces = sumND(forceData, 2); // souƒçet sil ze v≈°ech kan√°l≈Ø => zachovan√Ω stejn√Ω poƒçet ≈ô√°dk≈Ø TODO: do by 'load' definitions
        const displacements = positionData;

        // const minimalForceID = minimumIdx(forces);
        const maximalForceID = maximumIdx(forces);

        const F_tare = readNum("inputTareForce");      // N
        const w_tare = readNum("inputTareDisp");       // mm

        const Fmax_raw = forces[maximalForceID];            // N
        const w_Fmax_raw = displacements[maximalForceID];   // mm

        const Finitial_raw = readNum("inputInitialForce"); // N
        const [w_Finitial_raw, FinitialInd] = findTargetForce(forces, displacements, Finitial_raw);
        // const w_Finitial = calc_val_tare(w_Finitial_raw, w_tare);

        const Fmax = calc_val_tare(Fmax_raw, F_tare);
        const w_Fmax = calc_val_tare(w_Fmax_raw, w_tare);

        // Zapi≈° z√°kladn√≠ "max" (rozumƒõj aktu√°ln√≠ zadan√©) hodnoty, pokud v√Ωstupy existuj√≠
        writeOut("outputForceMax", Fmax, precisionForceSystem);
        writeOut("outputDisp", w_Fmax, precisionPositionSystem);

        const Ftarget_goal = readNum("inputTargetForce"); // N
        const [w_Ftarget_raw, FtargetInd] = findTargetForce(forces, displacements, Ftarget_goal);
        const w_Ftarget = calc_val_tare(w_Ftarget_raw, w_tare);
        writeOut('inputTargetDisp', w_Ftarget, precisionPositionSystem + 1);

        const inputForce = readNum("inputForce");
        const foundForce = nearest(forces, inputForce);
        const foundForceInd = foundForce.indexes;
        const isCloseForce = foundForceInd.length > 0 && (foundForce.distance < Math.max((inputForce * 0.02), (1 / Math.pow(10, Math.round(precisionForce / 2)))));
        const w_inputForce = isCloseForce ? roundDecimalFast(displacements[foundForceInd[0]], precisionPositionSystem) : NaN; // mm
        applyAdjust('inputDisp', w_inputForce);


        if ($ID("experimentTypeDropdown")?.value.toLowerCase().endsWith("-hbr")) {
            const lengthHolding = (forces.length - 1) - FtargetInd;
            const lengthAnalysis = clamp(Math.ceil(lengthHolding * 0.2), 100, lengthHolding); // use last 80% of holding phase for analysis
            const finalForce = roundDecimalFast(mean1D(forces.slice(lengthAnalysis)), precisionForceSystem);
            applyAdjust('inputForce', finalForce);


            const depthIndentation = roundDecimalFast(displacements[displacements.length - 1] - displacements[FinitialInd], precisionPositionSystem);
            fillComputableInputs("outputDepthInd", depthIndentation, precisionPositionSystem);


            // Rychlost zatƒõ≈æov√°n√≠: v = w_T / t
            const t_goal = readNum("inputLoadingTime", true);                   // s
            const w_goal = calc_val_tare(w_Ftarget_raw, w_Finitial_raw);        // mm

            const time = timeData;
            const t_Finitial_raw = time[FinitialInd];                                               // s
            const t_set_raw = time[FtargetInd];                                                     // s
            const t_set = calc_val_tare(t_set_raw, t_Finitial_raw);                                 // s
            const v_set = catchVal(speedForward_mmps, readNum("inputSpeedForward", true), isNumSafe);   // mm/s

            const v1 = calc_speed(w_goal, t_goal);              // variant 1     mm/s
            const v2 = calc_load_speed(v_set, t_set, t_goal);   // variant 2     mm/s

            console.log("\n",
                "\n\tGuess 1:", roundDecimalFast(v1, precisionSpeedSystem + 2),
                "\n\tGuess 2:", roundDecimalFast(v2, precisionSpeedSystem + 2));
            const v = v2;

            writeOut("outputLoadingSpeed", v, precisionSpeedSystem + 2);

            // TODO: speed: 0.6825mm/s => time: 2.6s - 5.2s => target time: 15s => new speed: 0.2944mm/s
            // TODO: ŒîT = 5.2 - 2.6 = 2.6s
            // TODO: ((5.2-2.6) / 15) = 0.1733 [-]
            // TODO: 0.6825 * ((5.2-2.6) / 15) = 0.1183 mm/s

            // 2.6 => 1.7745, 5.2 => 3.549
            // Œît = 2.6s, Œîw = 1.7745
            // v1 = 1.7745 / 15 = 0.1183 mm/s
            // v2 = 0.6825 * (2.6 / 15) = 0.1183 mm/s

            // TODO: v_new1 = position / T_target = (v_old * T_old) / T_target = ((position / T_old) * T_old) / T_target = position / T_target
            // TODO: v_new2 = v_old * (T_old / T_target) = (position / T_old) * (T_old / T_target) = position / T_target

        } else {
            const inputDisp = readNum("inputDisp");
            const foundDisp = nearest(displacements, inputDisp);
            const foundDispInd = foundDisp.indexes;
            const isCloseDisp = foundDispInd.length > 0 && (foundDisp.distance < Math.max((inputDisp * 0.02), (1 / Math.pow(10, Math.round(precisionPosition / 2)))));
            const F_inputDisp = isCloseDisp ? roundDecimalFast(forces[foundDispInd[0]], precisionForceSystem) : NaN; // N
            applyAdjust('inputForce', F_inputDisp);
        }
    }

    function clearCalculations() {

        $ID('inputTareForce').value = '0';
        $ID('inputTareDisp').value = '0';
        $ID('inputMaterialName').value = '';
        $$(".data-eq[data-eq-type]")?.forEach(el => {
            $$('input', el)?.forEach(input => {
                input.value = '';
            });
        });
        recomputeAllCalculations();
    }
</script>

<script>
    function showNotification(title = "Notification", message = "This is a notification.") {
        if (!("Notification" in window)) {
            alert("Your browser does not support notifications.");
            return;
        }

        if (notificationsAllowed) {
            // Show notification immediately
            new Notification(title, {body: message});
        } else {
            // Request permission if not yet granted
            Notification.requestPermission().then(permission => {
                if (permission === "granted") {
                    notificationsAllowed = true;
                    new Notification(title, {body: message});
                } else {
                    alert("Notifications were not allowed.");
                }
            });
        }
    }

</script>

<script>
    // /////// UI Elements /////////
    let UI;

    // Connection status messages and colors
    const STATE = {
        connected: {dot: 'üü¢', btn: '‚ùå', color: '#4CAF50', verb: 'Disconnect'},
        connecting: {dot: 'üîµ', btn: 'üîì', color: '#2196F3', verb: 'Connecting‚Ä¶'},
        reconnecting: {dot: 'üü†', btn: 'üîÑ', color: '#FFA500', verb: 'Reconnecting‚Ä¶'},
        disconnected: {dot: 'üî¥', btn: null, color: '#FF0000', verb: 'Connect'},
        disconnecting: {dot: 'üü£', btn: 'üîê', color: '#886CE4', verb: 'Disconnecting‚Ä¶'},
        error: {dot: '‚õî', btn: '‚ùó', color: '#DC143C', verb: 'Error'},
    };

    const TYPE_LABEL = {serial: 'USB', bluetooth: 'Bluetooth', wifi: 'Wi-Fi'};
    const TYPE_CONNECT_EMOJI = {serial: 'üîå', bluetooth: 'üì∂', wifi: 'üåê'};

    // jednoduch√Ω ‚Äûv√Ωrobc–µ textu‚Äú pro aktivn√≠ tlaƒç√≠tko
    function formatActiveBtn(status, type) {
        const t = String(type || '').toLowerCase().trim();
        const T = TYPE_LABEL[t] || '';
        if (status === 'disconnected') {
            // u disconnected chceme ‚ÄûConnect via ‚Ä¶‚Äú s typov√Ωm emoji
            return `${TYPE_CONNECT_EMOJI[t] || ''} Connect via ${T}`;
        }
        const emoji = STATE[status]?.btn || '';
        const verb = STATE[status]?.verb || '';
        return `${emoji} ${verb}<br>(${T})`;
    }

    // v√Ωchoz√≠ text jin√Ωch (neaktivn√≠ch) tlaƒç√≠tek
    function baseBtnText(type) {
        const t = String(type || '').toLowerCase().trim();
        const T = TYPE_LABEL[t] || '';
        return `${TYPE_CONNECT_EMOJI[t] || ''} Connect via<br>${T}`;
    }

    function updateConnectionStatus(status, type = null) {
        if (!STATE[status]) return;

        if (type != null) connectionType = String(type).toLowerCase().trim();

        // status ≈ô√°dek
        const dot = STATE[status].dot;
        const color = STATE[status].color;
        const T = TYPE_LABEL[connectionType] || null;
        UI.connectionStatus.textContent = `${dot} ${status[0].toUpperCase()}${status.slice(1)}${T ? ` via ${T}` : ''}`;
        UI.connectionStatus.style.color = color;

        // tlaƒç√≠tka
        UI.connectBtns.forEach(btn => {
            const btnType = String(btn.dataset.connectionType).toLowerCase().trim();
            const isActive = connectionType && btnType === connectionType;

            // text: aktivn√≠ podle stavu, ostatn√≠ na v√Ωchoz√≠
            btn.innerHTML = isActive ? formatActiveBtn(status, btnType) : baseBtnText(btnType);

            // povolen√≠/zak√°z√°n√≠ (jednodu≈°e: aktivn√≠ je povolen√© jen u connected/disconnected)
            const enabled =
                (isActive && (status === 'connected' || status === 'disconnected')) ||
                (!isActive && status === 'disconnected');

            btn.classList.toggle('disabled', !enabled);
            btn.toggleAttribute('disabled', !enabled); // voliteln√©, ale lep≈°√≠ pro p≈ô√≠stupnost
        });
    }

    function lockConnectionButtons(lock = true, exceptType = null) {
        if (isNonEmptyStr(exceptType)) exceptType = String(exceptType)?.toLowerCase().trim();
        else exceptType = null;
        UI.connectBtns?.forEach(btn =>
            btn.classList.toggle('disabled', isNonEmptyStr(exceptType) ? (String(btn.dataset.connectionType)?.toLowerCase().trim() === exceptType ? false : lock) : lock));
        UI.connectElement?.forEach(el =>
            el.classList.toggle('disabled', lock));
    }

    function controlContainerWidth(container) {
        if (!container) return;
        if (isStr(container)) container = $ID("resultsContainer");
        if (window.getComputedStyle(container).maxHeight !== "0px") {
            container.style.maxHeight = container.scrollHeight + "px"; // Adjust height on window resize
        }
    }


    function controlContainer(btn, container) {
        if (!container || !btn) return;

        if (window.getComputedStyle(container).maxHeight === "0px") {
            container.style.display = 'block';
            container.style.visibility = 'visible';
            container.style.contentVisibility = 'unset';
            container.style.maxHeight = container.scrollHeight + "px"; // Open the container and get real height
            container.style.opacity = "1";
            btn.textContent = "üîº";
        } else {
            container.style.maxHeight = "0"; // Close the container
            container.style.opacity = "0";
            btn.textContent = "üîΩ";
            container.addEventListener('transitionend', () => {
                container.style.visibility = 'hidden';
                container.style.display = 'none';
                container.style.contentVisibility = 'auto';
            }, {once: true});
        }
    }


    // /////// Input Validation and Adjustment /////////

    // Ensures user input is within a valid min / max range
    function checkInput(element, valueType, decimalPlaces) {
        if (!element) return;

        const val = parseFloat(element?.value);
        const min = parseFloat(element?.min);
        const max = parseFloat(element?.max);
        let newVal = val;

        // Validate input: if empty, set to a minimum or 0
        if (!isNumSafe(val)) {
            if (isNumSafe(min)) newVal = min;
            else if (isNumSafe(max)) newVal = max;
            else return;
        } else if (isStr(valueType)) {
            if (valueType === "intInput") {
                newVal = Math.floor(val)
            }

            // Enforce min/max constraints
            if (isNumSafe(min) && newVal < min) {
                newVal = min;
            }
            if (isNumSafe(max) && newVal > max) {
                newVal = max;
            }

            if (valueType.includes("floatInput")) {

                decimalPlaces = toNumber(decimalPlaces);
                let roundTo =
                    isNumSafe(decimalPlaces) ? decimalPlaces : parseFloat(valueType.replace('floatInput', ''));

                if (!isNumSafe(roundTo)) {
                    roundTo = maxPrecision;
                    const step = element?.step.trim();

                    if (step && !step.includes("any")) { // step !== "any" && step !== "any,any"
                        const decimals = (step.replace(',', '.').split(".")[1] || "").length;
                        const stepVal = Math.abs(parseFloat(step));

                        if (isNumSafe(stepVal) && stepVal > 0) {
                            if (stepVal < 1 && decimals > 0) roundTo = decimals;
                            if (stepVal >= 1) roundTo = stepVal;
                        }
                    }

                    roundTo = Math.max(roundTo, 5);
                }


                if (!isNumSafe(roundTo)) roundTo = maxPrecision;

                roundTo = Math.abs(Math.min(Math.round(roundTo), maxPrecision));

                if (roundTo >= 0) newVal = roundDecimalFast(newVal, roundTo);
            }
        }
        if (val !== newVal) {
            element.value = newVal;
            element.dispatchEvent(new Event("change", {bubbles: true}));
        }
    }


    // --- Convert unit markup to HTML (only <sub>/<sup> allowed) ---
    function unitMarkupToHTML(str = '') {
        // escape everything‚Ä¶
        let out = String(str).replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

        // ‚Ä¶allow only these forms of sub/sup notation:

        // [sub]x[/sub], [sup]x[/sup]
        out = out.replace(/\[sub]([\s\S]*?)\[\/sub]/gi, '<sub>$1</sub>')
            .replace(/\[sup]([\s\S]*?)\[\/sup]/gi, '<sup>$1</sup>');

        // entity &lt;sub&gt;x&lt;/sub&gt; a &lt;sup&gt;‚Ä¶&lt;/sup&gt;
        out = out.replace(/&lt;(sub|sup)&gt;([\s\S]*?)&lt;\/\1&gt;/gi, '<$1>$2</$1>');

        // underline / caret: _{...}, _x, ^{...}, ^x
        out = out.replace(/_\{([^}]+)}/g, '<sub>$1</sub>')
            .replace(/_([A-Za-z0-9+\-‚àí¬±]+)/g, '<sub>$1</sub>')
            .replace(/\^\{([^}]+)}/g, '<sup>$1</sup>')
            .replace(/\^([A-Za-z0-9+\-‚àí¬±]+)/g, '<sup>$1</sup>');

        return out;
    }

    // --- fill label ---
    function renderUnitsLabel(input) {
        if (!input || !input.id) return;
        const unitRaw = (input.dataset.unit || '').trim();
        const span = $(`label[for="${input.id}"] .units-text`);
        if (!span) return;
        span.innerHTML = unitRaw ? ` (${unitMarkupToHTML(unitRaw)})` : '';
    }
</script>

<script>

    function toggleDarkMode() {
        const body = document.body;
        const currentTheme = body.dataset.theme;
        const newTheme = currentTheme === "dark" ? "light" : "dark";
        $ID('darkModeButton').innerText = currentTheme === "dark" ? "üåô Dark mode" : "‚òÄÔ∏è Light mode";
        body.dataset.theme = newTheme;
        localStorage.setItem("theme", newTheme); // Save the theme to localStorage
        console.info("Theme changed to:", newTheme);
    }

</script>

<script>

    // Function Clear `localStorage`
    async function clearLocalStorage() {
        if (!storageKeyLoad) {
            console.error("Storage key is not defined.");
        }

        await showPreloaderScreen(true);

        await isSerialConnected();

        if (isConnected) await setSerialSignals(serialPort, true, true);

        if (isConnected) await rebootDevice();

        if (storageKeyLoad) localStorage.removeItem(storageKeyLoad);        // Remove the saved data
        // TODO: add other keys if needed

        if (storageKeyLoad) console.info("\tLocalStorage cleared.");
        else console.info("\tLocalStorage key not defined; nothing cleared.");

        if (isConnected) await sleep(1_500);

        if (isConnected) await disconnectSerial();

        window.location.reload();
    }

    // Function to save ONE input to localStorage
    function saveInputToLocalStorage(event, storage) {
        if (!storage) {
            console.error("Storage key is not defined.");
            return;
        }
        const input = event.target; // Get the input element
        let formData = JSON.parse(localStorage.getItem(storage)) || {}; // Load the saved data

        // Save the input value to the formData object or select the checked state for checkboxes
        formData[input.id] = (input.type === "checkbox") ? input.checked : input.value;

        localStorage.setItem(storage, JSON.stringify(formData)); // Save the updated data
    }


    // Function to save ALL inputs to localStorage
    function saveAllInputsToLocalStorage(elements, storage) {
        if (!storage) {
            console.error("Storage key is not defined.");
            return;
        }
        if (!elements) {
            console.error("Elements to load are not defined.");
            return;
        }

        let formData = {};

        elements?.forEach(input => {
            formData[input.id] = (input.type === "checkbox") ? input.checked : input.value;

        });

        localStorage.setItem(storage, JSON.stringify(formData));
        console.info(`\t#Ô∏è‚É£ All inputs (${elements.length}) saved to localStorage under key: ${storage}`);
    }

    // Function to load inputs from localStorage
    function loadInputsFromLocalStorage(elements, storage) {
        if (!storage) {
            console.error("Storage key is not defined.");
            return;
        }
        if (!elements) {
            console.error("Elements to load are not defined.");
            return;
        }

        let formData = JSON.parse(localStorage.getItem(storage)) || {}; // Load the saved data

        if (!isNonEmptyDict(formData)) {
            console.warn(`No saved data found in localStorage under key: ${storage}. Saving current inputs (${elements.length}) as defaults.`);
            saveAllInputsToLocalStorage(elements, storage);
        }

        elements?.forEach(input => {
            if (formData.hasOwnProperty(input.id)) {
                if (input.type === "checkbox") {
                    input.checked = formData[input.id]; // Restore the checkbox state
                } else if (input.tagName.toLowerCase() === "select") {
                    const options = Array.from(input.options).map(option => option.value);
                    if (options.some(option => option === formData[input.id])) {
                        input.value = formData[input.id]; // Restore the select value if it exists
                    } else if (options.some(option => option === "none")) {
                        // Set to fallback if saved value doesn't exist and make it display properly
                        input.value = "none";
                    }
                } else {
                    input.value = formData[input.id]; // Restore the input value
                }
            }

            // Trigger change event to update the UI
            input.dispatchEvent(new Event("change", {bubbles: true}));
            input.dispatchEvent(new Event("input", {bubbles: true}));
            input.dispatchEvent(new Event("blur", {bubbles: true}));
        });
    }


    function importSettings() {
        if (!initialAllLoaded) return;
        if (isExperimentRunning) return;

        if (!storageKeyLoad) {
            console.error("Storage key is not defined.");
            return;
        }

        const input = $MAKE('input');
        input.type = 'file';
        input.accept = '.json,application/json';

        input.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const content = e.target.result || '';
                    const formData = JSON.parse(String(content));

                    if (!isObj(formData)) {
                        console.error("Invalid settings file format.");
                        return;
                    }

                    const loadData = formData?.settingsLoad || {};
                    const sysData = formData?.settingsSys || {};
                    if (!debugging) {
                        const levels = ['operator', 'admin', 'service', 'developer', 'god'];
                        if (levels.some(level => level === sysData?.systemLevelSelect)) {
                            const level = 'expert';
                            sysData.systemLevelSelect = level;
                            console.info(`%c\nLoaded system level downgraded to ' ${level}'`, "color: orange; font-size: 12px;");
                        }
                    }

                    localStorage.setItem(storageKeyLoad, JSON.stringify(loadData));
                    localStorage.setItem(storageKeySys, JSON.stringify(sysData));
                    if (isNonEmptyStr(formData?.expName)) {
                        const expNameInput = $ID("experimentName");
                        if (expNameInput) {
                            expNameInput.value = formData.expName;
                            expNameInput.dispatchEvent(new Event("change", {bubbles: true}));
                        }
                    }
                    if (isNonEmptyStr(formData?.expDesc)) {
                        const expDescInput = $ID("experimentDesc");
                        if (expDescInput) {
                            expDescInput.value = formData.expDesc;
                            expDescInput.dispatchEvent(new Event("change", {bubbles: true}));
                        }
                    }

                    loadInputsFromLocalStorage(settingsInputsLoad, storageKeyLoad);
                    loadInputsFromLocalStorage(settingsInputsSys, storageKeySys);
                    console.info("\nüìÇ Settings imported successfully.");
                } catch (error) {
                    console.error("Error reading settings file:", error);
                }
            };
            reader.readAsText(file);
        });

        input.click();
    }


    function exportSettings() {
        if (!initialAllLoaded) return;

        if (!storageKeyLoad) {
            console.error("Storage key is not defined.");
            return;
        }

        const formData = {};

        formData.settingsLoad = JSON.parse(localStorage.getItem(storageKeyLoad)) || {};
        formData.settingsSys = JSON.parse(localStorage.getItem(storageKeySys)) || {};
        formData.expName = getElementValue("experimentName") || "";
        formData.expDesc = checkDescription() || "";

        if (!isNonEmptyDict(formData)) {
            console.warn("No settings found to export.");
            return;
        }

        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(formData, null, 2));
        const downloadAnchorNode = $MAKE('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", "moira_settings.json"); // TODO: add profiles later
        document.body.appendChild(downloadAnchorNode); // required for firefox
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
        console.info("\nüìÅ Settings exported successfully.");
    }
</script>

<script>
    // /////// Log Control Functions /////////

    // ------------ Log Settings ------------
    let isAutoScroll = true;// Enables automatic scrolling of log output
    let isLineLimit = true;// Limits the number of stored log lines
    let isLineLocker = true;// Locks the view at a fixed position when scrolling is disabled
    let logContentMaxLines = 150;// Maximum number of log lines to keep in memory
    let isScrolledToBottom = true;// Tracks whether the user has scrolled to the bottom of the log
    let logCount = 0; // Counter for received messages
    let logContentLines = []; // Array storing the log content

    let lastAutoScroll = null;
    let rafId = null;

    // Checks if the user is scrolled to the bottom of the log
    function checkScrolledToBottom(scrollTop = UI.regularLogContainer.scrollTop, clientHeight = UI.regularLogContainer.clientHeight, scrollHeight = UI.regularLogContainer.scrollHeight) {
        return Math.abs(scrollTop + clientHeight - scrollHeight) < 2;
    }

    // Toggles whether the log view is locked at a specific position
    function lineConsoleLock() {
        isLineLocker = !isLineLocker;
        if (isLineLocker) {
            UI.lineLockBtn.textContent = "üîí Fix Scroll: ON";
        } else {
            UI.lineLockBtn.textContent = "üîì Fix Scroll: OFF";
        }
    }

    // Clears the log completely
    function clearConsoleLog() {
        logContentLines = [];
        logCount = 0;
        UI.regularLogContainer.textContent = "";
    }

</script>

<script>
    // /////// Logging Messages /////////
    let visibleLines;

    // Global array for storing log messages in memory for display on the canvas
    // let logs = [];

    // // /////// Canvas DPI Adjustment /////////
    // function adjustCanvasDPI(canvas) {
    //     const ctx = canvas.getContext('2d', {willReadFrequently: true}); // Optimized for frequent reading
    //     const dpi = (window.devicePixelRatio || 1) * 1.5;
    //
    //     // Get the size of the canvas in CSS pixels.
    //     const width = canvas.clientWidth;
    //     const height = canvas.clientHeight;
    //
    //     // Store the current transformation matrix
    //     const savedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    //
    //     // Scale the canvas up by the device pixel ratio
    //     canvas.width = width * dpi;
    //     canvas.height = height * dpi;
    //     ctx.scale(dpi, dpi);
    //
    //     // Restore the old transformation matrix
    //     ctx.putImageData(savedImageData, 0, 0);
    //
    //     // Redraw the text on the canvas
    //     redrawCanvasText();
    //
    //     console.info(`üé® Canvas DPI changed: ${dpi}`);
    // }
    //
    // // Redraws the text on the canvas
    // function redrawCanvasText() {
    //     const ctx = UI.loadingLogContainer.getContext('2d');
    //     ctx.clearRect(0, 0, UI.loadingLogContainer.width, UI.loadingLogContainer.height);
    //
    //     ctx.font = '14px monospace';
    //     ctx.textBaseline = 'top';
    //
    //     const lineHeight = 16;
    //     const visibleLines = Math.floor(UI.loadingLogContainer.clientHeight / lineHeight);
    //     let scrollOffset = Math.max(0, logs.length - visibleLines);
    //
    //     for (let i = scrollOffset; i < logs.length; i++) {
    //         let msg = logs[i];
    //
    //         // üî• Change color to yellow if a message starts with "ds" (case-insensitive)
    //         if (msg.toLowerCase().startsWith("ds")) {
    //             ctx.fillStyle = 'yellow';
    //         } else {
    //             ctx.fillStyle = 'white';
    //         }
    //
    //         ctx.fillText(msg, 5, (i - scrollOffset + 0.5) * lineHeight);
    //     }
    // }
    //
    // // Function to log measurements to the canvas
    // function logMeasurements(msg) {
    //     if (!msg || typeof msg !== 'string') return;
    //
    //     logs.push(msg);
    //     if (logs.length > 100) logs.shift(); // Keep only the last 100 messages
    //
    //     redrawCanvasText();
    // }
    //
    // // Initial DPI adjustment for the canvas
    // adjustCanvasDPI(UI.loadingLogContainer);
    //
    // // Event listener for resizing the window and adjusting the canvas DPI
    // window.addEventListener("resize", () => adjustCanvasDPI(UI.loadingLogContainer));

    function logMeasurements(msg) {
        if (!isNonEmptyStr(msg)) return;

        // Check if a message starts with "ds" and apply yellow color, else use white
        let formattedMsg = msg.toLowerCase().startsWith("ds")
            ? `<span style="color:yellow;">${msg}</span>` // Highlight DSLR data
            : `<span style="color:white;">${msg}</span>`; // Normal log

        // Append the formatted message directly
        UI.loadingLogContainer.innerHTML += formattedMsg + "<br>";

        // Auto-scroll to the bottom for the latest logs
        UI.loadingLogContainer.scrollTop = UI.loadingLogContainer.scrollHeight;

        // Limit logs to 100 lines for performance
        let lines = UI.loadingLogContainer.innerHTML.split("<br>");
        if (lines.length > visibleLines) {
            UI.loadingLogContainer.innerHTML = lines.slice(lines.length - visibleLines).join("<br>");
        }
    }

    // Logs a message to the regular log container
    // const logLineHeight = 1.2 * parseInt(window.getComputedStyle(UI.regularLogContainer).fontSize);


    function logMessage(msg) {
        msg = (msg)?.toString() || "";
        if (isEmptyStr(msg)) return;

        isScrolledToBottom = checkScrolledToBottom();

        while (isLineLimit && (logCount >= logContentMaxLines)) {
            logContentLines.shift();
            logCount--;
        }


        logContentLines.push(msg);
        logCount++;
        UI.regularLogContainer.textContent = logContentLines.join("\n");


        if (isAutoScroll) {
            UI.regularLogContainer.scrollTop = UI.regularLogContainer.scrollHeight;
        }

        // // TODO : change to remember scrollPosition and scrollHeight, and scroll to it minus the new scrollHeight
        // if (isLineLocker) {
        //     UI.regularLogContainer.scrollTop -= Math.floor(UI.regularLogContainer.scrollHeight / (logCount - 1)); // UI.regularLogContainer.scrollHeight / logContentLines.length; // logCount;
        //     // console.info(UI.regularLogContainer.scrollHeight, logLineHeight * logCount, UI.regularLogContainer.scrollHeight / (logLineHeight * (logCount + 1)))
        //     // UI.regularLogContainer.scrollTop -= logLineHeight; // UI.regularLogContainer.scrollHeight / logContentLines.length; // logCount;
        // }

        if (isScrolledToBottom) {
            UI.regularLogContainer.scrollTop = UI.regularLogContainer.scrollHeight;
        }
    }

    function logAndConsoleMessage(msg, {
        doConsole = true,
        consoleStyling = "",
        consoleLevel = "info",
        showAlert = false
    } = {}) {
        if (!isNonEmptyStr(msg)) return;
        const doConsoleStyle = isNonEmptyStr(consoleStyling);
        let logMsg = msg;


        switch (consoleLevel) {
            case "warning":
            case "warn":
                logMsg = `\n\t${logMsg}`;
                break;
            case "err":
            case "error":
                logMsg = `\n${logMsg}`;
                break;
            case "info":
            default:
                break;
        }

        logMessage(msg);

        if (!doConsole) return;

        let consoleMsg = msg;
        if (doConsoleStyle) consoleMsg = `%c${consoleMsg}`;
        if (consoleLevel === "warn") console.warn(consoleMsg, consoleStyling);
        else if (consoleLevel === "error") console.error(consoleMsg, consoleStyling);
        if (consoleLevel === "info") console.info(consoleMsg, consoleStyling);


        if (showAlert) alert(msg);
    }


</script>

<script>
    // /////// IndexedDB Database Configuration /////////

    // /////// Opening IndexedDB /////////

    /**
     * Opens the IndexedDB database and initializes it if needed.
     */
    async function openDB() {
        let request = indexedDB.open(DB_NAME, 1);

        request.onupgradeneeded = function (event) {
            db = event.target.result;

            // Creates a new object store with an auto-incremented key
            db.createObjectStore(STORE_NAME, {keyPath: "id", autoIncrement: true});
            console.info("%c\n‚úÖ IndexedDB created", "color: green; font-weight: bold;");
        };

        request.onsuccess = function (event) {
            db = event.target.result;
            console.info("%c\n‚úÖ IndexedDB opened", "color: green; font-weight: bold;");
            checkExistingLog();
        };
    }

    function checkDescription({text = getElementValue("experimentDesc"), set = false} = {}) {
        if (!isNonEmptyStr(String(text))) return "";
        const cleanedDesc = String(text)?.replace(/(\r\n|\n|\r)/gm, " ").replace(/¬ß.*¬ß;/gm, "").trim() || "";
        if (set) $ID("experimentDesc").value = cleanedDesc || "";
        return cleanedDesc;
    }


    function checkExistingLog() {
        const transaction = db.transaction(STORE_NAME, "readonly");
        const store = transaction.objectStore(STORE_NAME);
        const request = store.count();

        request.onsuccess = async function () {
            if (!isExperimentRunning) maxDataPoints = maxDataPointsExpShow;
            await updateChart(false);
            await loadDataFromDBToChart();

            if (request.result > 0) {
                // TODO: p≈ôem√≠stit dotaz na 'star√° data' a≈æ po naƒçten√≠ v≈°eho a upravit dotaz, aby se ptal na smaz√°n√≠ a chtƒõl to 2x potvrdit
                // if (confirm("üîÑ Old log exists. Keep it or delete?\nOK = Keep\nCancel = Delete")) {
                //     saveCSV();
                // } else {


                // transaction = db.transaction(STORE_NAME, "readonly");
                // store = transaction.objectStore(STORE_NAME);
                // TODO: proƒç druh√Ω request???
                const request2 = store.getAll();
                request2.onsuccess = async function () {
                    let dataEntries = request2.result;
                    const experimentInfo = dataEntries[0];


                    let date = "Unknown date";
                    const expDate = experimentInfo.experimentDate;
                    if (expDate) {
                        const dateFormat = getLocaleOrder();
                        date = `${expDate} [${dateFormat.date} ${dateFormat.time}]`;
                        console.info(`\t\nüïí %cLast log date: ${date}`, "color: #0078d7; font-style: italic; font-weight: normal;");
                    } else {
                        console.info("\t\nüïõ %cLast log found without date information.", "color: #0078d7; font-style: italic; font-weight: normal;");
                    }

                    const loadDirection = (experimentInfo.loadDirection === -1 ? "DOWN" : (experimentInfo.loadDirection === 1 ? "UP" : (experimentInfo.loadDirection === 0 ? "CYCLING" : "N/A")));

                    const experimentLabel = experimentInfo.experimentLabel || "";

                    const expBasicInformation = "¬ß " + `(${date}); ` + "Loading direction: " + loadDirection + ";  " + experimentLabel + " ¬ß";

                    const expDescription = experimentInfo.experimentDescription || "";

                    // replace any original Basic Information in description - up new lines and ¬ß...¬ß
                    const description = expBasicInformation + "   " + checkDescription({text: expDescription});

                    $ID("experimentCount").value = experimentInfo.experimentCounter || "1";
                    $ID("experimentName").value = experimentInfo.experimentName || "";
                    $ID("experimentDesc").value = description || "";
                    initialDataLoaded = true;
                };
                // }
            } else {
                console.info("\t\nüïò %cNo existing log found in IndexedDB.", "color: #0078d7; font-style: italic; font-weight: normal;");
                initialDataLoaded = true;
            }
        };

    }

    // /////// Adding Data to the Log /////////

    const dbQueue = [];
    let dbFlushTimer = null;

    /**
     * Adds a new data entry to IndexedDB.
     *@param {Object} data - The data object to be stored.
     * @param id
     */
    function addDataToLog(data, id = undefined) {
        addSingleDataToDBImmediate(data, id);
        // dbQueue.push({data, id});
        // if (!dbFlushTimer) dbFlushTimer = setTimeout(flushDB, 500); // flush ~2√ó in one second
    }

    function flushDB() {
        if (dbQueue.length === 0) {
            dbFlushTimer = null;
            return;
        } else {
            if (!db) {
                console.warn("\n‚ùå IndexedDB not ready, cannot flush log.");
                // Wait for another 5 seconds and try again
                dbFlushTimer = setTimeout(flushDB, 5_000);
                return;
            }
        }

        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const keyPath = store.keyPath || null; // can also be an array, here we assume single keyPath

        // take all from the queue (atomically in one transaction)
        const items = dbQueue.splice(0);

        for (const {data, id} of items) {
            // id can be 0! => check for null/undefined/NaN
            const hasId = isNumSafe(id);

            if (hasId) {
                // Upsert with specified key
                if (keyPath === 'id') {
                    const value = isObj(data)
                        ? {...data, id} : {id, value: data};
                    store.put(value); // key is in the object (keyPath)
                } else {
                    store.put(data, id); // key provided separately
                }
            } else {
                // clean add => autoIncrement/autoKey
                store.add(data);
            }
        }

        tx.oncomplete = () => {
            dbFlushTimer = null;
        };
        tx.onerror = (e) => {
            console.error('‚ùå flushDB error:', e?.target?.error || e);
            dbFlushTimer = null;
        };
    }

    function addSingleDataToDBImmediate(data, id = undefined) {
        if (!db) {
            console.warn("\n‚ùå IndexedDB not ready, cannot add data.");
            return Promise.resolve(false);
        }
        return new Promise((resolve, reject) => {
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            const keyPath = store.keyPath || null; // can also be an array, here we assume single keyPath

            // id can be 0! => check for null/undefined/NaN
            const hasId = isNumSafe(id);

            if (hasId) {
                // Upsert with specified key
                if (keyPath === 'id') {
                    const value = isObj(data)
                        ? {...data, id} : {id, value: data};
                    store.put(value); // key is in the object (keyPath)
                } else {
                    store.put(data, id); // key provided separately
                }
            } else {
                // clean add => autoIncrement/autoKey
                store.add(data);
            }

            tx.oncomplete = () => resolve(true);
            tx.onerror = (e) => {
                console.error('‚ùå addDataImmediate error:', e?.target?.error || e);
                reject(e);
            };
        });
    }


    /**
     * Update (merge) a record by id. Returns Promise<boolean> (true = written).
     * - If the record does not exist and upsert=true, it will be created.
     * - The patch is merged over the existing value.
     */
    function updateLogById(id, patch, {upsert = true} = {}) {
        if (isVoid(id)) return Promise.resolve(false);
        if (!db) return Promise.resolve(false);
        return new Promise((resolve, reject) => {
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            const keyPath = store.keyPath || null;


            // 1) Check if there are any logs at all
            const countReq = store.count();
            countReq.onsuccess = () => {
                const total = countReq.result || 0;
                if (total > 1) {
                    // 2) Continue only if there are more than 1 log entries
                    const getReq = store.get(id);
                    getReq.onsuccess = () => {
                        const current = getReq.result;
                        if (!current && !upsert) {
                            resolve(false);
                            return;
                        }

                        // merge patch into current (keep key)
                        let updated;
                        if (keyPath === 'id') {
                            updated = {...(current || {}), ...(patch || {}), id};
                            store.put(updated);
                        } else {
                            updated = {...(current || {}), ...(patch || {})};
                            store.put(updated, id);
                        }
                    };


                    getReq.onerror = (err) => reject(err);
                } else {
                    // no update, nothing to log
                    resolve(false);
                }
            };
            countReq.onerror = (err) => reject(err);

            tx.oncomplete = () => resolve(true);
            tx.onerror = (e) => {
                console.error('‚ùå updateById error:', e?.target?.error || e);
                reject(e);
            };
        });
    }


    // /////// Clearing the Database Log /////////
    async function clearDatabase() {
        if (!db) {
            console.warn("\n‚ùå IndexedDB not ready, cannot clear database.");
            return;
        }
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, "readwrite");
            const store = transaction.objectStore(STORE_NAME);
            const clearRequest = store.clear();

            clearRequest.onsuccess = () => {
                console.info("üóëÔ∏è Database cleared successfully.");
                resolve(true);
            };

            clearRequest.onerror = (event) => {
                console.error("‚ùå Error clearing database:", event.target.error);
                reject(event.target.error);
            };
        });
    }

</script>

<script>
    // /////// Live Data Update and Chart Configuration /////////
    let timeChart;
    let positionChart;


    // Live update flag (disabled by default)
    let liveUpdate = false;
    let liveUpdatePaused = false;

    let dataChartInterval = 1; // Interval for live chart update

    // Maximum number of data points displayed in the charts
    const maxDataPointsExp = 1e5;
    const maxDataPointsExpShow = 1e10;
    const maxDataPointsIdle = convertUnits(1 / 10, 's', 'ms'); // 10x in 1 seconds (100 ms)
    let maxDataPoints = maxDataPointsIdle;


    // /////// Toggle Live Update /////////
    function chartUpdate(setState = null) {
        if (isBool(setState)) {
            liveUpdate = setState;
        } else {
            liveUpdate = !liveUpdate;
        }

        UI.chartsLiveButton.textContent = liveUpdate ? "‚è∏Ô∏è Disable Charts" : "‚èØÔ∏è Activate Charts";
        $ID("chartsWrapper").style.background = liveUpdate ? "var(--charts-bg-active)" : "var(--charts-bg)";

        if (isExperimentRunning && liveUpdate) loadDataFromDBToChart();

        if (!isExperimentRunning && isConnected) {
            if (liveUpdate) {
                const dataAppInterval = getInputNumDefAbsInt("inputAppInterval", NaN);
                sendCommandGeneral(`DATA SET INTERVAL ${Math.ceil(dataAppInterval)}`)
                const dataDuration = convertUnits(10, 's', 'ms'); // 10 seconds

                maxDataPoints = (isNumSafe(dataAppInterval) ?
                    calculateStep(dataAppInterval, dataDuration, maxDataPointsIdle) :
                    maxDataPointsIdle);

                let capacities = [];
                let outputs = [];
                let present = Array(loadCellNum).fill(true);
                if (systemLevel >= 200) {
                    for (let i = 0; i < loadCellNum; i++) {
                        const active = $ID(`activateLoadcell${i + 1}`).checked;
                        present[i] = active;
                        if (active === true) {
                            capacities[i] = getInputNumDefAbsInt(`inputLoadcellCapacity${i + 1}`, NaN);
                            outputs[i] = getInputNumDefAbsInt(`inputLoadcellOutput${i + 1}`, NaN);
                        }
                    }
                } else {
                    const loadcellCapacity = getInputNumDefAbsInt("inputLoadcellCapacity", NaN);
                    const loadcellOutput = getInputNumDefAbsFlt("inputLoadcellOutput", NaN);

                    capacities = Array(loadCellNum).fill(loadcellCapacity);
                    outputs = Array(loadCellNum).fill(loadcellOutput);
                }


                for (let i = 0; i < loadCellNum; i++) {
                    if (isNumSafe(capacities[i]) && isNumSafe(outputs[i])) {
                        sendCommandGeneral(`LC SET CAP ${i} ${capacities[i]}`);
                        sendCommandGeneral(`LC SET RO ${i} ${outputs[i]}`);
                        sendCommandGeneral(`LC TARE RESET ${i}`);
                    } else {
                        present[i] = false;
                    }

                    if (timeChart) timeChart.setSeries(i + 1, {show: present[i]});
                    if (positionChart) positionChart.setSeries(i + 1, {show: present[i]});
                }
            }

            sendCommandGeneral(`DATAC ${liveUpdate ? 1 : 0}`);
        }
    }


    const allowPageVisibilityHandling = false; // TODO: Enable or disable page visibility handling

    let isPageVisible = true; // Visibility status of the page
    let hideTimeout = null; // Timeout for hiding the page
    const MIN_HIDE_TIME = 20_000; // milliseconds

    async function handlePageVisibility() {
        if (!allowPageVisibilityHandling) return;
        if (!isExperimentRunning) return;
        if (!liveUpdate && !liveUpdatePaused) return;

        isPageVisible = !document.hidden;

        if (!isPageVisible) {
            console.info("\nüìÑ - üï∂Ô∏è Page is hidden.");


            // Set timeout for hiding the page
            if (hideTimeout) {
                clearTimeout(hideTimeout);
                hideTimeout = null; // Reset the timeout
            }
            hideTimeout = setTimeout(() => {
                if (!isPageVisible) {
                    console.info(`‚è≥ Page is hidden longer than ${roundDecimalFast(convertUnits(MIN_HIDE_TIME, 'ms', 's'), 2)}+ seconds.\n\tHiding...`);

                    if (liveUpdate && !liveUpdatePaused) {
                        console.info("‚è∏Ô∏è Pause live update of charts.");
                        updateChart(false);
                        liveUpdatePaused = true;
                    }
                }
            }, MIN_HIDE_TIME);

        } else {

            if (hideTimeout) {
                clearTimeout(hideTimeout); // Clear the hide timeout
                hideTimeout = null;
            }

            console.info("\nüìÑ - üëì Page is visible");
            if (liveUpdatePaused) {
                console.info("üîÑ Resuming live update of charts.");
                await loadDataFromDBToChart();
                await updateChart(true);
                liveUpdatePaused = false;
            }
        }
    }


    function aggregateData(dataEntries, chunkSize, timeData, positionData, forceData, photoData, overflowData) {
        if (!isNumSafe(loadCellNum)) throw new Error(`Total Loadcell count is not defined: ${loadCellNum}`);
        if (!isNumSafe(chunkSize)) chunkSize = 1;
        chunkSize = Math.max(1, Math.round(chunkSize));

        // const photoValidStep = dataEntries.findIndex((entry, i) => isFiniteNumber(entry.photoIndex, false) && i > 0);
        // if (photoValidStep > 0 && chunkSize > photoValidStep) {
        //     chunkSize = photoValidStep; // Ensure chunkSize does not exceed the first photo event step
        //     console.warn(`‚ö†Ô∏è Adjusted chunkSize to ${chunkSize} to capture first photo event.`);
        // }

        if (chunkSize === 1) {
            // If chunkSize = 1, no aggregation is needed (1:1 mapping)
            for (let i = 0; i < dataEntries.length; i++) {
                let entry = dataEntries[i];
                timeData[i] = entry.time;
                positionData[i] = entry.position;
                entry.force?.forEach((value, index) => forceData[index][i] = value);
                photoData[i] = isNumSafe(entry.photoIndex) ? 0 : null; // Mark photo event
            }
            return;
        }

        // const photosCount = dataEntries.reduce((count, entry) => count + (isNum(entry.photoIndex) ? 1 : 0), 0);

        let fullChunks = Math.floor(dataEntries.length / chunkSize) * chunkSize;
        // let chunkCount = Math.floor(dataEntries.length / chunkSize) + photosCount; // Block count
        let remainderStart = fullChunks; // First index of data

        // Predefine array size to match the new chunk count
        // timeData.length = chunkCount;
        // positionData.length = chunkCount;
        // photoData.length = chunkCount;
        // forceData?.forEach(arr => arr.length = chunkCount);

        let sumTime = 0, sumPosition = 0;
        let sumForce = Array(loadCellNum).fill(0);
        let count = 0, chunkIndex = 0;

        for (let i = 0; i < fullChunks; i++) {
            const entry = dataEntries[i];
            sumTime += entry.time;
            sumPosition += entry.position;
            entry.force?.forEach((value, index) => sumForce[index] += value);
            count++;

            if (isNumSafe(entry.photoIndex)) {
                // If a photo event is detected, add data immediately to the current chunk
                // timeData[chunkIndex] = entry.time;
                // positionData[chunkIndex] = entry.position;
                // sumForce?.forEach((value, index) => {
                //     forceData[index][chunkIndex] = value;
                // });
                timeData[chunkIndex] = null;
                positionData[chunkIndex] = null;
                forceData[chunkIndex] = [...Array(loadCellNum).fill(null)];
                photoData[chunkIndex] = 0; // Mark photo event
                chunkIndex++;
            }

            if (count === chunkSize) {
                let invCount = 1 / count; // Inverse count: quicker than '%' division operation
                timeData[chunkIndex] = sumTime * invCount;
                positionData[chunkIndex] = sumPosition * invCount;
                sumForce?.forEach((value, index) => {
                    forceData[index][chunkIndex] = value * invCount;
                    sumForce[index] = 0; // Reset for next chunk
                });
                photoData[chunkIndex] = isNumSafe(entry.photoIndex) ? 0 : null; // Mark photo event

                sumTime = sumPosition = 0;
                count = 0;
                chunkIndex++;
            }
        }

        // Add remaining data to an overflow array
        // console.info("Overflow: ", dataEntries.length - remainderStart);
        for (let i = remainderStart; i < dataEntries.length; i++) {
            let entry = dataEntries[i];
            overflowData.push({
                time: entry.time,
                position: entry.position,
                force: [...entry.force]
            });
        }
    }

    async function loadDataFromDBToChart() {
        if (!db) {
            console.error("‚ö†Ô∏è IndexedDB is not available (not opened).");
            return;
        }

        if (!isNumSafe(loadCellNum)) throw new Error(`Total Loadcell count is not defined: ${loadCellNum}`);

        const stateAtEnd = liveUpdate;

        await clearCharts();

        console.info("\n%cüîÑ Loading data from IndexedDB to charts...", "color: blue;");

        let transaction = db.transaction(STORE_NAME, "readonly");
        let store = transaction.objectStore(STORE_NAME);
        let request = store.getAll();

        request.onsuccess = async function () {
            let dataEntries = request.result;
            if (!dataEntries || dataEntries.length === 0) {
                return;
            } else if (dataEntries.length < 3) {
                console.warn("‚ö†Ô∏è Not enough data to load.");
                return;
            }

            // Clear IndexedDB after saving (only in initial load)
            console.log(initialDataLoaded === false, dataEntries[0]?.status === 'saved')
            if (initialDataLoaded === false && dataEntries[0]?.status === 'saved') {
                await clearDatabase();
                return;
            }

            // remove first element from entry
            await dataEntries.shift(); // <= experiment info object

            console.info("üìâ Loaded", dataEntries.length, "data points");


            // // ‚è© **Use `filter` to reduce the number of data points**
            // const filteredEntries = dataEntries.filter((_, index) => index % dataChartInterval === 0);
            //
            // // ‚è© **Use `map` to extract specific data fields**
            // timeDataTemp = filteredEntries.map(entry => entry.time);
            // positionDataTemp = filteredEntries.map(entry => entry.position);
            // forceDataTemp = Array(loadCellNum).fill().map((_, i) => filteredEntries.map(entry => entry.force[i]));

            const timeDataTemp = [];
            const positionDataTemp = [];
            const forceDataTemp = Array(loadCellNum).fill(null).map(() => []);
            const aggregatedDataBetweenStepsTemp = [];
            const photoDataTemp = [];

            aggregateData(dataEntries, dataChartInterval, timeDataTemp, positionDataTemp, forceDataTemp, photoDataTemp, aggregatedDataBetweenStepsTemp);


            const minTime = catchVal(minND(timeDataTemp), 0, isNumSafe);
            const maxTime = catchVal(maxND(timeDataTemp), 1e-10, isNumSafe);
            const timeRange = (maxTime - minTime) * 0.005;
            const minDist = catchVal(minND(positionDataTemp), 0, isNumSafe);
            const maxDist = catchVal(maxND(positionDataTemp), 1e-10, isNumSafe);
            const distRange = (maxDist - minDist) * 0.005;
            const forceMin = catchVal(minND(forceDataTemp), 0, isNumSafe);
            const forceMax = catchVal(maxND(forceDataTemp), 1e-10, isNumSafe);
            const forceRange = (forceMax - forceMin) * 0.125;


            timeDataChart = timeDataTemp;
            positionDataChart = positionDataTemp;
            forceDataChart = forceDataTemp;
            photoDataChart = photoDataTemp;

            timeData = timeDataTemp;
            positionData = positionDataTemp;
            forceData = forceDataTemp;

            /* TODO: replace with 'updateChart' function
                //      await propagateData({
                //            time: timeDataTemp,
                //             position: positionDataTemp,
                //             force: forceDataTemp,
                //             photoIndex: photoDataTemp,
                //      }, {overRide: true});
            */
            timeChart.setData([timeDataTemp, ...forceDataTemp, photoDataTemp]);
            positionChart.setData([positionDataTemp, ...forceDataTemp, photoDataTemp]);


            timeChart.setScale("x", {min: minTime - timeRange, max: maxTime + timeRange});
            positionChart.setScale("x", {min: minDist - distRange, max: maxDist + distRange});
            timeChart.setScale("y", {min: forceMin - forceRange, max: forceMax + forceRange});
            positionChart.setScale("y", {min: forceMin - forceRange, max: forceMax + forceRange});

            // // üîÑ Redraw graphs
            // timeChart.redraw();
            // positionChart.redraw();


            console.info("\n\t‚òëÔ∏è Graph data loaded successfully.");

            await sleep(1);
            liveUpdate = stateAtEnd;
        };
    }


    // /////// uPlot Chart Initialization /////////
    function createChart(containerID, seriesLabels, title = "Graph", labelX = "", labelY = "") {
        // Get the container element
        let container = $ID(containerID);
        if (!container) {
            console.error(`‚ùå Error: container s ID "${containerID}" not found.`);
            return null;
        }


        // Get the container dimensions
        let width = container.clientWidth || 400; // Default width if the container is empty
        let height = container.clientHeight || 300; // Default height if the container is empty

        // Configurations for uPlot chart
        const options = {
            title: title,
            width: width,
            height: height,
            axes: [
                {
                    label: labelX, // Axis label X
                },
                {
                    label: labelY, // Axis label Y
                }
            ],
            scales: {
                x: {time: false},
                y: {auto: true}
            },
            series: [...seriesLabels.map((label, index) => ({
                label: label,
                stroke: index === 0 ? "000000" : ["#FF2730", "#2196F3", "#4CAF50", "#9C27B0", "#00BCD4", "#8BC34A", "#E91E63", "#3F51B5", "#009688", "#FF9800"][index - 1] || "#555555"
            })),
                {
                    label: "Photos",                    // used to find the legend row and hide it below
                                                        // points-only: most efficient to disable paths (no line)
                    paths: () => null,                  // official recommendation for "points-only"
                    points: {show: true, size: 8, width: 2.5}, // size and width of points
                    stroke: "#FF8C00", fill: "#FF8C00", // color of points; for points, points.show is enough
                },],

            // hooks: {
            //     init: [
            //         (u) => {
            //             // find "Photos" and hide it
            //             $$(".u-legend tr", u.root)?.forEach((tr) => {
            //                 if (tr.textContent?.trim().startsWith("Photos")) tr.style.display = "none";
            //             });
            //         },
            //     ],
            // },

        };

        // Create the uPlot chart
        if (!window?.uPlot) {
            console.error("‚ùå uPlot library is not loaded.");
            return null;
        }
        let chart = new uPlot(options, [[], ...seriesLabels.slice(1).map(() => [])], container);

        // Dynamic resizing of the chart
        window.addEventListener("resize", async () => onResize(container, chart));

        // Initial resize to fit container
        onResize(container, chart);

        return chart;
    }

    function onResize(container, chart) {
        const newWidth = container.clientWidth || 400;
        const newHeight = container.clientHeight || 300;
        chart.setSize({width: newWidth, height: newHeight});
        UI.chartsContainer.style.height = getChartHeightIncludingLegend() + "px";
    }

    function getChartHeightIncludingLegend() {
        let charts = $$(".uplot");
        let maxHeight = 0;

        charts?.forEach(chart => {
            maxHeight = Math.max(maxHeight, chart.clientHeight);
        });

        return maxHeight;

    }


    // /////// Chart Update Function /////////

    /**
     * Updates the charts with new data.
     */

    function updateChart(inputData) {
        if (!isDict(inputData)) return;


        // Check if the data is valid
        if (!isNumSafe(inputData.time) || !isNumSafe(inputData.position)) {
            return;
        }

        // Add new data points
        timeDataChart?.push(inputData?.time);
        positionDataChart?.push(inputData?.position);
        inputData.force?.forEach((value, index) => forceDataChart[index]?.push(value));
        photoDataChart?.push(isNumSafe(inputData.photoIndex) ? 0 : null); // Mark photo event


        // Maintain max data points
        if (timeDataChart?.length > maxDataPoints) {
            timeDataChart?.shift();
            positionDataChart?.shift();
            forceDataChart?.forEach(dataset => dataset?.shift());
            photoDataChart?.shift();
        }

        // Update charts
        timeChart.setData([timeDataChart, ...forceDataChart, photoDataChart]);
        positionChart.setData([positionDataChart, ...forceDataChart, photoDataChart]);

    }

    function updateChartNEW(inputData) { // TODO: test and use
        if (!isDict(inputData)) return;

        // Normalizes scalar -> array of length len (used for uniform processing)
        const normalizeSeries = (value, mapper = v => v) => {
            if (isArr(value)) return value.map(mapper);
            return [mapper(value)]; // when scalar, make a single-element array
        };

        // Create markers for photo: number -> 0, otherwise null
        const toPhotoMarker = v => (isNumSafe(v) ? 0 : null);

        // After adding batch data, maintain maximum length of all series
        const trimToMax = () => {
            while (timeDataChart?.length > maxDataPoints) {
                timeDataChart.shift();
                positionDataChart.shift();
                forceDataChart.forEach(ds => ds?.shift());
                photoDataChart.shift();
            }
        };

        // --- 1) Normalizace vstup≈Ø na pole ---
        // time a position mohou b√Ωt number nebo array
        const timeArr = normalizeSeries(inputData.time);
        const positionArr = normalizeSeries(inputData.position);

        // photoIndex m≈Ø≈æe b√Ωt number nebo array -> p≈ôemapujeme na markery (0/null)
        const photoArr = normalizeSeries(inputData.photoIndex, toPhotoMarker);

        // force je v≈ædy array; m≈Ø≈æe b√Ωt [number, number, ...] nebo [[...],[...],...]
        // Nejprve zjist√≠me, zda je "vno≈ôen√°" forma
        const forceInput = Array.isArray(inputData.force) ? inputData.force : [];
        const forceIsNested = forceInput.some(v => Array.isArray(v));

        // Pokud nen√≠ vno≈ôen√©, bereme to jako v√≠ce kan√°l≈Ø po scalaru/array-i d√©lky 1
        // -> znormalizujeme na pole kan√°l≈Ø, kde ka≈æd√Ω kan√°l je pole o stejn√© d√©lce jako time/position.
        let forceChannels = [];

        // --- 2) Ovƒõ≈ôen√≠ a sjednocen√≠ d√©lek ---
        // Vypoƒçti c√≠lovou d√©lku batchu:
        const lenTime = timeArr.length;
        const lenPos = positionArr.length;
        const lenPhoto = photoArr.length;

        // Pokud nƒõkter√Ω ze vstup≈Ø chyb√≠ nebo nen√≠ ƒç√≠slo/array s ƒç√≠sly, neaktualizuj
        const allNumsOrNull = arr => arr.every(v => v == null || isNumSafe(v));
        if (!lenTime || !lenPos || !lenPhoto) return;

        // V≈°echny s√©rie mus√≠ m√≠t stejnou d√©lku
        if (!(lenTime === lenPos && lenPos === lenPhoto)) return;

        if (!allNumsOrNull(timeArr) || !allNumsOrNull(positionArr)) return;

        if (forceIsNested) {
            // force je [[...],[...],...]; ovƒõ≈ô, ≈æe ka≈æd√Ω kan√°l m√° spr√°vnou d√©lku
            for (const ch of forceInput) {
                if (!Array.isArray(ch) || ch.length !== lenTime) return;
                // povol√≠me null/undefined, jinak ƒç√≠sla
                if (!allNumsOrNull(ch)) return;
            }
            forceChannels = forceInput.map(ch => ch.slice());
        } else {
            // force je [scalar|array(1?), ...] ‚Äì ka≈æd√Ω prvek je hodnota pro dan√Ω kan√°l na jeden ƒçasov√Ω krok
            // Pokud je batch (lenTime > 1), oƒçek√°v√°me, ≈æe prvky jsou scalary opakovan√© pro ka≈æd√Ω vzorek,
            // nebo arraye d√©lky lenTime. Sjednot√≠me to na pole kan√°l≈Ø s d√©lkou lenTime.
            for (const v of forceInput) {
                if (Array.isArray(v)) {
                    if (v.length !== lenTime || !allNumsOrNull(v)) return;
                    forceChannels.push(v.slice());
                } else {
                    // scalar -> replikuj p≈ôes cel√Ω batch
                    if (v != null && !isNumSafe(v)) return;
                    forceChannels.push(Array(lenTime).fill(v));
                }
            }
        }

        // --- 3) Zajisti, ≈æe existuj√≠ odpov√≠daj√≠c√≠ datasets ve forceDataChart ---
        // forceDataChart je pole dataset≈Ø (po jednom na kan√°l)
        // Pokud m√°me v√≠ce kan√°l≈Ø ne≈æ existuje dataset≈Ø, inicializuj je.
        for (let i = 0; i < forceChannels.length; i++) {
            if (!forceDataChart[i]) forceDataChart[i] = [];
        }

        // Pokud m√°me v grafu v√≠ce dataset≈Ø ne≈æ aktu√°lnƒõ p≈ôich√°z√≠ kan√°l≈Ø, ty nav√≠c ponech√°me beze zmƒõny.

        // --- 4) Push v≈°ech bod≈Ø (batch-safe) ---
        for (let i = 0; i < lenTime; i++) {
            const t = timeArr[i];
            const p = positionArr[i];
            const photo = photoArr[i];

            // Ovƒõ≈ô ƒç√≠sla u time/position (null pro photo je OK)
            if (!isNumSafe(t) || !isNumSafe(p)) return;

            timeDataChart?.push(t);
            positionDataChart?.push(p);
            photoDataChart?.push(photo);

            // force kan√°ly
            for (let ch = 0; ch < forceChannels.length; ch++) {
                const val = forceChannels[ch][i];
                // povol√≠me null/undefined, jinak ƒç√≠slo
                if (val != null && !isNumSafe(val)) return;
                forceDataChart[ch]?.push(val);
            }

            // pr≈Øbƒõ≈æn√© o≈ôez√°v√°n√≠, aby to nebouchlo u velk√Ωch batch≈Ø
            trimToMax();
        }

        // --- 5) Aktualizace graf≈Ø ---
        // Sestav datov√° pole: [hlavn√≠ s√©rie..., force..., photo]
        timeChart.setData([timeDataChart, ...forceDataChart, photoDataChart]);
        positionChart.setData([positionDataChart, ...forceDataChart, photoDataChart]);
    }


    async function reloadCharts() {
        await loadDataFromDBToChart();  // Load data from DB to charts will wait for the data to be loaded
        timeChart.redraw();
        positionChart.redraw();
        console.info("üîÅ Charts refreshed.");
    }

    async function clearCharts() {
        if (!isNumSafe(loadCellNum)) throw new Error(`Total Loadcell count is not defined: ${loadCellNum}`);

        // Reset axis X and Y
        await timeChart.setScale("x", {min: 0, max: 1e-10});
        await positionChart.setScale("x", {min: 0, max: 1e-10});

        timeDataChart = [];
        positionDataChart = [];
        photoDataChart = [];
        forceDataChart = Array(loadCellNum).fill(null).map(() => []);
        dataCount = 0;

        await timeChart.setData(Array(loadCellNum + 1 + 1).fill(null).map(() => []));
        await positionChart.setData(Array(loadCellNum + 1 + 1).fill(null).map(() => []));

        await timeChart.setScale("y", {min: 0, max: 1e-10});
        await positionChart.setScale("y", {min: 0, max: 1e-10});


        console.info("üßπ Charts cleared!");
    }


</script>

<script>

    // /////// Serial Connection Variables /////////

    // Variables for handling serial (USB) communication
    let serialPort, serialWriter, serialReader;

    // Connection status flags
    let isConnected = false;

    // Reconnection attempts for serial connection
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    let isReconnecting = false;

    async function writeCommand(text) {
        try {
            //  Ensure a writer exists before writing
            if (!serialWriter) {
                serialWriter = serialPort.writable.getWriter();
            }

            await serialWriter.write(txtE.encode(text + "\n"));

            return true;
        } catch (error) {
            await handleError(error, "writeCommand");

            return false;
        }
    }

    function checkCommand(command) {
        if (debugging) console.info(`Preparing to send command:\n\t\t${command}`);
        if (!isConnected || !serialPort?.writable) {
            logMessage("\n‚ö†Ô∏è No device is connected or port is unavailable!");
            console.error("‚ö†Ô∏è", command);
            return false;
        }

        if (command.toLowerCase().includes(" nan")) {
            logAndConsoleMessage("‚ö†Ô∏è Command contains 'NaN' values. Please check the input.", {consoleLevel: 'error'});
            alert("‚ö†Ô∏è Aborted command due to 'NaN' values in the input.");
            return false;
        }

        return true;
    }

    // /////// Sending Commands /////////

    /**
     * Sends a command to the connected device.
     * Works with Serial (USB) connection;
     * @param {string} command - The command string to send.
     * @param timeOut
     * @param type
     */
    async function sendCommand(command, {type = "general", timeOut = 1} = {}) {
        switch (type) {
            case "console":
                await sendCommandConsole(command);
                break;
            case "app":
                await sendCommandApp(command);
                break;
            case "user":
                await sendCommandUser(command);
                break;
            case "silent":
                await sendCommandSilent(command);
                break;
            case "general":
            default:
                await sendCommandGeneral(command, timeOut);
        }
    }

    async function sendCommandGeneral(command, timeOut = 1) {
        if (!checkCommand(command)) return;

        writeCommand(command);

        if (!isNumSafe(timeOut)) timeOut = 1;
        timeOut = Math.max(0, Math.round(timeOut));

        if (command.toLowerCase() !== "syswr" && command.toLowerCase() !== "misc watchdog_reset") {
            await logMessage("üì§ General-Command sent: " + command);
        }
        await sleep(timeOut);  // Stop for at least 1 ms
    }

    async function sendCommandConsole(command) {
        switch (command.trim().toLowerCase()) {
            case "toggle port filter":
                useFilteredPort = !useFilteredPort;
                await logMessage(`\nüîÄ Toggled port filter: ${useFilteredPort ? "ON" : "OFF"}`);
                return;

            case "toggle port autoconnect":
                usePortAutoConnect = !usePortAutoConnect;
                await logMessage(`\nüîÄ Toggled port auto-connect: ${usePortAutoConnect ? "ON" : "OFF"}`);
                return;

            case "toggle port raw":
                allowRawConnect = !allowRawConnect;
                await logMessage(`\nüîÄ Toggled port raw-connections: ${allowRawConnect ? "ON" : "OFF"}`);
                return;

            case "toggle debugging":
                unblockDebugging(!debugging);
                await logMessage(`\nüîÄ Toggled debugging: ${debugging ? "ON" : "OFF"}`);
                return;

            case "clear all":
                if (isExperimentRunning) return;
                if (confirm("\nüóëÔ∏è Are you sure you want to disconnect from the machine and delete all saved settings, profiles, and data with logs from the database?\n\n\n     This action cannot be undone!\n\nClick 'OK' to proceed or 'Cancel' to abort.")) {
                    await clearAndResetAll();
                } else {
                    await logMessage("\n‚úñÔ∏è Clear all action cancelled by user.");
                }
                return;

            default:
                if (!checkCommand(command)) return;
                await writeCommand(command);
        }

        // User feedback in console
        await logMessage("  üó£Ô∏è User-Command sent: " + command);
    }

    async function sendCommandApp(command) {
        if (!checkCommand(command)) return;

        await writeCommand(command);

        // User feedback in console
        await logMessage("üëæ App-Command sent: " + command);
    }

    async function sendCommandUser(command) {
        if (!checkCommand(command)) return;

        await writeCommand(command);

        // User feedback in console
        await logMessage("üïπÔ∏è UI-Command sent: " + command);
    }

    async function sendCommandSilent(command) {
        if (!checkCommand(command)) return;

        await writeCommand(command);
    }

</script>

<script>

    async function sendMoveCommand(command, pauseMs = 1) {
        // check calibration status before moving
        calibrationStatus = await getCalibrationStatus(2_000);

        if (!calibrationStatus) {
            const msg = "\n‚ö†Ô∏è Motors are not calibrated.";
            await lockMovementExcept(UI.calibrateBtn);
            logAndConsoleMessage(msg);
            await endedMoving();
            alert(msg);
            return;
        }

        // Watchdog handles beganMoving/endedMoving, just send the command here
        await sendCommandGeneral(command, pauseMs);
    }

    async function setMachineName(name, pauseMs = 1) {
        if (!isNonEmptyStr(name)) {
            console.warn("‚ö†Ô∏è Machine name cannot be empty.");
            return;
        }
        if (isInvalidValue(name, {use_extended: true, considerFalse: true})) {
            console.warn("‚ö†Ô∏è Machine name contains invalid value.");
            return;
        }
        // ensure forbidden characters are removed
        name = name.replace(/[^a-zA-Z0-9 _-]/g, '').trim().replaceAll(" ", "_").toUpperCase();
        if (name.length === 0) {
            console.warn("‚ö†Ô∏è Machine name cannot be empty or contain only forbidden characters.");
            return;
        }
        const nameMaxLength = 35;
        if (name.length > nameMaxLength) {
            name = name.substring(0, nameMaxLength);
            console.warn(`‚ö†Ô∏è Machine name truncated to ${nameMaxLength} characters.`);
        }

        $ID("inputMachineName").value = name;
        machineName = name;
        const command = `MISC SET NAME ${name}`;

        await sendCommandGeneral(command, pauseMs);
    }

    async function setMachineID(id, pauseMs = 1, {overRide = false} = {}) {
        if (!isNonEmptyStr(id) && !isNumSafe(id)) {
            console.warn("‚ö†Ô∏è Machine ID cannot be empty.");
            return;
        }
        if (isInvalidValue(id, {use_extended: true, considerFalse: true})) {
            console.warn("‚ö†Ô∏è Machine ID contains invalid value.");
            return;
        }
        id = toInteger(id);
        if (!isNumSafe(id)) {
            console.warn("‚ö†Ô∏è Machine ID is not a valid number.");
            return;
        }
        if (!overRide) {
            if (0 >= id || id > 255) {
                console.warn("‚ö†Ô∏è Machine ID must be between 1 and 255.");
                return;
            }
        }

        $ID("inputMachineID").value = id;
        machineID = id;
        const command = `MISC SET MACHINE_ID ${id}`;

        await sendCommandGeneral(command, pauseMs);
    }


    // /////// Loading Commands from JSON /////////

    /**
     * Loads commands from an external JSON file and creates buttons for each command.
     */
    async function loadCommands() {
        try {
            const response = await fetch("commands.json");
            const commands = await response.json();

            for (const [name, command] of Object.entries(commands)) {
                const btn = $MAKE("button");
                btn.innerText = name;
                btn.onclick = () => sendFunction(name, command);
                // $$("buttons").appendChild(btn);
            }
        } catch (error) {
            await handleError(error, "loadCommands");
        }
    }

    // /////// Command Handling /////////

    /**
     * Sends a command to the ESP device.
     * If the command is for reading a specific LoadCell, it replaces the placeholder with the selected ID.
     * @param {string} name - The command name.
     * @param {string} inputCommand - The raw command string.
     */
    async function sendFunction(name, inputCommand) {
        let command;

        if (name === "read Loadcell[#]") { // LC GET FORCE 0-2
            let loadcellId = parseInt(getElementValue("inputNumLoadID"));
            command = replaceVariables(inputCommand, {loadcellId: loadcellId});
        } else {
            command = inputCommand;
        }

        await sendCommandGeneral(command);
    }

    // /////// Template Variable Replacement /////////

    /**
     * Replaces variables inside a command template with actual values.
     * @param {string} template - The command template containing placeholders.
     * @param {Object} variables - An object mapping variable names to their actual values.
     * @returns {string} - The command string with replaced values.
     */
    function replaceVariables(template, variables) {
        return template.replace(/{{(.*?)}}/g, (match, key) => variables[key.trim()] || match);
    }

</script>

<script>
    async function handleError(error, context = "Unknown") {
        // üìå Connection Errors Handling Identifiers
        const connectionErrors = [
            "NetworkError",
            "The device was lost.",
            "The port is no longer available.",
            "Device not responding",
            "openSerial",
            "connectSerial",
            "readserial",
        ];

        const reconnectTurnOff = true;

        if (reconnectTurnOff &&
            (connectionErrors.some(msg => error.message.includes(msg) || msg === context) || error.name === "NetworkError")) {

            // if (isExperimentRunning) {
            //     await endMeasuring(0, {
            //         ednStatus: 'connection lost',
            //         endText: "‚ùå Experiment stopped due to connection loss.",
            //         immediateText: "Connection lost! Stopping experiment..."
            //     });
            //     UI.experimentStageLabel.textContent = `Error`;
            //     document.documentElement.style.setProperty('--progressColor', 'var(--progressError-color)');
            // }

            await disconnectSerial({override: true});

            // console.warn("\n‚ö†Ô∏è Connection lost! Attempting to reconnect...");
            // isConnected = false;
            // await attemptReconnect(); // TODO: change reconnect handle
        } else {
            await logAndConsoleMessage(`‚ùå ${context} error: ${error}`, {consoleLevel: 'error'});
        }

    }

</script>

<script>

    // MOVING
    let movingTimeout = null;

    let watchdogTimer = null;
    let activeWatchDog = false;
    const WATCHDOG_INTERVAL_MS = 500; // min 500 ms

    let movementElements;
    let controlElements;
    let machineElements;


    async function moveToOriginalPosition({getCurrent = true, overRide = false} = {}) {
        if (!isConnected) return;
        if (isExperimentRunning) return;
        if (!overRide && machineOccupation) return;

        const endPosition = await measurePosition();
        if (!(isNumSafe(tareValues.position) && isNumSafe(endPosition))) {
            return;
        }

        const distance = tareValues.position - endPosition;
        if (Math.abs(distance) < 1e-2) {
            endedMoving();
            console.info("üö© Already at the original position.");
            return;
        }

        console.info("‚¨ÖÔ∏è Moving backward...");
        await moveBy(distance, {getCurrent, overRide});
        console.info("üö© Returning to original position completed.");
    }

    function disableInputsAndLabelsIn(root) {
        root.querySelectorAll?.("input")?.forEach(inp => {
            inp.disabled = true;
        });

        root.querySelectorAll?.("*")?.forEach(el => {
            if (el.shadowRoot) disableInputsAndLabelsIn(el.shadowRoot);
        });
    }

    function enableInputsAndLabelsIn(root) {
        root.querySelectorAll?.("input[disabled]")?.forEach(inp => {
            inp.disabled = false;
        });

        root.querySelectorAll?.("*")?.forEach(el => {
            if (el.shadowRoot) enableInputsAndLabelsIn(el.shadowRoot);
        });
    }

    const lockMovement = () => lockElements(movementElements);
    const lockMovementExcept = (exceptEl) => lockElementsExcept(movementElements, exceptEl);
    const unlockMovement = () => {
        let exceptEl = null;
        if (!tareValues.position) exceptEl = UI.returnBtn; // TODO: udƒõlat p≈ôes observer
        unlockElementsExcept(movementElements, exceptEl);
    }

    const lockControls = () => lockElements(controlElements);
    const lockControlsExcept = (exceptEl) => lockElementsExcept(controlElements, exceptEl);
    const unlockControls = () => unlockElements(controlElements);

    const lockMachineControls = () => lockElements(machineElements);
    const unlockMachineControls = () => unlockElements(machineElements);
    const lockMachineControlsExcept = (exceptEl) => lockElementsExcept(machineElements, exceptEl);

    const lockControlAndMove = () => {
        lockMovement();
        lockControls();
    };
    const unlockControlAndMove = () => {
        unlockMovement();
        unlockControls();
    };

    function lockElements(elements) {
        elements?.forEach((el) => {
            el?.classList.add("disabled");
            disableInputsAndLabelsIn(el);
        });
    }


    function lockElementsExcept(elements, exceptEl) {
        elements?.forEach(el => {
            const isExcept = el === exceptEl || el?.contains?.(exceptEl);
            if (!isExcept) {
                el?.classList?.add("disabled");
                disableInputsAndLabelsIn(el);
            } else {
                el?.classList?.remove?.("disabled");
                enableInputsAndLabelsIn(el);
            }
        });
    }

    function unlockElements(elements) {
        elements?.forEach((el) => {
            el?.classList.remove("disabled");
            enableInputsAndLabelsIn(el);
        });
    }

    function unlockElementsExcept(elements, exceptEl) {
        elements?.forEach(el => {
            const isExcept = el === exceptEl || el?.contains?.(exceptEl);
            if (!isExcept) {
                el?.classList?.remove?.("disabled");
                enableInputsAndLabelsIn(el);
            } else {
                el?.classList?.add("disabled");
                disableInputsAndLabelsIn(el);
            }
        });
    }

    // ------- Watchdog (bƒõ≈æ√≠ jen p≈ôi pohybu) -------
    function startWatchdog(intervalMs = WATCHDOG_INTERVAL_MS) {
        const interval = Math.round(Math.max(100, Number(intervalMs) || WATCHDOG_INTERVAL_MS));
        if (watchdogTimer) return; // u≈æ bƒõ≈æ√≠

        activeWatchDog = true;

        // Nastaven√≠ watchdog HW (p≈ôedstihem ~10% + 50ms)
        const hwInterval = interval + Math.ceil(clamp(interval * 0.10, 100, 250)) + 50;
        // nezdr≈æujeme ‚Äî fire and forget
        sendCommandGeneral(`MISC SET WATCHDOG_INTERVAL ${hwInterval}`);
        sendCommandGeneral(`MISC SET WATCHDOG_ENABLED ${1}`);
        if (debugging) console.info("\tüêï Watchdog is active.");

        watchdogTimer = setInterval(() => {
            // pos√≠lej SYSWR pouze kdy≈æ je to smyslupln√©
            if (!isConnected || !activeWatchDog || !machineOccupation) return;
            sendCommandGeneral("SYSWR");
        }, interval * 0.9); // 90% intervalu
    }

    function stopWatchdog(turnOff = true) {
        activeWatchDog = false;
        if (watchdogTimer) {
            clearInterval(watchdogTimer);
            watchdogTimer = null;
        }
        // HW watchdog turn off ‚Äî optional:
        if (isConnected && turnOff) sendCommandGeneral(`MISC SET WATCHDOG_ENABLED ${0}`);// if (debugging) TODO: turned off by DEBUGGING!!!
        if (debugging) console.info("\tüê∂ Watchdog is inactive.");
    }

    // ------- Movement -------
    async function beganMoving(timeoutMs = null) {
        if (machineOccupation) return; // is already moving
        lockConnectionButtons(true);
        lockControls();

        // schedule automatic ending (optional)
        if (isValidInputNum(timeoutMs)) {
            machineOccupation = true;
            warnOnClose = true;
            startWatchdog(WATCHDOG_INTERVAL_MS);

            const delay = toInteger(timeoutMs, "up");
            if (!isNumber(delay)) {
                console.warn("\nInvalid delay for beganMoving:", timeoutMs);
                endedMoving();
                return;
            }
            if (isDef(movingTimeout)) {
                clearTimeout(movingTimeout);
                movingTimeout = null;
            }
            movingTimeout = setTimeout(() => {
                endedMoving();
            }, delay);
        }
    }

    function setSpeed(speed, updateCurrent = true, timeOut = 1) {
        if (!isConnected) return;

        if (!isValidInputNum(speed)) return;

        if (!isValidInputNum(timeOut)) timeOut = 1;

        sendCommandGeneral(`MC SET SPEEDMM ${speed}`, timeOut);

        if (updateCurrent === true) currentSpeed = speed;
        setSpeedUI(speed);
    }

    function setSpeedUI(speed) {
        UI.speedSlider.value = speed;
        UI.speedLabel.value = `${speed.toFixed(2)}`;
    }

    function setAcceleration(acceleration, updateCurrent = true, timeOut = 1) {
        if (!isConnected) return;

        if (!isValidInputNum(acceleration)) return;
        if (!isValidInputNum(timeOut)) timeOut = 1;

        sendCommandGeneral(`MC SET ACCELMM ${acceleration}`, timeOut);

        if (updateCurrent === true) currentAcceleration = acceleration;
        setAccelerationUI(acceleration);
    }

    function setAccelerationUI(acceleration) {
        UI.accelerationSlider.value = acceleration;
        UI.accelerationLabel.value = `${acceleration.toFixed(2)}`;
    }

    function setSpeedAndAcceleration(speed, acceleration, updateCurrent = true, timeOut = 2) {
        if (!isConnected) return;

        timeOut = Math.max(Math.abs(Math.round(timeOut / 2)), 1);
        setSpeed(speed, updateCurrent, timeOut);
        setAcceleration(acceleration, updateCurrent, timeOut);
    }

    function endedMoving() {
        // idempotence
        if (isDef(movingTimeout)) {
            clearTimeout(movingTimeout);
            movingTimeout = null;
        }

        if (isConnected) sendCommandGeneral("MC STOP");
        machineOccupation = false;

        warnOnClose = false;
        machineOccupation = false;
        stopWatchdog(false); // TODO: check if disable movement of machine is good idea

        if (isConnected) setSpeedAndAcceleration(currentSpeed, currentAcceleration, true, 10);

        if (calibrationStatus) unlockMovement();
        else if (!calibrationStatus && isConnected) lockMovementExcept(UI.calibrateBtn);
        lockConnectionButtons(true, connectionType);
        unlockControls();
    }

    function speedFromDistance(goal, dMax = 100, sMin = 1, sMax = 25) { // 25 u≈æ od 100 mm
        const d = Math.max(0, Math.abs(toNumber(goal)) || 0);
        const t = Math.min(1, d / dMax);              // 0..1
        const v = sMin + (sMax - sMin) * t;           // linear 1..25
        return roundDecimalFast(v, 2);                // float f.2
    }

    async function moveBy(distance, {
        getCurrent = true,
        requiredSpeed = null,
        requiredAcceleration = null,
        overRide = false
    } = {}) {
        if (!isConnected) return;
        if (isExperimentRunning) return;
        if (!overRide && machineOccupation) {
            console.warn("Machine is already busy.\nPlease wait.");
            return;
        }

        try {
            // check calibration
            calibrationStatus = await getCalibrationStatus(2_000);

            if (!calibrationStatus) {
                const msg = "‚ö†Ô∏è Motors are not calibrated.";
                await lockMovementExcept(UI.calibrateBtn);
                logAndConsoleMessage(msg, {consoleLevel: 'warn'});
                endedMoving();
                return;
            }

            if (getCurrent) {
                currentSpeed = (await getSpeed()) || 15;
                currentAcceleration = (await getAcceleration()) || 150;
            }

            const acceleration = requiredAcceleration || 100; // mm/s¬≤
            const speed = requiredSpeed || await speedFromDistance(distance, acceleration, 0.5, 25); // mm/s

            if (!speed || !acceleration) {
                console.warn("\n‚ö†Ô∏è Invalid speed or acceleration values.");
                endedMoving();
                return;
            }

            await setSpeedAndAcceleration(speed, acceleration, false, 10);


            lockMovement();               // for normal moves, lock the entire movement section
            await beganMoving();          // without timeout ‚Äî we will calculate and set it below


            const movingTime =
                Math.ceil(convertUnits(computeMotionTime(distance, speed, acceleration), 's', 'ms') + 150);

            // set/reset moving timeout after ending of movement
            if (isDef(movingTimeout)) {
                clearTimeout(movingTimeout);
                movingTimeout = null;
            }

            await sendMoveCommand(`MC MOVEBY MACH ${distance}`, 5);

            movingTimeout = setTimeout(() => endedMoving(), movingTime);


            await sleep(movingTime);

        } catch (e) {
            console.error("Error during moveBy:", e);
            endedMoving();
        }
    }

    function computeMotionTime(distance, speed, acceleration) {
        const t_accel = speed / acceleration;               // time acceleration
        const s_accel = 0.5 * acceleration * t_accel ** 2;  // distance during acceleration

        distance = Math.abs(distance);

        if (2 * s_accel >= distance) {
            // üö© Triangular profile ‚Äì only acceleration and deceleration
            return 2 * Math.sqrt(distance / acceleration);
        } else {
            // üö© Trapezoidal profile ‚Äì acceleration, constant speed, and deceleration
            const s_cruise = distance - 2 * s_accel;
            const t_cruise = s_cruise / speed;
            return 2 * t_accel + t_cruise;
        }
    }


    function stopMachine(type = 'machine') {
        if (isConnected) {
            setAcceleration(200, false); // Set acceleration to 200 mm/s¬≤
            sendStopAllMeasuring();
        }

        if (isExperimentRunning) {
            let reason;
            let endColor;

            switch (type) {
                case 'user':
                    endColor = 'var(--progressError-color)';
                    reason = "user stop";
                    break;
                case 'machine':
                    endColor = 'var(--progressWarning-color)';
                    reason = "machine stop";
                    break;
                case 'error':
                    endColor = 'var(--progressError-color)'
                    reason = "error";
                    break;
                case 'alarm':
                    endColor = 'var(--progressError-color)'
                    reason = "machine alarm";
                    break;
                default:
                    endColor = 'var(--progressError-color)'
                    reason = "unknown stop";
            }

            endMeasuring(0, {
                overRide: true,
                ednStatus: String(reason),
                endText: 'üõë Experiment stopped',
            });

            UI.experimentStageLabel.textContent = `Stopped`;
            document.documentElement.style.setProperty('--progressColor', String(endColor));

        }

        endedMoving();
    }

    function stopMoving() {
        if (isConnected) {
            setAcceleration(200, false); // Set acceleration to 200 mm/s¬≤
            sendStopAllMeasuring();
        }

        sendCommandGeneral("MC STOP");
        console.info("\tüõë Movement stopped.");

        endedMoving();
    }


    async function softStopMachine() {
        setAcceleration(200, false); // Set acceleration to 200 mm/s¬≤

        await rampSpeed(currentSpeed, 0.1);

        endedMoving();

        if (isExperimentRunning) {
            await endMeasuring(0, {
                overRide: true,
                ednStatus: 'user soft stop',
                endText: 'üõë Experiment stopped',
            });
            UI.experimentStageLabel.textContent = `Stopped`;
            document.documentElement.style.setProperty('--progressColor', 'var(--progressError-color)');
        }
    }

    /**
     * Ramping of speed with fixed steps 20ms, max. ~300ms total.
     * @param {number} currSpeed - current speed (mm/s)
     * @param {number} targetSpeed - target speed (mm/s), default 0.05
     */
    async function rampSpeed(currSpeed, targetSpeed = 0.05) {
        const INTERVAL_MS = 8;
        const MAX_INTERVALS = 9;    // 15 * 20ms = 300ms between 1. and last SEND
        const PREFERRED_STEP = 1;   // mm/s
        const MIN_STEP = 0.5;       // mm/s

        if (!isConnected) return;
        if (!isNumSafe(currSpeed)) currSpeed = currentSpeed || 15;

        const delta = targetSpeed - currSpeed;
        const dir = Math.sign(delta);
        const absDelta = Math.abs(delta);

        // If we're already at the target (or very close), send the exact command directly.
        if (absDelta < 1e-9) {
            return sendCommandSilent(`MC SET SPEEDMM ${targetSpeed.toFixed(3)}`);
        }

        //Choose step size: prefer 1 mm/s; if it wouldn't fit in 300 ms, increase the step.
        // Max number of SENDs is 16 (15 intervals + final command).
        let step = PREFERRED_STEP;
        const neededWithPreferred = Math.ceil(absDelta / step);
        // Number of intervals is (num_sends - 1). I.e. max 16 sends => 15 intervals.
        if (neededWithPreferred - 1 > MAX_INTERVALS) {
            step = Math.max(MIN_STEP, absDelta / MAX_INTERVALS); // may be >1 if needed
        }

        // How many intermediate steps can we fit within the 15 intervals with the chosen step
        let intermediateSteps = Math.min(Math.floor(absDelta / step), MAX_INTERVALS);

        // Round to 3 decimal places (0.001 mm/s)
        const fmt = (v) => Number(v).toFixed(3);

        let curr = currSpeed;

        // Send intermediate steps every 20 ms (each step size >= 0.5 mm/s)
        for (let i = 0; i < intermediateSteps; i++) {
            curr += dir * step;

            // Sanitize to avoid overshooting
            if ((dir > 0 && curr > targetSpeed) || (dir < 0 && curr < targetSpeed)) {
                curr = targetSpeed;
            }

            await sleep(INTERVAL_MS);
            await sendCommandSilent(`MC SET SPEEDMM ${fmt(curr)}`);

            // If we're already at the target, exit early
            if (Math.abs(curr - targetSpeed) < 1e-9) {
                return;
            }
        }

        // If we're still not exactly at the target, send the final precise command.
        // This is the last SEND (max 16 in total), again with a 20ms gap from the previous one.
        if (Math.abs(curr - targetSpeed) >= 1e-9) {
            await sleep(INTERVAL_MS);
            await sendCommandGeneral(`MC SET SPEEDMM ${fmt(targetSpeed)}`);
        }
    }

</script>

<script>
    // /////// Optimized Measurement Processing /////////
    let _msgQueue = Promise.resolve();

    function handleIncomingChunkQueued(dataChunk) {
        _msgQueue = _msgQueue
            .then(() => processMessage(dataChunk))
            .catch(err => console.error('processMessage failed:', err));
    }


    /**
     * Processes incoming measurement data.
     * @param {Array} dataChunk - An array of measurement data lines.
     */
    async function processMessage(dataChunk) {
        if (!dataChunk || !dataChunk.length) return;

        if (isStr(dataChunk)) {
            dataChunk = String(dataChunk).split("\n").map(line => line.trim()).filter(line => line.length > 0);
        }
        if (!isNonEmptyArr(dataChunk)) return;
        else dataChunk = dataChunk.map(line => String(line).trim()).filter(line => isNonEmptyStr(line));

        for (let msg of dataChunk) {
            if (msg === "S0:WR") continue; // ignore

            // If 'alarm' or 'alarmed' is in the message, log it and skip further processing
            if (/alarm(ed)?/i.test(msg)) {
                await logMessage("üö®\t" + msg);
                if (isExperimentRunning) {
                    isExperimentRunning = false;
                    await stopMachine("alarm");
                    logMessage("‚ö†Ô∏è Experiment stopped due to alarm.");
                }
                continue;
            }

            // First, try to match and resolve waiting messages in the queue
            const consumed = _tryMatchAndResolve(msg);
            if (consumed) {
                if (debugging) logMessage("   üìØ\t" + msg);
                continue;             // If a message is consumed, skip further processing
            }

            // rest of the message logic
            // TODO: rozmyslet co pou≈æ√≠vat:         split(":") // substring(measurementPrefix.length)
            const measurementPrefix = "DS"; // "S205:"
            if (msg.startsWith(measurementPrefix)) {
                await processMeasurements(msg.substring(measurementPrefix.length));
            } else {
                logMessage("üì©\t" + msg);
            }
        }
    }

</script>

<script>
    const getMeasurementPartsLength = (obj) =>
        Object.entries(obj).reduce((sum, [key, val]) => {
            if (key === 'length' || key === 'lengths') return sum; // skip special keys

            const arr = isArr(val) ? val : (isNumber(val) ? [val] : []);

            obj[key] = arr;                 // normalize to array
            (obj.lengths ||= {})[key] = arr.length; // save length
            return sum + arr.length;                     // add lengths to total
        }, 0);

    function analyzeForces(fields) {
        const err = {min: NaN, max: NaN, mean: NaN, std: NaN, median: NaN, allInvalid: true};
        return fields.map(arr => {
            let found = false;
            let min = Number.POSITIVE_INFINITY, max = Number.NEGATIVE_INFINITY;

            for (const v of arr) { // TODO: create optimized version 'minMaxND'
                if (isNumSafe(v)) {
                    found = true;
                    if (v < min) min = v;
                    if (v > max) max = v;
                }
            }

            if (!found || (Math.abs(min) === 0 && Math.abs(max) === 0)) return err;
            if (min === max) {
                logMessage(`‚ö†Ô∏è Warning: min and max forces are equal: ${min}, ${max}`);
                console.warn("‚ö†Ô∏è Warning: min and max forces are equal:", min, max);
                return err;
            }

            const mean = mean1D(arr);
            const std = std1D(arr);
            const median = median1D(arr);

            return {min, max, mean, std, median, allInvalid: false};
        });
    }

    function hasRequiredParsedKeys(experimentEndLimits, parsedData) {
        if (!isDict(experimentEndLimits) || !isDict(parsedData)) return false;

        // used keys (required for ending the experiment), check if invalid: null/NaN
        const required = Object.entries(experimentEndLimits).filter(([, v]) => !isNumSafe(v));

        // atleast one required key must exist
        if (required.length === 0) return false;

        // all keys must be in parsedData
        return required.every(([k]) => Object.prototype.hasOwnProperty.call(parsedData, k));
    }

    function calculateStep(frequencyMicroseconds, updateFrequencyMilliseconds = 200, minimum = 1) {
        if (!isValidInputNum(frequencyMicroseconds)) return minimum;
        minimum = catchVal(minimum, 1, isValidInputNum);
        updateFrequencyMilliseconds = catchVal(updateFrequencyMilliseconds, 200, isValidInputNum);
        return Math.max(1, minimum, Math.ceil(convertUnits(updateFrequencyMilliseconds, 'ms', '¬µs') / frequencyMicroseconds));
    }

    function computeFrenchingMs(frequencyMicroseconds, inSeconds = 1, minimum = 50) {
        if (!isValidInputNum(frequencyMicroseconds)) return minimum;
        minimum = catchVal(minimum, 50, isValidInputNum);
        inSeconds = catchVal(inSeconds, 1, isValidInputNum);

        const samplesPerSecond = Math.floor(convertUnits(inSeconds, 's', '¬µs') / frequencyMicroseconds); // (Hz)

        return Math.max(minimum, samplesPerSecond);
    }

</script>

<script>
    // /////// Experiment Configuration /////////
    let forceLimitDropPercent = 0;
    let forceLimitDropValue = 0;
    let experimentEndLimits = {position: null, force: null, time: null};
    let expControl = '';

    let checkSpeed = true;
    let isExperimentRunning = false;
    let machineOccupation = false;

    let maxForces = Array(catchVal(loadCellNum, 0, isNumSafe)).fill(null);

    let measureForces = Array(catchVal(loadCellNum, 0, isNumSafe)).fill(null).map(() => []);
    let takeMeasurements = false;

    let tareValues = {time: null, position: null, force: Array(catchVal(loadCellNum, 0, isNumSafe)).fill(0)};

    let parsedData = {
        time: null,
        position: null,
        speed: null,
        force: Array(catchVal(loadCellNum, 0, isNumSafe)).fill(null),
        photoIndex: null
    }; // Last data log

    // TODO: make One large Experiment variable object: measurementParts, tareValues, limits, loadcellErr, measuredData
    // TODO: make Tow large Experiment variable objects: measuredData (time, pos, ...) vs chartData (timeData, posData, ...)
    const measurementPartDefault = {
        length: null,
        time: [0],
        position: [1],
        speed: [2],
        force: [3, 4, 5],
    };
    measurementPartDefault.length = getMeasurementPartsLength(measurementPartDefault);

    let measurementParts = measurementPartDefault; // Array to store measurement parts

    let aggregatedDataBetweenSteps = [];
    let displacementSignCorrection = 1;
    let loadSignCorrections = [-1, -1, -1];

    let loadcellErrRate = [];
    let measurementErrRate = [];
    let totalErrRate = [];

    let endMeasurement = false;
    let endMeasurementCounter = null;
    const delayMsAfterEndMeasurement = 100; // microseconds

    let experimentProgress = 0;

    let endedBy = null;

    let experimentEvents = {
        doubleSpeed: {active: false, value: null, limit: null, initValue: null},
        doubleAccel: {active: false, value: null, limit: null, initValue: null},
    };

    let measurement_limits = {
        zero_speed: {counter: 0, limit: 2},
        over_limitForce: {counter: 0, limit: 2},
        invalid_data: {counter: 0, limit: 2},
    };

</script>

<script>
    function createPIController(userOpts = {}) {
        // Kp (mm/s)/N = mm/(N¬∑s)
        // Ki (mm/s)/(N¬∑s) = mm/N
        const cfg = {
            // --- set of parameters for PI controller ---
            setForceN: null,    // target force [N]
            deadbandN: 0.5,     // dead zone ¬± [N]
            vMin: +0.00,        // min speed [mm/s]
            vMax: 25.00,        // max speed [mm/s]
            Kp: 0.20,           // [mm/s ¬∑ N‚Åª¬π]
            Ki: 0.03,           // [mm/s ¬∑ N‚Åª¬π ¬∑ s‚Åª¬π]
            accel: null,        // limitation of speed change [mm/s¬≤]; null = no limit
            integLimit: 500,    // anti-windup clamp
            roundDigits: 3,     // round ouput (0.001 mm/s)
            unilateral: true,   // only positive output ( => down)
            ...userOpts,
        };

        let integ = 0;
        let lastT = null;
        let lastV = 0;

        function step(t, x, F) {
            // t [s], x [mm], F [N]  ‚Üí  v [mm/s]
            if (isNull(lastT)) lastT = t;
            const dt = Math.max(1e-6, t - lastT);
            lastT = t;

            const err = cfg.setForceN - F;

            // integrace jen kdy≈æ jsme mimo mrtvou z√≥nu (stejnƒõ jako v p≈Øvodn√≠m k√≥du)
            if (err > cfg.deadbandN) {
                integ = clamp(integ + err * dt, -cfg.integLimit, cfg.integLimit);
            }

            // PI v√Ωstup jen p≈ôi pozitivn√≠ chybƒõ mimo mrtvou z√≥nu (jen dol≈Ø)
            let vCmd = 0;
            if (err > cfg.deadbandN) {
                vCmd = cfg.Kp * err + cfg.Ki * integ;
                // vMin..vMax (pokud je aktivn√≠)
                vCmd = clamp(vCmd, cfg.vMin, cfg.vMax);
            }

            // jednostrann√© omezen√≠ (bezpeƒçnostnƒõ, i kdy≈æ u≈æ je vCmd‚â•vMin)
            if (cfg.unilateral && vCmd < 0) vCmd = 0;

            // voliteln√Ω slew-rate limit p≈ôes 'accel' (mm/s¬≤)
            if (isValidInputNum(cfg.accel)) {
                const dvMax = cfg.accel * dt;
                if (vCmd > lastV + dvMax) vCmd = lastV + dvMax;
                else if (vCmd < lastV - dvMax) vCmd = lastV - dvMax;
            }

            // zaokrouhlen√≠ jako v simulaci
            const k = 10 ** cfg.roundDigits;
            vCmd = Math.round(vCmd * k) / k;

            lastV = vCmd;
            return vCmd;
        }

        function reset(newOpts) {
            if (newOpts) Object.assign(cfg, newOpts);
            integ = 0;
            lastT = null;
            lastV = 0;
        }

        return {
            step,   // (t, x, F) => v
            reset,  // reset stavu integr√°toru/ƒçasovaƒçe (+ volitelnƒõ nov√© nastaven√≠)
            get state() {
                return {integ, lastT, lastV, cfg: {...cfg}};
            },
        };
    }

    let pi;

    // // jednou p≈ôi startu:
    // pi = createPIController({
    //     setForceN: 100,
    //     Kp: 0.200,
    //     Ki: 0.030,
    //     deadbandN: 0.5,
    //     vMin: 0.025,
    //     vMax: 25,
    // });
    //
    // // v bƒõ≈æ√≠c√≠m cyklu ≈ô√≠zen√≠/simulace:
    // const v = pi.step(tSeconds, xMm, forceN);
    // // ‚Üí po≈°li v do pohonu jako po≈æadovanou rychlost (mm/s)

</script>

<script>

    /**
     * Vypoƒçte jerk-limited S-profil pro rozjezd z 0 na rychlost v.
     * Vstupy v mm/s, mm/s¬≤, mm/s¬≥. ƒåas v sekund√°ch.
     *
     * @param {number} v     - c√≠lov√° rychlost [mm/s]
     * @param {number} jmax  - max jerk [mm/s^3]
     * @param {number} amax  - max zrychlen√≠ [mm/s^2] (voliteln√©, default Infinity)
     * @param {number} amin  - min zrychlen√≠ [mm/s^2] (default 5)
     * @returns {{
     *   a_peak: number,   // doporuƒçen√© ≈°piƒçkov√© zrychlen√≠ [mm/s^2]
     *   mode: "no_plateau" | "with_plateau",
     *   t_total: number,  // celkov√Ω ƒças rozjezdu 0‚Üív [s]
     *   warning?: string  // p≈ô√≠padn√© upozornƒõn√≠ na omezen√≠
     * }}
     */
    function accelFromJerkAndVelocity(v, jmax, amax = Infinity, amin = 5) {
        if (!(v > 0) || !(jmax > 0)) {
            throw new Error("v > 0 a jmax > 0");
        }
        if (!(amax > 0)) amax = Infinity;
        if (!(amin > 0)) amin = 5;

        // Limit dan√Ω jerky: bez poru≈°en√≠ Jmax nelze j√≠t nad sqrt(J*v)
        const aByJerk = Math.sqrt(jmax * v);

        let warning;
        if (aByJerk < amin) {
            // Po≈æadovan√© min. zrychlen√≠ je nerealizovateln√© p≈ôi dan√©m jmax a v
            // (musel bys povolit vy≈°≈°√≠ jerk nebo zv√Ω≈°it v).
            warning = `amin=${amin} mm/s¬≤ nelze dos√°hnout pro v=${v} mm/s a jmax=${jmax} mm/s¬≥; pou≈æito a_peak=${aByJerk.toFixed(3)} mm/s¬≤.`;
        }

        // a_peak omezeno postupnƒõ: jerkem, mechanick√Ωm amax a minimem amin
        // (pokud aByJerk < amin, vezmeme aByJerk a p≈ôipoj√≠me warning).
        let a_peak = (aByJerk < amin) ? aByJerk : Math.min(amax, Math.max(amin, aByJerk));

        // Re≈æim: bez plateau, pokud jsme omezeni ƒçistƒõ jerky (a == aByJerk)
        const mode = (Math.abs(a_peak - aByJerk) < 1e-12) ? "no_plateau" : "with_plateau";

        // Celkov√Ω ƒças rozjezdu:
        // - no_plateau: t_total = 2 * sqrt(v / jmax)
        // - with_plateau: t_total = 2*(a_peak/jmax) + (v/a_peak - a_peak/jmax)
        let t_total;
        if (mode === "no_plateau") {
            t_total = 2 * Math.sqrt(v / jmax);
        } else {
            const tRamp = a_peak / jmax;
            const tFlat = Math.max(0, v / a_peak - tRamp);
            t_total = 2 * tRamp + tFlat;
        }

        const result = {a_peak, mode, t_total};
        if (warning) result.warning = warning;
        return result;
    }


</script>

<script>
    let speedForward_mmps = 0;
    let takePhotos = false;
    let dataInterval_us = null;
    let experimentHoldConstantForce = false;
    let stoppingForceLimit = null;
    let holdForceTimeMs = null;

    let timer = null; // TODO: create a universal dicionary for all experiment-based variables needed for experiment

    let loadcellsInfo = {presentLoadcells: [], loadcellsIDX: [], capacities: [], outputs: []};

    async function startExperiment() {

        if (!isConnected) {
            logAndConsoleMessage("‚ö†Ô∏è ESP is not connected!", {consoleLevel: 'warn'});
            return;
        }

        if (isExperimentRunning) {
            logAndConsoleMessage("‚ö†Ô∏è Experiment is already running.", {consoleLevel: 'warn'});
            return;
        }

        if (machineOccupation) {
            logAndConsoleMessage("‚ö†Ô∏è Machine is currently moving. Please wait until it stops.", {consoleLevel: 'warn'});
            return;
        }

        // === System Limits ===
        const minDistance = 5e-3;
        const minFSpeed = 0.025; // TODO: check this
        const maxFSpeed = 25;
        const minInt = 5e-6;
        const minLoadCap = 5e-4;
        const minLoadOut = 5e-4;
        const minForce = 1e-3;
        const minAccel = 1;
        const maxAccel = 200;
        const configuredJerk = 3_000; // TODO: make user-configurable if needed

        let internalError = false;
        const throwInternalError = (msg, errMsg) => {
            internalError = true;
            if (isNonEmptyStr(errMsg)) logAndConsoleMessage(errMsg, {consoleLevel: 'warn', showAlert: true});
            throw new Error(msg);
        };

        const disableCharts = ({lcCount = loadCellNum, show = false} = {}) => {
            for (let i = 1; i <= (lcCount + 1); i++) {
                if (timeChart) timeChart.setSeries(i, {show: show});
                if (positionChart) positionChart.setSeries(i, {show: show});
            }
        };

        try {
            UI.experimentStageLabel.textContent = `Preparing`;

            await lockMovement();
            await beganMoving();
            await lockConnectionButtons(true);

            if (!debugging) await console.clear();
            if (!debugging) await clearConsoleLog();
            await console.info("%c\n\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NEW EXPERIMENT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n\n", "color: black; font-size: 14px; font-weight: bold;");
            await console.groupCollapsed("New Experiment Section");
            await console.info(`%cüïí Experiment started at: ${new Date().toLocaleString()}`, "color: gray; font-size: 12px; font-style: italic;");

            // === Retrieve Parameters from Inputs ===
            const distance_mm = getInputNumDefAbsFlt("inputDistance", NaN);
            const experimentType = getElementValue("experimentTypeDropdown")?.toLowerCase();
            displacementSignCorrection = experimentType.includes("down") ? 1 : -1;
            speedForward_mmps = getInputNumDefAbsFlt("inputSpeedForward", NaN);
            dataInterval_us = Math.max(getInputNumDefAbsInt("inputDataInterval", NaN), 100);
            takePhotos = $ID("inputTakePhotos").checked;
            const photoInterval_ms = convertUnits(getInputNumDefAbsFlt("inputPhotoInterval", NaN), 's', 'ms', {precision: 0});
            forceLimitDropPercent = catchVal((getInputNum("inputLoadLimitDropPercent") / 100), NaN, isNumSafe);
            forceLimitDropValue = getInputNumDefAbsFlt("inputLoadLimitDropValue", NaN);


            if (!isNumSafe(loadCellNum)) throwInternalError(`Total Loadcell count is not defined: ${loadCellNum}`);

            const loadcellCount = loadCellNum; // TODO: Change by user selection if needed

            loadcellsInfo = {
                presentLoadcells: Array(loadcellCount).fill(false),
                loadcellsIDX: [],
                capacities: Array(loadcellCount).fill(null),
                outputs: Array(loadcellCount).fill(null)
            };
            loadcellErrRate = [];
            measurementErrRate = [];
            totalErrRate = [];


            const basicLCCapId = "inputLoadcellCapacity";
            const basicLCOutId = "inputLoadcellOutput";
            const isLCComplex = isUnavailable($ID(basicLCCapId));
            if (isLCComplex) {
                for (let i = 0; i < loadcellCount; i++) {
                    const active = $ID(`activateLoadcell${i + 1}`).checked;
                    if (active === true) {
                        loadcellsInfo.loadcellsIDX.push(i)
                        loadcellsInfo.presentLoadcells[i] = true;
                        loadcellsInfo.capacities[i] = getInputNumDefAbsInt(`${basicLCCapId}${i + 1}`, NaN);
                        loadcellsInfo.outputs[i] = getInputNumDefAbsInt(`${basicLCOutId}${i + 1}`, NaN);
                    }
                }
            } else {
                const loadcellCapacity = getInputNumDefAbsInt(basicLCCapId, NaN);
                const loadcellOutput = getInputNumDefAbsFlt(basicLCOutId, NaN);

                loadcellsInfo.presentLoadcells = Array(loadcellCount).fill(true);
                loadcellsInfo.loadcellsIDX = Array.from({length: loadcellCount}, (_, i) => i);
                loadcellsInfo.capacities = Array(loadcellCount).fill(loadcellCapacity);
                loadcellsInfo.outputs = Array(loadcellCount).fill(loadcellOutput);
            }

            let initialAccelForward_mmps2 = maxAccel;
            let initialSpeed_mmps = speedForward_mmps;
            experimentEvents.doubleSpeed = {active: false, value: null, limit: null, initValue: null},
                experimentEvents.doubleAccel = {active: false, value: null, limit: null, initValue: null},
                experimentHoldConstantForce = false;
            stoppingForceLimit = Number.POSITIVE_INFINITY;
            holdForceTimeMs = null;
            const responsiveness = {Kp: NaN, Ki: NaN, minSpeed: NaN, maxSpeed: NaN, accel: NaN};


            const suffixes = ["-inb", "-hbr"]; // TODO: doplnit i pro Flex ("-flx") a "basic" m√≠t jako default
            if (suffixes.some(suf => experimentType.endsWith(suf))) {
                initialSpeed_mmps = getInputNumDefAbsFlt("inputInitialSpeed", NaN);
                experimentEvents.doubleSpeed.limit = getInputNumDefAbsFlt("inputInitialForce", NaN);
                experimentEvents.doubleSpeed.active = true;
                experimentEvents.doubleSpeed.value = speedForward_mmps;
                experimentEvents.doubleSpeed.initValue = initialSpeed_mmps;

                if (experimentType.endsWith("-hbr")) {

                    stoppingForceLimit = getInputNumDefAbsFlt("inputStopForce", NaN);
                    holdForceTimeMs = convertUnits(getInputNumDefAbsFlt("inputEndDelay", NaN), 's', 'ms', {precision: 0});
                    experimentHoldConstantForce = true;

                    const basicPICId = "inputResponseCoefPI";
                    const isPICComplex = isUnavailable($ID(basicPICId));
                    if (isPICComplex) {
                        const respKp = getInputNumDefAbsFlt(basicPICId.replace('PI', 'Kp'), NaN);
                        const respKi = getInputNumDefAbsFlt(basicPICId.replace('PI', 'Ki'), NaN);
                        responsiveness.Kp = respKp;
                        responsiveness.Ki = respKi;
                    } else {
                        const respCoef = getInputNumDefAbsFlt(basicPICId, NaN);
                        responsiveness.Kp = respCoef;
                        responsiveness.Ki = respCoef;
                    }

                    const basicPISId = "inputResponseCoefMinS";
                    const isPISComplex = isUnavailable($ID(basicPISId));
                    if (isPISComplex) {
                        const respMinS = getInputNumDefAbsFlt(basicPISId, NaN);
                        const respMaxS = getInputNumDefAbsFlt(basicPISId.replace('MinS', 'MaxS'), NaN);
                        const respAcc = getInputNumDefAbsFlt(basicPISId.replace('MinS', 'Accel'), NaN);
                        responsiveness.minSpeed = clamp(respMinS, 1e-4, respMaxS - 1e-5);
                        responsiveness.maxSpeed = clamp(respMaxS, respMinS + 1e-5, maxFSpeed);
                        responsiveness.accel = respAcc >= 200 ? null : clamp(respAcc, 1, 200);
                    } else {
                        responsiveness.minSpeed = Math.min(minFSpeed, 5e-4);
                        responsiveness.maxSpeed = clamp(Math.max(minFSpeed * 5 / 2, speedForward_mmps * 4 / 5), minFSpeed + 1e-5, speedForward_mmps); // minFSpeed * 3 / 2, speedForward_mmps * 2 / 3);
                        responsiveness.accel = 25;
                    }
                }
            }


            let doCycles = false;
            let cyclesCount = NaN;

            // TODO: 'customNumber'
            if (experimentType.endsWith("-basic") && $ID("inputDoCycles").checked === true) {
                doCycles = true;
                const cyclesVal = getInputVal("inputCycles")?.toLowerCase().trim() || '';
                if (cyclesVal.includes('inf') || cyclesVal.includes('‚àû') || cyclesVal.includes('Íùè') || cyclesVal.includes('·Äë')) {
                    cyclesCount = Number.POSITIVE_INFINITY;
                } else {
                    cyclesCount = getInputNumDefAbsInt("inputCycles", NaN);
                }
            }


            if (!doCycles) {
                const accelProfile = accelFromJerkAndVelocity(initialSpeed_mmps, configuredJerk, maxAccel, minAccel);
                // TODO: or use 'rampSpeed(0, initialSpeed_mmps)' to get gradual acceleration

                if (accelProfile.warning) {
                    logAndConsoleMessage(`‚ö†Ô∏è Warning: ${accelProfile.warning}`, {consoleLevel: 'warn'});
                }

                if (isNumSafe(accelProfile.t_total) && convertUnits(accelProfile.t_total, 's', 'ms') > 10) {
                    initialAccelForward_mmps2 = roundDecimalFast(accelProfile.a_peak, precisionAcceleration);
                    experimentEvents.doubleAccel.active = true;
                    experimentEvents.doubleAccel.limit = accelProfile.t_total * 0.975; // slightly less to be safe
                    experimentEvents.doubleAccel.value = maxAccel;
                    experimentEvents.doubleAccel.initValue = initialAccelForward_mmps2;

                    if (convertUnits(accelProfile.t_total * 0.5, 's', 'ms') < convertUnits(dataInterval_us, '¬µs', 'ms')) {
                        dataInterval_us = Math.floor(convertUnits(accelProfile.t_total * 0.5, 's', '¬µs'));
                        logAndConsoleMessage(`‚ö†Ô∏è Warning: Data interval was adjusted to ${dataInterval_us} ¬µs to accommodate acceleration profile.`, {consoleLevel: 'warn'});
                    }
                }
            }


            if (experimentType.includes("-pos-")) {
                experimentEndLimits = {position: distance_mm, force: null, time: null};  // The total distance to be moved; force and time limits are not used now
                expControl = 'position'; // Control the experiment by position
                logAndConsoleMessage("\t\t‚û°Ô∏è Experiment type: Position controlled");
            } else {
                throwInternalError("Unknown Experiment type error");
            }

            calibrationStatus = await getCalibrationStatus(2_000);

            // =================================
            // ======= Input Validations =======
            // =================================
            if (expControl === 'position')
                if (!isValidInputNum(distance_mm) || distance_mm < minDistance)
                    throwInternalError("Distance error", `‚ö†Ô∏è Distance must be greater than ${minDistance} mm.`);


            if (doCycles && !(isNumberOrInfinity(cyclesCount) && cyclesCount > 0))
                throwInternalError("Cycles count error", `‚ö†Ô∏è Number of cycles must be a positive integer bigger than 0.`);

            if (!isNumberOrInfinity(forceLimitDropValue) || forceLimitDropValue <= minForce)
                throwInternalError("Force limit drop value error", `‚ö†Ô∏è Force limit drop value must be a valid positive number.`);
            if (!isNumberOrInfinity(forceLimitDropPercent) || forceLimitDropPercent <= (minForce / 1_000))
                throwInternalError("Force limit drop percent error", `‚ö†Ô∏è Force limit drop percent must be a valid positive number.`);

            if (!isNumSafe(speedForward_mmps) || speedForward_mmps < minFSpeed)
                throwInternalError("Speed error", `‚ö†Ô∏è Speed must be greater than ${minFSpeed} mm/s.`);
            else if (speedForward_mmps > maxFSpeed)
                throwInternalError("Speed error", `‚ö†Ô∏è Speed must be less than ${maxFSpeed} mm/s.`);

            if (!isNumSafe(initialAccelForward_mmps2) || initialAccelForward_mmps2 < minAccel)
                throwInternalError("Acceleration error", `‚ö†Ô∏è Acceleration must be greater than ${minAccel} mm/s¬≤.`);
            else if (initialAccelForward_mmps2 > maxAccel)
                throwInternalError("Acceleration error", `‚ö†Ô∏è Acceleration must be less than ${maxAccel} mm/s¬≤.`);

            if (!isNumSafe(dataInterval_us) || dataInterval_us < 1)
                throwInternalError("Data interval error", `‚ö†Ô∏è Data interval must be greater than 1 ¬µs.`);


            if (!isArr(loadcellsInfo.loadcellsIDX) || loadcellsInfo.loadcellsIDX.length === 0)
                throwInternalError("Loadcell activation error", `‚ö†Ô∏è At least one loadcell must be activated.`);

            if (!isArr(loadcellsInfo.capacities) || loadcellsInfo.capacities.every(cap => !isNumSafe(cap)))
                throwInternalError("Loadcell activation error", `‚ö†Ô∏è At least one loadcell must be activated with valid capacity.`);
            else if (loadcellsInfo.capacities.some(cap => isNumSafe(cap) && cap < minLoadCap))
                throwInternalError("Loadcell capacity error", `‚ö†Ô∏è Loadcell capacity must be greater than ${minLoadCap} kg.`);

            if (!isArr(loadcellsInfo.outputs) || loadcellsInfo.outputs.every(out => !isNumSafe(out)))
                throwInternalError("Loadcell activation error", `‚ö†Ô∏è At least one loadcell must be activated with valid output.`);
            else if (loadcellsInfo.outputs.some(out => isNumSafe(out) && out < minLoadOut))
                throwInternalError("Loadcell output error", `‚ö†Ô∏è Loadcell output must be greater than ${minLoadOut} mV/V.`);

            if (experimentEvents.doubleSpeed.active === true) {
                if (!isNumSafe(initialSpeed_mmps) || initialSpeed_mmps < minFSpeed)
                    throwInternalError("Initial speed error", `‚ö†Ô∏è Initial speed must be greater than ${minFSpeed} mm/s.`);
                else if (initialSpeed_mmps > maxFSpeed)
                    throwInternalError("Initial speed error", `‚ö†Ô∏è Initial speed must be less than ${maxFSpeed} mm/s.`);
                else if (!isValidInputNum(experimentEvents.doubleSpeed.limit))
                    throwInternalError("Initial force load error", `‚ö†Ô∏è Initial force load must be greater than 0 N.`);
            }

            if (takePhotos) {
                if (!isNumSafe(photoInterval_ms) || photoInterval_ms <= minInt)
                    throwInternalError("Photo interval error", `‚ö†Ô∏è Photo interval must be greater than ${convertUnits(minInt, 'ms', 's')} s.`);

                if (convertUnits(photoInterval_ms, 'ms', 's') < dataInterval_us) {
                    logAndConsoleMessage("‚ö†Ô∏è Photo interval must be bigger than data interval.", {consoleLevel: 'warn'});
                    const newDataInterval = convertUnits(photoInterval_ms, 'ms', 's') * 0.9;
                    await logMessage(`‚ùó Changing data interval from ${dataInterval_us} to ${newDataInterval} ¬µs ‚ùó`);
                    dataInterval_us = newDataInterval;
                    $ID("inputDataInterval").value = dataInterval_us;
                }
            }

            if (experimentType.endsWith("-hbr")) {
                if (!isValidInputNum(stoppingForceLimit))
                    throwInternalError("Stopping force error", `‚ö†Ô∏è Stopping force must be greater than 0 N.`);


                if (stoppingForceLimit <= experimentEvents.doubleSpeed.limit)
                    throwInternalError("Stopping force error", `‚ö†Ô∏è Stopping force must be greater than initial force.`);


                if (!isNumSafe(holdForceTimeMs) || holdForceTimeMs < minInt || convertUnits(holdForceTimeMs, 'ms', 's') < 0)
                    throwInternalError("Hold force time error", `‚ö†Ô∏è Hold force time must be equal or greater than ${convertUnits(minInt, 'ms', 's')} s.`);


                const minDataInterval = 25_000;
                if (dataInterval_us < minDataInterval) {
                    logAndConsoleMessage(`‚ö†Ô∏è Data interval must be at least 30000 ¬µs for hold constant force mode.`, {consoleLevel: 'warn'});
                    await logMessage(`‚ùó Changing data interval from ${dataInterval_us} to ${minDataInterval} ¬µs ‚ùó`);
                    dataInterval_us = minDataInterval;
                    $ID("inputDataInterval").value = minDataInterval;
                }

                const minDataIntervalHold = convertUnits(holdForceTimeMs, 'ms', '¬µs') * 0.05;
                if (minDataIntervalHold < dataInterval_us) {
                    logAndConsoleMessage(`‚ö†Ô∏è Hold force time must be at least 20 times bigger than data interval: holdForceTime=${holdForceTimeMs} ms, dataInterval=${convertUnits(holdForceTimeMs, 'ms', '¬µs')} ms.`, {consoleLevel: 'warn'});
                    await logMessage(`‚ùó Changing data interval from ${dataInterval_us} to ${minDataIntervalHold} ¬µs ‚ùó`);
                    dataInterval_us = minDataIntervalHold;
                    $ID("inputDataInterval").value = minDataIntervalHold;
                }


                if (!isNumSafe(responsiveness.Kp) || responsiveness.Kp <= 0)
                    throwInternalError("Responsiveness coefficient Kp error", `‚ö†Ô∏è Responsiveness coefficient Kp must be equal or greater than 0.`);
                if (!isNumSafe(responsiveness.Ki) || responsiveness.Ki <= 0)
                    throwInternalError("Responsiveness coefficient Ki error", `‚ö†Ô∏è Responsiveness coefficient Ki must be equal or greater than 0.`);
                if (!isNumSafe(responsiveness.minSpeed))
                    throwInternalError("Responsiveness minimum speed error", `‚ö†Ô∏è Responsiveness minimum speed must be a valid number.`);
                if (!isNumSafe(responsiveness.maxSpeed))
                    throwInternalError("Responsiveness maximum speed error", `‚ö†Ô∏è Responsiveness maximum speed must be a valid number.`);
                if (responsiveness.minSpeed >= responsiveness.maxSpeed)
                    throwInternalError("Responsiveness speed error", `‚ö†Ô∏è Responsiveness minimum speed must be less than maximum speed.`);
                if (!isNumSafe(responsiveness.accel) || responsiveness.accel < 1)
                    throwInternalError("Responsiveness acceleration error", `‚ö†Ô∏è Responsiveness acceleration must be equal or greater than 1.`);
            }


            if (isEmptyStr(expControl)) throwInternalError("Experiment control is not set.");
            if (isUndefined(experimentEndLimits[expControl])) throwInternalError(`Experiment end limit for ${expControl} is not set.`);
            if (isUndefined(parsedData[expControl])) throwInternalError(`Parsed data for ${expControl} is not available.`);
            if (!hasRequiredParsedKeys(experimentEndLimits, parsedData)) throwInternalError("Experiment end limits are not properly set.");


            if (!calibrationStatus) {
                // if (confirm("‚ö†Ô∏è Motors are not calibrated. Calibrate the motor?\n\nOK = Calibrate\tCancel = Not Calibrate")) {
                //     let confirmCalibrationCount = 0;
                //
                //     await logMessage("‚ö†Ô∏è Motors are not calibrated. Calibrating the motor...");
                //     console.warn("\n‚ö†Ô∏è Motors are not calibrated. Calibrating the motor...");
                //     await sendCommandGeneral('MC CALIBRATE');
                //     await sleep(5); // Stop for 5 ms
                //
                //
                //     while (!calibrationStatus) {
                //         await sleep(2500);
                //         calibrationStatus = await getCalibrationStatus(500);
                //
                //         // log time
                //         // console.info("üïí Time: ", new Date().toLocaleTimeString());
                //
                //         if (confirmCalibrationCount > 50) {
                //             await logMessage("‚ùå Calibration timeout reached. Please check the motor.\n\tMotors are not calibrated.");
                //             console.error("‚ùå Calibration timeout. Please check the motor.\n\tMotors are not calibrated.");
                //             await sleep(5); // Stop for 5 ms
                //         } else {
                //             confirmCalibrationCount++;
                //         }
                //
                //         if (!isConnected) {
                //             console.warn("\n‚ö†Ô∏è Serial connection lost during calibration.");
                //             await logMessage("‚ö†Ô∏è Serial connection lost during calibration.");
                //             throwInternalError("Serial connection lost during calibration.");
                //         }
                //     }

                // console.info("üìê Machine is calibrated.");
                // await logMessage("üìê Machine is calibrated.\n\tüîÉ Please restart the experiment.");
                // alert("üìê Machine is calibrated.\n\tüîÉ Please restart the experiment.");
                // } else {
                await lockMovementExcept(UI.calibrateBtn);
                logAndConsoleMessage("‚ùå Calibration is required to start the experiment.", {
                    consoleLevel: 'error',
                    showAlert: true
                });
                // }
                throwInternalError("Calibration is required to start the experiment.");
            }
            // =================================
            // =================================

            currentSpeed = (await getSpeed()) || 15;
            currentAcceleration = (await getAcceleration()) || 150;

            await logMessage(`\nüéØ Starting experiment ${takePhotos ? "with photos üì∏" : ""}`);
            await console.info("üß™ Starting experiment...");
            UI.loadingLogContainer.style.background = "black";
            disableCharts({lcCount: loadcellCount});
            await checkDescription({set: true});


            if (getElementValue('inputAutoSave')?.toLowerCase().endsWith('before')) {
                UI.experimentStageLabel.textContent = `Saving`;
                await saveCSV();
            }


            await sleep(5);
            await clearDatabase();
            await clearCharts();
            await chartUpdate(false);
            if (await $ID('inputClearCalculations').checked) await clearCalculations();


            // === Progress Bar Setup ===
            UI.experimentStageLabel.textContent = `Configuring`;
            UI.progressBar.value = 0;
            UI.progressLabel.textContent = `0%`;
            document.documentElement.style.setProperty('--progressColor', 'var(--progressPrimary-color)');

            // === Experiment Parameters ===

            maxDataPoints = maxDataPointsExp;

            // TODO: use 'resetVariables' function !!!!!!!!!!!!!!!!
            // === Reset Variables ===
            tareValues.time = null;
            tareValues.position = null;
            lastAcceptedTime = null;
            maxForces = Array(loadcellCount).fill(null);

            timeData = [];
            positionData = [];
            forceData = Array(catchVal(loadcellCount, 0, isNumSafe)).fill(null).map(() => []);
            measureForces = Array(loadcellCount).fill(null).map(() => []);
            tareValues.force = Array(loadcellCount).fill(0);

            timeDataChart = [];
            positionDataChart = [];
            forceDataChart = Array(loadcellCount).fill(null).map(() => []);
            photoDataChart = [];
            dataCount = 0;


            measurementParts = {
                length: null,
                time: [0],
                position: [1],
                speed: [2],
                force: [3, 4, 5],
            }; // TODO: adjust if needed by type of experiments, loadcells, etc.

            measurementParts.length = getMeasurementPartsLength(measurementParts);

            dataChartInterval = calculateStep(dataInterval_us, 150, 1);
            const minimumConditionCount = calculateStep(dataInterval_us, 50, 3);

            aggregatedDataBetweenSteps = [];
            dataCount = 0;

            Object.values(measurement_limits).forEach(v => {
                v.counter = 0;
                v.limit = minimumConditionCount;
            });
            measurement_limits.over_limitForce.limit = calculateStep(dataInterval_us, 10, 2);

            if (doCycles) {
                experimentEndLimits = {position: null, force: null, time: null};
                measurement_limits.zero_speed.limit = calculateStep(dataInterval_us, 5_000, 2);
            }

            // === LoadCell Configuration ===
            for (let i = 0; i < loadcellCount; i++) {
                if (isNull(loadcellsInfo.capacities[i]) || isNull(loadcellsInfo.outputs[i])) continue;
                await sendCommandGeneral(`LC SET CAP ${i} ${loadcellsInfo.capacities[i]}`);
                await sendCommandGeneral(`LC SET RO ${i} ${loadcellsInfo.outputs[i]}`);
            }

            // === Prepare Machine ===
            await sendStopAllMeasuring();
            if (takePhotos) await sendCommandGeneral('DSLR RESET COUNTERS');

            await setSpeedAndAcceleration(initialSpeed_mmps, initialAccelForward_mmps2, false);

            // === Prepare Data Collection ===
            tareValues.position = await measurePosition();
            UI.returnBtn.textContent = `‚Ü©Ô∏è Return to start position: ${tareValues.position} mm`;

            loadSignCorrections = Array(loadcellCount).fill(displacementSignCorrection * -1);
            for (let i = 0; i < loadcellCount; i++) {
                if (loadcellsInfo.capacities[i] <= 50) loadSignCorrections[i] *= -1; // Reverse direction if loadcell capacity is less than or equal to 50 N
            }


            UI.experimentStageLabel.textContent = `Tarring`;

            await sendCommandGeneral(`DATA SET INTERVAL ${Math.ceil(2_500)}`);

            for (let i = 0; i < loadcellCount; i++) {
                await sendCommandGeneral(`LC TARE ${i}`);
            }

            await sleep(2_000); // Wait for 2 second between taring loadcells

            // --- 1) Take measurements ---
            takeMeasurements = true;
            await sendCommandGeneral("DATAC 1");


            // Take measurements for 1.5 second
            await sleep(1_500); // Wait


            await sendCommandGeneral("DATAC 0", 10);
            takeMeasurements = false;


            UI.experimentStageLabel.textContent = `Analyzing`;

            // --- 2) Analysis ---
            const forceAnalysis = await analyzeForces(measureForces);  // TODO: Implement and save present/used loadcells to the experiment log and use it when loading form DB and when loading CSV
            console.info("Force analysis:");
            console.table(forceAnalysis);

            // --- 3) Mean forces ---
            tareValues.force = forceAnalysis.map(r => roundDecimalFast(r.mean, precisionForce));

            // --- 4) Valid fields ---
            const validFields = await forceAnalysis.filter(r => !r.allInvalid);

            // indexes of valid fields => present Loadcells indexes
            const presentLC = forceAnalysis.flatMap((r, i) => r.allInvalid ? [] : i);

            if (!isLCComplex) {
                loadcellsInfo.presentLoadcells = forceAnalysis.map(r => !r.allInvalid);
                loadcellsInfo.loadcellsIDX = presentLC;
            }

            // --- 5) Check for errors ---
            // If more one force is not eaqule to zero, than Stop and Alert
            if (!experimentType.endsWith("-basic"))
                if (validFields.length > 1 || (isLCComplex && loadcellsInfo.loadcellsIDX.length > 1))
                    throwInternalError("Multiple loadcells connected", "‚ö†Ô∏è Multiple loadcells are connected. Please check the loadcell connections and connect only one loadcell.");

            if (validFields.length === 0 || (isLCComplex && loadcellsInfo.loadcellsIDX.length === 0))
                throwInternalError("No loadcell connected", "‚ö†Ô∏è No loadcell is connected. Please check the loadcell connection and try again.");

            if (isLCComplex)
                if (!loadcellsInfo.loadcellsIDX.every(lc => presentLC.includes(lc)))
                    throwInternalError("Not all selected loadcells are connected", "‚ö†Ô∏è Not all selected loadcells are connected. Please check the loadcell connections and try again.");


            // for (let attempt = 1; attempt <= 3; attempt++) {
            //     try {
            //         loadcellsInfo.presentLoadcells = (await isLoadcellsPresent(2000)) || [];
            //         if (loadcellsInfo.presentLoadcells.some(p => p === true)) break; // At least one loadcell is present
            //     } catch (e) {
            //         console.warn("‚ö†Ô∏è Warning: Could not determine loadcell presence, attempt", attempt, "of 3.");
            //     }
            //     if (attempt === 3) {
            //         await logMessage("‚ùå No loadcells detected. Please check the connection.");
            //         console.error("‚ùå No loadcells detected. Please check the connection.");
            //         alert("‚ùå No loadcells detected. Please check the connection.");
            //         throwInternalError("No loadcells detected. Please check the connection.");
            //     }
            //     await sleep(500); // Wait before retrying
            // }


            const setChart = (chart) => {
                if (isVoid(chart)) return;
                loadcellsInfo.presentLoadcells?.forEach((r, i) => chart.setSeries((i + 1), {show: r}));
                chart.setSeries((loadcellCount + 1), {show: takePhotos});
            };
            setChart(timeChart);
            setChart(positionChart);

            // --- 6) Valid dispersion ---
            const diffs = validFields.flatMap(({
                                                   min, max
                                               }) => (isNumSafe(min) && isNumSafe(max)) ? [max - min] : []);
            console.info("\nValid dispersions:", diffs);

            // --- 7) Error rates ---
            for (let i = 0; i < loadcellCount; i++) {
                measurementErrRate[i] = await roundDecimalFast(diffs[i], precisionForce);
                console.info(`\n\t\tLC ${i}: üé∞ Measurement error rate:`, measurementErrRate[i], "N");


                loadcellErrRate[i] = (loadcellsInfo.capacities[i] * 9.81) / 2_000; // 0.05% of the capacity
                console.info(`\n\t\tLC ${i}: üé∞ Loadcell error rate:`, loadcellErrRate[i], "N");

                // --- 8) Final error rate ---
                const alpha = 0.65; // Weighting factor between measurement and loadcell error rates
                totalErrRate[i] = alpha * measurementErrRate[i] + (1 - alpha) * loadcellErrRate[i];
                console.info(`\n\tLC ${i}: üé≤ Final error rate:`, totalErrRate[i], "N");
                await logMessage(`\tLC ${i}: üé≤ Set error rate: ${totalErrRate[i]} N`);
            }

            const err = mean1D(totalErrRate); // TODO: dle sledovan√Ωch sil


            UI.experimentStageLabel.textContent = `Starting`;

            // === Create PI Controller ===
            if (experimentType.endsWith("-hbr")) {
                pi = createPIController({
                    //      Target force
                    setForceN: roundDecimalFast(stoppingForceLimit, precisionForce),
                    //      Proportional gain                           (default: 0.200)
                    Kp: roundDecimalFast(0.0200 * responsiveness.Kp, 6),
                    //      Integral gain                               (default: 0.030)
                    Ki: roundDecimalFast(0.0030 * responsiveness.Ki, 6),
                    //      Deadband set to 115% of total error rate
                    deadbandN: roundDecimalFast(err * 1.15, precisionForce),
                    //      Minimum speed during holding
                    vMin: roundDecimalFast(responsiveness.minSpeed, 6),
                    //      Limit max speed during holding e.g. to 250% of min speed or 80% of forward speed but not exceeding forward speed
                    vMax: roundDecimalFast(responsiveness.maxSpeed, 6),
                    //      Slew-rate limit to 5 mm/s¬≤ (null => no limit)
                    accel: roundDecimalFast(responsiveness.accel, 3),
                    //      Anti-windup clamp: readings in the last 25% of hold time
                    integLimit: computeFrenchingMs(dataInterval_us, holdForceTimeMs * 0.25, 125),
                    //      Precision of calculations
                    roundDigits: (precisionSpeedSystem + 2),
                });
            }


            // ==================================
            // === Reset Experiment Variables ===

            checkSpeed = true; // TODO: reset if needed
            timer = null;
            endedBy = null;
            pendingDSLR = null;
            parsedData = {
                time: 0,
                position: 0,
                speed: 0,
                force: loadcellsInfo.presentLoadcells.map(value => value ? 0 : null),
                photoIndex: takePhotos ? 0 : null // Store DSLR photo order
            };

            experimentProgress = 0
            tareValues.time = null;
            lastAcceptedTime = null;
            isExperimentRunning = true;
            endMeasurement = false;
            clearTimeout(endMeasurementCounter)
            endMeasurementCounter = null;

            timeData = [];
            positionData = [];
            forceData = Array(catchVal(loadCellNum, 0, isNumSafe)).fill(null).map(() => []);
            measureForces = Array(loadcellCount).fill(null).map(() => []);

            timeDataChart = [];
            positionDataChart = [];
            forceDataChart = Array(loadcellCount).fill(null).map(() => []);
            photoDataChart = [];
            dataCount = 0;

            await clearCharts();

            const settings = await collectExpSettings(".expInput", "Moira-exp-settings") || {};

            const expInfoV = settings?.version;
            let experimentKey = null;
            if (expInfoV === 1) {
                experimentKey = settings?.inputs["experimentTypeDropdown"]?.extra?.essence;
            }
            const experimentLabel = catchVal(expTypesLabels[experimentKey], "", isOk);

            await addDataToLog({
                status: "initialized",
                expSettings: settings,
                experimentName: getElementValue("experimentName"),
                experimentLabel: experimentLabel?.trim(),
                experimentCounter: getElementValue("experimentCount"),
                experimentDescription: getElementValue("experimentDesc"),
                experimentDate: (new Date().toLocaleString())?.replaceAll(". ", "."),
                loadDirection: doCycles ? 0 : displacementSignCorrection,
                loadDistance: distance_mm,
                loadSpeed: speedForward_mmps,
                loadcellsInfo: structuredClone(loadcellsInfo),
                loadcellsAnalysis: forceAnalysis,
                loadcellType: 'Undefined',
                appSoftWare: softwareVersion,
                machineFirmware: machineFirmware,
                // TODO: machineFirmwares: structuredClone(machineFirmwares),
                endStatus: endedBy,
                experimentProgress: experimentProgress,
                precisions: {
                    time: precisionTime,
                    position: precisionPosition,
                    speed: precisionSpeed,
                    acceleration: precisionAcceleration,
                    force: precisionForce,
                },
                experimentLimits: structuredClone(experimentEndLimits),
                experimentEvents: structuredClone(experimentEvents),
                experimentControl: expControl,
            }, 0);


            await addDataToLog(parsedData);
            await updateChart(parsedData);

            UIupdate();
            await chartUpdate(true);

            if (experimentEvents.doubleSpeed.active === true) UI.experimentStageLabel.textContent = `Initial`;
            else UI.experimentStageLabel.textContent = doCycles ? `Cycling` : `Loading`;

            // ==================================
            // ==================================


            if (takePhotos) await sendCommandGeneral('DSLR SHOOT', 500); // Initial photo

            await updateLogById(0, {status: "collecting"});

            // === Enable Data Streaming and DSLR Shooting ===
            await sendCommandGeneral(`DATA SET INTERVAL ${Math.ceil(dataInterval_us)}`, 5); // Set data interval
            if (takePhotos) await sendCommandGeneral(`DSLR START CYCLIC ${photoInterval_ms}`); // Start cyclic shooting
            await sendCommandGeneral("DATAC 1"); // Start data collection

            // === Move Forward ===
            await sendCommandGeneral(`MC MOVEBY MACH ${distance_mm * displacementSignCorrection}`);
            console.info("‚û°Ô∏è Moving forward...");

            if (doCycles) {
                const oneBigInt = toBigInt(1);

                let cycle = oneBigInt;
                const isInfinite = isInfinity(cyclesCount);
                const totCyclesLabel = isInfinite ? "‚àû" : cyclesCount;
                const movementIntervalMs = convertUnits(computeMotionTime(distance_mm, speedForward_mmps, initialAccelForward_mmps2), 's', 'ms') + 5; // TODO: modify with Performance.now() and not Intervals

                const oneCycleSeconds = roundDecimalFast(distance_mm / speedForward_mmps, 2);

                let cycleTextPending = false;

                let movementTimer = null;
                let minuteLogger = null;
                let hourlyClear = null;

                const stopAllCycles = () => {
                    if (movementTimer) {
                        clearInterval(movementTimer);
                        movementTimer = null;
                    }
                    if (minuteLogger) {
                        clearInterval(minuteLogger);
                        minuteLogger = null;
                    }
                    if (hourlyClear) {
                        clearInterval(hourlyClear);
                        hourlyClear = null;
                    }
                };

                // extra ƒçasovaƒçe jen pro nekoneƒçn√Ω re≈æim
                if (isInfinite) {
                    // log ka≈ædou minutu
                    minuteLogger = setInterval(async () => {
                        cycleTextPending = true;
                    }, convertUnits(1, 'min', 'ms'));

                    // ƒçistit konzoli ka≈ædou hodinu
                    hourlyClear = setInterval(async () => console.clear(), convertUnits(1, 'h', 'ms'));
                }

                movementTimer = setInterval(async () => {
                    // ukonƒçovac√≠ podm√≠nky
                    const noMoreFiniteCycles = !isInfinite && cyclesCount <= 0;
                    if (!isExperimentRunning || !doCycles || !isNumberOrInfinity(cyclesCount) || noMoreFiniteCycles) {
                        stopAllCycles();

                        endMeasuring(Math.max(Math.floor(delayMsAfterEndMeasurement / 3), 10),
                            {
                                ednStatus: noMoreFiniteCycles ? `cycles completed (${totCyclesLabel})` : `cycling interrupted (${cycle.toString()}/${totCyclesLabel})`,
                                endText: `‚èπÔ∏è Experiment stopped after ${cycle.toString()} out of ${totCyclesLabel} cycles.`,
                                immediateText: `Experiment cycling stopped.`,
                            });
                        UI.experimentStageLabel.textContent = noMoreFiniteCycles ? `Completed` : `Stopped`;
                        document.documentElement.style.setProperty('--progressColor',
                            noMoreFiniteCycles ? 'var(--progressDone-color)' : 'var(--progressError-color)');

                        return;
                    }

                    displacementSignCorrection *= -1;
                    await sendCommandGeneral(`MC MOVEBY MACH ${distance_mm * displacementSignCorrection}`);

                    // u koneƒçn√©ho re≈æimu dekrementuj, u ‚àû nesahej na cyclesCount
                    if (!isInfinite) cyclesCount--;
                    cycle += oneBigInt;

                    // loguj po ka≈æd√©m kroku jen u koneƒçn√©ho re≈æimu (‚àû ≈ôe≈°√≠ minuteLogger)
                    if (!isInfinite) {
                        console.info(
                            `%c\nüîÉ Starting cycle [${cycle.toString()} / ${totCyclesLabel}].\n\tRemaining cycles: ${cyclesCount}\n\t\tOne cycle time: ~${oneCycleSeconds} s.`,
                            'color: red; font-style: italic;'
                        );
                    } else if (cycleTextPending) {
                        console.info(
                            `%c\nüîÉ Running (‚àû). Current cycle: ${cycle.toString()} / ${totCyclesLabel}\n\t\tOne cycle time: ~${oneCycleSeconds} s.`,
                            'color: blue; font-style: italic;'
                        );
                        cycleTextPending = false;
                    }

                }, movementIntervalMs);
            }


            // === Data Collection Loop ===
            while (isExperimentRunning) {
                await sleep(1_000); // Prevents excessive CPU usage
            }

            isExperimentRunning = false;

            // === Stop Data Streaming and DSLR Shooting ===
            await sendStopAllMeasuring();

            await logAndConsoleMessage("üé¨ Measurements stopped.");

            await updateLogById(0, {experimentProgress: experimentProgress, status: "collected"});


            if (experimentType.endsWith("-inb")) {
                // // === Move Further ===
                // // TODO: Make sure, that it will not break sample (window to user to accept)
                // if (UI.autoReturnPosition.checked) {
                //     await sleep(2000); // Stop for 2 s
                //
                //     let endPosition = await measurePosition();
                //
                //     const shift = Math.abs(100);
                //
                //     console.info(`‚û°Ô∏è Moving further to ${endPosition - shift} mm...`);
                //
                //     await sendCommandGeneral(`MC MOVEBY MACH -${shift}`);
                //     await sleep(convertUnits(computeMotionTime(shift, returningSpeed, returningAcceleration), 's', 'ms') + 500); // Wait
                //
                //     endPosition = await measurePosition();
                //
                //     console.info(`üö© Reached position: ${endPosition} mm`);
                // }
            } else {
                // === Move Back ===
                if (UI.autoReturnPosition.checked) {
                    UI.experimentStageLabel.textContent = `Returning`;
                    await moveToOriginalPosition({getCurrent: false, overRide: true});
                }
            }

            UI.experimentStageLabel.textContent = `Finalizing`;

            await console.info("\n‚òëÔ∏è Experiment finished.");
            if (isDef(endedBy) && (endedBy === 'end position' || endedBy === 'cycles completed')) {
                await showNotification("Experiment Finished",
                    "The experiment has been completed successfully.");
            } else {
                await showNotification("Experiment Finished",
                    `The experiment was stopped before completion. Status: ${endedBy || "unknown"}.`);
            }


        } catch
            (error) {

            if (internalError) {
                await disableCharts();
                await clearCharts();
                await chartUpdate(false);

                timeData = [];
                positionData = [];
                forceData = Array(catchVal(loadCellNum, 0, isNumSafe)).fill(null).map(() => []);

                timeDataChart = [];
                positionDataChart = [];
                forceDataChart = Array(loadCellNum).fill(null).map(() => []);
                photoDataChart = [];
                dataCount = 0;
            } else {
                await updateLogById(0, {status: "error"});
            }


            await handleError(error, "Experiment");
            await showNotification("Experiment Interrupted",
                "An error occurred during the experiment. Please check the logs and machine.");
            document.documentElement.style.setProperty('--progressColor', 'var(--progressError-color)');
            UI.experimentStageLabel.textContent = `Error`;
            endedBy = internalError ? 'wrong exp variables' : 'error';
            await alert(`Experiment Finished\n     ‚ùå Experiment failed. Please check the logs and machine.\n\n     Error: ${error.message || error}`);

        } finally {
            await endMeasuring(0, {endText: '‚ôªÔ∏è Experiment finalizing...'});


            for (let i = 0; i < loadCellNumMax; i++) {
                await sendCommandGeneral(`LC TARE RESET ${i}`);
            }

            await sleep(100);

            if (isDef(endedBy)) await updateLogById(0, {endStatus: endedBy});
            await updateLogById(0, {experimentProgress: experimentProgress});

            document.title = initialTitle;
            maxDataPoints = maxDataPointsExpShow;

            await sleep(400);

            clearTimeout(dbFlushTimer);
            dbFlushTimer = null;
            await flushDB();

            await recomputeAllCalculations();

            await updateLogById(0, {status: "finalized"});

            // === Save Data ===
            if (getElementValue('inputAutoSave')?.toLowerCase().endsWith('after')) {
                if (!internalError) {
                    UI.experimentStageLabel.textContent = `Saving`;
                    await saveCSV();
                }
            }

            await reloadCharts();

            endedMoving();    // unlock UI and watchdog
            unlockMovement();

            await chartUpdate();

            await console.info(`\n‚úÖ Experiment completed.\n\t\tExperiment Status: ${endedBy || "completed"}\n`);

            await console.groupEnd();

            UI.experimentStageLabel.textContent = `Idle`;
        }
    }

    async function sendStopAllMeasuring() {
        await sendCommandGeneral("MC STOP"); // Stop movement
        await sendCommandGeneral("DSLR STOP CYCLIC"); // Stop DSLR cyclic
        await sendCommandGeneral("DATAC 0"); // Stop data collection
    }


    async function endMeasuring(timeoutMs = 0, {

        overRide = false,
        ednStatus = '',
        endText = '‚õî Experiment stopped.',
        immediateText = '',
        command = ''

    } = {}) {


        if (!overRide) {
            if (!isExperimentRunning || endMeasurement) return;
        }
        endMeasurement = true;

        const delayFixMs = 5; // fix for setTimeout delays

        if (endMeasurementCounter) {
            clearTimeout(endMeasurementCounter);
            endMeasurementCounter = null;
        }

        if (!isNumSafe(timeoutMs)) timeoutMs = 0;

        if (isNonEmptyStr(command)) await sendCommandGeneral(command);

        if (isNonEmptyStr(immediateText)) logAndConsoleMessage(immediateText);


        const totDelayMs = Math.max(0, timeoutMs - delayFixMs);


        logAndConsoleMessage(`üïê Ending in ${totDelayMs} miliseconds...`);


        endMeasurementCounter = setTimeout(async () => {
            if (isNonEmptyStr(endText)) logAndConsoleMessage(endText);

            if (isConnected) await sendStopAllMeasuring();


            isExperimentRunning = false;
            dataCount = null;
            dataChartInterval = 1;

            UI.loadingLogContainer.style.background = "#323232";

            if (aggregatedDataBetweenSteps.length > 0) {
                console.info("\nüëÅÔ∏è‚Äçüó®Ô∏è Data not sent to chart.", aggregatedDataBetweenSteps.length);
                await updateChart(calculateAverageParsedData(aggregatedDataBetweenSteps));
            }

            // progress UI
            if (experimentProgress >= 99.990) {
                experimentProgress = 100;
                document.documentElement.style.setProperty('--progressColor', 'var(--progressDone-color)');
                UI.experimentStageLabel.textContent = `Finished`;
                UI.progressBar.value = 100;
                UI.progressLabel.textContent = `100%`;
                document.title = `ŒúŒø·øñœÅŒ±‚Äá-‚ÄáExperiment done (100%)`;
                if (debugging) console.info("‚úÖ Experiment done üíØ");
            }

            aggregatedDataBetweenSteps = [];

            // const lastData = await calculateAverageParsedData(aggregatedDataBetweenSteps);
            // console.warn(lastData);
            // aggregatedDataBetweenSteps.forEach(data => {
            //     updateChart(data);
            // });

            clearTimeout(endMeasurementCounter);
            endMeasurementCounter = null;

            if (ednStatus) endedBy = ednStatus;
        }, totDelayMs);
    }

</script>

<script>

    async function UIupdate() {
        lastTitle = document.title;

        while (isExperimentRunning) {

            let progressNumber, progressLabel, progressTitle;

            if (!isNumSafe(experimentProgress)) {
                progressNumber = 0;
                progressLabel = 'N/A';
                progressTitle = 'Unknown';
            } else {
                progressNumber = experimentProgress;
                progressLabel = `${experimentProgress.toFixed(2)}%`; // .padStart(5, "0")
                progressTitle = `${Math.floor(experimentProgress)}%`;
            }

            UI.progressBar.value = progressNumber;
            UI.progressLabel.innerText = progressLabel;
            const newTitle = `ŒúŒø·øñœÅŒ±‚Äá-‚Äá${progressTitle}`;
            if (lastTitle !== newTitle) {
                document.title = newTitle;
                lastTitle = newTitle;
            }

            if (experimentProgress >= 100) break;

            // wait for 50 ms => 20FPS
            await sleep(50);
        }
    }

</script>

<script>
    // -------------------------
    // Fronta ƒçekaj√≠c√≠ch po≈æadavk≈Ø
    // -------------------------

    let _reqId = 0;
    /** Pomocn√°: odstran√≠ po≈æadavek z fronty podle id */
    const _pending = /** @type {PendingReq[]} */([]);

    /** @typedef {{
     *   id: number,
     *   regex: RegExp,
     *   valueIndex: number,
     *   resolve: (v:any)=>void,
     *   timeoutId: ReturnType<typeof setTimeout>
     * }} PendingReq
     */
    function _removePending(id) {
        const idx = _pending.findIndex(p => p.id === id);
        if (idx !== -1) _pending.splice(idx, 1);
    }

    /** P≈ôid√° po≈æadavek do fronty a nastav√≠ timeout */
    function _enqueue(format, valueIndex, timeoutMs) {
        const regex = (format instanceof RegExp)
            // zajist√≠me "global" a "m" pro p≈ô√≠pad v√≠ce ≈ô√°dk≈Ø; zachov√°me i p≈Øvodn√≠ flagy:
            ? new RegExp(format.source, new Set((format.flags + "gm").split(""))
                .size ? Array.from(new Set((format.flags + "gm").split(""))).join("") : "gm")
            : new RegExp(String(format), "gm");

        const id = ++_reqId;

        let resolveRef;
        const p = new Promise((resolve) => {
            resolveRef = resolve;
        });

        // timeout: po vypr≈°en√≠ odstran√≠me z fronty a resolve(null)
        const timeoutId = setTimeout(() => {
            _removePending(id);
            resolveRef(null);
        }, Math.max(0, timeoutMs || 0));

        /** @type {PendingReq} */
        const entry = {id, regex, valueIndex, resolve: resolveRef, timeoutId};
        _pending.push(entry);

        return {id, promise: p};
    }

    /** Zpracuje jednu p≈ô√≠choz√≠ zpr√°vu: zkus√≠ ji sp√°rovat s frontou.
     *  Vrac√≠ true, pokud zpr√°va byla spot≈ôebovan√° (sp√°rovala se s nƒõkter√Ωm po≈æadavkem).
     */
    function _tryMatchAndResolve(msg) {
        // Pozn√°mka: zpr√°vu m√°me porovnat ‚Äûse v≈°√≠m ve frontƒõ‚Äú, ale jakmile JEDEN souhlas√≠,
        // zpr√°vu u≈æ d√°l neporovn√°v√°me.
        for (let i = 0; i < _pending.length; i++) {
            const req = _pending[i];

            // reset lastIndex because of the 'g' flag
            req.regex.lastIndex = 0;
            const match = req.regex.exec(msg);
            if (match) {
                clearTimeout(req.timeoutId);
                _pending.splice(i, 1); // delete from pending
                const val = match[req.valueIndex];
                req.resolve(val);
                return true; // do not process further
            }
        }
        return false;
    }


    function cancelAllPending() {
        while (_pending.length) {
            const p = _pending.pop();
            clearTimeout(p.timeoutId);
            p.resolve(null);
        }
    }


    function waitForFormat(format, valueIndex, timeout = 5_000) {
        const {promise} = _enqueue(format, valueIndex, timeout);
        return promise;
    }


    /**
     * Sends a command and waits for a value extracted from the first message
     * that matches the given format (regex). If nothing is received within
     * `timeout` ms, it returns `null`.
     *
     * @param {string} command - command to send
     * @param {RegExp|string} format - regex or string pattern
     * @param {number} valueIndex - index from match field (0 = whole match, 1.. = capture groups)
     * @param {number} [timeout=5000]
     * @returns {Promise<any|null>}
     */
    async function getPromisedValue(command, format, valueIndex, timeout = 5_000) {
        // 1) First, set up the expected data format and create a promise to wait for it
        const p = waitForFormat(format, valueIndex, timeout);

        // 2) Then, send the command to request the data
        await sendCommandGeneral(command);

        // 3)
        return p;
    }


    // === Firmware version ===
    async function getFirmwareVersion(timeOut = 2_000) {
        if (!isConnected) {
            logAndConsoleMessage("‚ö†Ô∏è ESP is not connected!", {consoleLevel: 'warn'});
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet firmware version...");
            const version = await getPromisedValue("MISC GET LIBINFO", /Firmware:\s*([^,]+)/, 1, timeOut);

            if (!version) {
                throw new Error(`Version is empty: ${version}`);
            }
            console.info(`\n\tüì¶ Firmware version: ${version}`);
            return version;
        } catch (error) {
            console.error(error.message);
            throw new Error(`Firmware version not received. ${error}`);
        }
    }

    async function getFirmwaresVersions(timeOut = 2_000) {
        if (!isConnected) {
            logAndConsoleMessage("‚ö†Ô∏è ESP is not connected!", {consoleLevel: 'warn'});
            return;
        }
        // TODO: doplnit dal≈°√≠ moduly
        const tags = ['MOTOR', 'LOADCELL', 'POWER', 'MOTION', 'DSLR', 'FAN', 'EXP', 'MEMORY', 'REPORT', 'COMMAND']; // list of firmware tags
        const versions = {};
        try {
            for (const t of tags) {
                if (debugging) logMessage(` üì¢\tGet ${t} firmware version...`);
                let version = await getPromisedValue(`MISC GET LIBINFO ${t}`, /Firmware:\s*([^,]+)/, 1, timeOut);

                version = version || null;

                console.info(`\n\t\tüß© ${t} Firmware version: ${version}`);
                versions[t.toLowerCase()] = version;
            }
            return versions;
        } catch (error) {
            console.error(error.message);
            throw new Error(`Firmware version not received. ${error}`);
        }
    }


    async function getMachineName(timeOut = 2_000) {
        try {
            if (debugging) logMessage(" üì¢\tGet machine name...");
            const name = await getPromisedValue("MISC GET NAME", /Machine Name:\s*(.+)/, 1, timeOut);

            if (!name) {
                throw new Error(`Name is empty: ${name}`);
            }
            console.info(`\n\tüè∑Ô∏è Machine name: ${name}`);
            return name;
        } catch (error) {
            console.error(error.message);
            throw new Error(`Machine name not received. ${error}`);
        }
    }

    async function getMachineID(timeOut = 2_000) {
        try {
            if (debugging) logMessage(" üì¢\tGet machine ID...");
            const id = toNumber(await getPromisedValue("MISC GET MACHINE_ID", /Machine ID:\s*(.+)/, 1, timeOut), true);

            if (!isNumSafe(id)) {
                throw new Error(`ID is not a number: ${id}`);
            }
            console.info("\n\tüÜî Machine ID:", id);
            return id;
        } catch (error) {
            console.error(error.message);
            throw new Error(`Machine ID not received. ${error}`);
        }
    }

    // === Measure Position ===
    async function measurePosition(timeOut = 2_000) {
        if (!isConnected) {
            logAndConsoleMessage("‚ö†Ô∏è ESP is not connected!", {consoleLevel: 'warn'});
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet position...");
            const position = toNumber(await getPromisedValue("MC GET POS", /^Motor position:\s(-?\d+(\.\d+)?)\smm$/, 1, timeOut), true);
            // const position = parseFloat(await getPromisedValue("MC GET POS", /S0:([+-]?\d+\.\d{4})/, 1, timeOut));

            if (!isNumSafe(position)) {
                throw new Error(`Position is not a number: ${position}`);
            }
            console.info("\tüìå Current position:", position, "mm");
            return roundDecimalFast(position, precisionPosition);
        } catch (error) {
            console.error(error.message);
            throw new Error(`Position not received. ${error}`);
        }
    }

    // === Measure Position ===
    async function readLoadcell(loadcellID, timeOut = 2_000) {
        if (!isConnected) {
            logAndConsoleMessage("‚ö†Ô∏è ESP is not connected!", {consoleLevel: 'warn'});
            return;
        }
        const ldID = toInteger(loadcellID);
        try {
            if (debugging) logMessage(` üì¢\tGet Loadcell ${ldID} reading...`);

            if (!isNumSafe(loadCellNum)) throw new Error(`Total Loadcell count is not defined: ${loadCellNum}`);
            if (!isNumSafe(ldID) || (ldID < 0 || ldID > (loadCellNum - 1))) throw new Error(`Loadcell ID must be between 0 and ${loadCellNum - 1}: ${ldID} given.`);

            const force = toNumber(await getPromisedValue(`LC READ ${ldID}`, /.../, 1, timeOut), true);

            if (!isNumSafe(force)) {
                throw new Error(`Load on Loadcell${ldID} is not a number: ${force}`);
            }
            return roundDecimalFast(force, precisionForce);
        } catch (error) {
            console.error(error.message);
            throw new Error(`Load on Loadcell${ldID} not received. ${error}`);
        }
    }

    async function readLoadcells(timeOut = 2_000) {
        if (!isConnected) {
            logAndConsoleMessage("‚ö†Ô∏è ESP is not connected!", {consoleLevel: 'warn'});
            return;
        }
        const forces = [];
        try {
            if (debugging) logMessage(" üì¢\tGet Loadcells readings...");

            if (!isNumSafe(loadCellNum)) throw new Error(`Total Loadcell count is not defined: ${loadCellNum}`);
            for (let i = 0; i < loadCellNum; i++) {
                const force = await readLoadcell(i, timeOut);
                forces.push(force);
            }
            return forces;
        } catch (error) {
            console.error(error.message);
            throw new Error(`Load on Loadcells not received. ${error}`);
        }
    }

    async function isLoadcellPresent(loadcellID, timeOut = 2_000) {
        if (!isConnected) {
            logAndConsoleMessage("‚ö†Ô∏è ESP is not connected!", {consoleLevel: 'warn'});
            return;
        }
        try {
            const ldID = toInteger(loadcellID);
            if (debugging) logMessage(` üì¢\tCheck Loadcell ${ldID} presence...`);

            if (!isNumSafe(loadCellNum)) throw new Error(`Total Loadcell count is not defined: ${loadCellNum}`);
            if (!isNumSafe(ldID) || (ldID < 0 || ldID > (loadCellNum - 1))) throw new Error(`Loadcell ID must be between 0 and ${loadCellNum - 1}: ${ldID} given.`);

            const force = await getPromisedValue(`LC READ ${ldID}`, /.../, 1, timeOut);

            if (!(!isVal(force) || force === '0' || force === '-0')) {
                return true;
            }

            return false;
        } catch (error) {
            console.error(error.message);
            throw new Error(`Load on Loadcells not received ${error}`);
        }
    }

    async function isLoadcellsPresent(timeOut = 2_000) {
        if (!isConnected) {
            logAndConsoleMessage("‚ö†Ô∏è ESP is not connected!", {consoleLevel: 'warn'});
            return;
        }
        const isPresent = [];
        try {
            if (debugging) logMessage(" üì¢\tCheck Loadcells presence...");

            if (!isNumSafe(loadCellNum)) throw new Error(`Total Loadcell count is not defined: ${loadCellNum}`);
            for (let i = 0; i < loadCellNum; i++) {
                const presence = await isLoadcellPresent(i, timeOut);
                isPresent.push(presence);
            }
            return isPresent;
        } catch (error) {
            console.error(error.message);
            throw new Error(`Load on Loadcells not received ${error}`);
        }
    }

    async function getCalibrationStatus(timeOut = 2_000) {
        if (!isConnected) {
            logAndConsoleMessage("‚ö†Ô∏è ESP is not connected!", {consoleLevel: 'warn'});
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet calibration status...");

            return await getPromisedValue("MC GET ISCALIBRATED", /^Motors calibrated:\s(Yes|No)$/, 1, timeOut) === "Yes";
            // return await getPromisedValue("MC GET ISCALIBRATED", /S0:([01])/, 1, timeOut) === "1";
        } catch (error) {
            console.error(error.message);
            throw new Error(`Calibration status not received. ${error}`);
        }
    }

    async function getSpeed(timeOut = 2_000) {
        if (!isConnected) {
            logAndConsoleMessage("‚ö†Ô∏è ESP is not connected!", {consoleLevel: 'warn'});
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet speed...");

            const speed = toNumber(await getPromisedValue("MC GET SPEED", /Motor speed:\s(-?\d+(\.\d+)?)\smm\/s/, 1, timeOut), true);
            // const speed = parseFloat(await getPromisedValue("MC GET SPEED", /S0:([+-]?\d+\.\d{4})/, 1, timeOut));
            if (!isNumSafe(speed)) {
                throw new Error(`Speed is not a number: ${speed}`);
            }
            console.info("\n\tüöÖ Current speed:", speed, "mm/s");

            return roundDecimalFast(speed, precisionSpeed);
        } catch (error) {
            console.error(error.message);
            throw new Error(`Speed not received. ${error}`);
        }
    }


    async function getAcceleration(timeOut = 2_000) {
        if (!isConnected) {
            logAndConsoleMessage("‚ö†Ô∏è ESP is not connected!", {consoleLevel: 'warn'});
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet acceleration...");

            const acceleration = toNumber(await getPromisedValue("MC GET ACCEl", /Motor acceleration:\s(-?\d+(\.\d+)?)\smm\/s\^2/, 1, timeOut), true);
            // const acceleration = parseFloat(await getPromisedValue("MC GET ACCEl", /S0:([+-]?\d+\.\d{4})/, 1, timeOut));
            if (!isNumSafe(acceleration)) {
                throw new Error(`Acceleration is not a number: ${acceleration}`);
            }
            console.info("\n\tüöù Current acceleration:", acceleration, "mm/s¬≤");

            return roundDecimalFast(acceleration, precisionAcceleration);
        } catch (error) {
            console.error(error.message);
            throw new Error(`Acceleration not received. ${error}`);
        }
    }

    async function isMoving(timeOut = 100) {
        if (!isConnected) {
            logAndConsoleMessage("‚ö†Ô∏è ESP is not connected!", {consoleLevel: 'warn'});
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet moving status...");

            return await getPromisedValue("MC GET RUNNING", /Motor running:\s[01]/, 1, timeOut) === "1";
            // return await getPromisedValue("MC GET RUNNING", /S0:([01])/, 1, timeOut) === "1";
        } catch (error) {
            console.error(error.message);
            throw new Error(`Moving status not received. ${error}`);
        }
    }

    async function rebootDevice(delayMs = 1_000) {
        if (!isConnected) {
            logAndConsoleMessage("‚ö†Ô∏è ESP is not connected!", {consoleLevel: 'warn'});
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tRebooting device...");

            await sendCommandGeneral("MISC REBOOT");

            console.info("\n\t‚ôªÔ∏è Device is rebooting...");

            await sleep(delayMs); // wait for device to reboot

        } catch (error) {
            console.error(error.message);
            throw new Error(`Device reboot failed. ${error}`);
        }
    }

    async function resetMemoryDevice(delayMs = 1_000) {
        if (!isConnected) {
            logAndConsoleMessage("‚ö†Ô∏è ESP is not connected!", {consoleLevel: 'warn'});
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tResetting memory device...");

            await sendCommandGeneral("MEMORY RESET");

            console.info("\n\tüóëÔ∏è Memory device is resetting...");

            await sleep(delayMs); // wait for device to reset

        } catch (error) {
            console.error(error.message);
            throw new Error(`Memory device reset failed. ${error}`);
        }
    }

</script>

<script>

    let pendingDSLR = null; // Store DSLR event until the next data arrives
    let lastAcceptedTime = null;

    function timeStepCheck(previous, current, stepSize, tolerance = null) {
        if (!isNumSafe(tolerance)) tolerance = (stepSize * 0.01); // set default tolerance to 2x 1% of step size

        // TODO: optimalizovat tolerance dle rychlosti zpracov√°n√≠ dat
        tolerance = clamp(roundDecimalFast(Math.abs(tolerance), 9), 0.0011, 0.1);

        const actualStep = current - previous;

        if (!((stepSize - tolerance) <= actualStep && actualStep <= (stepSize + tolerance))) {
            console.warn("‚ö†Ô∏è Step size mismatch:", {previous, current, actualStep, stepSize, tolerance});
            return previous + stepSize;
        }

        return current;
    }

    // TODO: - je to ≈°patnƒõ
    function timeStepCheckNEW(prev, curr, step, tol = step * 0.1) {
        if (curr >= prev) {
            const delta = curr - prev;
            const n = Math.round(delta / step);
            if (Math.abs(delta - n * step) <= Math.max(tol, step * 0.25)) {
                return prev + n * step; // posu≈à o cel√© n√°sobky kroku
            }
        }
        // fallback: vƒõ≈ô p≈ôijat√©mu ƒçasu, a≈• pozn√°≈° drift/drop
        return curr;
    }

    function interpolateDSLRDataNEW(dslrEvent, nextData, prevData) {
        if (!prevData || !nextData || !dslrEvent) {
            console.info("‚ö†Ô∏è No valid data for interpolation.");
            return null;
        }

        // TODO: zkontrolovat DSLR time relativnƒõ ke startu mƒõ≈ôen√≠
        const dslrTime = roundDecimalFast(dslrEvent.time - tareValues.time, precisionTime);
        const photoIndex = dslrEvent.photoIndex;

        if (!(prevData.time < nextData.time)) {
            console.error("‚ö†Ô∏è Not enough data for interpolation.");
            return null;
        }

        let interpolatedData;

        if (prevData.time <= dslrTime && dslrTime <= nextData.time) {
            const t1 = prevData.time, t2 = nextData.time;
            const factor = (dslrTime - t1) / (t2 - t1);

            const interpPos = roundDecimalFast(prevData.position + factor * (nextData.position - prevData.position), precisionPosition);
            const interpSpeed = roundDecimalFast(prevData.speed + factor * (nextData.speed - prevData.speed), precisionSpeed);

            const interpForce = prevData.force.map((v1, i) => {
                const v2 = nextData.force[i];
                if (isNumSafe(v1) && isNumSafe(v2)) return roundDecimalFast(v1 + factor * (v2 - v1), precisionForce);
                if (isNumSafe(v1)) return v1;
                if (isNumSafe(v2)) return v2;
                return null;
            });

            interpolatedData = {
                time: dslrTime,
                position: interpPos,
                speed: interpSpeed,
                force: interpForce,
                photoIndex
            };

        } else {
            console.warn("‚ö†Ô∏è DSLR time out of [prev,next] ‚Äî using midpoint.");
            const midT = roundDecimalFast((prevData.time + nextData.time) / 2, precisionTime);
            const midPos = roundDecimalFast((prevData.position + nextData.position) / 2, precisionPosition);
            const midSpeed = roundDecimalFast((prevData.speed + nextData.speed) / 2, precisionSpeed);
            const midForce = prevData.force.map((v1, i) => {
                const v2 = nextData.force[i];
                if (isNumSafe(v1) && isNumSafe(v2)) return roundDecimalFast((v1 + v2) / 2, precisionForce);
                return isNumSafe(v1) ? v1 : (isNumSafe(v2) ? v2 : null);
            });

            interpolatedData = {
                time: midT,
                position: midPos,
                speed: midSpeed,
                force: midForce,
                photoIndex
            };
        }

        console.info("üì∏ DSLR Interpolated Data @", interpolatedData.time);
        return interpolatedData;
    }


    // /////// Data Parsing /////////
    function interpolateDSLRData(dslrEvent, nextData, prevData) {
        if (!prevData || !nextData || !dslrEvent) {
            console.info("‚ö†Ô∏è No valid data for interpolation.");
            return;
        }

        const dslrTime = roundDecimalFast(dslrEvent.time - tareValues.time, precisionTime);

        const photoIndex = dslrEvent.photoIndex;

        // Ensure valid data for interpolation
        if (prevData.time >= nextData.time) {
            console.error("‚ö†Ô∏è Not enough data for interpolation.");
            return;
        }

        let interpolatedData;

        if ((prevData.time <= dslrTime) && (dslrTime <= nextData.time)) {
            // Linear interpolation factor
            const t1 = prevData.time, t2 = nextData.time;
            const factor = (dslrTime - t1) / (t2 - t1);

            const interpolatedPosition = roundDecimalFast(prevData.position + factor * (nextData.position - prevData.position), precisionPosition);
            const interpolatedSpeed = roundDecimalFast(prevData.speed + factor * (nextData.speed - prevData.speed), precisionSpeed);
            const interpolatedForce = prevData.force.map((f1, i) => {
                const f2 = nextData.force[i];
                if (isNumSafe(f1) && isNumSafe(f2)) return roundDecimalFast(f1 + factor * (f2 - f1), precisionForce);
                if (isNumSafe(f1)) return f1;
                if (isNumSafe(f2)) return f2;
                return null;
            });

            interpolatedData = {
                time: dslrTime,
                position: interpolatedPosition,
                speed: interpolatedSpeed,
                force: interpolatedForce,
                photoIndex: photoIndex // Store DSLR photo order
            };

        } else {
            console.error("‚ö†Ô∏è Invalid interpolation range.", {
                prevTime: prevData.time,
                dslrTime,
                nextTime: nextData.time
            });

            interpolatedData = {
                time: roundDecimalFast((prevData.time + nextData.time) / 2, precisionTime),
                position: roundDecimalFast((prevData.position + nextData.position) / 2, precisionPosition),
                speed: roundDecimalFast((prevData.speed + nextData.speed) / 2, precisionSpeed),
                force: prevData.force.map((val, i) => roundDecimalFast((val + nextData.force[i]) / 2, precisionForce)),
                photoIndex: photoIndex // Store DSLR photo order
            };
        }


        // Log interpolated data
        // logMeasurements(`${Math.round(dslrEvent.time * 10e6)},${(interpolatedPosition + tareValues.position).toFixed(4)},${interpolatedSpeed.toFixed(2)},${interpolatedForce[0].toFixed(2)},${interpolatedForce[1].toFixed(2)},${interpolatedForce[2].toFixed(2)},    ${photoIndex}`);
        addDataToLog(interpolatedData);

        updateChart(interpolatedData);

        //TODO: zv√°≈æit zda dƒõlat p≈ôid√°v√°n√≠ dat do pr≈Ømƒõr≈Ø:
        dataCount++;
        aggregatedDataBetweenSteps.push(interpolatedData);
        pendingDSLR = null;


        console.info("üì∏ DSLR Interpolated Data:", interpolatedData.time);
    }


    /**
     * Parses raw measurement data into a structured object.
     * @returns {Object} - Parsed data object containing time, position, value, and load values.
     * @param parsedDataList
     */
    function calculateAverageParsedData(parsedDataList) {
        const totalEntries = parsedDataList.length;

        if (totalEntries === 0) return {
            time: 0,
            position: 0,
            force: Array(catchVal(loadCellNum, 0, isNumSafe)).fill(0)
        }; // Return zero values if no data

        let sumTime = 0;
        let sumPosition = 0;
        let sumForce = Array(catchVal(loadCellNum, 0, isNumSafe)).fill(0); // Empty list of `force` values

        parsedDataList?.forEach(data => {
            sumTime += data.time;
            sumPosition += data.position;

            // Sum all values in `load` list
            data.force?.forEach((value, index) => {
                sumForce[index] += value;
            });
        });

        return {
            time: roundDecimalFast(sumTime / totalEntries, precisionTime),
            position: roundDecimalFast(sumPosition / totalEntries, precisionPosition),
            force: sumForce.map(value => roundDecimalFast(value / totalEntries, precisionForce)) // Average of `force` list values (per index)
        };
    }


    function parseData(dataString) {

        const parts = dataString.split(",");

        if (!parts || parts?.length !== measurementParts.length) {
            logMessage("üå°Ô∏è DS" + dataString);
            return {};
        } else {
            logMeasurements(dataString);
        }

        // Common parsing logic
        const timeRaw = sum1D(measurementParts.time?.map(idx => parseFloat(parts[idx]))) * timeConversionDATAC; // Convert microseconds to seconds
        const distRaw = sum1D(measurementParts.position?.map(idx => parseFloat(parts[idx]))); // Position value
        const speedRaw = sum1D(measurementParts.speed?.map(idx => parseFloat(parts[idx]))); // Speed value
        const forceRaw = measurementParts.force?.map((idx) => {
            const val = parts[idx];
            if (val === "0") return null;
            const num = parseFloat(val);
            return catchVal(num, null, isNumSafe);
        }); // LoadCell values
        // const photoIndexRaw = isDef(measurementParts?.photoIndex) ? parseInt(parts[measurementParts?.photoIndex]) : null; // DSLR photo index

        return {
            time: catchVal(timeRaw, null, isNumSafe),
            position: catchVal(distRaw, null, isNumSafe),
            speed: catchVal(speedRaw, null, isNumSafe),
            force: catchVal(forceRaw, null, isNonEmptyArr),
            // photoIndex: catchVal(photoIndexRaw, null, Number.isInteger)
        };
    }

    let lastMove = null;

    async function processMeasurements(dataString) {
        const newData = parseData(dataString);

        if (takeMeasurements) { // Handle takeMeasurements
            newData.force?.forEach((value, index) => (loadcellsInfo.presentLoadcells[index] && isNumSafe(value)) ? measureForces[index].push(value) : null);  // Collect force data for calibration
            return;
        }

        if (!takeMeasurements && !isExperimentRunning) {
            await propagateData(newData);
            return;
        }

        // Detect DSLR shoot event
        const DSLRPrefix = "LR shoot:";
        if (takePhotos && dataString.startsWith(DSLRPrefix)) {
            const [dslrTime, photoIndex] = dataString.split(":")[1].split(",");
            pendingDSLR = {time: parseFloat(dslrTime) * timeConversionDSLR, photoIndex: parseInt(photoIndex) - 1};
            logMeasurements("Photo" + dataString.substring(2));
            return;
        }

        // Handle regular data (not DSLR)
        if (!isNumSafe(tareValues.time)) {
            tareValues.time = newData?.time;
            newData.time = 0.000_000;
        } else {
            // TODO => check if this is correct (step must be same), must be bigger than 0, process as UINT, process as FLOAT in export/saving and charts, BIGINT???
            const corrected = timeStepCheck(catchVal(lastAcceptedTime, parsedData.time, isNumSafe), (newData?.time - tareValues.time), (dataInterval_us * timeConversionDATAC));
            newData.time = roundDecimalFast(corrected, precisionTime);

        }
        lastAcceptedTime = newData?.time;

        newData.position = roundDecimalFast((newData.position - tareValues.position) * displacementSignCorrection, precisionPosition);
        newData.speed = roundDecimalFast(newData.speed * displacementSignCorrection, precisionSpeed);
        newData.force = newData?.force?.map((value, index) =>
            (loadcellsInfo.presentLoadcells[index] && isNumSafe(value))
                ?
                roundDecimalFast((value * loadSignCorrections[index]) - (tareValues.force[index] || 0), precisionForce)
                :
                null);

        // If a pending DSLR timestamp exists, interpolate values
        if (takePhotos && pendingDSLR) {
            const clone = structuredClone(parsedData); // TODO: zkontrolovat zda to m√° smysl a funguje
            interpolateDSLRData(pendingDSLR, newData, clone);
        }

        if (!isNumSafe(newData?.time) || !isNumSafe(newData?.position)) {
            measurement_limits.invalid_data.counter++;

            if (measurement_limits.invalid_data.counter > measurement_limits.invalid_data.limit) {
                console.warn("‚ö†Ô∏è Invalid data received:", {time: newData?.time, position: newData?.position});
                endMeasuring(0, {
                    ednStatus: 'data error',
                    endText: "‚èπÔ∏è Movement stopped due to data error.",
                    command: "MC STOP"
                });
                document.documentElement.style.setProperty('--progressColor', 'var(--progressError-color)');
                UI.experimentStageLabel.textContent = `Error`;
            }
            return;
        } else {
            measurement_limits.invalid_data.counter = 0;
        }

        parsedData = newData;

        if (experimentEvents.doubleSpeed.active === true && newData.force?.some(value => isNumSafe(value) && value >= experimentEvents.doubleSpeed.limit)) {
            setSpeed(experimentEvents.doubleSpeed.value, false);
            experimentEvents.doubleSpeed.active = false;
            document.documentElement.style.setProperty('--progressColor', 'var(--progressSecondary-color)');
            UI.experimentStageLabel.textContent = `Loading`;
        }

        if (experimentEvents.doubleAccel.active === true && newData?.time >= experimentEvents.doubleAccel.limit) {
            setAcceleration(experimentEvents.doubleAccel.value, false);
            experimentEvents.doubleAccel.active = false;
        }

        // const sumForce = newData.force?.reduce((acc, val) => acc + (isNum(val) ? val : 0), 0);
        // const sumForce = sumND(newData?.force); // TODO: check and optimize the speed of sum calculation: (reduce loop vs sum1D vs sumND)
        // const sumForce = sum1D(newData?.force);

        if ((newData.force?.some(value => isNumSafe(value) && value >= stoppingForceLimit)) || (measurement_limits.over_limitForce.limit < 0)) {
            measurement_limits.over_limitForce.counter++;

            if (measurement_limits.over_limitForce.counter > measurement_limits.over_limitForce.limit) {
                if (experimentHoldConstantForce) {
                    checkSpeed = false; // disable speed check
                    measurement_limits.over_limitForce.limit = Number.NEGATIVE_INFINITY;

                    if (!isNumSafe(timer)) {
                        timer = newData?.time;
                        document.documentElement.style.setProperty('--progressColor', 'var(--progressOnHold-color)');
                        UI.experimentStageLabel.textContent = `Holding`;
                    }

                    const forceHoldTimeMs = (newData?.time - timer) * timeConversionSToMs;

                    if (forceHoldTimeMs >= holdForceTimeMs) {
                        const holdTime = convertUnits(forceHoldTimeMs, 'ms', 's', {precision: 3});
                        endMeasuring(0, {
                            ednStatus: `hold force time limit [${holdTime}s]`,
                            endText: `‚èπÔ∏è Experiment stopped due to hold force time limit (${stoppingForceLimit} N for ${holdTime} s).`,
                            command: "MC STOP"
                        });

                    } else {
                        const sumF = sum1D(newData?.force);
                        const v = pi.step(newData?.time, newData?.position, sumF);
                        // adjust speed according to PI controller to maintain constant force ...
                        if (isValidInputNum(v)) {
                            if (v !== lastMove) {
                                lastMove = v;
                                await setSpeed(v, false);
                                await sendCommandGeneral(displacementSignCorrection === 1 ? "MC END" : "MC HOME");
                            }
                        }
                        // ... or stop if invalid, negative or zero
                        else {
                            if (v !== lastMove) {
                                lastMove = 0;
                                await sendCommandGeneral("MC STOP");
                                setSpeedUI(0);
                            }
                        }
                    }

                } else {
                    endMeasuring(0, {
                        ednStatus: 'force limit',
                        endText: `‚èπÔ∏è Movement stopped due to force limit (${stoppingForceLimit} N).`,
                        command: "MC STOP"
                    });
                    document.documentElement.style.setProperty('--progressColor', 'var(--progressStoppedcolor)');
                    UI.experimentStageLabel.textContent = `Stopped`;
                }
            }

        } else {
            measurement_limits.over_limitForce.counter = 0;
            timer = null;
        }


        // Handle speed checks and experiment stopping
        if (checkSpeed && (newData?.speed < (1 / 1e2) && newData?.time > 1)) { // speedVal < 0.01 m/s <= speed value is limited to 2 decimal places // (timeVal - tareValues.time) > 1 second => handled in 'timeStepCheck'
            measurement_limits.zero_speed.counter++;

            if (measurement_limits.zero_speed.counter > measurement_limits.zero_speed.limit) {
                endMeasuring(Math.max(delayMsAfterEndMeasurement / 2, 10), {
                    ednStatus: 'zero speed',
                    endText: "üõë Experiment stopped due to zero speed.",
                    command: takePhotos ? "DSLR STOP CYCLIC" : '',
                });
                document.documentElement.style.setProperty('--progressColor', 'var(--progressStoppedcolor)');
                UI.experimentStageLabel.textContent = `Stopped`;
            }
        } else {
            measurement_limits.zero_speed.counter = 0;
        }


        // Handle LoadCell limit checks
        for (let i = 0; i < catchVal(loadCellNum, 0, isNumSafe); i++) {
            const currForce = newData?.force[i];
            if (isNumSafe(currForce)) {
                if (isNumSafe(maxForces[i])) {
                    if ((maxForces[i] - currForce) > (Math.abs(maxForces[i]) * forceLimitDropPercent) && (maxForces[i] - currForce) > forceLimitDropValue) {
                        endMeasuring(50, {
                            ednStatus: `LoadCell[${i + 1}] drop`,
                            endText: `üõë Experiment stopped due to LoadCell ${i + 1} drop:\n\tPercentage: ${(maxForces[i] - currForce)} > ${(Math.abs(maxForces[i]) * forceLimitDropPercent)} and Absolute: ${maxForces[i] - currForce} > ${forceLimitDropValue}.`,
                            command: "MC STOP",
                        });
                        if (takePhotos) setTimeout(() => sendCommandGeneral("DSLR STOP CYCLIC"), 30); // small delay to allow data processing
                        break; // Stop checking other LoadCells if one fails
                    }
                }
                if (!isNumSafe(maxForces[i]) || currForce > maxForces[i]) maxForces[i] = currForce;
            }
        }

        addDataToLog(newData);

        // Update Progress Bar
        const progressValue = progressCalculate(newData[expControl], experimentEndLimits[expControl]);

        if (isNumSafe(progressValue) && progressValue >= 100) {
            if (experimentProgress < 100) {
                const delayMs = endMeasurement ? 0 : delayMsAfterEndMeasurement;
                endMeasuring(delayMs, {
                    overRide: true,
                    ednStatus: 'end position',
                    endText: "üèÅ Experiment finished.",
                });
                if (takePhotos) setTimeout(() => sendCommandGeneral("DSLR STOP CYCLIC"), 30); // small delay to allow data processing
            }
        }
        experimentProgress = progressValue;

        await propagateData(newData);
    }

    async function propagateData(data, {overRide = false} = {}) {
        if (isExperimentRunning) {
            // Live chart update
            dataCount++;
            aggregatedDataBetweenSteps.push(data);
            if (liveUpdate) {
                if (dataChartInterval === 1) {
                    updateChart(data);
                } else if (dataCount % dataChartInterval === 0) {
                    updateChart(calculateAverageParsedData(aggregatedDataBetweenSteps));
                }
            }
            if (dataCount % dataChartInterval === 0) {
                aggregatedDataBetweenSteps = [];
            }

            // Data for Calculations / Exports
            timeData.push(data.time);
            positionData.push(data.position);
            data.force.forEach((val, index) => forceData[index].push(val));
            return;
        }

        if (liveUpdate || overRide) {
            // const lastPos = positionDataChart[positionDataChart.length - 1]
            // const deltaPos = Math.abs(data.position - lastPos);
            // if (deltaPos <= (9 / Math.pow(10, precisionPosition + 1))) data.position = null; // prevent too dense data in chart
            updateChart(data);
        }
    }


    /////////////////////////////////////////////////////////////////

</script>

<script>
    function renderLoadcells(n) {
        const container = $ID('machSettings');
        container.innerHTML = '';

        const frag = $FRAG();

        // --- √∫vodn√≠ (neƒç√≠slovan√°) dvojice ---
        const baseCap = $MAKE('div');
        baseCap.className = 'input-group';
        baseCap.dataset.systemLevel = '0-200';
        baseCap.innerHTML = `
      <label for="inputLoadcellCapacity">
        Loadcell Capacity<span class="units-text"></span>:
      </label>
      <input
        data-input-type="intInput" type="number" id="inputLoadcellCapacity" value="0"
        step="any" min="0" max="100000000" data-unit="kg" data-essence="scale, conversion" required>
    `;

        const baseOut = $MAKE('div');
        baseOut.className = 'input-group';
        baseOut.dataset.systemLevel = '100-200';
        baseOut.innerHTML = `
      <label for="inputLoadcellOutput">
        Loadcell Rated Output<span class="units-text"></span>:
      </label>
      <input
        data-input-type="floatInput2" type="number" id="inputLoadcellOutput" value="2.0"
        step="any" min="0" max="100000000" data-unit="mV/V" data-essence="voltage, ratio, scale, conversion" required>
    `;

        frag.appendChild(baseCap);
        frag.appendChild(baseOut);

        // --- oƒç√≠slovan√© dvojice 1..N ---
        for (let i = 1; i <= n; i++) {
            const cap = $MAKE('div');
            cap.className = 'input-group';
            cap.dataset.systemLevel = '200';
            cap.innerHTML = `
        <div style="display: inline-flex; gap: var(--gap); min-width: var(--inputLabelWidth);
                    justify-content: flex-end; align-items: center;">
            <label for="activateLoadcell${i}" hidden></label>
            <input type="checkbox" id="activateLoadcell${i}" class="expInput" value="activateLoadcell${i}"
                   data-essence="switch">
            <label for="inputLoadcellCapacity${i}" style="width: calc(var(--inputLabelWidth) - 80px);">
              <b>Loadcell</b> <b style="color: var(--text-info-3-color);">${i}</b>
              Capacity <span class="units-text"></span>:
            </label>
        </div>
        <input
          data-input-type="intInput" type="number" id="inputLoadcellCapacity${i}" value="0"
          step="any" min="0" max="100000000" data-unit="kg" data-essence="scale, conversion" required>
      `;

            const out = $MAKE('div');
            out.className = 'input-group';
            out.dataset.systemLevel = '200';
            out.innerHTML = `
        <label for="inputLoadcellOutput${i}">
          <b>Loadcell</b> <b style="color: var(--text-info-3-color);">${i}</b>
          Rated Output <span class="units-text"></span>:
        </label>
        <input
          data-input-type="floatInput" type="number" id="inputLoadcellOutput${i}" value="2.0"
          step="any" min="0" max="100000000" data-unit="mV/V" data-essence="voltage, ratio, scale, conversion" required>
      `;

            frag.appendChild(cap);
            frag.appendChild(out);
        }

        container.appendChild(frag);
    }
</script>

<script>

    (function ensureBlinkStyles() {
        if ($ID('blink-border-style')) return;
        const style = $MAKE('style');
        style.id = 'blink-border-style';
        style.textContent = `
    .blink-border-on {
      border-color: orange !important;
      background-color: Moccasin !important;
      /* border-width: 3px !important; */
      /* volitelnƒõ: transition: none !important;  // aby neprobƒõhly CSS p≈ôechody */
    }
  `;
        document.head.appendChild(style);
    })();

    // Glob√°ln√≠ (nebo modulov√°) mapa bƒõ≈æ√≠c√≠ch blik√°n√≠ pro konkr√©tn√≠ elementy
    const _blinkLocks = new WeakMap();

    /**
     * Kr√°tk√© "bliknut√≠" r√°meƒçku libovoln√©ho elementu.
     * - target: Element nebo CSS selektor
     * - options:
     *   - color           (default: 'orange')
     *   - backgroundOn    (default: 'Moccasin')
     *   - blinks          (default: 4)   // kolikr√°t blikne
     *   - interval        (default: 200) // ms mezi stavy
     *   - borderWidthOn   (default: null) // nap≈ô. '3px'
     *   - restart         (default: false) // kdy≈æ u≈æ bƒõ≈æ√≠, restartuje
     * @returns {boolean} true = spu≈°tƒõno; false = ignorov√°no (u≈æ bƒõ≈æelo a restart=false / chyb√≠ element)
     */
    async function blinkBorder(target, options = {}) {
        if (!initialAllLoaded) return;
        const el = isStr(target) ? $(target) : target;
        if (!el) return false;

        const {
            color = 'orange',
            backgroundOn = 'Moccasin',
            blinks = 4,
            interval = 200,
            borderWidthOn = null,
            restart = false,
        } = options;

        // prevent-spam: pokud u≈æ bƒõ≈æ√≠
        const running = _blinkLocks.get(el);
        if (running) {
            if (!restart) return false;
            clearInterval(running.id);
            running.restore?.();
            _blinkLocks.delete(el);
        }

        // Snapshot p≈Øvodn√≠ho vizu√°ln√≠ho stavu
        const cs = getComputedStyle(el);
        const original = {
            borderColor: cs.borderColor,
            borderWidth: cs.borderWidth,
            backgroundColor: cs.backgroundColor,
            transition: el.style.transition,
        };

        let ticks = 0;
        let on = false;

        const restore = () => {
            // vypnout p≈ôechody, tvrdƒõ vr√°tit, a zase zapnout
            el.style.transition = 'none';
            void el.offsetWidth; // reflow
            el.style.borderColor = original.borderColor;
            el.style.borderWidth = original.borderWidth;
            el.style.backgroundColor = original.backgroundColor;
            void el.offsetWidth; // reflow
            el.style.transition = original.transition;
            _blinkLocks.delete(el);
        };

        const id = setInterval(() => {
            // kdy≈æ element zmiz√≠ z DOMu, ukliƒè
            if (!document.contains(el)) {
                clearInterval(id);
                restore();
                return;
            }

            on = !on;
            if (on) {
                el.style.borderColor = color;
                if (borderWidthOn) el.style.borderWidth = borderWidthOn;
                el.style.backgroundColor = backgroundOn;
            } else {
                el.style.borderColor = original.borderColor;
                el.style.borderWidth = original.borderWidth;
                el.style.backgroundColor = original.backgroundColor;
            }

            ticks++;
            if (ticks >= blinks * 2) {
                clearInterval(id);
                restore(); // ‚Üê po dobƒõhnut√≠ v≈ædy stejn√© barvy jako na zaƒç√°tku
            }
        }, interval + 50);

        _blinkLocks.set(el, {id, restore});
        return true;
    }

    // Volitelnƒõ: ruƒçn√≠ ukonƒçen√≠/obnova
    blinkBorder.stop = function (target) {
        const el = isStr(target) ? $(target) : target;
        if (!el) return false;
        const running = _blinkLocks.get(el);
        if (!running) return false;
        clearInterval(running.id);
        running.restore?.();
        _blinkLocks.delete(el);
        return true;
    };


</script>

<script>
    function collectExpSettings(selector, schema = null) {
        if (isEmptyStr(selector)) return [];
        const nodes = Array.from($$(selector));
        const inputs = {};

        for (const el of nodes) {
            const key = el.dataset.key || el.name || el.id; // prefer data-key
            if (!key) continue;

            let val;
            if (el.type === "checkbox") val = !!el.checked;
            else if (el.type === "number") val = el.value === "" ? null : toNumber(el.value);
            else if (el.tagName === "SELECT") val = el.value;
            else val = el.value;

            const essence = (el?.tagName === "SELECT") ? ((el.selectedOptions[0]?.dataset.essence) ? el.selectedOptions[0]?.dataset.essence : el?.dataset.essence) : el?.dataset.essence;

            const value = isInvalidValue(val, {considerFalse: false}) ? "N/A" : (isStr(val) ? val.replace('‚àû', "Inf").replace('Íùè', "Inf").replace('·Äë', "Inf").replace('Íùé', "Inf").replace('¬±', '').replace(/[‚Äì‚Äî‚àí]/g, '-').trim() : val);
            inputs[key] = {
                value: isNotEmpty(value) ? value : null,            // null pro pr√°zdn√©/invalidn√≠ hodnoty
                type: el.type || el.tagName.toLowerCase(),          // nap≈ô. "number", "checkbox", "text", "select"
                label: el.dataset.label || el.placeholder || key,   // volitelnƒõ pro hezƒç√≠ zobrazen√≠
                classes: el.className || null,                      // volitelnƒõ pro dal≈°√≠ filtrov√°n√≠
                name: el.name || null,                               // jm√©no elementu
                id: el.id || null,                                   // id elementu

                extra: {
                    unit: el.dataset.unit || null,  // jednotka
                    essence: essence || null, // nap≈ô. "force", "disp", "stress", "modulus", "area", "iy", "hardness"
                    description: el.dataset.description || null, // voliteln√Ω popis
                }
            };
        }

        return {
            selector: selector,
            schema: schema,
            version: 1,
            timestamp: new Date().toISOString(),
            inputs,
        };
    }

    async function restoreExpSettingsToUI(settings, {
        customSelector = undefined,
        customKey = undefined,
        fireEvents = false,
    } = {}) {

        const keys = [];
        if (customKey) {
            keys.push(String(customKey));
        } else {
            if (settings?.generalSettings) keys.push('generalSettings');
            if (settings?.machineSettings) keys.push('machineSettings');
            if (settings?.deviceSettings) keys.push('deviceSettings');
            if (settings?.chartSettings) keys.push('chartSettings');
            if (settings?.expSettings) keys.push('expSettings');
            if (settings?.calcSettings) keys.push('calcSettings');
        }

        const results = [];
        for (const key of keys) {
            if (!settings[key]) continue;
            const r = await restoreSettingsToUI(settings[key], {customSelector, fireEvents});
            results.push({key, ...r});
        }

        const ok = results.some(r => r.ok);
        const summary = results.reduce((acc, r) => {
            acc.tried += 1;
            acc.ok |= r.ok;
            acc.totalNodes += r.foundNodes || 0;
            acc.applied += r.appliedCount || 0;
            acc.missingKeys += (r.missingKeys?.length || 0);
            return acc;
        }, {tried: 0, ok: false, totalNodes: 0, applied: 0, missingKeys: 0});

        return {ok, results, summary};
    }

    const setElValue = (el, val, fireEvents = true, fire = null) => {
        const tag = el.tagName.toLowerCase();
        const type = (el.type || "").toLowerCase();

        if (isVoid(fire)) fire = (el) => {
            if (!fireEvents) return;
            el.dispatchEvent(new Event("input", {bubbles: true}));
            el.dispatchEvent(new Event("change", {bubbles: true}));
            el.dispatchEvent(new Event("blur", {bubbles: true}));
        };

        if (type === "checkbox") {
            el.checked = !!val;
            fire(el);
            return true;
        }
        if (type === "radio" && el.name) {
            $$(`input[type="radio"][name="${CSS.escape(el.name)}"]`)
                ?.forEach(r => {
                    r.checked = (String(r.value) === String(val));
                    fire(r);
                });
            return true;
        }
        if (tag === "select") {
            if (el.multiple && isArr(val)) {
                const set = new Set(val.map(String));
                Array.from(el.options)?.forEach(opt => {
                    opt.selected = set.has(String(opt.value));
                });
            } else {
                el.value = val || "";
            }
            fire(el);
            return true;
        }
        if (type === "number" || type === "range") {
            let v = val;
            if (isStr(v) && v.includes(",")) v = v.replace(",", ".");
            if (!isNonEmptyStr(v)) el.value = "";
            else if (Number.isFinite(+v)) ("valueAsNumber" in el) ? el.valueAsNumber = +v : el.value = String(+v);
            else el.value = "";
            fire(el);
            return true;
        }
        el.value = (val || "");
        fire(el);
        return true;
    };

    async function restoreSettingsToUI(settings, {
        customSelector = undefined,
        fireEvents = false,
    } = {}) {

        const report = {
            ok: false,
            selector: null,
            foundNodes: 0,
            appliedCount: 0,
            missingKeys: [],
            unusedEls: [],
            details: [] // {key, found, applied, reason}
        };

        let selector = customSelector;
        if (!settings?.inputs) {
            report.details.push({key: null, found: 0, applied: false, reason: 'no-inputs'});
            return report;
        }
        if (!customSelector || isEmptyStr(customSelector)) selector = settings.selector;
        report.selector = selector;
        if (!selector || isEmptyStr(selector)) {
            report.details.push({key: null, found: 0, applied: false, reason: 'no-selector'});
            return report;
        }

        const nodes = Array.from($$(selector));
        report.foundNodes = nodes.length;
        if (!nodes.length) {
            report.details.push({key: null, found: 0, applied: false, reason: 'no-nodes'});
            return report;
        }

        // index dle data-key | name | id
        const index = new Map();
        for (const el of nodes) {
            const key = el.dataset.key || el.name || el.id;
            if (!key) {
                report.unusedEls.push(el);
                continue;
            }
            (index.get(key) || index.set(key, []).get(key)).push(el);
        }

        const fire = (el) => {
            if (!fireEvents) return;
            el.dispatchEvent(new Event("input", {bubbles: true}));
            el.dispatchEvent(new Event("change", {bubbles: true}));
            el.dispatchEvent(new Event("blur", {bubbles: true}));
        };


        // aplikuj hodnoty
        for (const [key, meta] of Object.entries(settings.inputs)) {
            const els = index.get(key);
            if (!els?.length) {
                report.missingKeys.push(key);
                report.details.push({key, found: 0, applied: false, reason: 'no-match'});
                continue;
            }

            try {
                if (els[0].type === "radio") {
                    setElValue(els[0], meta.value, fireEvents, fire);
                } else if (els[0].tagName.toLowerCase() === "select" && els[0].multiple) {
                    setElValue(els[0], isArr(meta.value) ? meta.value : [meta.value], fireEvents, fire);
                } else {
                    setElValue(els[0], meta.value, fireEvents, fire);
                }
                report.appliedCount += 1;
                report.details.push({key, found: els.length, applied: true});
            } catch (e) {
                report.details.push({key, found: els.length, applied: false, reason: String(e?.message || e)});
            }
        }

        report.ok = report.appliedCount > 0;
        return report;
    }

    async function applyCsvToUI(csvText, opts) {
        const settings = await parseSettingsFromCsv(csvText);
        if (!settings) return {ok: false, reason: 'parse-failed', settings: null, results: []};
        const res = await restoreExpSettingsToUI(settings, opts); // { ok, results, summary }


        const outputsOpts = {
            time: {key: 'time', unit: 's', precision: 12, columnLimit: 1},
            position: {key: 'dist, disp, position', unit: 'mm', precision: 12, columnLimit: 1},
            force1: {key: 'force 1, load 1, loadcell 1', unit: 'N', precision: 12, columnLimit: 1},
            force2: {key: 'force 2, load 3, loadcell 2', unit: 'N', precision: 12, columnLimit: 1},
            force3: {key: 'force 3, load 3, loadcell 3', unit: 'N', precision: 12, columnLimit: 1},
        };
        const csvData = {}; // await getCSVData(csvText, outputsOpts, "loadedCSVfile") ||

        if (isNonEmptyDict(csvData)) {
            const {
                // preamble: preambleMetaData = {},
                // fileType,
                // fileOptions: fileOptionsUsed = {},
                data: parsedData = {}
            } = csvData;

            if (parsedData.time) {
                timeData = parsedData.time;
                timeDataChart = parsedData.time;
            }
            if (parsedData.position) {
                positionData = parsedData.position;
                positionDataChart = parsedData.position;
            }
            if (parsedData.force1) {
                forceData.push(parsedData.force1);
                forceDataChart.push(parsedData.force1);
            }
            if (parsedData.force2) {
                forceData.push(parsedData.force2);
                forceDataChart.push(parsedData.force2);
            }
            if (parsedData.force3) {
                forceData.push(parsedData.force3);
                forceDataChart.push(parsedData.force3);
            }
            while (forceData.length !== loadCellNum) {
                forceData.push(Array.from({length: timeDataChart.length}).fill(null));
                forceDataChart.push(Array.from({length: timeDataChart.length}).fill(null));
            }

            photoDataChart = Array.from({length: timeDataChart.length}).fill(null); // reset photo data chart

            if (timeChart) timeChart.setData([timeDataChart, ...forceDataChart, photoDataChart]);
            if (positionChart) positionChart.setData([positionDataChart, ...forceDataChart, photoDataChart]);
        }

        return {ok: !!res.ok, settings, ...res};
    }

    async function processFile(file) {
        const text = await file.text();
        const res = await applyCsvToUI(text, {fireEvents: true});

        const nameEl = $ID("loadedFileName");

        if (res.ok) {
            nameEl.textContent = `‚úÖ Loaded: ${file.name} ‚Äî applied ${res.summary.applied} fields`;
            console.groupCollapsed(`‚úîÔ∏è Settings applied (${file.name})`);
            console.table(res.results.map(r => ({
                key: r.key,
                selector: r.selector,
                nodes: r.foundNodes,
                applied: r.appliedCount,
                missingKeys: r.missingKeys.length
            })));
            res.results?.forEach(r => {
                if (r.missingKeys.length) {
                    console.groupCollapsed(`‚ö†Ô∏è Missing keys in ${r.key}`);
                    console.info(r.missingKeys);
                    console.groupEnd();
                }
            });
            console.groupEnd();
        } else {
            nameEl.textContent = `‚ö†Ô∏è In file ${file.name} are no settings meta data`;
            console.warn("\nDetails:", res);
            alert("‚ö†Ô∏è In file are missing or are invalid meta data: (##MOIRA_EMETA=...).");
        }
    }


    // --- gzip (preferuj nativn√≠ streamy; fallback pako) ---
    async function gzipBytes(u8, {level = 6} = {}) { // level 6 is fast and decent compression choice
        level = clamp(Math.round(level), 0, 9);
        if (!isUndefined(CompressionStream)) {
            const stream = new Blob([u8]).stream().pipeThrough(new CompressionStream("gzip", {level: level}));
            const buf = await new Response(stream).arrayBuffer();
            return new Uint8Array(buf);
        } else if (self.pako?.gzip) {
            return self.pako.gzip(u8, {level: level});
        }
        throw new Error("No gzip available (CompressionStream/pako).");
    }

    function looksLikeGzip(u8) {
        return u8 && u8.length >= 2 && u8[0] === 0x1f && u8[1] === 0x8b;
    }

    // --- gunzip (preferuj nativn√≠ streamy; fallback pako) ---
    async function gunzipBytes(u8) {
        if (!looksLikeGzip(u8)) throw new Error("Data do not look like gzip format.");
        if (!isUndefined(DecompressionStream)) {
            const stream = new Blob([u8]).stream().pipeThrough(new DecompressionStream("gzip"));
            const buf = await new Response(stream).arrayBuffer();
            return new Uint8Array(buf);
        } else if (self.pako?.ungzip) {
            return self.pako.ungzip(u8); // pako fallback
        }
        throw new Error("No gunzip available (DecompressionStream/pako).");
    }

    // --- tvorba preambule (vybere krat≈°√≠ z gzip/plain) ---
    async function settingsToCsvPreamble(settings) {
        const json = JSON.stringify(settings);
        const plainB64 = u8ToB64(txtE.encode(json));

        let gzipB64 = null;
        try {
            const gz = await gzipBytes(txtE.encode(json));
            gzipB64 = u8ToB64(gz);
        } catch (err) {
            // nem√°me gzip => z≈Østaneme u plain
        }

        if (gzipB64 && gzipB64.length < plainB64.length) {
            return `##MOIRA_METAZ=${gzipB64}`;
        } else {
            return `##MOIRA_METAP=${plainB64}`;
        }
    }

    // --- ƒçten√≠ preambule z 1. ≈ô√°dku ---
    async function readSettingsFromPreamble(line) {
        // odstra≈à BOM na zaƒç√°tku, kdyby se vyskytl
        line = line.replace(/^\uFEFF/, "");

        if (line.startsWith("##MOIRA_METAZ=")) {
            const b64 = line.slice("##MOIRA_METAZ=".length).trim();
            const u8 = b64ToU8(b64);
            const unz = await gunzipBytes(u8);
            return JSON.parse(txtD.decode(unz));
        }
        if (line.startsWith("##MOIRA_METAP=")) {
            const b64 = line.slice("##MOIRA_METAP=".length).trim();
            const json = txtD.decode(b64ToU8(b64));
            return JSON.parse(json);
        }
        throw new Error("Unknown MOIRA_META prefix.");
    }

    // --- parsing z cel√©ho CSV textu (vr√°t√≠ objekt nebo null) ---
    async function parseSettingsFromCsv(csvData) {
        if (!isNotEmpty(csvData)) return null;

        let firstLine;
        if (isStr(csvData)) {
            // vezmi jen prvn√≠ ≈ô√°dku; split(limit=1) vrac√≠ pole => [0]
            firstLine = (csvData.split(/\r?\n/, 1)[0] || "");
        } else if (isArr(csvData)) {
            firstLine = (csvData[0] || "");
        } else {
            return null;
        }

        firstLine = firstLine.replace(/^\uFEFF/, "").trim();

        // rozpoznej prefix a zbytek jako Base64
        const m = firstLine.match(/^##MOIRA_META([ZP])=([A-Za-z0-9+/=]+)\s*$/);
        if (!m) return null;

        try {
            return await readSettingsFromPreamble(firstLine);
        } catch (e) {
            console.error("‚ùå Invalid settings JSON in MOIRA_META:", e);
            return null;
        }
    }

</script>

<script>
    // /////// Saving Log to File /////////

    /**
     * Saves the stored log entries from IndexedDB to a downloadable CSV file.
     */
    let handFolderSelect = false;

    function toggleDirectorySelector() {
        handFolderSelect = !handFolderSelect;
    }

    async function saveCSV() {
        if (isExperimentRunning) return;
        console.info("\nüíæ Saving data to CSV file...");

        let dirHandle = null;
        // Delimiter for CSV file "\t" = tab, "," = comma, ";" = semicolon
        const delimiterSymbolVal = await getElementValue("delimiterSymbol") || "Option-Semicolon";
        let delimiter = await (delimiterSymbolVal === "Option-Comma" ? "," : delimiterSymbolVal === "Option-Semicolon" ? ";" : delimiterSymbolVal === "Option-Tab" ? "\t" : delimiterSymbolVal === "Option-Space" ? " " : ";") || ";";
        // Decimal symbol for CSV file "." = dot, "," = comma
        const decimalSymbol = await (getElementValue("decimalSymbol") === "Option-Comma" ? "," : ".") || ".";

        // 6 of random symbols that are unlikely to be in the data
        const delimiterPlaceHolder = "¬ß" + Math.random().toString(36).substring(2, 4) + Math.random().toString(36).substring(2, 4) + Math.random().toString(36).substring(2, 4) + "¬ß";

        if (decimalSymbol === "," && delimiter === ",") delimiter = ";"; // If comma is selected as decimal symbol, use semicolon as delimiter to avoid conflicts


        const expNum = parseInt(getElementValue("experimentCount")) || 0;
        const experimentName = getElementValue("experimentName");
        const experimentDesc = checkDescription();

        handFolderSelect = $ID("storagePath").checked || false;

        if (!experimentName) {
            alert("Unable to save the data.\n    Please enter the Experiment name.");
            return;
        }

        let experimentCount
        if (expNum) {
            experimentCount = `_${expNum.toString().padStart(3, "0")}`;
        } else {
            experimentCount = "";
        }
        const fileName = `${experimentName}${experimentCount}.csv`;

        let fileHandle;
        if (handFolderSelect) {
            try {
                dirHandle = await window.showDirectoryPicker(); // User selects a folder
            } catch (error) {
                console.error("‚ùå Folder selection canceled or error occurred:", error);
                return;
            }
            fileHandle = await dirHandle.getFileHandle(fileName, {create: true});

        } else {
            fileHandle = {name: `${fileName}`}; // Simulated save outside File System Access API
        }

        let transaction = db.transaction(STORE_NAME, "readonly");
        let store = transaction.objectStore(STORE_NAME);
        let request = store.getAll();

        // Helper rounding functions
        const getRoundVal = (x, dec, decSym) => getCustomStrValue(x, dec, decSym, false, true, "");

        const rTime = (num) => getRoundVal(num, precisionTime, decimalSymbol);
        const rDist = (num) => getRoundVal(num, precisionPosition, decimalSymbol);
        const rForce = (num) => getRoundVal(num, precisionForce, decimalSymbol);
        const rSpeed = (num) => getRoundVal(num, precisionSpeed, decimalSymbol);
        const rPhoto = (num) => getRoundVal(num, 0, decimalSymbol);

        request.onsuccess = async function () {
            let dataEntries = request.result;

            if (!dataEntries || dataEntries.length === 0) {
                console.warn("‚ö†Ô∏è No data to save.");
                alert("‚ö†Ô∏è No data to save. Ensure experiment has been run.");
                return;
            }
            const experimentInfo = dataEntries[0];

            dataEntries.shift(); // Skip the first entry (initial values)

            const settings = experimentInfo || {};
            settings.id = undefined; // Remove id from metadata

            if (settings.status === 'saved') {
                if (!confirm("‚ö†Ô∏è This experiment data has already been saved before. Do you still want to save it again?")) {
                    console.info("‚ùé Save operation cancelled by user.");
                    return;
                } else {
                    console.info("‚ö†Ô∏è Saving data that was already marked as 'saved'.");
                }
            } else if (settings.status !== 'finalized') {
                if (settings.status === 'collected') {
                    if (!confirm("‚ö†Ô∏è This experiment data is marked as possibly incomplete. Do you still want to save it?")) {
                        console.info("‚ùé Save operation cancelled by user.");
                        return;
                    }
                    console.info("‚ö†Ô∏è Saving data that is marked as incomplete.");
                } else {
                    if (!confirm("‚ö†Ô∏è This experiment data is possibly incomplete or corrupted. Do you still want to save it?")) {
                        console.info("‚ùé Save operation cancelled by user.");
                        return;
                    }
                    console.info("‚ö†Ô∏è Saving data that is possibly incomplete and corrupted.");
                }
            }

            // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            settings.headerVersion = 1;
            settings.columns = 6;
            settings.skipRows = 6;
            // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

            settings.calcSettings = collectExpSettings(".calcInput", "Moira-calc-settings") || {};
            settings.decimalSymbol = decimalSymbol;
            settings.delimiter = delimiter;

            let content = '';

            const dateFormat = getLocaleOrder();

            const basicInfo = [
                `Date [${dateFormat.date} ${dateFormat.time}]:`, experimentInfo.experimentDate,
                'Experiment type:', experimentInfo.experimentLabel,
                'Experiment end:', experimentInfo.endStatus,
                'Loading speed (mm/s):', experimentInfo.loadSpeed,
                'Load distance (mm):', experimentInfo.loadDistance,
                'Loadcell capacity (kg):', experimentInfo.loadcellsInfo.capacities.map((v, i) => experimentInfo.loadcellsInfo.presentLoadcells[i] ? v : NaN).join('/'),
                'Software version:', `v${experimentInfo.appSoftWare}`,
                'Firmware version:', `v${experimentInfo.machineFirmware}`,
            ];

            const head = [
                'Time [s]', 'Displacement [mm]', 'Speed [mm/s]', ...experimentInfo.loadcellsInfo.capacities.map((_, idx) => `Force ${idx + 1} [N]`), 'Photo Index'
            ];


            content += (await settingsToCsvPreamble(settings)).replace(/ /g, "").replace(/^\uFEFF/, "");
            content += '\n';
            content += `\n${basicInfo.join(delimiterPlaceHolder)}`;
            content += `\nDescription:${delimiterPlaceHolder}${experimentDesc}`;
            content += '\n';
            content += `\n${head.join(delimiterPlaceHolder)}`;


            if (delimiter === ",") experimentDesc.replaceAll(",", ".");
            // Remove delimiter from description to avoid confusion in space-delimited files (CSV)
            if (delimiter === " ") {
                content = content.replaceAll(/ /g, "_");
            } else {
                content = content.replaceAll(delimiter, "|");

            }

            content = content.replaceAll(delimiterPlaceHolder, delimiter); // Replace placeholder with actual delimiter

            dataEntries?.forEach(entry => {
                const dataRow = [rTime(entry.time), rDist(entry.position), rSpeed(entry.speed), ...entry.force.map(rForce), rPhoto(entry.photoIndex)];
                if (dataRow.some(d => d !== "")) content += `\n${dataRow.join(delimiter)}`; // Only add rows with at least one non-empty value
            });

            if (handFolderSelect) {
                // Save the file to the selected folder using File System Access API
                const writable = await fileHandle.createWritable();
                await writable.write(`\uFEFF${content}`); // Add BOM for correct UTF-8 encoding
                await writable.close();
            } else {
                // Simulated file download (browsers don't allow direct writes)
                const blob = new Blob([`\uFEFF${content}`], {type: "text/csv;charset=utf-8"});
                const link = $MAKE("a");
                link.href = URL.createObjectURL(blob);
                link.download = fileHandle.name.split("/").pop();
                link.click();
            }

            if (expNum) {
                $ID("experimentCount").value = expNum + 1;
                $ID("experimentCount")?.dispatchEvent(new Event("change", {bubbles: true}));
            }

            console.info(`‚úÖ Data saved to file: ${fileName}`);

            // Update IndexedDB status after saving
            await updateLogById(0, {status: 'saved'});
        };
    }

</script>

<script>


    async function getCSVData(csvData, fileOptions = {}, fileName = '') {
        if (!isNonEmptyStr(csvData)) return null; //  || isNonEmptyArr(csvData)
        if (!isNonEmptyDict(fileOptions)) return null;

        function setupParsers(head, fileSet, outputs) {
            // --- sanity checks ---
            if (!isStr(head)) {
                console.warn("\n‚ö†Ô∏è Cannot setup parsers, head is not an array.");
                return {};
            }
            if (!fileSet || !fileSet.delimiter) {
                console.warn("\n‚ö†Ô∏è Cannot setup parsers, missing delimiter or fileSet.");
                return {};
            }
            if (!fileSet.dataTypes) fileSet.dataTypes = {};

            // --- helpers ---
            const getUnitFromHeader = (header) => {
                if (isEmptyStr(header)) return null;
                // nech√°v√°m tv≈Øj vzor; p≈ô√≠padnƒõ roz≈°√≠≈ôit o ƒç√≠slice, lom√≠tka apod.
                const match = String(header).match(/[(\[]\s*([a-zA-Z%ŒºŒºmNnkgkPaasS]+)\s*[)\]]/);
                return match ? match[1] : null;
            };

            // --- 1) hlaviƒçka ---
            const headerParts = head.split(fileSet.delimiter).map(s => String(s).trim());
            const headerUnits = headerParts.map(part => getUnitFromHeader(part) || '');

            // mapa synonym z outputs[*].key (ƒç√°rkami oddƒõlen√©)
            const types = Object.keys(outputs || {});
            const keysByType = Object.fromEntries(
                types.map(t => [
                    t,
                    String(outputs[t]?.key || t)
                        .toLowerCase()
                        .split(',')
                        .map(s => s.trim())
                        .filter(Boolean),
                ])
            );

            // pro ka≈æd√Ω sloupec rozhodni typ dle substring≈Ø
            const headerTypes = headerParts.map(part => {
                const p = String(part).toLowerCase();
                for (const t of types) {
                    if (keysByType[t].some(k => k && p.includes(k))) return t;
                }
                return null;
            });

            // --- 2) dopl≈à/nen√°silnƒõ nastav fileSet.dataTypes[*] ---
            function ensureType(t) {
                const prev = fileSet.dataTypes[t] || {};
                const outCfgUnit = outputs[t]?.unit || '';

                // 2.1 Indexy
                let indexes = isArr(prev.indexes) && prev.indexes.length > 0
                    ? prev.indexes.slice() // respektuj p≈ôedem zadan√© indexy
                    : headerTypes
                        .map((tt, i) => (tt === t ? i : -1))
                        .filter(i => i >= 0);

                // 2.2 C√≠lov√° jednotka (preferuj u≈æ d≈ô√≠v nastavenou)
                const targetUnit = isNonEmptyStr(prev.unit) ? prev.unit : outCfgUnit;

                // 2.3 Udr≈æ jednotn√Ω "fromUnit" pro 1 spoleƒçn√Ω conversion
                let fromUnit = '';
                if (!isNonEmptyArr(prev.indexes) && isNonEmptyArr(indexes)) {
                    if (targetUnit) {
                        // najdi prvn√≠ jednotku mezi kandid√°ty
                        for (const i of indexes) {
                            if (headerUnits[i]) {
                                fromUnit = headerUnits[i];
                                break;
                            }
                        }
                        if (fromUnit) {
                            // filtruj jen na sloupce se shodn√Ωm fromUnit
                            indexes = indexes.filter(i => (headerUnits[i] || '') === fromUnit);
                        }
                    } else {
                        // bez targetUnit ‚Äì dr≈æ jednotnost dle prvn√≠ nalezen√© (nebo pr√°zdn√©)
                        fromUnit = headerUnits[indexes[0]] || '';
                        indexes = indexes.filter(i => (headerUnits[i] || '') === fromUnit);
                    }
                } else if (isNonEmptyArr(prev.indexes)) {
                    // indexy d√°ny u≈æivatelem ‚Üí odvoƒè fromUnit (pokud jde)
                    const i0 = prev.indexes[0];
                    if (Number.isInteger(i0) && i0 >= 0 && i0 < headerUnits.length) {
                        fromUnit = headerUnits[i0] || '';
                    }
                }

                // 2.4 Konverze (preferuj p≈ôedvyplnƒõnou)
                let conversion = isDef(prev.conversion) ? toNumber(prev.conversion) : undefined;
                if (isVoid(conversion) || !isNumSafe(conversion)) {
                    if (targetUnit && fromUnit) {
                        try {
                            conversion = convertUnits(1, fromUnit, targetUnit) || 1;
                        } catch (_) {
                            conversion = 1;
                        }
                    } else {
                        conversion = 1;
                    }
                }

                // 2.5 Z√°pis (zachovej p≈ô√≠padn√© dal≈°√≠ kl√≠ƒçe v prev)
                fileSet.dataTypes[t] = {
                    ...prev,
                    indexes: isNonEmptyArr(prev.indexes) ? prev.indexes : indexes,
                    unit: isNonEmptyStr(prev.unit) ? prev.unit : targetUnit,
                    conversion,
                };
            }

            for (const t of types) ensureType(t);

            // --- 3) gettery (p≈ôesnost z outputs[*].precision) ---
            const getters = {};
            for (const t of types) {
                const precision = outputs[t]?.precision ?? 12;

                getters[t] = (entry) => {
                    const spec = fileSet.dataTypes[t];
                    if (!spec || !isNonEmptyArr(spec.indexes)) return 0;

                    const convRaw = toNumber(spec.conversion, true);
                    const conv = Number.isFinite(convRaw) ? convRaw : 1;

                    // vezmi prvn√≠ nenulovou / ƒç√≠selnou hodnotu
                    for (let i = 0; i < spec.indexes.length; i++) {
                        const idx = spec.indexes[i];
                        const vRaw = toNumber(entry[idx], true);
                        const v = Number.isFinite(vRaw) ? vRaw : 0;
                        if (v !== 0) {
                            return roundDecimalFast(v * conv, precision);
                        }
                    }
                    return 0;
                };

                // metadata/utility metody (ne-s√©riovateln√© a bezpeƒçn√©)
                Object.defineProperties(getters[t], {
                    indexes: {
                        value: () => (fileSet.dataTypes?.[t]?.indexes ? [...fileSet.dataTypes[t].indexes] : []),
                        enumerable: false
                    },
                    count: {
                        value: () => (fileSet.dataTypes?.[t]?.indexes?.length ?? 0),
                        enumerable: false
                    },
                    unit: {
                        value: () => (fileSet.dataTypes?.[t]?.unit ?? ''),
                        enumerable: false
                    },
                    conv: {
                        value: () => {
                            const c = toNumber(fileSet.dataTypes?.[t]?.conversion, false);
                            return Number.isFinite(c) ? c : (fileSet.dataTypes?.[t]?.conversion ?? 1);
                        },
                        enumerable: false
                    }
                });
            }


            return getters;
        }

        const getDelimiter = (rows, minParts = 3) => {
            const testLine = rows[Math.ceil(2 * rows.length / 3)]; // data line of CSV file
            let delimiter = null; // Delimiter of data in a a CSV file

            for (const separator of delimiters) {
                const parts = testLine.split(separator);
                if (parts.length >= minParts) {
                    delimiter = separator;
                    break; // Found the delimiter
                }
            }

            return delimiter;
        };

        // ===== Main parsing logic =====

        fileName = String(fileName).trim() || 'Unknown File';

        const delimiters = [";", ",", "\t", " "];
        const preferFoundDelimiter = false;

        let fileType = null;
        let fileVersion = null;
        let preambleMetaData = null;
        const fileOpts = {
            delimiter: null,
            skipRows: 0,
            columns: null,
            dataTypes: {},
            dataLength: null,
        }; // Options for parsing the file


        const csvText = csvData.replace(/\r\n?/g, "\n");

        const rows = csvText.split("\n").map(r => r.trim()); // Split text into lines

        const dataRows = rows.map(r => r.toLowerCase()); // Split text into lines

        if (dataRows.length === 0) {
            console.warn(`CSV file '${fileName}' is empty.`);
            return null;
        }


        if (dataRows[0].startsWith("##moira")) {
            // MOIRA file
            fileType = "moira";
            console.info(`üìÅ Processing MOIRA file: ${fileName}`);

            preambleMetaData = await parseSettingsFromCsv(rows[0]) || {};

            if (!isNonEmptyDict(preambleMetaData)) {
                console.warn(`‚ùå Invalid or missing MOIRA meta data in file: ${fileName}`);
                return null;
            }

            fileVersion = preambleMetaData?.version || 0;

            fileOpts.delimiter = preambleMetaData?.delimiter || ";";
            if (preambleMetaData?.headerVersion === 1) fileOpts.skipRows = preambleMetaData?.skipRows; // (Experiment settings) // (Empty) // (Info) // (Description) // (Empty) // (Header)
            fileOpts.columns = preambleMetaData?.columns;


            const precisions = preambleMetaData?.precisions || {};
            Object.keys(fileOptions)?.forEach(key => {
                const n = toRounds(precisions[key]);
                if (isDef(n) && isNumSafe(n)) fileOptions[key].precision = clamp(Math.abs(n), 0, 12);
            });
        } else if (dataRows[0].startsWith("date:")) {

            // MOIRA LEGACY file
            fileType = "moira_legacy";
            console.info(`üìÅ Processing MOIRA legacy file: ${fileName}`);

            fileOpts.delimiter = ";";
            fileOpts.skipRows = 3; // (Info) // (Description) // (Header)
            fileOpts.columns = 6;
        } else if (dataRows[0].startsWith("timestamp_us")) {

            // MATLAB file
            fileType = "matlab";
            console.info(`üìÅ Processing MATLAB file: ${fileName}`);

            fileOpts.delimiter = ";";
            fileOpts.skipRows = 1;  // (Header)
            fileOpts.columns = 5;
            fileOpts['dataTypes']['time']['conversion'] = convertUnits(1, '¬µs', 's'); // Convert time from microseconds to seconds
        } else {
            // Unknown file type
            fileType = "unknown";
            console.info(`üìÅ Processing unknown format file: ${fileName}`);

            // find first row that starts with text 'time'
            // const headerRowIndex = rows.findIndex(row => row.trim().startsWith("time"));
            // fileOpts.skipRows = headerRowIndex !== -1 ? headerRowIndex : 0;
            // fileOpts.columns = 4;

            // let maxTries = 50;
            // let validRowFound = false;
            //
            // while (maxTries-- > 0 && rows.length > 0) {
            //     const firstRow = rows[0];
            //     const values = firstRow.slice(0, 6).map(val => parseFloat(val));
            //
            //     if (!firstRow || values.length < 6) {
            //         rows.shift();
            //         continue;
            //     }
            //
            //     const allValid = values.every(val => isNum(val));
            //
            //     if (allValid) {
            //         validRowFound = true;
            //         break; // Found a valid row
            //     } else {
            //         rows.shift(); // Remove the first row
            //     }
            // }
            //
            // if (!validRowFound) {
            //     logMessage(`‚ùå No valid data found in file: ${file.name}`);
            //     console.warn("\n‚ùå No valid data found in file:", file.name);
            //     return null;
            // }

            console.info(`‚ùå Skipping unknown file: ${fileName}`);
            return null;
        }


        if (dataRows.length <= fileOpts.skipRows) {  // Skip if the file has no data
            logAndConsoleMessage(`‚úñÔ∏è Not enough data in file: ${fileName}`, {consoleLevel: 'warn'});
            console.info(`‚ùå Skipping empty or invalid file: ${fileName}`);
            return null;
        }

        const foundDelimiter = getDelimiter(rows, fileOpts.columns);

        if (foundDelimiter !== fileOpts.delimiter) {
            logAndConsoleMessage(`‚úñÔ∏è Unexpected delimiter in file: ${fileName}. Expected '${fileOpts.delimiter}', but found '${foundDelimiter || "none"}'.`, {consoleLevel: 'warn'});

            if (!preferFoundDelimiter) {
                console.info(`‚ùå Skipping file due to delimiter mismatch: ${fileName}`);
                return null;
            }
            fileOpts.delimiter = foundDelimiter;
        }

        if (!fileOpts.delimiter) {
            logAndConsoleMessage(`‚úñÔ∏è Delimiter not found in file: ${fileName}`, {consoleLevel: 'warn'});

            console.info(`‚ùå Skipping file due to missing delimiter: ${fileName}`);
            return null;
        }


        const header = dataRows[fileOpts.skipRows - 1] || ''; // Header row based on skipRows

        const getters = setupParsers(header, fileOpts, fileOptions);

        if (Object.keys(fileOptions).some(k => !getters[k] || getters[k].count() === 0)) {
            logAndConsoleMessage(`‚úñÔ∏è Cannot parse required data columns in file: ${fileName}. Check the delimiter and file format.`, {consoleLevel: 'warn'});
            return null;
        }

        let err = false;
        for (const key of Object.keys(fileOptions)) {
            if (isDef(fileOptions[key].columnLimit) && (getters[key].count() > fileOptions[key].columnLimit)) {
                logAndConsoleMessage(`‚úñÔ∏è Invalid number of columns for '${key}' in file: ${fileName}. Expected ${fileOptions[key].columnLimit}, but found ${getters[key].count()}.`, {consoleLevel: 'warn'});
                err = true;
            }
        }
        if (err) {
            logAndConsoleMessage(`‚ùå Skipping file due to invalid column counts: ${fileName}`);
            return null;
        }


        const dataFiltered = dataRows.slice(fileOpts.skipRows).filter(r => r.length > 0); // Remove header rows and remove empty ones

        fileOpts.dataLength = dataFiltered.length;

        const data = dataFiltered.map(row => row.split(fileOpts.delimiter)); // Parse CSV lines into an array

        const OutputData = {preamble: preambleMetaData || {}, fileType, fileVersion, fileOptions: fileOpts, data: {}};


        for (const key of Object.keys(fileOptions)) {
            OutputData.data[key] = data.map(cells => getters[key](cells));
            if (!OutputData.data[key].some(val => isNumSafe(val))) OutputData.data[key] = null; // If no numeric data found, set to empty array
        }


        return OutputData;
    }


</script>

<script>

    function waitForXLSX() {
        return new Promise((resolve, reject) => {
            const ok = () => window.XLSX ? resolve() : setTimeout(ok, 50);
            ok();
            setTimeout(() => reject(new Error("XLSX failed to load")), 5_000);
        });
    }


    function setMattesColumnWidths(ws) {
        if (!ws['!ref']) return;
        const rng = XLSX.utils.decode_range(ws['!ref']);
        const cols = [];
        for (let c = rng.s.c; c <= rng.e.c; c++) {
            // ka≈æd√° sekce m√° 5 sloupc≈Ø: 0..3 data, 4 mezera
            const inSection = c % 5;
            cols[c] = {wch: (inSection === 4 ? 6 : 12)};
        }
        ws['!cols'] = cols;
    }

    function setSamplesColumnWidths(ws) {
        if (!ws['!ref']) return;
        const rng = XLSX.utils.decode_range(ws['!ref']);
        const cols = [];
        for (let c = rng.s.c; c <= rng.e.c; c++) {
            cols[c] = {wch: c === 0 ? 15 : (c === 2 ? 5 : 8)};
        }
        ws['!cols'] = cols;
    }

    // --- helpers pro Rich Text (subscript) ---
    // parts: [{text:"F"}, {text:"max", sub:true}, {text:"(N)"}]
    function setRich(ws, r, c, parts) {
        const addr = XLSX.utils.encode_cell({r, c});
        const text = parts.map(p => String(p.text ?? "")).join("");

        if (!ws[addr]) ws[addr] = {t: "s"};

        // nastav plain text + rich runs
        ws[addr].t = "s";
        ws[addr].v = text;          // <<< D≈ÆLE≈ΩIT√â (fallback + nƒõkter√© buildy to vy≈æaduj√≠)
        ws[addr].r = parts.map(p => {
            const run = {t: String(p.text ?? "")};
            if (p.sub) run.s = {vertAlign: "subscript"};  // spodn√≠ index
            return run;
        });

        // volitelnƒõ zarovn√°n√≠ a zalomen√≠
        ws[addr].s = ws[addr].s || {};
        ws[addr].s.alignment = {horizontal: "center", vertical: "center", wrapText: true};
    }

    function setRichBaseSub(ws, r, c, base, sub, suffix = "") {
        const parts = [{text: base}, {text: sub, sub: true}];
        if (suffix) parts.push({text: suffix});
        setRich(ws, r, c, parts);
    }


    function ensureRefFromAoa(ws, aoa) {
        if (!ws['!ref']) {
            const rows = aoa.length;
            const cols = (aoa[0] || []).length;
            if (rows && cols) {
                ws['!ref'] = XLSX.utils.encode_range({
                    s: {r: 0, c: 0},
                    e: {r: rows - 1, c: cols - 1}
                });
            }
        }
    }


    async function convertCSVtoXLSX_MATTES() {
        if (isExperimentRunning) return;

        // 1) PICK FILES FIRST ‚Äî BEFORE ANY await
        const files = await pickCsvFiles(); // This returns after the user picks files
        if (!files || !files.length) {
            console.warn("‚ùå No files selected.");
            alert("‚ùå No files were selected. Please select one or more CSV files and try again.");
            return;
        }

        // 2) Now it's safe to await other work
        try {
            await waitForXLSX();
        } catch (e) {
            alert("‚ùå Failed to load XLSX library. Please check the logs and your internet connection and try again.");
            return;
        }

        const mattesMaxLines = 20_000; // Maximum number of lines in one file

        if (!files.length) {
            console.warn("‚ùå No files selected.");
            alert("‚ùå No files were selected. Please select one or more CSV files and try again.");
            return;
        }

        files.sort((a, b) => {
            let nameA = a.name.toLowerCase();
            let nameB = b.name.toLowerCase();

            // Regular expression to extract the base name and optional index
            let regex = /(.*?)(?:\s\((\d+)\))?\.csv$/;

            let matchA = nameA.match(regex);
            let matchB = nameB.match(regex);

            if (!matchA || !matchB) return 0; // Skip if no match

            let baseA = matchA[1]; // Base name
            let indexA = matchA[2] ? parseInt(matchA[2]) : -1; // Index (if present) or -1

            let baseB = matchB[1];
            let indexB = matchB[2] ? parseInt(matchB[2]) : -1;

            // Sort by base name first
            if (baseA !== baseB) return baseA.localeCompare(baseB);

            // Sort by index if base names are the same
            if (indexA === -1) return -1;
            if (indexB === -1) return 1;

            // Sort by index
            return indexA - indexB;
        });

        console.info("üìÇ Sorted files:", files.map(f => f.name)); // Log sorted file names


        const measurementName = files[0].name.replace(/\.csv$/, "").replace(/\s*\(\d+\)\s*$/, "").replace(/^(.*)_(\d+)$/, "$1").trim(); // Measurement name
        let wb = XLSX.utils.book_new(); // Create a new Excel workbook
        let sheetName = ("P-" + measurementName).slice(0, (31 - 8)); // Sheet name

        // ==================== FILES LIST ==================== //

        // TODO: lep≈°√≠ n√°zev promƒõnn√©
        const resultsHead = ["File Order", "File name", "Experiment type", "Material",
            "b (mm)", "h (mm)", "L (mm)", "E (MPa)", "f_m (MPa)",
            "F_max (N)", "w_Fmax (mm)", "œÉ_max (MPa)",
            "F_T (N)", "h_D (mm)", "d_D (mm)", "H_BW (-)"];

        const resultsData = [resultsHead]; // Third sheet data

        // ================== LOADING DATA ================== //

        const formattedData = []; // First sheet data  -   Array to store ALL formatted measurement data
        let columnOffset = 0; // Column shift for each section


        // ================== SAMPLES TABLE ================== //


        const samplesTable = [
            ["Code", "Method", "W", "Number", "Dimensions, weight, before drying", "", "", "", "Dimensions, weight, after drying", "", "", "", "lo \n(mm)"], // row 0
            ["", "", "", "", "hw", "lw", "ww", "mw", "h0", "l0", "w0", "m0", ""], // row 1
            ["", "", "", "", "height \n(mm)", "length \n(mm)", "width \n(mm)", "(g)", "height \n(mm)", "length \n(mm)", "width \n(mm)", "(g)", ""] // row 2
        ];// Second sheet data

        const outputsOpts = {
            time: {key: 'time', unit: 's', precision: 12, columnLimit: 1},
            position: {key: 'dist, disp, position', unit: 'mm', precision: 12, columnLimit: 1},
            force: {key: 'force, load', unit: 'N', precision: 12, columnLimit: null},
        };


        const getMetaValue = (metaData, key, unit = null) => {
            if (!isDict(metaData)) return "";

            if (metaData.hasOwnProperty(key)) {
                let value = metaData[key]?.value || "";
                if (!hasValue(value)) return "";

                const valUnit = metaData[key].unit || null;
                if (isNonEmptyStr(unit) && isNonEmptyStr(valUnit)) value = convertUnits(value, valUnit, unit);

                const isNotInvalidValWrap = (val) => !isInvalidValue(val ,{considerFalse: false});
                return catchVal(value, "", isNotInvalidValWrap);
            }
            return "";
        };

        // ≈°√≠≈ôky sloupc≈Ø podle d√©lky hlaviƒçek
        const PAD = 2;      // rezerva, a≈• to nen√≠ nalepen√©
        const MIN = 6;      // minim√°ln√≠ ≈°√≠≈ôka

        function fitToCols(rows, {pad = 2, min = 6} = {}) {
            const cols = rows[0]?.length ?? 0;
            const out = Array.from({length: cols}, () => ({wch: min}));
            for (let c = 0; c < cols; c++) {
                let maxLen = 0;
                for (let r = 0; r < rows.length; r++) {
                    const v = rows[r][c];
                    const s = isVoid(v) ? "" : String(v);
                    if (s.length > maxLen) maxLen = s.length;
                }
                out[c].wch = Math.max(min, maxLen + pad);
            }
            return out;
        }

        function setNumFmt(colIndex, fmt, data, ws) {
            for (let r = 1; r < data.length; r++) {
                const addr = XLSX.utils.encode_cell({r, c: colIndex});
                const cell = ws[addr];
                if (cell && isNumber(cell.v)) cell.z = fmt; // nap≈ô. "0.00"
            }
        }


        // ----------------- LOOPING THROW CSV FILES ----------------- //
        let fileCount = 0;
        for (let file of files) {
            fileCount++;
            const raw = await file.text();

            const csvData = await getCSVData(raw, outputsOpts, file.name) || {};


            if (!isNonEmptyDict(csvData)) {
                logAndConsoleMessage(`‚ùå Failed to parse file: ${file.name}`, {consoleLevel: 'warn'});
                fileCount--;
                continue;
            }

            const {
                preamble: preambleMetaData = {},
                fileType,
                fileOptions: fileOptionsUsed = {},
                data: parsedData = {}
            } = csvData;


            if (file.name.toLowerCase().includes("tk_005")) {
                console.log(preambleMetaData);
            }


            const samplesInfo = {
                method: 3,  // Method (place 3)
                W: 0,       // W (place 0)
                hw: "",
                lw: "",
                ww: "",
                mw: "",
                h0: "",
                l0: "",
                w0: "",
                m0: "",
                lo: "",     // lo (empty)
            }; // Sample information

            const expResults = {
                experimentType: "", // Experiment type
                material: "",       // Material
                b: "",              // b (mm)
                h: "",              // h (mm)
                L: "",              // L (mm)
                E: "",              // E (MPa)
                f_m: "",            // f_m (MPa)
                F_max: "",          // F_max (N)
                w_Fmax: "",         // w_Fmax (mm)
                sigma_max: "",      // œÉ_max (MPa)
                F_T: "",            // F_T (N)
                h_D: "",            // h_D (mm)
                d_D: "",            // d_D (mm)
                H_BW: ""            // H_BW (-)
            }; // Experiment results


            switch (fileType) {
                case "moira":
                    const calcSettingsInputs = await preambleMetaData.calcSettings.inputs || {};

                    const expInfoV = await preambleMetaData.expSettings?.version || 0;
                    if (expInfoV >= 1) {
                        expResults.experimentType = await preambleMetaData?.experimentLabel || "";
                        expResults.material = getMetaValue(calcSettingsInputs, "inputMaterialName");
                        expResults.b = getMetaValue(calcSettingsInputs, "inputCSWidth", "mm");
                        expResults.h = getMetaValue(calcSettingsInputs, "inputCSHeight", "mm");
                        expResults.L = getMetaValue(calcSettingsInputs, "inputCSLength", "mm");
                        expResults.E = getMetaValue(calcSettingsInputs, "outputModulus", "MPa");
                        expResults.f_m = getMetaValue(calcSettingsInputs, "outputFlexStrength", "MPa");
                        expResults.F_max = getMetaValue(calcSettingsInputs, "outputForceMax", "N");
                        expResults.w_Fmax = getMetaValue(calcSettingsInputs, "outputDisp", "mm");
                        expResults.sigma_max = getMetaValue(calcSettingsInputs, "outputMaxStress", "MPa");
                        expResults.F_T = getMetaValue(calcSettingsInputs, "inputTargetForce", "N");
                        expResults.h_D = getMetaValue(calcSettingsInputs, "outputDepthInd", "mm");
                        expResults.d_D = getMetaValue(calcSettingsInputs, "outputDiameterInd", "mm");
                        expResults.H_BW = getMetaValue(calcSettingsInputs, "outputHardness");
                    }

                    const calcInfoV = await preambleMetaData.calcSettings?.version || 0;
                    if (calcInfoV >= 1) {
                        samplesInfo.hw = getMetaValue(calcSettingsInputs, "inputCSHeight_BeforeDrying", "mm");
                        samplesInfo.lw = getMetaValue(calcSettingsInputs, "inputLength_BeforeDrying", "mm");
                        samplesInfo.ww = getMetaValue(calcSettingsInputs, "inputCSWidth_BeforeDrying", "mm");
                        samplesInfo.mx = getMetaValue(calcSettingsInputs, "inputWeight_BeforeDrying", "g");
                        samplesInfo.h0 = getMetaValue(calcSettingsInputs, "inputCSHeight_AfterDrying", "mm");
                        samplesInfo.l0 = getMetaValue(calcSettingsInputs, "inputLength_AfterDrying", "mm");
                        samplesInfo.w0 = getMetaValue(calcSettingsInputs, "inputCSWidth_AfterDrying", "mm");
                        samplesInfo.m0 = getMetaValue(calcSettingsInputs, "inputWeight_AfterDrying", "g");
                    }

                    break;

                case "moira-legacy":
                    break;

                case "matlab":
                    break;

                case "unknown":
                default:
                    fileCount--;
                    continue;
            }

            const dataLength = fileOptionsUsed.dataLength; // Number of rows in one file


            if (dataLength === 0) {
                logAndConsoleMessage(`‚ùå No data found in file: ${file.name}`, {consoleLevel: 'warn'});
                fileCount--;
                continue;
            }


            if (dataLength > mattesMaxLines) {
                let step;
                if (dataLength - (mattesMaxLines * 0.01) > mattesMaxLines) {
                    Object.entries(parsedData).forEach(([key, arr]) => {
                        parsedData[key] = arr.slice(0, mattesMaxLines);
                    });
                } else {
                    // Data (rows) reduction
                    step = Math.ceil(dataLength / mattesMaxLines);
                    Object.entries(parsedData).forEach(([key, arr]) => {
                        parsedData[key] = arr.filter((_, index) => index % step === 0);
                    });
                }
                const newDataSize = parsedData[Object.keys(parsedData)[0]]?.length || 0;

                logAndConsoleMessage(`‚ùó Too many lines in file: ${file.name} (${dataLength} > ${mattesMaxLines})\n\tData (rows) reduction: ${dataLength} -> ${newDataSize} lines\n${step ? '\tData step:' + String(step) : ''}`);
            }

            const dataSize = parsedData[Object.keys(parsedData)[0]]?.length || 0;


            console.info(file.name, ": üìä Rows in file:", dataLength, "üì¶ Rows to process:", dataSize);


            // ==================== FILES LIST ==================== //

            resultsData.push([
                fileCount,
                file.name.replace(/\.csv$/i, ""),
                expResults.experimentType,
                expResults.material,
                expResults.b,
                expResults.h,
                expResults.L,
                expResults.E,
                expResults.f_m,
                expResults.F_max,
                expResults.w_Fmax,
                expResults.sigma_max,
                expResults.F_T,
                expResults.h_D,
                expResults.d_D,
                expResults.H_BW,
            ]);


            // ================== SAMPLES TABLE ================== //

            samplesTable.push([
                file.name.replace(/\.csv$/i, ""),   // Code
                samplesInfo.method,                 // Method (place 3)
                samplesInfo.W,                      // W (place 0)
                fileCount,                          // Number (file count)
                samplesInfo.hw, samplesInfo.lw,     // hw, lw,
                samplesInfo.ww, samplesInfo.mx,     // ww, mw
                samplesInfo.h0, samplesInfo.l0,     // h0, l0,
                samplesInfo.w0, samplesInfo.m0,     // w0, m0
                samplesInfo.lo                      // lo (empty)
            ]);


            const getTime = (i) => isNonEmptyArr(i) ? i.map(idx => parsedData.time[idx]) : (isNumSafe(i) ? parsedData.time[i] : null);
            const getPosition = (i) => isNonEmptyArr(i) ? i.map(idx => parsedData.position[idx]) : (isNumSafe(i) ? parsedData.position[i] : null);
            const getForce = (i) => isNonEmptyArr(i) ? i.map(idx => parsedData.force[idx]) : (isNumSafe(i) ? parsedData.force[i] : null);

            // ================== LOADING DATA ================== //
            // let firstShiftAbove1 = null; // Track first shift where force > 1 N (for deformation calculation)
            const firstTime = getTime(0); // First time value
            const firstShift = getPosition(0); // First shift value
            const firstForce = getForce(0); // First force value

            // Define headers for this section
            let sectionHeader1 = [], sectionHeader2 = [], sectionHeader3 = [], sectionHeader4 = [];
            sectionHeader1[columnOffset] = fileCount; // Section number
            sectionHeader2[columnOffset] = "Measured values from testing machine";
            sectionHeader3[columnOffset] = "Time";
            sectionHeader3[columnOffset + 1] = "Total distance covered by loading pin";
            sectionHeader3[columnOffset + 2] = "Force";
            sectionHeader3[columnOffset + 3] = "Deformation from F > 1N";
            sectionHeader4[columnOffset] = outputsOpts.time.unit;
            sectionHeader4[columnOffset + 1] = outputsOpts.position.unit;
            sectionHeader4[columnOffset + 2] = outputsOpts.force.unit;
            sectionHeader4[columnOffset + 3] = outputsOpts.position.unit;

            // Ensure headers are fully added for every section
            if (formattedData.length === 0) {
                formattedData.push(sectionHeader1, sectionHeader2, sectionHeader3, sectionHeader4);
            } else {
                formattedData[0][columnOffset] = sectionHeader1[columnOffset];
                formattedData[1][columnOffset] = sectionHeader2[columnOffset];
                formattedData[2][columnOffset] = sectionHeader3[columnOffset];
                formattedData[3][columnOffset] = sectionHeader4[columnOffset];

                // Ensure other section headers also extend fully in the new columns
                for (let i = 0; i < 4; i++) {
                    for (let j = 1; j <= 3; j++) {
                        formattedData[i][columnOffset + j] = [sectionHeader1, sectionHeader2, sectionHeader3, sectionHeader4][i][columnOffset + j];
                    }
                }
            }

            // Add data to the section
            for (let rowIndex = 0; rowIndex < dataSize; rowIndex++) {
                const dataRow = formattedData[rowIndex + 3] || [];

                const time = (getTime(rowIndex) - firstTime) || 0; // Time (s)

                const force = (getForce(rowIndex) - firstForce) || 0; // Force sum

                // if (isVoid(firstShiftAbove1) && force >= 1) firstShiftAbove1 = shift; // Save first shift above 1 N

                const shift = (getPosition(rowIndex) - firstShift) || 0; // Displacement (mm)

                // deformation = isVoid(firstShiftAbove1) ? 0 : (shift - firstShiftAbove1); // Calculate deformation
                const deformation = shift; // Calculate deformation

                dataRow[columnOffset] = time;
                dataRow[columnOffset + 1] = shift;
                dataRow[columnOffset + 2] = force;
                dataRow[columnOffset + 3] = deformation;

                formattedData[rowIndex + 3] = dataRow;
            }

            columnOffset += 5; // Shift by 4 columns + 1 empty column
        }


        if (fileCount === 0 || !isNotEmpty(formattedData)) {
            console.error("\n‚ùå No valid files were processed.");
            alert("‚ùå No valid files were processed. Please check the file formats and try again.");
            return;
        }

        // Create the first sheet with data
        const wsMattes = await XLSX.utils.aoa_to_sheet(formattedData); // Convert data to Excel sheet
        wsMattes["!merges"] = (wsMattes['!merges'] || []);
        // Create the second with file order index
        const wsSamples = await XLSX.utils.aoa_to_sheet(samplesTable, {raw: true});  // Convert data to Excel sheet
        ensureRefFromAoa(wsSamples, samplesTable);
        wsSamples["!merges"] = (wsSamples['!merges'] || []); // Merge cells
        // Create the third sheet with file order index
        const wsResults = await XLSX.utils.aoa_to_sheet(resultsData);  // Convert data to Excel sheet
        ensureRefFromAoa(wsResults, resultsData);


        // wsSamples rich-text
        setRichBaseSub(wsSamples, 1, 4, "h", "w");
        setRichBaseSub(wsSamples, 1, 5, "l", "w");
        setRichBaseSub(wsSamples, 1, 6, "w", "w");
        setRichBaseSub(wsSamples, 1, 7, "m", "w");
        setRichBaseSub(wsSamples, 1, 8, "h", "0");
        setRichBaseSub(wsSamples, 1, 9, "l", "0");
        setRichBaseSub(wsSamples, 1, 10, "w", "0");
        setRichBaseSub(wsSamples, 1, 11, "m", "0");
        setRichBaseSub(wsSamples, 0, 12, "l", "o", "\n(mm)");


        // wsResults rich-text (HEAD)
        setRich(wsResults, 0, 8, [{text: "f"}, {text: "m", sub: true}, {text: " (MPa)"}]);
        setRich(wsResults, 0, 9, [{text: "F"}, {text: "max", sub: true}, {text: " (N)"}]);
        setRich(wsResults, 0, 10, [{text: "w"}, {text: "Fmax", sub: true}, {text: " (mm)"}]);
        setRich(wsResults, 0, 11, [{text: "œÉ"}, {text: "max", sub: true}, {text: " (MPa)"}]);
        setRich(wsResults, 0, 12, [{text: "F"}, {text: "T", sub: true}, {text: " (N)"}]);
        setRich(wsResults, 0, 13, [{text: "h"}, {text: "D", sub: true}, {text: " (mm)"}]);
        setRich(wsResults, 0, 14, [{text: "d"}, {text: "D", sub: true}, {text: " (mm)"}]);
        setRich(wsResults, 0, 15, [{text: "H"}, {text: "BW", sub: true}, {text: " (-)"}]);


        // console.info('WS Results J1 =', wsResults[XLSX.utils.encode_cell({r: 0, c: 9})]);


        columnOffset = 0; // Column shift for each section
        for (let f = 0; f < fileCount; f++) {
            wsMattes["!merges"].push({
                s: {r: 0, c: columnOffset}, e: {r: 0, c: columnOffset + 3} // merge 'fileCount' over 4 columns in line 0
            });
            wsMattes["!merges"].push({
                s: {r: 1, c: columnOffset}, e: {r: 1, c: columnOffset + 3} // merge "Measured values from testing machine" over 4 columns in line 1
            });
            columnOffset += 5; // Shift by 4 columns + 1 empty column
        }


        wsSamples['!merges'].push(
            {s: {r: 0, c: 0}, e: {r: 2, c: 0}}, // Code
            {s: {r: 0, c: 1}, e: {r: 2, c: 1}}, // Method
            {s: {r: 0, c: 2}, e: {r: 2, c: 2}}, // W
            {s: {r: 0, c: 3}, e: {r: 2, c: 3}}, // Number
            {s: {r: 0, c: 4}, e: {r: 0, c: 7}}, // Dimensions before drying
            {s: {r: 0, c: 8}, e: {r: 0, c: 11}}, // Dimensions after drying
            {s: {r: 0, c: 12}, e: {r: 2, c: 12}} // lo (mm)
        );


        const range = XLSX.utils.decode_range(wsSamples['!ref']); // Get table size

        for (let R = range.s.r; R <= range.e.r; ++R) {
            for (let C = range.s.c; C <= range.e.c; ++C) {
                const cellAddress = XLSX.utils.encode_cell({r: R, c: C});
                const cell = wsSamples[cellAddress];
                if (!cell) continue; // Empty cells

                cell.s = cell.s || {};

                // Set cell style
                cell.s = {
                    font: {
                        bold: R <= 2 // First three line in Bold text (0,1,2)
                    },
                    border: {
                        top: {style: "thin", color: {auto: 1}},
                        bottom: {style: "thin", color: {auto: 1}},
                        left: {style: "thin", color: {auto: 1}},
                        right: {style: "thin", color: {auto: 1}}
                    }
                };


                cell.s.alignment = {
                    horizontal: "center",
                    vertical: "center"
                };

                // Bold text for the first three lines if the cell is not empty
                if (R <= 2) {
                    cell.s.font = {bold: true};
                }
            }
        }

        wsResults['!ref'] = XLSX.utils.encode_range(
            {s: {r: 0, c: 0}, e: {r: resultsData.length - 1, c: resultsHead.length - 1}}
        );

        // autofilter p≈ôes hlaviƒçku
        // wsResults['!autofilter'] = {ref: XLSX.utils.encode_range(0, 0, resultsData.length - 1, HEAD.length - 1)};


        setMattesColumnWidths(wsMattes);

        columnOffset = 0; // Column shift for each section
        for (let f = 0; f < fileCount; f++) {
            setNumFmt(columnOffset, "0.000000", formattedData, wsMattes);       // time (s)
            setNumFmt(columnOffset + 1, "0.0000", formattedData, wsMattes);       // position (mm)
            setNumFmt(columnOffset + 2, "0.00", formattedData, wsMattes);         // force (N)
            setNumFmt(columnOffset + 3, "0.0000", formattedData, wsMattes);       // deformation (mm)

            columnOffset += 5; // Shift by 4 columns + 1 empty column
        }


        setSamplesColumnWidths(wsSamples);

        setNumFmt(4, "0.00", samplesTable, wsSamples);       // hw (mm)
        setNumFmt(5, "0.0", samplesTable, wsSamples);        // lw (mm)
        setNumFmt(6, "0.00", samplesTable, wsSamples);       // ww (mm)
        setNumFmt(7, "0.000", samplesTable, wsSamples);      // mw (g)
        setNumFmt(8, "0.00", samplesTable, wsSamples);       // h0 (mm)
        setNumFmt(9, "0.0", samplesTable, wsSamples);        // l0 (mm)
        setNumFmt(10, "0.00", samplesTable, wsSamples);      // w0 (mm)
        setNumFmt(11, "0.000", samplesTable, wsSamples);     // m0 (g)


        wsResults['!cols'] = fitToCols(resultsData, {pad: PAD, min: MIN}); // wsResults['!cols'] = HEAD.map(h => ({wch: Math.max(MIN, h.length + PAD)}));


        setNumFmt(4, "0.00", resultsData, wsResults);      // b (mm)
        setNumFmt(5, "0.00", resultsData, wsResults);      // h (mm)
        setNumFmt(6, "0.00", resultsData, wsResults);      // L (mm)
        setNumFmt(7, "0.000", resultsData, wsResults);     // E (MPa)
        setNumFmt(8, "0.000", resultsData, wsResults);     // f_m (MPa)
        setNumFmt(9, "0.00", resultsData, wsResults);      // F_max (N)
        setNumFmt(10, "0.00", resultsData, wsResults);      // w_Fmax (mm)
        setNumFmt(11, "0.000", resultsData, wsResults);    // œÉ_max (MPa)
        setNumFmt(12, "0.00", resultsData, wsResults);     // F_T (N)
        setNumFmt(13, "0.00", resultsData, wsResults);     // h_D (mm)
        setNumFmt(14, "0.000", resultsData, wsResults);     // d_D (mm)
        setNumFmt(15, "0.000", resultsData, wsResults);    // H_BW (-)


        XLSX.utils.book_append_sheet(wb, wsMattes, sheetName); // Append a sheet to workbook

        XLSX.utils.book_append_sheet(wb, wsSamples, (sheetName + "-objects").slice(0, 31)); // Append a sheet to workbook

        XLSX.utils.book_append_sheet(wb, wsResults, "File Order"); // Append a sheet to workbook

        // Save the file
        XLSX.writeFile(wb, `${measurementName.slice(0, 31)}.xlsx`);
        console.info("‚úÖ Excel file created.");
    }

    function pickCsvFiles() {
        // Prefer showOpenFilePicker when available
        if (window.showOpenFilePicker) {
            // Must be called synchronously from the click; we are.
            return window.showOpenFilePicker({
                multiple: true,
                types: [{
                    description: 'CSV files',
                    accept: {'text/csv': ['.csv']}
                }]
            }).then(async handles => {
                const files = [];
                for (const h of handles) files.push(await h.getFile());
                return files;
            }).catch(err => {
                // User canceled or NotAllowedError‚Äîreturn empty to handle upstream
                return [];
            });
        }

        // Fallback: <input type="file">
        return new Promise(resolve => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv';
            input.multiple = true;

            // Some browsers (Safari) are happier if it's in the DOM.
            input.style.position = 'fixed';
            input.style.left = '-9999px';
            document.body.appendChild(input);

            input.addEventListener('change', () => {
                const files = Array.from(input.files || []);
                document.body.removeChild(input);
                resolve(files);
            }, {once: true});

            input.click(); // still within the user gesture
        });
    }
</script>

<script>

    /**
     * Opens a serial port for communication.
     *  SerialPort => comPort - The selected serial port.
     */
    let machineFirmware = "";
    let machineName = "";
    let machineID = "";
    let fingerprint = null;

    const thymosFingerprints = [
        // "6790:29987",   // Thymos ESP32-S3
        // "6790:29986",   // Thymos ESP32-C3
        // "6790:29985",   // Thymos ESP32-C6
        "12346:4097",   // Thymos ESP32-S2   //  ‚âà "0x303a:0x1001"
    ];
    let useFilteredPort = true;
    let usePortAutoConnect = true;

    let tryCount = 0; // TODO: opravit p≈ôipojov√°n√≠

    // /////// Serial Connection Handling /////////

    /**
     * Starts the Serial (USB) connection by opening the database and initiating the connection.
     */
    async function startSerial(userRequest = true) {
        if (!('serial' in navigator)) {
            alert('This browser do not support serialPorts, try using Chrome/Edge.');
            return;
        }

        await isSerialConnected();

        if (isConnected) {
            console.info("\nüöÄ Stopping application...", "Serial");
            await disconnectSerial();
        } else {
            console.info("\nüöÄ Starting application...", "Serial");
            await connectSerial(userRequest);

        }
    }

    /////////////////////////////////////////////////////////////////

    const serialFunctionGetPorts = async () => {
        try {
            const ports = await navigator.serial?.getPorts();
            return ports.length ? ports : null;
        } catch (error) {
            console.error("Error getting serial ports:", error);
            return null;
        }
    };

    const serialFunctionRequestPort = async () => {
        try {
            return await navigator.serial?.requestPort(
                {
                    // Example: 'xx:yy' => usbVendorId: xx, usbProductId: yy
                    filters: useFilteredPort ? [
                        ...thymosFingerprints.map(fp => {
                            const [vendorId, productId] = fp.split(":").map(id => parseInt(id, 10));
                            return {usbVendorId: vendorId, usbProductId: productId};
                        })
                    ] : []
                }
            );
        } catch (error) {
            if (error.name === "NotFoundError") {
                logAndConsoleMessage("‚ö†Ô∏è No port selected.", {consoleLevel: 'warn'});
                return null;
            } else {
                throw new Error(`Error requesting serial port: ${error.message}`);
            }
        }
    };


    function checkAllPorts() {
        let thymosPorts = [];
        navigator.serial?.getPorts().then(ports => {
            ports?.forEach(port => {
                if (port.manufacturer === "Thymos") {
                    thymosPorts.push(port);
                }
            });


            return thymosPorts
        }).catch(_ => {
            return null
        });
    }


    // /////// Serial (USB) Connection to ESP /////////

    /**
     * Establishes a connection with the ESP device via serial.
     */
    async function connectSerial(userRequest = true) {
        let serialComPort = null;
        await lockConnectionButtons(true);
        await updateConnectionStatus("connecting", "serial");
        try {
            let ports = null;

            if (usePortAutoConnect) {
                ports = await serialFunctionGetPorts();
                console.info("üîç Searching for available ports...");
            }


            if (isArr(ports) && ports.length === 1) {
                serialComPort = ports[0];
                console.info("\t... Only one port found.");

            } else {
                let founds = false;

                if (isArr(ports) && ports.length > 1) {
                    console.info("Multiple ports found. Select one.");

                    // serialComPort = checkAllPorts();

                    for (let port of ports) {
                        if (port.connected) await closePort(port);
                    }
                    founds = true;
                }

                if (userRequest) {
                    if (!serialPort) serialComPort = await serialFunctionRequestPort();
                }

                if (isVoid(serialComPort)) {
                    if (userRequest) {
                        // console.info("\t\t‚ö†Ô∏è No port selected. Connecting canceled.");
                        // await logMessage("\n\t\t‚ö†Ô∏è No port selected. Connecting canceled.");
                    } else {
                        if (founds) {
                            logAndConsoleMessage("‚ö†Ô∏è Multiple ports found, please select one.");
                        } else {
                            logAndConsoleMessage("\n‚ùé No previously connected devices found.");
                        }
                    }

                    console.info("üîå Connecting canceled.");
                    await disconnectSerial({override: true});
                    return;
                }
            }

            if (!serialComPort) throw new Error("No serial port available.");


            await openSerial(serialComPort);

        } catch (error) {

            await handleError(error, "connectSerial");
            await disconnectSerial({override: true});
        }
    }

    async function openSerial(comPort, retry = false) {
        try {
            activeWatchDog = false;

            if (!comPort) {
                logAndConsoleMessage("‚ö†Ô∏è No available port.", {consoleLevel: 'error'});
                return;
            }

            // TODO opravit funkci na odpojov√°n√≠ viz n√≠≈æe + opravit reconnect/disconnect v n√°vaznosti na restartov√°n√≠ za≈ô√≠zen√≠.

            // Get the writer and reader for the port after opening
            const err = await closeComPort();
            if (isNonEmptyDict(err)) {
                console.error("‚ö†Ô∏è Error closing existing port before opening a new one:", err);
            }
            if (comPort.connected) await closePort(comPort, {verbose: false});


            console.info("üîå Opening new port...");
            await openComPort(comPort);

            await logMessage("\n‚úÖ Connected to ESP via Serial\n");

            tryCount = 0;
            reconnectAttempts = 0;

        } catch (error) {
            activeWatchDog = false;
            if (!(error.name === "InvalidStateError" && retry)) {
                await handleError(error, "openSerial");
            }
        }
    }

    async function openComPort(comPort) {
        serialPort = comPort;

        const baudRate = getInputNumDefAbsInt('inputNumBaudRate', 115200);

        await comPort.open({
            baudRate: baudRate,
            // dataBits: 8,
            // stopBits: 1,
            // parity: "none",
            // bufferSize: 255,
            // flowControl: "none"
        });

        serialWriter = comPort.writable.getWriter(); // üî•  writer
        serialReader = comPort.readable.getReader(); // üî•  reader

        isConnected = true;

        await sendCommandGeneral("DATAC 0"); // Stop data collection

        readSerial();

        await checkSerialSignals(comPort);

        await setSerialSignals(comPort, true, false); // Set DTR to true and RTS to false

        await logMessage("\n");

        await sendCommandGeneral("MC STOP"); // Stop movement
        await sendCommandGeneral(`DATA SET INTERVAL ${Math.ceil(clamp(getInputNumDefAbsInt("inputAppInterval", 1), (debugging ? 1 : maxDataPointsIdle * 5_000), convertUnits(2, 'min', '¬µs')))}`); // Stop data collection
        await sendCommandGeneral("DSLR STOP CYCLIC"); // Stop DSLR cyclic

        await sendCommandGeneral("MC ENDSTOPS ENABLE");
        await sendCommandGeneral("MC SET ALARMS ENABLE");

        await logMessage("\n");

        await sendCommandGeneral(`MISC SET WATCHDOG_ENABLED ${0}`);
        await sendCommandGeneral(`MISC SET WATCHDOG_INTERVAL ${Math.ceil(WATCHDOG_INTERVAL_MS)}`); // TODO: check units

        await sendCommandGeneral(`MISC SET USB_CHECK_ENABLED ${1}`);
        await sendCommandGeneral(`MISC SET USB_CHECK_INTERVAL ${Math.ceil(clamp(WATCHDOG_INTERVAL_MS * 0.9, 150, convertUnits(1, 's', 'ms')))}`);

        await logMessage("\n");


        // try {
        //     // 2) Poƒçkat na v≈°echny ‚Äì kdy≈æ jedna chyba, vyhod√≠ se catch
        //     const [r1, r2, r3] = await Promise.all([handShake(), getFingerprint({port: comPort}), setMovement()]);
        //     // 3) Hotovo ‚Äì m≈Ø≈æe≈° nƒõco udƒõlat s v√Ωsledky
        //     await updateConnectionStatus("connected", "serial");
        // } catch (err) {
        //
        // }

        const signal = AbortSignal.timeout(convertUnits(10, 's', 'ms'));
        if (signal.aborted) throw signal.reason ?? new DOMException('Aborted', 'AbortError');
        signal.addEventListener('abort', (ev) => {
            console.info('Canceled!', signal.reason);
        }, {once: true});
        // signal.onabort = (ev) => {
        //     console.info('Canceled!', signal.aborted, signal.reason); // true, p≈ô√≠padnƒõ d≈Øvod
        // };

        try {
            const [r1, r2, r3] = await Promise.all([
                handShake({signal}),
                getFingerprint({port: comPort, signal: signal}),
                setMovement({signal})
            ]);
            if (signal.aborted) throw signal.reason ?? new DOMException('Aborted', 'AbortError');

            await updateConnectionStatus("connected", "serial");
        } catch (e) {
            if (e.name === 'AbortError') {
                console.warn("Operation aborted:", e);
            } else {
                console.error("Error during operations:", e);
            }

            if (allowRawConnect && (serialPort?.connected && serialPort?.readable && serialPort?.writable)) {
                isConnected = true;
                await updateConnectionStatus("connected", "serial");
            } else {
                await disconnectSerial({override: true});
            }
        } finally {
        }
    }

    const abort = (s) => isVoid(s) ? null : (s?.throwIfAborted?.() ?? (s?.aborted && (() => {
        throw new DOMException('Aborted', 'AbortError')
    })()));

    async function handShake({signal = null} = {}) {
        abort(signal);
        try {
            machineName = (await getMachineName(5_000) || "")?.trim();
            abort(signal);
        } catch (e) {
            machineName = null;
            console.error('Name error:', e);
        }
        try {
            machineID = await getMachineID(5_000) || "";
            abort(signal);
        } catch (e) {
            machineID = null;
            console.error('ID error:', e);
        }
        try {
            machineFirmware = (await getFirmwareVersion(5_000) || "")?.toLowerCase().trim();
            abort(signal);
        } catch (e) {
            machineFirmware = null;
            console.error('Firmware error:', e);
        }

        if (!(isOk(machineFirmware) && isOk(machineName) && isOk(machineID))) {
            if (debugging) console.warn("Firmware, Name or ID not read correctly, retrying...");
            if (debugging) console.info(`\nFirmware:  ${machineFirmware} = ${isOk(machineFirmware)}\nName:  ${machineName} = ${isOk(machineName)}\nID:  ${machineID} = ${isOk(machineID)}\n`);

            abort(signal);
            alert("\n‚ö†Ô∏è Device did not respond correctly.");
            await logMessage("\n‚ö†Ô∏è Device did not respond correctly, rebooting and retrying...\n");
            throw new Error("Device not responding");
            // start reconnect procedure
            // if (tryCount === 0) {
            //     abort(signal);
            //     tryCount++;
            //     alert("\n‚ö†Ô∏è Device did not respond correctly.\n\n   FIRST TRY: rebooting and retrying...\n\n   CLICK OK AND PLEASE WAIT...");
            //     await rebootDevice();
            //     await logMessage("\n‚ö†Ô∏è Device did not respond correctly, rebooting and retrying...\n");
            //     await logMessage("   Rebooting via Command.\n");
            //     throw new Error("Device not responding");
            //     // await disconnectSerial({override: true});
            //     // return;
            //
            // } else if (tryCount === 1) {
            //     abort(signal);
            //     tryCount++;
            //     alert("\n‚ö†Ô∏è Device did not respond correctly.\n\n   SECOND TRY: rebooting and retrying...\n\n   CLICK OK AND PLEASE WAIT...");
            //     await logMessage("\n‚ö†Ô∏è Device did not respond correctly, rebooting and retrying...\n");
            //     await logMessage("   Rebooting via DTR toggle.\n");
            //     await setSerialSignals(serialPort, false, false, false); // Set DTR to false
            //     await sleep(250);
            //     await setSerialSignals(serialPort, true, false, false); // Set DTR to true
            //     await sleep(2_500);
            //     throw new Error("Device not responding");
            //     // await disconnectSerial({override: true});
            //     // return;
            //
            // } else {
            //     abort(signal);
            //     console.error("Device not responding after multiple attempts.");
            //     await logMessage("\n‚ùå Failed to connect after multiple attempts. Please check the device.\n");
            //     alert("\n‚ùå Failed to connect after multiple attempts.\n\n   PLEASE CHECK THE DEVICE.\n");
            //     // reconnectAttempts = 1_000; // TODO: or show error and block further retries
            //     await disconnectSerial({override: true});
            //     return;
            // }
        }

        abort(signal);
        // TODO: implement Name-based/ID-based (reconnection)
        const machName = machineName?.toLowerCase();
        if (!isOk(machName) || !isNonEmptyStr(machName) || machName.includes('unnamed')) {
            machineName = 'Thymos_Device-' + Math.random().toString(36).substring(2, 10);
            await setMachineName(machineName);
        }
        if (machineID === 0) {
            machineID = clamp(Math.ceil(Math.random() * 255), 1, 255) * -1;
            await setMachineID(machineID, 1, {overRide: true});
        }

        abort(signal);
        const machineVersionStatus = compareVersions(machineFirmware, "1.2.7");

        if (machineVersionStatus === 0) {
            console.info("%c\n\tüîß\tFirmware is same as supported.", "color: gray; font-weight: bold;");
        } else if (machineVersionStatus === 1) {
            console.warn("%c\n\tüîß\tFirmware is newer than supported!", "color: red; font-weight: bold;");
        } else {
            console.info("%c\n\tüîß\tFirmware is older than supported.", "color: orange; font-weight: bold;");
            alert("\n‚ö†Ô∏è Firmware is older than supported!\n\n   Please consider updating the device firmware to ensure compatibility and access to the latest features.\n");
            throw new Error("Firmware outdated");
            // TODO: implement: confirm(.....) => automatic firmware update procedure
        }

        if (debugging) console.info(`\nü§ñ Machine Info:\n\tüìõ Name: ${machineName}\n\tüÜî ID: ${machineID}\n\tüì¶ Firmware: ${machineFirmware}\n`);

        $ID("inputMachineName").value = machineName;
        $ID("inputMachineID").value = machineID;

        abort(signal);
        const saveSelected = getInputValDef("inputUseMachineSettings", null)

        let userChoiceSave = null;
        let userChoiceLoad = null;

        abort(signal);
        if (saveSelected === 'ask' || saveSelected === 'none') {
            userChoiceLoad = confirm("\n‚úÖ Connected successfully!\n\nDo you want to LOAD previous settings for this device?\n\n   CLICK 'OK' TO LOAD SETTINGS\n   CLICK 'CANCEL' TO KEEP CURRENT SETTINGS");
            userChoiceSave = confirm("\n‚úÖ Connected successfully!\n\nDo you want to SAVE current settings to this device?\n\n   CLICK 'OK' TO SAVE SETTINGS ON DISCONNECT\n   CLICK 'CANCEL' TO NOT SAVE SETTINGS");
        }

        abort(signal);
        if (saveSelected === 'yes_save' || saveSelected === 'no_save' || userChoiceSave === true) storageKeyLoad = `${storageKeyBase}_Device_${machineName}[${machineID}]`.trim().replaceAll(" ", "_");
        else storageKeyLoad = storageKeyIdle;

        // TODO: zdvojen√© (respektive ztrojen√©) pos√≠l√°n√≠ rychlosti a zrychlen√≠, vy≈ôe≈°it t≈ôeba pomoc√≠ lep≈°√≠ho pou≈æit√≠ 'isConnected' nebo jinou logikou
        abort(signal);
        if (saveSelected === 'yes_save' || saveSelected === 'yes_not' || userChoiceLoad === true) await loadInputsFromLocalStorage(settingsInputsLoad, storageKeyLoad);
        await saveAllInputsToLocalStorage(settingsInputsLoad, storageKeyLoad);

        return true;
    }

    async function setMovement({signal = null} = {}) {
        abort(signal);
        // check Calibration status
        calibrationStatus = await getCalibrationStatus(2_000);

        abort(signal);
        await unlockMachineControls();

        if (calibrationStatus) await unlockMovement();
        else await lockMovementExcept(UI.calibrateBtn);

        abort(signal);
        const speed = (await getSpeed(2_000)) || 15;
        const acceleration = (await getAcceleration(2_000)) || 150;

        abort(signal);
        setSpeedAndAcceleration(speed, acceleration, true);

        return true;
    }

    async function getFingerprint({
                                      signal = null,
                                      port = serialPort,
                                      save = true,
                                      storageKey = "lastFingerprint"
                                  } = {}) {
        abort(signal);
        if (!port) return null;

        const {usbVendorId, usbProductId} = port?.getInfo() ?? {};
        if (!usbVendorId || !usbProductId) return null;
        fingerprint = `${Number(usbVendorId)?.toString(10) ?? 'N/A'}:${Number(usbProductId)?.toString(10) ?? 'N/A'}`;

        abort(signal);
        console.info("üë£ Port Fingerprint:\n\t\tusbVendorId:", usbVendorId, "\n\t\tusbProductId:", usbProductId);

        abort(signal);
        if (save) localStorage.setItem(storageKey, fingerprint);
        return {usbVendorId, usbProductId};
    }

    async function checkSerialSignals(port) {
        if (!port) return;

        try {
            const signals = await port?.getSignals();
            console.info("üì° Serial port signals...");
            console.info("\tüö¶ Signals:", signals);
        } catch (error) {
            console.error("‚ùå Error reading serial signals:", error);
        }
    }


    async function setSerialSignals(port, dtrState, rtsState, brkState) {
        if (!port) return;

        try {
            await port?.setSignals({
                dataTerminalReady: dtrState,
                requestToSend: rtsState,
                break: brkState
            });

            console.info("‚úÖ DTR:", dtrState, "RTS:", rtsState, "BRK:", brkState);
        } catch (error) {
            console.error("‚ùå Error setting serial signals:", error);
        }
    }


    /**
     * Disconnects from the ESP device via USB.
     */
    async function disconnectSerial({override = false, verbose = true} = {}) {
        console.info("\nüö™ Disconnecting from Serial...");

        const wasConnected = isConnected;
        isConnected = (serialPort?.connected && serialPort?.readable && serialPort?.writable);

        const connectionLost = wasConnected && !isConnected;
        if (connectionLost) console.warn("%c‚≠ïÔ∏è Connection lost detected.", "color: darkred; font-weight: bold;");

        if (!override && !isConnected) {
            console.warn("‚ö†Ô∏è Port is not connected.");
            return;
        }

        updateConnectionStatus("disconnecting");
        connectionType = null;

        try {
            try {
                if (isExperimentRunning) endMeasuring(0, {
                    overRide: true,
                    ednStatus: connectionLost ? 'lost connection' : 'disconnected',
                    endText: connectionLost ? "üöß Experiment stopped due to lost connection" : "üöß Experiment stopped due to disconnect",
                });

            } catch (error) {
                if (debugging) console.warn("\n‚ö†Ô∏è Error stopping data collection:", error);
            }

            await endedMoving();

            // Stop data reading before releasing the reader
            await closeComPort({override: override, verbose: verbose});

            if (!connectionLost && verbose) await logMessage("‚úñÔ∏è Disconnected from ESP\n\n");
            if (connectionLost && verbose) await logMessage("‚ö†Ô∏è Connection from ESP lost\n\n");

            console.info("%c‚úÖ Disconnected successfully.", "color: #28a745; font-weight: bold;");
        } catch (error) {
            console.error("‚ùå DisconnectSerial error:", error);
        } finally {
            cancelAllPending();
            activeWatchDog = false;
            machineOccupation = false;
            isExperimentRunning = false;
            await saveAllInputsToLocalStorage(settingsInputsLoad, storageKeyIdle);
            await flushDB();
            await resetValues();
            await updateConnectionStatus("disconnected");
            connectionType = null;
            await lockMachineControls();
            await lockConnectionButtons(false);

            // const baudRateInput = $ID('inputNumBaudRate');
            // const baudRateLabel = $(`label[for="inputNumBaudRate"]`);
            // const baudRate = getInputNumDefAbsInt(baudRateInput, 115200);
            // activate(baudRateInput, baudRateLabel, isActive);
        }
    }

    async function closePort(port, {reader = null, writer = null, verbose = false} = {}) {
        if (!port) return;

        const info = (() => {
            try {
                return port?.getInfo();
            } catch {
                return {};
            }
        })();
        if (verbose) console.info("\t‚öì Closing port...", info);

        // 1) Ukonƒçit ƒçten√≠
        try {
            // Preferuj p≈ôedan√©ho readera; jinak pokud je stream locked, pokus se ho uvolnit
            if (reader) {
                try {
                    await reader.cancel();
                } catch {
                }
                try {
                    reader.releaseLock();
                } catch {
                }
                if (verbose) console.info("\t\tüìç Reader canceled & released.");
            } else if (port.readable?.locked) {
                // Nƒõkdo jin√Ω dr≈æ√≠ lock ‚Äì posledn√≠ mo≈ænost√≠ je vytvo≈ôit doƒçasn√©ho readera a hned ho zru≈°it
                const tmp = port.readable.getReader();
                try {
                    await tmp.cancel();
                } catch {
                }
                try {
                    tmp.releaseLock();
                } catch {
                }
                if (verbose) console.info("\tüìç Forced-canceled locked readable.");
            }
        } catch (err) {
            console.warn("‚ö†Ô∏è Error handling reader", info, ":", err);
        }

        // 2) Ukonƒçit z√°pis
        try {
            if (writer) {
                try {
                    await writer.close();
                } catch {/* m≈Ø≈æe b√Ωt u≈æ zav≈ôen√Ω */
                }
                try {
                    writer.releaseLock();
                } catch {
                }
                if (verbose) console.info("\t\tüìç Writer closed & released.");
            } else if (port.writable?.locked) {
                const tmpW = port.writable.getWriter();
                try {
                    await tmpW.close();
                } catch {
                }
                try {
                    tmpW.releaseLock();
                } catch {
                }
                if (verbose) console.info("\tüìç Forced-closed locked writable.");
            }
        } catch (err) {
            console.warn("‚ö†Ô∏è Error handling writer", info, ":", err);
        }

        // 3) Zav≈ô√≠t port
        try {
            try {
                await port.close();
            } catch (e) {
            }
            if (verbose) console.info("\tüìç Port closed.");
        } catch (err) {
            console.warn("‚ö†Ô∏è Error closing port", info, ":", err);
        }
    }


    async function closeComPort({override = false, verbose = true} = {}) {
        const errors = {};

        // 1) Reader
        try {
            if (serialReader) {
                try {
                    await serialReader.cancel();
                } catch {
                }
                try {
                    serialReader.releaseLock();
                } catch {
                }
                if (verbose) console.info("\t‚õèÔ∏è Released Reader...");
            }
        } catch (error) {
            console.warn("‚ö†Ô∏è Error releasing reader:", error);
            errors.reader = error;
        } finally {
            serialReader = null;
        }

        // 2) Writer
        try {
            if (serialWriter) {
                try {
                    await serialWriter.close();
                } catch {
                }
                try {
                    serialWriter.releaseLock();
                } catch {
                }
                if (verbose) console.info("\t‚õèÔ∏è Released Writer...");
            }
        } catch (error) {
            console.warn("‚ö†Ô∏è Error releasing writer:", error);
            errors.writer = error;
        } finally {
            serialWriter = null;
        }

        // 3) Port
        try {
            if (serialPort) {
                // Pokud nƒõkde z≈Østal lock, pokus se ho vynutit
                if (serialPort.readable?.locked) {
                    const r = serialPort.readable.getReader();
                    try {
                        await r.cancel();
                    } catch {
                    }
                    try {
                        r.releaseLock();
                    } catch {
                    }
                }
                if (serialPort.writable?.locked) {
                    const w = serialPort.writable.getWriter();
                    try {
                        await w.close();
                    } catch {
                    }
                    try {
                        w.releaseLock();
                    } catch {
                    }
                }

                if (override || serialPort) {
                    try {
                        await serialPort.close();
                    } catch {
                    }
                    if (verbose) console.info("\t‚õèÔ∏è Closed Serial Port...");
                }
            }
        } catch (error) {
            console.warn("‚ö†Ô∏è Error closing serial port:", error);
            errors.port = error;
        } finally {
            serialPort = null;
            isConnected = false;
        }

        return errors;
    }


    // /////// Reading Data from ESP /////////

    /**
     * Reads incoming data from the ESP device over a serial connection.
     */
    async function readSerial() {
        let buffer = "";
        const decoder = txtD ?? new TextDecoder(); // pokud pou≈æ√≠v√°≈° glob√°ln√≠ txtD, klidnƒõ ho nech

        if (!serialPort?.readable) {
            await logMessage("\n‚ùå Port is unavailable.\n");
            return;
        }

        // Tady u≈æ P≈òEDPOKL√ÅD√ÅME, ≈æe serialReader existuje z openSerial()
        if (!serialReader) {
            // fallback, kdyby p≈ôece jen nebyl
            serialReader = serialPort.readable.getReader();
        }

        try {
            while (isConnected) {
                const {value, done} = await serialReader.read();
                if (done) break;

                buffer += decoder.decode(value, {stream: true});

                const lastNewline = buffer.lastIndexOf("\n");
                if (lastNewline !== -1) {
                    const dataChunk = buffer.slice(0, lastNewline).split("\n");
                    buffer = buffer.slice(lastNewline + 1);
                    // await handleIncomingChunkQueued(dataChunk);
                    await processMessage(dataChunk);
                }
            }
        } catch (error) {
            activeWatchDog = false;
            await handleError(error, "readSerial");
        } finally {
            // doflushnout p≈ô√≠padn√Ω zbytek (pokud to d√°v√° smysl pro tv≈Øj protokol)
            const tail = decoder.decode();
            if (tail) {
                buffer += tail;
                const lines = buffer.split("\n");
                // if (lines.length) await handleIncomingChunkQueued(lines);
                if (lines.length) await processMessage(lines);
            }

            // Bezpeƒçn√© ukonƒçen√≠ readeru
            if (serialReader) {
                try {
                    await serialReader.cancel();
                } catch {
                }
                try {
                    serialReader.releaseLock();
                } catch {
                }
            }

            await logMessage("\n‚úÖ Reading stopped.\n");
        }
    }


    async function findPreferredPortIndex(showMessage = false) {
        if (!fingerprint) {
            console.warn("‚ö†Ô∏è No fingerprint available.");
            return null;
        }
        const ports = await navigator.serial?.getPorts();

        for (let i = 0; i < ports.length; i++) {
            const info = ports[i]?.getInfo();
            const currentFingerprint = `${info.usbVendorId}:${info.usbProductId}`;
            if (currentFingerprint === fingerprint) {
                console.info("‚úÖ Matched port at index:", i);
                return ports[i];
            }
        }

        if (showMessage) logAndConsoleMessage("‚ö†Ô∏è No matching port found.", {consoleLevel: 'warn'});

        return null;
    }

    async function attemptReconnect() {
        // TODO: opravit logiku reconnectu a zmen≈°it pokusy na 3
        console.info("%c\nüîÑ Attempting to reconnect...", "color: blue; font-weight: bold;");

        if (isConnected || isReconnecting) {
            console.warn("\nüöß Reconnect aborted - Already connected or disconnect was expected.");
            return;
        }

        if (reconnectAttempts >= maxReconnectAttempts) {
            console.warn("\n‚ö†Ô∏è Stopping auto-reconnect. Maximum attempts reached.");
            await logMessage("\n‚ö†Ô∏è Stopping auto-reconnect.\n");
            isReconnecting = false;
            await disconnectSerial();
            await resetValues();
            return;
        }

        // Reset the connection status
        // await serialReader.cancel();
        // await serialReader.releaseLock();
        // await serialPort.close();
        // serialReader = null;
        // serialPort = null;

        isConnected = false;
        await disconnectSerial({override: true, verbose: false});

        // TODO: opravit;
        return;


        activeWatchDog = false;
        isReconnecting = true;
        reconnectAttempts++;
        await updateConnectionStatus("reconnecting");
        await logMessage(`\nüîÑ Attempting reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);

        try {

            // TODO: implement also using machine name
            const port = await findPreferredPortIndex();

            if (port) {
                serialPort = port; // Update the serialPort reference
                await openSerial(port, true);
            }


            if (isConnected) {
                console.info("‚úÖ Reconnected successfully!");
                isReconnecting = false;
                await updateConnectionStatus("connected");
                await logMessage("‚úÖ Reconnected successfully!\n");
                await unlockMachineControls();
            } else {
                throw new Error("Reconnect failed: not connected after openPort");
            }
        } catch (error) {
            console.warn("\n‚ö†Ô∏è Reconnection failed:", error);
            await logMessage("\n‚ùå Reconnection failed: " + error.message);

            if (reconnectAttempts < maxReconnectAttempts) {
                setTimeout(() => {
                    isReconnecting = false; // Allow another reconnection attempt
                    attemptReconnect();
                }, 3_000);
            } else {
                console.warn("\n‚ö†Ô∏è Max reconnect attempts reached. Reconnecting stopped.");
                await logMessage("\n‚ùå Max reconnect attempts reached. Reconnecting stopped.\n");
                await resetValues();
                isReconnecting = false;
            }
        }
    }


    async function isSerialAvailable() {
        if (!('serial' in navigator)) {
            alert('This browser do not support serialPorts, try using Chrome/Edge.');
            return;
        }
        try {
            const ports = await navigator.serial.getPorts();
            return true
        } catch (error) {
            console.error("Error checking serial ports:", error);
            return false;
        }
    }

    async function isPortsAvailable() {
        try {
            const ports = await navigator.serial.getPorts();
            return ports.length > 0;
        } catch (error) {
            console.error("Error checking serial ports:", error);
            return false;
        }
    }

    async function availablePorts() {
        try {
            const ports = await navigator.serial.getPorts();
            return ports.length;
        } catch (error) {
            console.error("Error checking serial ports:", error);
            return 0;
        }
    }

    async function grantSerialOnce() {
        if (!('serial' in navigator)) throw new Error('Web Serial is not supported');
        try {
            await navigator.serial.requestPort();
        } catch { /* u≈æivatel zru≈°il */
        }
    }

    async function isSerialConnected() {
        if (!serialPort) {
            isConnected = false;
            return false;
        }
        try {
            await serialPort.getSignals();
            isConnected = true;
            return true;
        } catch (error) {
            isConnected = false;
            return false;
        }
    }

    /////////////////////////////////////////////////////////////////

    // Web Serial API - connect event - auto connect to Thymos devices
    if ('serial' in navigator) {
        navigator.serial.addEventListener('connect', e => {
            if (isConnected) return;

            const port = e?.target;
            const portInfo = port?.getInfo(); // TODO: upravit, ≈æe jich m≈Ø≈æe b√Ωt v√≠ce (teƒè kontrola posledn√≠ho p≈ôipojen√©ho)
            const lastFingerPrint = localStorage.getItem("lastFingerprint") || null;

            const THYMOS_USB_INFOS = [...[...thymosFingerprints, lastFingerPrint].map(fp => {
                if (!isNonEmptyStr(fp)) return null;
                const [vendorId, productId] = fp.split(":").map(id => parseInt(id, 10));
                return {usbVendorId: vendorId, usbProductId: productId};
            })
            ];

            const THYMOS_DEVICES = [];

            if (THYMOS_USB_INFOS.some(info => isNonEmptyDict(info) && info.usbVendorId === portInfo.usbVendorId && info.usbProductId === portInfo.usbProductId)) {
                THYMOS_DEVICES.push(port);
            }

            if (THYMOS_DEVICES.length === 0) return;

            console.info(`%c\nüëÄ ${THYMOS_DEVICES.length > 1 ? THYMOS_DEVICES.length : 'A'} Thymos device${THYMOS_DEVICES.length > 1 ? 's' : ''} has been connected.`, "color: gray; font-weight: bold;");

            const autoConnectSetting = getInputValDef("inputAutoConnect", 'never')?.toLowerCase();

            if (THYMOS_DEVICES.length === 1) {
                if (autoConnectSetting === 'always') startSerial(false);
                else if (autoConnectSetting === 'ask') if (confirm("Thymos device connected. Do you want to connect?")) startSerial(true);

            } else if (THYMOS_DEVICES.length > 1) {
                if (autoConnectSetting === 'always' || autoConnectSetting === 'ask') if (confirm("Multiple Thymos devices connected. Do you want to connect?")) startSerial(true);
            }
        });
    }

</script>

<script>

    async function startBluetooth(userRequest = true) {
        if (!('bluetooth' in navigator)) {
            alert('This browser do not support Bluetooth, try using Chrome/Edge.');
            return;
        }

        if (isConnected) {
            console.info("\nüöÄ Stopping application...", "Bluetooth");
            await disconnectBluetooth();
        } else {
            console.info("\nüöÄ Starting application...", "Bluetooth");
            await connectBluetooth(userRequest);

        }
    }

    function connectBluetooth(userRequest = true) {
        alert('Bluetooth connection is not yet implemented.');
    }

    function disconnectBluetooth() {
        alert('Bluetooth disconnection is not yet implemented.');
    }

</script>

<script>

    async function startWIFI(userRequest = true) {

        if (isConnected) {
            console.info("\nüöÄ Stopping application...", "WiFi");
            await disconnectWIFI();
        } else {
            console.info("\nüöÄ Starting application...", "WiFi");
            await connectWIFI(userRequest);

        }
    }

    function connectWIFI(userRequest = true) {
        alert('WiFi connection is not yet implemented.');

        // fetch('http://192.168.4.1/status', { // http://esp32.local/api/thing
        //     method: 'GET',
        //     headers: {'Content-Type': 'application/json'},
        // }).then(r => r.json())
        //     .then(data => console.info('ESP response:', data))
        //     .catch(err => console.error('Connection error:', err));
    }

    function disconnectWIFI() {
        alert('WiFi disconnection is not yet implemented.');
    }

    // let ws;
    //
    // function connect(ip) {
    //     // pokud str√°nku serv√≠ruje≈° p≈ôes HTTPS, mus√≠≈° pou≈æ√≠t WSS (viz pozn√°mky n√≠≈æe)
    //     const url = `ws://${ip}/ws`;
    //     ws = new WebSocket(url);
    //
    //     ws.addEventListener('open', () => logMessage('WS open'));
    //     ws.addEventListener('message', (e) => logMessage('WS in:', e.data));
    //     ws.addEventListener('close', () => logMessage('WS closed'));
    //     ws.addEventListener('error', (e) => logMessage('WS error', e.message || ''));
    //
    //     // jednoduch√Ω heartbeat: ka≈æd√Ωch 20 s ping
    //     const ping = setInterval(() => {
    //         if (ws && ws.readyState === WebSocket.OPEN) ws.send('{"ping":1}');
    //         else clearInterval(ping);
    //     }, 20_000);
    // }
    //
    // document.getElementById('connect').onclick = () => {
    //     const ip = prompt('ESP IP (nap≈ô. 192.168.1.50)'); // nebo 192.168.4.1 pro AP
    //     if (ip) connect(ip.trim());
    // };
    //
    // document.getElementById('send').onclick = () => {
    //     if (ws && ws.readyState === WebSocket.OPEN) {
    //         ws.send(JSON.stringify({cmd: "move", x: 10}));
    //     } else {
    //         logMessage('WS not open');
    //     }
    // };
    //
    // function autoConnect(url) {
    //     let ws;
    //     const connect = () => {
    //         ws = new WebSocket(url);
    //         ws.onopen = () => console.info('open');
    //         ws.onclose = () => setTimeout(connect, 2000); // reconnect za 2 s
    //     };
    //     connect();
    //     return () => ws && ws.close();
    // }

</script>

<script>

    function resetValues() {
        parsedData = {
            time: null,
            position: null,
            speed: null,
            force: Array(catchVal(loadCellNum, 0, isNumSafe)).fill(null),
            photoIndex: null
        };
        measurementParts = measurementPartDefault;
        chartUpdate(false);

        isExperimentRunning = false;
        machineOccupation = false;
        UI.loadingLogContainer.style.background = "#323232";

        maxDataPoints = maxDataPointsIdle;

        experimentEndLimits = {position: null, force: null, time: null};
        expControl = '';
        pendingDSLR = null;
        dataCount = null;
        maxForces = Array(catchVal(loadCellNum, 0, isNumSafe)).fill(null);
        measureForces = Array(catchVal(loadCellNum, 0, isNumSafe)).fill(null).map(() => []);
        tareValues.force = Array(catchVal(loadCellNum, 0, isNumSafe)).fill(0);
        tareValues.position = null;
        UI.returnBtn.classList.add('disabled'); // TODO: sp√°rovat 'tareValues.position' s classlist tlaƒç√≠tka 'UI.returnBtn' p≈ôes REACT
        tareValues.time = null;
        lastAcceptedTime = null;
        aggregatedDataBetweenSteps = [];
        Object.values(measurement_limits).forEach(v => {
            v.counter = 0;
            v.limit = null;
        });
        endMeasurement = false;
        clearTimeout(endMeasurementCounter)
        endMeasurementCounter = null;
        checkSpeed = true;


        displacementSignCorrection = 0;
        loadSignCorrections = Array(catchVal(loadCellNum, 0, isNumSafe)).fill(0);

        loadcellErrRate = [];
        measurementErrRate = [];
        totalErrRate = [];

        calibrationStatus = false;

        activeWatchDog = false;

        isConnected = false;
        serialPort = null;
        serialReader = null;
        serialWriter = null;


        storageKeyLoad = storageKeyIdle;
        machineFirmware = "";
        machineName = "";
        machineID = "";
        // fingerprint = null;
        // tryCount = 0;
        // reconnectAttempts = 0;
    }

    async function clearAndResetAll() {
        await showPreloaderScreen(true);

        console.clear();

        if (isExperimentRunning) {
            await endMeasuring(0, {overRide: true, ednStatus: 'reset', endText: "üöß Experiment stopped due to reset"});
            await sleep(2_000); // wait for proper ending
        }
        stopMachine();
        await chartUpdate(false);
        await clearCharts();
        await clearConsoleLog();
        await clearDatabase();

        await unregisterServiceWorkers();


        // Remove all other saved data from local storage
        Object.keys(localStorage).forEach(key => (key.startsWith(storageKeyBase)) ? localStorage.removeItem(key) : null);


        await isSerialConnected();

        if (isConnected) {
            await setSerialSignals(serialPort, true, true);

            await resetMemoryDevice(500);

            await rebootDevice(1_000);

            await sleep(500);
        }

        await disconnectSerial({override: true, verbose: true});


        await resetValues();
        fingerprint = null;
        tryCount = 0;
        reconnectAttempts = 0;


        timeData = [];
        positionData = [];
        forceData = Array(catchVal(loadCellNum, 0, isNumSafe)).fill(null).map(() => []);

        timeDataChart = [];
        positionDataChart = [];
        forceDataChart = Array(catchVal(loadCellNum, 0, isNumSafe)).fill(null).map(() => []);
        photoDataChart = [];
        dataCount = 0;

        // Experiment parameters
        // --------------------------------
        speedForward_mmps = 0;
        currentSpeed = null;
        currentAcceleration = null;
        takePhotos = false;
        dataInterval_us = null;
        experimentHoldConstantForce = false;
        stoppingForceLimit = null;
        holdForceTimeMs = null;
        loadcellsInfo = {presentLoadcells: [], loadcellsIDX: [], capacities: [], outputs: []};
        checkSpeed = true;
        timer = null;
        // --------------------------------


        window.location.reload();
    }

</script>

<script>

    function showPreloaderScreen(show = false) {
        const preloadScreen = $ID('preloadScreen');
        if (!preloadScreen) return;
        if (show) {
            preloadScreen.style.display = 'flex';
            preloadScreen.style.opacity = "1";
            document.body.style.overflowY = "hidden";
            if (debugging) console.info("%cPreloader screen shown.", "color: gray; font-style: italic;");
            return;
        }

        preloadScreen.getBoundingClientRect(); // force reflow
        preloadScreen.style.opacity = "0";
        document.body.style.overflowY = "auto";

        preloadScreen.addEventListener('transitionend', () => {

            // preloadScreen?.remove();
            preloadScreen.style.display = "none";

            if (debugging) console.info("%cPreloader screen hidden.", "color: gray; font-style: italic;");
        }, {once: true});
    }

</script>

<script>
    const activate = (input, label, active) => {
        if (active) {
            // disable photo interval input
            input.classList.remove("disabled");
            input.readOnly = false;
            input.tabIndex = 1;

            // disable photo interval input label
            label.classList.remove("disabled");
        } else {
            // disable photo interval input
            input.classList.add("disabled");
            input.readOnly = true;
            input.tabIndex = -1;

            // disable photo interval input label
            label.classList.add("disabled");
        }
    }

</script>


<script>

    // vyt√°hne typ ze suffixu hodnoty (oddƒõlovaƒçe - _ / mezera)
    const typeFrom = s =>
        (String(s || '').toLowerCase().match(/(?:^|[-_\/\s])(inb|hbr|flx)$/)?.[1]) || '';

    // rozparsuje data-eq-type na inkluze/exkluze; podporuje "HB,IB", "HB|IB", "HB IB", "HB/IB", "-HBR"
    const parseEqRule = attr => {
        const tokens = String(attr || '')
            .split(/[,\s;|/]+/)
            .map(t => t.trim().toLowerCase())
            .filter(Boolean);

        const includes = new Set();
        const excludes = new Set();

        for (const t of tokens) {
            if (t.startsWith('-')) {
                const x = t.slice(1).trim();
                if (x) excludes.add(x);
            } else {
                includes.add(t);
            }
        }
        return {includes, excludes};
    };

    // vyhodnot√≠ shodu se zvolen√Ωm typem
    const matchesRule = (rule, selType) => {
        const hasIncl = rule.includes.size > 0;
        const hasExcl = rule.excludes.size > 0;

        if (hasIncl) {
            return rule.includes.has(selType);
        }
        if (hasExcl) {
            return !rule.excludes.has(selType);
        }

        return true; // Empty rule matches all
    };

    const matchLevel = (el, sysLevel = systemLevel) => {
        const elSysVal = el.getAttribute('data-system-level')?.toLowerCase().trim();

        if (isNonEmptyStr(elSysVal)) {
            const elLevel = elSysVal.split('-');
            const valLevel = parseInt(elLevel[0]);
            const valLevelTop = catchVal(parseInt(elLevel[1]), Number.POSITIVE_INFINITY, isNumSafe);

            const visible = (elLevel[0] === 'all' || (valLevel <= sysLevel && sysLevel < valLevelTop));

            return {sys: elSysVal, visible: visible};
        }
        return {sys: null, visible: true};
    };

    function manageElementsVisibilities(elements, {
        selectedValue = ($ID("experimentTypeDropdown").value || '').toLowerCase(),
        setLevel = systemLevel,
        doBubbles = true
    } = {}) {

        elements = checkArray(elements);

        if (!(isNonEmptyArr(elements) || isNonEmptyNodeList(elements))) {
            console.warn("manageElementsVisibilities: 'elements' is not an array or NodeList.");
            return;
        }
        if (!isNonEmptyStr(selectedValue)) {
            console.warn("manageElementsVisibilities: 'selectedValue' is not a non-empty string.");
            return;
        }
        if (!isNumSafe(setLevel)) {
            console.warn("manageElementsVisibilities: 'setLevel' is not a number.");
            return;
        }
        if (!isBool(doBubbles)) {
            console.warn("manageElementsVisibilities: 'doBubbles' is not a boolean.");
            return;
        }

        elements.forEach(el => {
            manageElementVisibility(el, {
                selectedValue: selectedValue,
                setLevel: setLevel,
                doBubbles: doBubbles
            });
        });

        window.dispatchEvent(new Event('resize', {bubbles: true}));
    }

    function manageElementVisibility(el, {
        selectedValue = ($ID("experimentTypeDropdown").value || '').toLowerCase(),
        setLevel = systemLevel,
        doBubbles = false
    } = {}) {

        const selectedType = typeFrom(selectedValue); // "inb" | "hbr" | "flx" | ""
        const rule = parseEqRule(el.dataset.eqType);

        const isType = matchesRule(rule, selectedType);
        const {sys: elLevel, visible: isLevel} = matchLevel(el, setLevel);

        const isVisible = isType && isLevel;

        el.classList.toggle(((isNonEmptyStr(elLevel) && elLevel.endsWith('v') && !isType) ? 'invisible' : 'undisplayed'), !isVisible);

        if (!isVisible && doBubbles === true) {
            $$('input', el)?.forEach(input => {
                // input.value = '';
                input.dispatchEvent(new Event("change", {bubbles: true}));
            });
        }
    }
</script>


<script>

    // -------------------- Global variables --------------------
    let systemLevel = 0;

    let connectionType = null; // 'serial' | 'bluetooth' | 'wifi' | null

    let initialAllLoaded = false;
    let initialPageLoaded = false;
    let initialDataLoaded = false;

    let lastTitle = document.title;


    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////


    let calibrationStatus = false;
    let currentSpeed = null;
    let currentAcceleration = null;

    /////////////////////////////////////////////////////////////////


    // Store dataset
    let timeDataChart = [];
    let positionDataChart = [];
    let forceDataChart = Array(catchVal(loadCellNum, 0, isNumSafe)).fill(null).map(() => []);
    let photoDataChart = []; // List of time markers
    let dataCount = 0;

    let timeData = [];
    let positionData = [];
    let forceData = Array(catchVal(loadCellNum, 0, isNumSafe)).fill(null).map(() => []);

    let notificationsAllowed = false;

    let lockInterim = false

    let allowRawConnect = false

    /////////////////////////////////////////////////////////////////

    // -------- Local Storage Keys ------ //
    const storageKeyBase = "MoiraUIData";                    // Base-name of Key in localStorage
    const storageKeyDefaults = `${storageKeyBase}_Defaults`; // System Defaults Key in localStorage (all)
    const storageKeyIdle = `${storageKeyBase}_Idle`;         // User Defaults Key in localStorage (some)
    const storageKeySys = `${storageKeyBase}_Sys`;           // User-System Defaults Key in localStorage (rest)
    let storageKeyLoad = storageKeyIdle;                     // Current Key in localStorage

    // -------- IndexedDB Setup -------- //
    const DB_NAME = "MoiraMeasurementData";// Database name
    const STORE_NAME = "LastLog";// Store name for saving log entries
    let db;// Database instance

</script>


<script>

    let allSettingsInputs;
    let appSettingsWrapper;

    let settingsInputsLoad;
    let settingsInputsSys;


    // ===============================================
    // -------------------- Init --------------------
    // ===============================================

    document.addEventListener("DOMContentLoaded", function () {
        // start at top of page
        try {
            history.scrollRestoration = 'manual';
        } catch {
        }
        window.scrollTo(0, 0);
        document.body.style.overflowY = "hidden";

        showPreloaderScreen(true);

        openDB();

        UI = {
            regularLogContainer: $ID("regularLog"),// Reference to the log display container
            loadingLogContainer: $ID("loadingLog"),// Reference to the loading log display container
            toggleScrollBtn: $ID("toggleScrollBtn"), // Button to toggle automatic scrolling
            lineLockBtn: $ID("toggleLineLockBtn"), // Button to lock the log view
            commandInput: $ID('commandInput'),// Input elements for command entry and settings
            sendButton: $ID('sendButton'),// Input elements for command entry and settings

            chartsLiveButton: $ID('toggleLiveGraph'),// Input elements for command entry and settings
            connectionStatus: $ID("connectionStatus"), // Display for connection status
            connectBtns: $$(".connectBtn"), // Container for connection buttons
            connectElement: $$(".connectElement"), // Container for connection buttons
            Serial: $ID("connectBtnSerial"), // Button to connect via Serial
            Bluetooth: $ID("connectBtnBluetooth"), // Button to connect via Bluetooth
            WiFi: $ID("connectBtnWiFi"), // Button to connect via WiFi

            progressBar: $ID("experimentProgress"), // Progress bar for experiment status
            progressLabel: $ID("experimentProgressLabel"), // Label for progress percentage
            experimentStageLabel: $ID("experimentStage"), // Label for current experiment stage

            timeChartContainer: $ID("timeChart"),
            positionChartContainer: $ID("positionChart"),
            chartsContainer: $ID("chartsContainer"),

            autoReturnPosition: $ID("autoReturnPositionExperiment"),
            autoReturnPositionLabel: $ID("autoReturnPositionExperimentLabel"),

            moveUpBtn: $ID("moveMachineUP"), // Button to move the device up
            moveDownBtn: $ID("moveMachineDOWN"), // Button to move the device down
            moveUp50Btn: $ID("moveUp50"), // Button to move the device up
            moveDown50Btn: $ID("moveDown50"), // Button to move the device down

            returnBtn: $ID("returnPositionExperimentBtn"), // Button to return to the starting position


            moveToBtn: $ID("moveToBtn"), // Button to move to a specific position
            moveToInput: $ID("moveToInput"), // Input field for target position

            calibrateBtn: $ID("calibrateBtn"), // Button to calibrate the device

            speedSlider: $ID("movementSpeed"), // Slider for speed adjustment
            speedLabel: $ID("labelSpeed"), // Label for speed value
            accelerationSlider: $ID("movementAcceleration"), // Slider for acceleration adjustment
            accelerationLabel: $ID("labelAcceleration"), // Label for acceleration value
        };

        resetValues();

        // Load the saved theme from localStorage on initialization
        const savedTheme = localStorage.getItem("theme") || "light";
        if (exists('darkModeButton')) $ID('darkModeButton').innerText = savedTheme === "dark" ? "‚òÄÔ∏è Light mode" : "üåô Dark mode"
        document.body.dataset.theme = savedTheme;

        renderLoadcells(loadCellNum);

        movementElements = Array.from($$(".movementControlElement"));
        controlElements = Array.from($$(".controlElement"));
        machineElements = Array.from($$(".machineControlElement"));
        allSettingsInputs = Array.from($$("input, select")).filter(el => !isSkippable(el));
        appSettingsWrapper = $ID('appSettingsSection');

        settingsInputsLoad = allSettingsInputs.filter(el => !appSettingsWrapper.contains(el));
        settingsInputsSys = allSettingsInputs.filter(el => appSettingsWrapper.contains(el));  // TODO: or use data-system="app"

        lockMachineControls();

        lockConnectionButtons(true);

        bindCloseHandler();

        UI.Serial.addEventListener("click", async () => startSerial());
        UI.WiFi.addEventListener("click", async () => startWIFI());
        UI.Bluetooth.addEventListener("click", async () => startBluetooth());

        // Event listener for the save button
        $$(".saveDataBtns")?.forEach(btn => btn?.addEventListener("click", saveCSV));

        // Attach live update toggle to button
        UI.chartsLiveButton.addEventListener("click", async () => chartUpdate());

        // Event listener for page visibility change
        document.addEventListener("visibilitychange", async () => await handlePageVisibility());

        // /////// Logging Messages /////////
        visibleLines = Math.floor(UI.loadingLogContainer.clientHeight / 16);
        UI.loadingLogContainer.style.fontFamily = "monospace";
        UI.loadingLogContainer.style.fontSize = "14px";
        UI.loadingLogContainer.style.overflow = "hidden";

        // ------------ Auto-scroll ------------
        UI.toggleScrollBtn.addEventListener('click', async () => {
            isAutoScroll = !isAutoScroll;
            UI.toggleScrollBtn.classList.toggle('active', isAutoScroll);
            UI.toggleScrollBtn.textContent = `üìå Auto-scroll: ${isAutoScroll ? "ON" : "OFF"}`;
            if (isAutoScroll) {
                UI.regularLogContainer.scrollTop = UI.regularLogContainer.scrollHeight;
            }
        });

        // Detects manual scrolling by the user
        UI.regularLogContainer.addEventListener('scroll', () => {
            if (rafId) return;
            rafId = requestAnimationFrame(() => {
                const atBottom = checkScrolledToBottom();
                if (atBottom !== lastAutoScroll) {
                    lastAutoScroll = atBottom;
                    isAutoScroll = atBottom;
                    UI.toggleScrollBtn.textContent = `üìå Auto-scroll: ${atBottom ? "ON" : "OFF"}`;
                    UI.toggleScrollBtn.classList.toggle('active', atBottom);
                }
                rafId = null;
            });
        }, {passive: true}); // scroll je sice necancelovateln√Ω, ale passive=hint

        // ------------ Command Input Handling ------------
        // Listens for the Enter key in the command input field and sends command
        UI.commandInput.addEventListener("keydown", async (event) => {
            if (event.key === "Enter") {
                event.preventDefault();
                await sendCommandConsole(getElementValue(UI.commandInput));
            }
        });

        // Sends command when clicking the send-button
        UI.sendButton.addEventListener('click', async () => {
            await sendCommandConsole(getElementValue(UI.commandInput));
        });

        // /////// Event Listeners for UI Buttons /////////
        // These were commented out, but they could be used to attach click events
        (() => {
            const addControlContainer = (name) => {
                const btn = $ID(name + "OpenBtn");
                const el = $ID(name);
                btn?.addEventListener('click', async () => controlContainer(btn, el));
                window.addEventListener('resize', async () => controlContainerWidth(el));
            };

            addControlContainer("resultsContainer");
            addControlContainer("settingsContainer");
            addControlContainer("consoleContainer");
        })();


        bindCopyAdjustButtons();


        // ===== Ovl√°dac√≠ logika tlaƒç√≠tka =====
        const btnLoadCSV = $ID("btnLoadSettings");
        const inputLoadCSV = $ID("appFileInput");

        inputLoadCSV.addEventListener("change", async (e) => {
            if (isExperimentRunning) return;
            const file = e.target.files?.[0];
            if (!file) return;
            await processFile(file);
            inputLoadCSV.value = ""; // reset pro dal≈°√≠ v√Ωbƒõr stejn√©ho souboru
        });

        btnLoadCSV.addEventListener("click", async () => {
            if (isExperimentRunning) return;
            if ("showOpenFilePicker" in window) {
                try {
                    const [handle] = await window.showOpenFilePicker({
                        types: [{description: "CSV", accept: {"text/csv": [".csv"]}}],
                        excludeAcceptAllOption: false,
                        multiple: false
                    });
                    const file = await handle.getFile();
                    await processFile(file);
                    return;
                } catch (e) {
                    if (e?.name === "AbortError") return; // u≈æivatel zru≈°il
                    console.warn("showOpenFilePicker failed, falling back to <input type=file>:", e);
                }
            }
            // fallback
            inputLoadCSV.click();
        });

        // #TODO do better disabling of elements //////////////////////////////////////////////////
        $$('.prohibited')?.forEach(element => {
            element.readOnly = true;

            element.addEventListener("selectstart", async (e) => e.preventDefault());
            element.addEventListener("mousedown", async (e) => e.preventDefault());
            element.addEventListener("keydown", async (e) => e.preventDefault());
        })

        if (!isNumSafe(loadCellNum)) throw new Error(`Total Loadcell count is not defined: ${loadCellNum}`);

        const levelElements = $$('[data-system-level]');
        $ID('systemLevelSelect').addEventListener('change', (event) => {
            const selectedLevel = event.target.value.toLowerCase().trim();
            switch (selectedLevel) {
                case 'minimal':
                    systemLevel = 1;
                    break;
                case 'basic':
                    systemLevel = 50;
                    break;
                case 'standard':
                    systemLevel = 100;
                    break;
                case 'advanced':
                    systemLevel = 200;
                    break;
                case 'expert':
                    systemLevel = 300;
                    break;
                case 'emergency':
                    systemLevel = 400;
                    break;
                case 'admin':
                    systemLevel = 600;
                    break;
                case 'operator':
                    systemLevel = 700;
                    break;
                case 'service':
                    systemLevel = 800;
                    break;
                case 'developer':
                    systemLevel = 999;
                    break;
                case 'god':
                    systemLevel = 1000;
                    break;
                default:
                    systemLevel = 0;
            }


            document.body.setAttribute('data-system-level', selectedLevel);
            console.info(`\n\t‚öôÔ∏è Selected System-level: ${selectedLevel} (${systemLevel})`);

            manageElementsVisibilities(levelElements);

            if (!isExperimentRunning && liveUpdate && systemLevel === 0) chartUpdate();

            // TODO: udƒõlat p≈ôes observer
            const consoleLine = getElement('consoleLineWrapper');
            // remove/add consoleLine in machineElements/controlElements
            if (systemLevel < 300) {  // expert
                if (!machineElements.includes(consoleLine)) machineElements.push(consoleLine);
            } else {
                machineElements = machineElements.filter(el => el !== consoleLine);
            }
            if (systemLevel < 700) {  // operator
                if (!controlElements.includes(consoleLine)) controlElements.push(consoleLine);
            } else {
                controlElements = controlElements.filter(el => el !== consoleLine);
            }
            if (systemLevel < 300) consoleLine.classList.toggle('disabled', (isDisabled(machineElements[0]) || isDisabled(controlElements[0])));
            else if (systemLevel < 700) consoleLine.classList.toggle('disabled', isDisabled(controlElements[0]));
            else consoleLine.classList.remove('disabled');
        });


        $ID('inputStopForce')?.addEventListener('change', async (event) => applyAdjust('inputTargetForce', event.target.value));

        if (exists("inputLoadingTime")) adjustSet('inputLoadingTime', 15);
        if (exists("inputIndDiameter")) adjustSet('inputIndDiameter', 10);

        bindRecalcOnInputs();

        (() => {
            const allButtons = $$('button');

            allButtons?.forEach(button => {
                // block right-click context menu on buttons
                button.addEventListener('contextmenu', event => event.preventDefault());
            });
        })();

        // Listen for changes in all inputs
        settingsInputsLoad?.forEach(input => {
            input.addEventListener("change", async (event) => saveInputToLocalStorage(event, storageKeyLoad));
        });
        settingsInputsSys?.forEach(input => {
            input.addEventListener("change", async (event) => saveInputToLocalStorage(event, storageKeySys));
        });


        Array.from($$("input, select")).filter(el => el.matches('[id][data-unit]')).forEach((input) => {
            // Use examples:
            //      <input id="a" data-unit="m/s^2">
            //      <!-- -> (m/s<sup>2</sup>) -->
            //
            //      <input id="b" data-unit="CO_2">
            //      <!-- -> (CO<sub>2</sub>) -->
            //
            //      <input id="c" data-unit="10^{‚àí3} mol¬∑L^{‚àí1}">
            //      <!-- -> (10<sup>‚àí3</sup> mol¬∑L<sup>‚àí1</sup>) -->
            //
            //      <input id="d" data-unit="[sup]2[/sup]¬∑m">
            //      <!-- -> (<sup>2</sup>¬∑m) -->
            //
            //      <!-- pokud chce≈° ps√°t p≈ô√≠mo HTML, v atributu pou≈æij entity: -->
            //      <input id="e" data-unit="m/s&lt;sup&gt;2&lt;/sup&gt;">
            //      <!-- -> (m/s<sup>2</sup>) -->

            renderUnitsLabel(input);

            // Pokud by se data-unit mƒõnilo dynamicky, hl√≠dej zmƒõnu atributu:
            const mo = new MutationObserver((muts) => {
                for (const m of muts) {
                    if (m.type === 'attributes' && m.attributeName === 'data-unit') {
                        renderUnitsLabel(input);
                    }
                }
            });
            mo.observe(input, {attributes: true, attributeFilter: ['data-unit']});
        });

        // Initialization of uPlot charts
        timeChart = createChart("timeChart", ["Time (s)", "Force 1", "Force 2", "Force 3"], "Force-Time", "Time [s]", "Force [N]");
        positionChart = createChart("positionChart", ["Position (mm)", "Force 1", "Force 2", "Force 3"], "Force-Position", "Position [mm]", "Force [N]");


        $ID("experimentName")?.addEventListener("change", async (event) => {
            const countInput = $ID("experimentCount");
            if (countInput && countInput.value !== '1') {
                blinkBorder(countInput, {restart: true});
                countInput.value = 1;
            }
            await updateLogById(0, {experimentName: event.target.value.trim()});
        });

        $ID("experimentCount")?.addEventListener("change", async (event) => {
            blinkBorder(event.target, {
                restart: true,
                color: '#2196F3',
                backgroundOn: '#a7e7ff',
                blinks: 2,
            });
        });

        $ID("experimentDesc")?.addEventListener("change", async (event) => {
            await updateLogById(0, {experimentDescription: event.target.value.trim()});
        });

        // === Experiment Data Saving ===
        $ID("startExperiment")?.addEventListener('click', async () => startExperiment());

        $ID("stopMachine")?.addEventListener('click', async () => stopMachine('user'));

        $ID("inputLoadLimitDropPercent")?.addEventListener('change', async (event) => {
            // forceLimitDropPercent = parseFloat(event.target.value) / 100;
        });
        $ID("inputLoadLimitDropValue")?.addEventListener('change', async (event) => {
            // forceLimitDropValue = parseFloat(event.target.value);
        });


        $ID("inputTakePhotos")?.addEventListener('change', async (event) => {
            const isActive = event.target.checked;
            const photosInput = $ID("inputPhotoInterval");
            const photosLabel = $(`label[for="inputPhotoInterval"]`);
            activate(photosInput, photosLabel, isActive);
            if (timeChart) timeChart.setSeries(loadCellNum + 1, {show: isActive});
            if (positionChart) positionChart.setSeries(loadCellNum + 1, {show: isActive});
        });

        $ID("inputDoCycles")?.addEventListener('change', async (event) => {
            const cyclesInput = $ID("inputCycles");
            const cyclesLabel = $(`label[for="inputCycles"]`);
            activate(cyclesInput, cyclesLabel, event.target.checked);
        });

        for (let i = 1; i <= (loadCellNum); i++) {
            $ID(`activateLoadcell${i}`)?.addEventListener('change', async (event) => {
                const isActive = event.target.checked;
                const capInput = $ID(`inputLoadcellCapacity${i}`);
                const capLabel = $(`label[for="inputLoadcellCapacity${i}"]`);
                const outInput = $ID(`inputLoadcellOutput${i}`);
                const outLabel = $(`label[for="inputLoadcellOutput${i}"]`);
                activate(capInput, capLabel, isActive);
                activate(outInput, outLabel, isActive);
                if (timeChart) timeChart.setSeries(i, {show: isActive});
                if (positionChart) positionChart.setSeries(i, {show: isActive});
            });
        }


        $ID("clearChartBtn")?.addEventListener("click", async () => clearCharts());

        // TODO:  $$$("saveChartBtn")?.addEventListener("click", async () => saveChartsAsPNG());

        $ID("reloadChartBtn")?.addEventListener("click", async () => reloadCharts());

        $ID("convertCSV")?.addEventListener("click", async () => convertCSVtoXLSX_MATTES());

        $ID("clearCalculationsButton")?.addEventListener("click", async () => clearCalculations());

        $ID("inputLockInterimCalculations")?.addEventListener("change", async (event) => {
            lockInterim = event.target.checked;
            // // readOnly for all inputs in 'interimCalcWrapper'
            // $$('#interimCalcWrapper input')?.forEach(input => {
            //     input.readOnly = lockInterim;
            // });
            recomputeAllCalculations();
        });

        $ID("inputRawConnection")?.addEventListener("change", async (event) => allowRawConnect = event.target.checked);

        $ID("darkModeButton")?.addEventListener("click", async () => toggleDarkMode());

        // Open in current tab:     window.location.href = 'about.html'
        // Open in new tab:         window.open('about.html', '_blank', 'noopener,noreferrer')
        // Open in new window:      window.open('about.html', '_blank', 'noopener,noreferrer,width=800,height=600')

        $ID("aboutButton")?.addEventListener("click", async () => window.open('about.html', '_blank', 'noopener,noreferrer'));

        $ID("updateMachButton")?.addEventListener("click", async () => {
            // const preloadScreen = $ID("preloadScreen");
            // preloadScreen.style.display = "flex";
            // preloadScreen.style.opacity = "1";

            // TODO: script communication => name, ID, port info, ...

            await disconnectSerial({override: true});
            await sleep(100);
            window.location.href = './update.html';
        });

        $ID("rebootButton")?.addEventListener("click", async () => await rebootDevice());

        $ID("clearStorageButton")?.addEventListener("click", async () => {
            if (confirm("‚ö†Ô∏è This will clear all settings and disconnect from the machine.\n\n     Are you sure?")) {
                await clearLocalStorage();
            }
        });

        $ID("clearAllButton")?.addEventListener("click", async () => {
            if (confirm("‚ö†Ô∏è This will clear all Data and disconnect from the machine.\n\n     Are you sure?")) {
                await clearAndResetAll();
            }
        });

        $ID("exportSettingButton")?.addEventListener("click", async () => exportSettings());

        $ID("importSettingButton")?.addEventListener("click", async () => importSettings());

        $ID("toggleLineLockBtn")?.addEventListener("click", async () => lineConsoleLock());

        $ID("clearRegularLog")?.addEventListener("click", async () => clearConsoleLog());

        // TODO: $$$("saveRegularLog")?.addEventListener("click", async () => saveLogAsText());

        const machNameInput = $ID("inputMachineName");
        const machIDInput = $ID("inputMachineID");
        $ID("sendMachineNameBtn")?.addEventListener("click", async () => setMachineName(getInputValDef(machNameInput, '')));
        $ID("sendMachineIDBtn")?.addEventListener("click", async () => setMachineID(getInputValDef(machIDInput, '')));

        $ID("inputAppInterval")?.addEventListener("change", async (event) => (!isExperimentRunning && isConnected) ? await sendCommandGeneral(`DATA SET INTERVAL ${getInputNumDefAbsInt(event.target.value, 5_000)}`) : null);

        $ID("recomputeAllBtn")?.addEventListener("click", async () => recomputeAllCalculations());

        machNameInput?.addEventListener("change", async (event) => {
            const val = event.target.value.trim();
            if (val === '') {
                if (isOk(machineName)) event.target.value = machineName;
                return;
            }
            if (isNonEmptyStr(val) && isOk(val)) {
                event.target.value = val;
                await sleep(3_500);
                if (isOk(machineName)) event.target.value = machineName;
            }
        });
        machIDInput?.addEventListener("change", async (event) => {
            const val = event.target.value.trim();
            if (val === '') {
                if (isOk(machineID)) event.target.value = machineID;
                return;
            }
            const num = clamp(toInteger(val), 1, 255);
            if (isNumSafe(num)) {
                event.target.value = num;
                await sleep(3_500);
                if (isOk(machineID)) event.target.value = machineID;
            }
        });


        machNameInput?.addEventListener("keydown", async (event) => {
            if (event.key === "Enter") {
                await setMachineName(getInputValDef(machNameInput, ''));
            }
        });

        machIDInput?.addEventListener("keydown", async (event) => {
            if (event.key === "Enter") {
                await setMachineID(getInputValDef(machIDInput, ''));
            }
        });


        function attachHoldHandlers(element, onStart) {
            let isHolding = false;

            const start = async () => {
                if (isHolding) return;
                isHolding = true;
                lockMovementExcept(element);  // zamkni v≈°e krom pr√°vƒõ dr≈æn√©ho
                await beganMoving();          // spust√≠ watchdog
                onStart();
            };

            const stop = async () => {
                if (!isHolding) return;
                isHolding = false;
                await softStopMachine();          // po pu≈°tƒõn√≠ zastav a ukonƒçi pohyb
            };

            // My≈°
            element.addEventListener("mousedown", start);
            element.addEventListener("mouseup", stop);
            element.addEventListener("mouseleave", () => {
                if (isHolding) stop();
            });

            // Dotyk
            element.addEventListener("touchstart", start, {passive: true});
            element.addEventListener("touchend", stop);
            element.addEventListener("touchcancel", stop);
        }


        attachHoldHandlers(UI.moveUpBtn, async () => sendMoveCommand("MC HOME")); // TODO: probl√©m s rychlostmi na konci
        attachHoldHandlers(UI.moveDownBtn, async () => sendMoveCommand("MC END")); // TODO: probl√©m s rychlostmi na konci


        UI.returnBtn.addEventListener('click', async () => moveToOriginalPosition());

        UI.moveUp50Btn.addEventListener("click", async () => moveBy(-50));  // TODO: probl√©m s rychlostmi na konci a zrychlen√≠m
        UI.moveDown50Btn.addEventListener("click", async () => moveBy(50));  // TODO: probl√©m s rychlostmi na konci a zrychlen√≠m


        UI.calibrateBtn.addEventListener("click", async () => {
            calibrationStatus = false;
            machineOccupation = true;
            await lockMovement();
            await lockConnectionButtons(true);

            await sendCommandGeneral('MC ENDSTOPS ENABLE');
            await sendCommandGeneral(`MISC SET WATCHDOG_ENABLED ${0}`);
            await sendCommandGeneral('MC CALIBRATE');

            let confirmCalibrationCount = 0;
            // maximal 1 minute
            const maxConfirmCalCount = 60 / 2.5;

            while (!calibrationStatus && isConnected && machineOccupation === true) {
                await sleep(2_500);
                calibrationStatus = await getCalibrationStatus(500);
                if (!isConnected) {
                    calibrationStatus = false;
                    logAndConsoleMessage("‚ö†Ô∏è Serial connection lost during calibration.", {consoleLevel: 'warn'});
                    break;
                }
                if (confirmCalibrationCount > maxConfirmCalCount) {
                    calibrationStatus = false;
                    await logMessage("‚ùå Calibration timeout reached. Please check the machine.\n\tMotors are not calibrated.");
                    console.error("‚ùå Calibration timeout.\n\tCalibration failed.");
                    break;
                }
                confirmCalibrationCount++;
            }
            if (calibrationStatus) await unlockMovement();
            if (!calibrationStatus) await lockMovementExcept(UI.calibrateBtn);
            await lockConnectionButtons(true, connectionType);
        });


        // Set both elements' limits to match
        [[UI.speedSlider, UI.speedLabel], [UI.accelerationSlider, UI.accelerationLabel]]?.forEach(pair => {
            pair[1].min = pair[0].min;
            pair[1].max = pair[0].max;
            pair[1].value = pair[0].value;
            pair[1].step = pair[0].step;

            pair[1].dispatchEvent(new Event("input", {bubbles: true}));
        });

        $$('.sliderInputLabel')?.forEach(input => {
            input.addEventListener("change", (event) => {
                checkInput(event.target, 'floatInput', 2);
                const slider = $ID(event.target.id.replaceAll("label", "movement"));
                const value = parseFloat(event.target.value).toFixed(2); // Round to 2 decimal places
                if (slider) {
                    slider.value = value;
                    event.target.value = value; // Update the input value to match the slider
                    slider.dispatchEvent(new Event("change", {bubbles: true})); // Trigger input event to update the slider
                }
                x
            });
        });

        // Attaches validation checks to numeric inputs
        $$("input[type=number]")?.forEach(input => {
            input.addEventListener("change", async (event) => {
                checkInput(event.target, event.target.dataset.inputType);
            });
            input.addEventListener("keydown", async (event) => {
                if (event.key === "Enter") {
                    checkInput(event.target, event.target.dataset.inputType);
                    event.target.blur();
                }
            });
        });

        const decSymbolElement = $ID('decimalSymbol');
        const delimSymbolElement = $ID('delimiterSymbol');

        decSymbolElement.addEventListener("change", (event) => {
            const isValueComma = event.target.value === "Option-Comma";
            const currentValue = delimSymbolElement.value;
            const commaOptions = $$('option[value="Option-Comma"]', delimSymbolElement);
            if (isValueComma) {
                commaOptions?.forEach(o => o.disabled = true);
            } else {
                commaOptions?.forEach(o => o.disabled = false);
            }
            if (isValueComma === currentValue) {
                delimSymbolElement.value = "Option-Semicolon";
                delimSymbolElement.dispatchEvent(new Event("change", {bubbles: true}));
            }
        });
        delimSymbolElement.addEventListener("change", (event) => {
            const isValueComma = event.target.value === "Option-Comma";
            const currentValue = decSymbolElement.value;
            const commaOptions = $$('option[value="Option-Comma"]', decSymbolElement);
            if (isValueComma) {
                commaOptions?.forEach(o => o.disabled = true);
            } else {
                commaOptions?.forEach(o => o.disabled = false);
            }
            if (isValueComma === currentValue) {
                decSymbolElement.value = "Option-Dot";
                decSymbolElement.dispatchEvent(new Event("change", {bubbles: true}));
            }
        });


        // Sliders
        UI.speedSlider.addEventListener("input", () => {
            currentSpeed = roundDecimalFast(getInputNumDef(UI.speedSlider.value, 15), precisionSpeedSystem);
            UI.speedLabel.value = `${currentSpeed.toFixed(precisionSpeedSystem)}`;
        });
        UI.speedSlider.addEventListener("change", async () => isConnected ? sendCommandGeneral(`MC SET SPEEDMM ${UI.speedSlider.value}`) : null);

        UI.accelerationSlider.addEventListener("input", () => {
            currentAcceleration = roundDecimalFast(getInputNumDef(UI.accelerationSlider.value, 150), precisionAccelerationSystem);
            UI.accelerationLabel.value = currentAcceleration.toFixed(precisionAccelerationSystem);
        });
        UI.accelerationSlider.addEventListener("change", async () => isConnected ? sendCommandGeneral(`MC SET ACCELMM ${UI.accelerationSlider.value}`) : null);

        // pouze ty .data-eq, kter√© maj√≠ data-eq-type
        const experiment_result_elements = $$("[data-eq-type]");
        $ID("experimentTypeDropdown")?.addEventListener("change", async (event) => {

            manageElementsVisibilities(experiment_result_elements);
            // ------------------------------------------------------------------------

            requestAnimationFrame(() => {
                controlContainerWidth($ID("resultsContainer"));
            });
        });


        saveAllInputsToLocalStorage(allSettingsInputs, storageKeyDefaults);

        // Load saved data when the page loads
        loadInputsFromLocalStorage(settingsInputsLoad, storageKeyIdle);
        loadInputsFromLocalStorage(settingsInputsSys, storageKeySys);


        Notification.requestPermission().then(permission => {
            if (permission === "granted") {
                notificationsAllowed = true;
            }
        });

        setTimeout(() => window.dispatchEvent(new Event('resize', {bubbles: true})), 0);

        initialPageLoaded = true;
    });


    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////


    // /////// Page Initialization /////////

    /**
     * Runs when the page loads.
     * - Logs a message to the console.
     * - Loads available commands from the JSON file.
     */
    window.onload = async () => {

        while (!(initialPageLoaded && initialDataLoaded)) await sleep(200);

        // await loadCommands();

        const serialAllowed = await isSerialAvailable();
        const portsCount = (serialAllowed ? await availablePorts() : 0) || 0;

        const preloadScreen = $ID("preloadScreen");
        const autoConnectSetting = getInputValDef("inputAutoConnect", 'never')?.toLowerCase();

        if (serialAllowed && portsCount === 1 &&
            (autoConnectSetting === 'always' || autoConnectSetting === 'beginning')) await startSerial(false);
        else await updateConnectionStatus("disconnected");

        const anyDataLoaded = isNonEmptyArr(timeData);

        if (anyDataLoaded) {
            console.info("\t\n‚ÑπÔ∏è %cPrevious log loaded.", "color: #0078d7; font-style: italic; font-weight: normal;");
            recomputeAllCalculations();
            for (let i = 1; i <= (loadCellNum + 1); i++) { // TODO: udƒõlat dle aktivn√≠ch loadcell
                if (timeChart) timeChart.setSeries(i, {show: true});
                if (positionChart) positionChart.setSeries(i, {show: true});
            }
            await logMessage("\n‚ÑπÔ∏è Found previous unsaved logged data.\n");
        } else {
            console.info("\t\n*Ô∏è‚É£ %cNo previous log found.", "color: #0078d7; font-style: italic; font-weight: normal;");
            $ID("experimentName").value = "";
            $ID("experimentDesc").value = "";
            await clearCalculations();
            await clearCharts();

            setSpeedUI(0);
            setAccelerationUI(0);
        }

        if (anyDataLoaded) alert("\n‚ÑπÔ∏è Found previous unsaved logged data.\n     It has been successfully loaded into the charts.\n\n     You can now save it as a CSV file if desired.");

        await showPreloaderScreen(false);

        preloadScreen?.addEventListener('transitionend', async () => {

            if (serialAllowed && !isConnected) {
                if (
                    (portsCount >= 1 && autoConnectSetting === 'ask') ||
                    (portsCount > 1 && (autoConnectSetting === 'always' || autoConnectSetting === 'beginning'))
                ) {
                    if (confirm(`${portsCount > 1 ? 'Multiple machines' : 'Machine'} found. Do you want to connect?`)) await startSerial(false);
                }
            }

            await sleep(500); // Let user see the app

            if (!serialAllowed) {
                await alert("‚ö†Ô∏è Please make sure to grant Serial Port permission for full functionality."); // {okOnly: true}
                await sleep(1_000); // Let user read the alert
                await grantSerialOnce();
            }

            if (!notificationsAllowed) {
                await alert("‚ö†Ô∏è Please allow Notifications for full functionality."); // {okOnly: true}
                await sleep(1_000); // Let user read the alert
                await showNotification("Test", "This is test notification to check if notifications are working.");
            }

            console.info("\n‚úÖ %cApplication fully loaded.", "color: #28a745; font-style: italic; font-weight: normal;");

            await sleep(25);
            initialAllLoaded = true;

        }, {once: true});

    }

    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////


</script>

</body>
</html>
