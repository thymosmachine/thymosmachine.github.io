<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Moira controller</title>

    <!--
          __  __       _                          __ _
         |  \/  |     (_)                        / _| |
         | \  / | ___  _ _ __ __ _     ___  ___ | |_| |___      ____ _ _ __ ___
         | |\/| |/ _ \| | '__/ _` |   / __|/ _ \|  _| __\ \ /\ / / _` | '__/ _ \
         | |  | | (_) | | | | (_| |   \__ \ (_) | | | |_ \ V  V / (_| | | |  __/
         |_|  |_|\___/|_|_|  \__,_|   |___/\___/|_|  \__| \_/\_/ \__,_|_|  \___|


    -->
    <!-- https://patorjk.com/software/taag/#p=display&f=Big -->


    <meta name="description"
          content="Moira Controller: Open Source software for controlling scientific experiments and machines.">
    <meta name="author" content="Matƒõj Porubsk√Ω, Czech Republic">
    <meta name="keywords"
          content="Moira, Controller, Thymos, Machine, Control, Software, Experiment, Science, Standards, Open Source">


    <script>
        const softwareVersion = "0.0.2.0";
        const softwareDate = "06.10.2025";

        // Initial title
        const initialTitle = 'ŒúŒø·øñœÅŒ±‚ÄáController‚Äá-‚ÄáThymos';


        document.title = initialTitle;

        // Clear console - Fresh start
        console.clear();
        console.info(`%c\n\nMoira Controller - Thymos\n`, "color: #007bff; font-size: 20px; font-weight: bold;");
        console.info(`%c\n\nVersion: ${softwareVersion} , Release-date: ${softwareDate}\n\nApp inicialization: ${(new Date().toLocaleString()).replaceAll(". ", ".")}\n`, "color: gray; font-size: 12px; font-weight: normal;");


        fetch("shared-header.html")
            .then(res => res.text())
            .then(html => document.head.insertAdjacentHTML("beforeend", html));
    </script>

    <!-- External libraries: -->
    <!-- uPlot -->
    <link rel="stylesheet" href="packages/uplot/uPlot.min.css"> <!-- Add uPlot CSS for styling -->
    <script defer src="packages/uplot/uPlot.iife.min.js"></script> <!-- Add uPlot JavaScript -->

    <!-- XLSX -->
    <script async src="packages/xlsx/xlsx.full.min.js"></script> <!-- Add XLSX (MS Excel) JavaScript -->
    <!--    <script async src="https://unpkg.com/xlsx-js-style/dist/xlsx.bundle.js"></script>-->

    <!-- ZIP -->
    <!--    <script async src="packages/zip/jszip.min.js"></script> &lt;!&ndash; Add JSZip JavaScript &ndash;&gt;-->

    <!-- KaTeX -->
    <!-- source: "https://cdn.jsdelivr.net/npm/katex@0.16.9/" -->
    <link rel="stylesheet" href="packages/katex/katex.min.css">
    <script defer src="packages/katex/katex.min.js"></script>
    <script defer src="packages/katex/auto-render.min.js"></script>
    <script>
        // automatic rendering: inline \( ‚Ä¶ \) a $ ‚Ä¶ $, block \[ ‚Ä¶ \]
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "\\(", right: "\\)", display: false},
                    // {left: "$", right: "$", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ],
                ignoredTags: ["script", "noscript", "style", "textarea", "pre", "code", "kbd", "samp"],
                ignoredClasses: ["katex", "katex-display", "no-math"],
            });
        });
    </script>


    <script>
        /**
         * Zkus√≠ naƒç√≠st "debug.txt" (nebo libovolnou URL) a vyhodnot√≠, zda obsah je "true".
         * - Soubor neexistuje / 404 / chyba -> false
         * - Obsah po o≈ô√≠znut√≠ a bez BOM je "true" (case-insensitive) -> true
         * - Jinak -> false
         */
        async function checkDebugFlag(url = 'debug.txt', {timeoutMs = 5000, bustCache = true} = {}) {
            // Timeout p≈ôes AbortController (ochrana proti vis√≠c√≠m request≈Øm)
            const controller = new AbortController();
            const t = setTimeout(() => controller.abort(), timeoutMs);

            // Volitelnƒõ rozb√≠t cache p≈ôid√°n√≠m query parametru
            const finalUrl = bustCache ? `${url}${url.includes('?') ? '&' : '?'}_=${Date.now()}` : url;

            try {
                const res = await fetch(finalUrl, {
                    method: 'GET',
                    // no-store, aby se nevracela star√° verze (pokud m√°≈° server, kter√Ω to respektuje)
                    cache: 'no-store',
                    headers: {'Accept': 'text/plain'},
                    signal: controller.signal
                });

                if (!res.ok) {
                    // nap≈ô. 404 -> false
                    return false;
                }

                let text = await res.text();
                clearTimeout(t);

                // Odstra≈à BOM, o≈ô√≠zni whitespace
                text = text.replace(/^\uFEFF/, '').trim().toLowerCase();

                // true/TRUE/True atd.
                return text === 'true' || text === 'y' || text === 'yes';
            } catch {
                // s√≠≈•ov√° chyba, timeout, CORS atp. -> false
                clearTimeout(t);
                return false;
            }
        }

        let debugging = false;

        (async () => {
            debugging = await checkDebugFlag(); // hled√° "debug.txt" vedle str√°nky
            console.info(`%c\nDebug mode ${debugging ? 'ON' : 'OFF'}`, "color: orange; font-size: 16px; font-weight: bold;");
            const debugWrapper = await document.getElementById('debuggingWrapper');

            if (debugging) {
                debugWrapper.style.display = 'flex';
                document.querySelector('html').style.background = 'lightcoral';


                // load 'scripts/testingScript.js'
                const script = document.createElement('script');
                script.src = './scripts/testingScript.js';
                script.type = 'text/javascript';
                document.head.appendChild(script);

            } else {
                debugWrapper?.remove();
                document.querySelector('html').style.background = 'none';
            }
        })();


    </script>

    <!--    <script type="text/plain" src="./scripts/appState.js"></script>-->

    <script>
        Object.defineProperty(window, "softwareVersion", {
            value: softwareVersion,
            writable: false,
            configurable: false,
            enumerable: true
        });

        async function hasInternet(timeout = 3000) {
            const ctrl = new AbortController();
            const t = setTimeout(() => ctrl.abort(), timeout);
            try {
                const res = await fetch(`/ping.txt?ts=${Date.now()}`, {
                    method: 'HEAD',
                    cache: 'no-store',
                    signal: ctrl.signal
                });
                return res.ok;
            } catch {
                return false;
            } finally {
                clearTimeout(t);
            }
        }

        // try {
        //     // Check if the File System Access API is supported
        //     if ('showDirectoryPicker' in window) {
        //         console.info("‚úÖ File System Access API is supported.");
        //     } else {
        //         console.error("‚õî File System Access API is not supported.");
        //     }
        // } catch (error) {
        //     console.error("‚õî Error checking File System Access API support:", error);
        // }

        function compareVersions(versionA, versionB) {
            const a = versionA.trim().split('.').map(Number);
            const b = versionB.trim().split('.').map(Number);
            const maxLength = Math.max(a.length, b.length);

            for (let i = 0; i < maxLength; i++) {
                const numA = a[i] || 0; // missing parts are treated as 0
                const numB = b[i] || 0;

                if (numA > numB) return 1;  // A is newer
                if (numA < numB) return -1; // B is newer
            }
            return 0; // Versions are equal
        }

        let reallyOnline;


        async function loadCurrentVersion() {
            if (!reallyOnline) return;

            try {
                // Try to load the latest version of the app from the latest.txt [server]
                fetch(`/latest.txt?ts=${Date.now()}`, {
                    cache: "no-store"
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error("Network response was not ok");
                        }
                        return response.text();
                    })
                    .then(data => {
                        // Trim the data to remove any extra spaces or newlines and take the first line
                        const latestVersion = data.split("\n")[0].trim();
                        const appStatus = compareVersions(softwareVersion, latestVersion);

                        if (appStatus === 0) {
                            console.info("%c\n\tüîß\tApp is upto date!", "color: blue; font-weight: bold;");
                        } else if (appStatus === 1) {
                            console.warn("%c\n\tüîß\tAvaileble version is older than App!", "color: red; font-weight: bold;");
                        } else {
                            console.info("%c\n\tüîß\tNew version is availeble!", "color: orange; font-weight: bold;");
                        }

                        if (appStatus !== 0) {
                            document.getElementById("updateHeader").style.visibility = "visible";
                            document.getElementById("updateHeaderVersion").innerText = `[from: v${softwareVersion} to v${latestVersion}]`;
                        }
                    })
                    .catch(error => {
                        console.error("‚õî Error fetching latest version:", error);
                    });
            } catch (error) {
                console.error("‚õî Error checking File System Access API support:", error);
            }
        }

        // is online?
        document.addEventListener("DOMContentLoaded", async () => {
            reallyOnline = await hasInternet();
            if (reallyOnline) {
                console.info("%cüì∂ Ping successful. User is Online! üåê", "color: blue; font-weight: bold;");

                document.getElementById("softwareInfo").innerText = `v${softwareVersion} , ${softwareDate}`;

                await loadCurrentVersion();              // a≈• si klidnƒõ z≈Østane async
            } else {
                console.info("%cüì¥ Offline.", "color: gray; font-weight: bold;");
            }
        });
    </script>


    <style>
        :root {
            --blue-dark-color: #004aa6;
            --blue-color: #007bff;
            --blue-lighter-color: #2196F3;
            --blue-light-color: #4CA2FF;
            --green-color: #28a745;
            --green-light-color: #68C17C;
            --green-lighter-color: #90EE90;
            --red-color: #dc3545;
            --red-light-color: #E6717C;
            --red-lighter-color: #FFB6C1FF;
            --yellow-color: #FFD580;
            --orange-color: #ffc107;
            --darkorange-color: #FF8C00;
            --cyan-color: #17a2b8;
            --cyan-light-color: #3FC1E8;
            --cyan-lighter-color: #87CEEB;
            --purple-color: #6f42c1;
            --purple-light-color: #9B59B6;
            --purple-lighter-color: #D2B4DE;
            --pink-color: #e83e8c;
            --pink-light-color: #FF69B4;
            --pink-lighter-color: #FFB6C1;
            --light-color: #f8f9fa;
            --mid-color: #e9ecef;
            --mid-dark-color: #adb5bd;
            --dark-color: #ced4da;
            --dark-light-color: #495057;
            --darker-color: #343a40;
            --gray-color: #6c757d;


            --progressPrimary-color: linear-gradient(to right, var(--cyan-lighter-color), var(--cyan-light-color), var(--cyan-color)); /* Blue color for secondary progress */
            --progressSecondary-color: linear-gradient(to right, var(--purple-lighter-color), var(--purple-light-color), var(--purple-color)); /* Blue color for primary progress */
            --progressOnHold-color: linear-gradient(to right, var(--blue-light-color), var(--blue-lighter-color), var(--blue-color), var(--blue-dark-color)); /* Green color for completed progress */
            --progressDone-color: linear-gradient(to right, var(--green-lighter-color), var(--green-light-color), var(--green-color)); /* Green color for completed progress */
            --progressStoppedcolor: linear-gradient(to right, var(--yellow-color), var(--orange-color), var(--darkorange-color)); /* Green color for ongoing progress */
            --progressError-color: linear-gradient(to right, var(--red-lighter-color), var(--red-light-color), var(--red-color)); /* Red color for error progress */

            --progressColor: var(--progressPrimary-color); /* --blue-color // --orange-color  ///   linear-gradient(to right, #FFD580, #FF8C00) */

            --radius: 10px;

            --inputLabelWidth: 275px;
            --inputMinWidth: 230px;
            --gap: 10px;
        }


        html * {
            transition: color 0.3s, background 0.3s, background-color 0.3s, border-color 0.3s, filter 0.2s;
            /*scroll-behavior: smooth;*/
        }

        body[data-theme="light"] {
            --page-bg: white;
            --color-bg: var(--mid-color);
            --containers-bg: var(--dark-color);

            --chart-text: black;
            --charts-bg: #e6e6e6;
            --charts-bg-active: white;
            --chart-border: lightgray;

            --text-color: black;
            --text-info-1-color: var(--blue-lighter-color);
            --text-info-2-color: var(--blue-dark-color);

            --slider-bg: #ddd;
            --slider-fg: var(--blue-color);
            --slider-btn: var(--blue-dark-color);
            --input-bg: white;
            --button-color: #f0f0f0;
            --button2-color: var(--blue-color);
            --logBtn-bg: var(--gray-color);
            --border-color: darkgray;
            --headerPanel-color: darkgray;
            --progress-bg: #eee;

            --regular-log-color: darkgray;
            --loading-log-color: #323232;
            --command-log-color: #f5f5f5;


            --startEpx-bg: lightblue;
            --startEpx-color: var(--blue-color);
            --stopEpx-bg: lightpink;
            --stopEpx-color: var(--red-color);
            --returnEpx-bg: lightgray;
            --returnEpx-color: black;

            --logo-bg: white;
            --logo-fg: var(--blue-color);
            --logo-text: var(--blue-color);

            --highligth: rgba(255, 255, 255, 0.5);
            --shadow: rgba(0, 0, 0, 0.2);
        }

        body[data-theme="dark"] {
            /*--page-bg: var(--darker-color);*/
            /*--color-bg: var(--dark-light-color);*/
            /*--containers-bg: var(--gray-color);*/
            /*--charts-bg: var(--gray-color);*/
            /*--charts-bg-active: var(--mid-dark-color);*/
            /*--text-color: white;*/
            /*--slider-bg: var(--mid-dark-color);*/
            /*--input-bg: var(--mid-dark-color);*/
            /*--button-color: var(--mid-dark-color);*/
            /*--button2-color: var(--blue-color);*/
            /*--logBtn-bg: var(--dark-light-color);*/
            /*--border-color: var(--gray-color);*/
            /*--headerPanel-color: var(--gray-color);*/

            --page-bg: #181818;
            --color-bg: #212121;
            --containers-bg: #303030;

            --chart-text: black;
            --charts-bg: #303030;
            --charts-bg-active: #b4b4b4;
            --chart-border: #4e4e4e;

            --text-color: #b4b4b4;
            --text-info-1-color: #4e4e4e;
            --text-info-2-color: black;

            --slider-bg: #4e4e4e;
            --slider-fg: #303030;
            --slider-btn: #212121;
            --input-bg: #4e4e4e;
            --button-color: #4e4e4e;
            --button2-color: var(--dark-light-color);
            --logBtn-bg: var(--dark-light-color);
            --border-color: #303030;
            --headerPanel-color: var(--gray-color);
            --progress-bg: var(--gray-color);

            --regular-log-color: #4e4e4e;
            --loading-log-color: #181818;
            --command-log-color: #212121;

            --startEpx-bg: var(--blue-light-color);
            --startEpx-color: lightblue;
            --stopEpx-bg: var(--red-light-color);
            --stopEpx-color: lightpink;
            --returnEpx-bg: var(--gray-color);
            --returnEpx-color: #181818;

            --logo-bg: var(--blue-light-color);
            --logo-fg: var(--page-bg);
            --logo-text: var(--blue-light-color);

            --highligth: rgba(255, 255, 255, 0.2);
            --shadow: rgba(0, 0, 0, 0.4);
        }

        /* General styling for the body */
        body {
            font-family: Arial, sans-serif;
            min-width: 650px;
            padding: 5px 20px 0;
            border-radius: 1em;
            background: var(--page-bg);
            color: var(--text-color);
        }

        *:disabled {
            background-color: #f0f0f0;
            color: #888;
            cursor: not-allowed;
        }

        .u {
            text-decoration: underline;
            text-underline-offset: 0.1em; /* odsazen√≠ linky od textu */
            text-decoration-thickness: 0.1em; /* tlou≈°≈•ka linky */
            text-decoration-color: color-mix(in srgb, var(--text-color), white 50%); /* barva linky */
            text-decoration-skip-ink: auto; /* nevykresl√≠ p≈ôes ‚Äúoc√°sky‚Äù p√≠smen */
        }

        .insetShadow {
            box-shadow: inset 2px 2px 3px rgba(0, 0, 0, 0.2), inset -2px -2px 5px rgba(0, 0, 0, 0.15);
        }

        .outsetShadow {
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.15), 0 0 5px rgba(0, 0, 0, 0.35);
        }

        /* Button styling for spacing and cursor behavior */
        button {
            padding: 5px;
            cursor: pointer;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            font-size: 14px;
            background: var(--button-color);

            user-select: none; /* Disables text selection */
            color: color-mix(in srgb, var(--text-color) 10%, black);

            box-shadow: inset 2px 2px 5px var(--highligth), inset -2px -2px 3px var(--shadow);
        }

        /* When the button is hovered */
        button:not(:disabled):hover {
            filter: brightness(1.15); /* 15% brighter */
            transform: scale(1.05); /* Slightly larger */
            z-index: 4;
        }

        /* When the button is clicked */
        button:not(:disabled):active {
            filter: brightness(0.85); /* 15% darker */
            transform: scale(0.95); /* Slightly smaller */
            box-shadow: inset 2px 2px 3px rgba(0, 0, 0, 0.35), inset -2px -2px 3px rgba(0, 0, 0, 0.2);
        }

        /* Styling for textAreas used for user input */
        textarea {
            resize: none; /* Disables resizing */
            overflow: auto;
            border: none;
        }

        input, select, .textareaWrapper {
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 0 6px;
        }

        input:not([type="checkbox"]), select, textarea {
            background: var(--input-bg);
            min-height: 34px;
            box-sizing: border-box;

            font-family: Arial, sans-serif;
            font-size: 13px;
            font-weight: normal;

            color: var(--text-color);
            box-shadow: inset 2px 2px 3px rgba(0, 0, 0, 0.15), inset -2px -2px 3px rgba(0, 0, 0, 0.1);
        }

        input[type="checkbox"] {
            accent-color: var(--blue-color);
        }

        pre {
            white-space: pre-wrap; /* zachov√° \n a v√≠cen√°sobn√© mezery, ale dovol√≠ zalomen√≠ */
            overflow-wrap: break-word; /* prim√°rnƒõ l√°me na mezer√°ch, dlouh√° slova zlom√≠ jen kdy≈æ mus√≠ */
            word-break: normal; /* nemrskej slova zbyteƒçnƒõ (CJK nech norm√°lnƒõ) */
            hyphens: auto; /* voliteln√©: p≈ôid√° dƒõlen√≠ slov (s hyfenac√≠) */
        }

        .textareaWrapper {
            display: flex;
            background: var(--input-bg);
            width: -webkit-fill-available;
            height: min-content;
            padding: 4px;
            overflow: hidden;
            box-shadow: inset 2px 2px 3px rgba(0, 0, 0, 0.15), inset -2px -2px 3px rgba(0, 0, 0, 0.1);
        }

        .textareaWrapper:not(:disabled):focus-within {
            outline: 2px solid black; /* vlastn√≠ barva */
            outline-offset: -2px;
            box-shadow: 0 0 0 1px var(--input-bg);
        }

        .textareaWrapper textarea {
            width: 100%;
            padding: 3px 7px;
            box-shadow: none;
            background: transparent;
        }

        .textareaWrapper textarea:not(:disabled):focus {
            outline: none;
        }

        /* Disabled elements styling */
        .prohibited, .disabled, .prohibited *, .disabled * {
            cursor: not-allowed !important;
            user-select: none !important; /* Disables text selection */
            -webkit-user-select: none !important; /* Safari */
            -moz-user-select: none !important; /* Firefox */
            -ms-user-select: none !important; /* IE/Edge */
            pointer-events: none !important; /* Prevents interaction */
            tab-index: -1 !important;
            outline: none !important;
        }

        .prohibited, .disabled {
            opacity: 0.5;
        }


        .sizeableContainer {
            overflow: hidden;
            content-visibility: auto;

            max-height: 0;
            opacity: 0;
            transition: max-height 0.5s ease, opacity 0.45s; /* Animation */

            display: block;
            width: 95%;
            padding: 5px 15px 20px 15px;
            justify-self: center;
            justify-content: center;
        }

        .input-group {
            display: inline-flex;
            gap: var(--gap); /* Space between inputs and labels */
            white-space: nowrap; /* Prevents wrapping */
            padding-left: 20px;
            align-items: center;
            justify-content: center;

        }

        .input-group label {
            flex-shrink: 0; /* Prevents shrinking */
            text-align: right;
            width: var(--inputLabelWidth); /* Label width */
            white-space: normal; /* Allows wrapping if necessary */
        }

        .input-group input {
            height: 25px;
        }

        .input-group input[type="number"], .input-group input[type="text"] {
            flex-grow: 1; /* Input will grow if there is space */
            justify-self: left;
            max-width: var(--inputMinWidth);
        }

        input[type="checkbox"] {
            transform: scale(1.5); /* Scale the checkbox to 1.5 */
            margin: 5px; /* Space around the checkbox */
        }

        h3 {
            position: relative;
            margin-top: 20px;
            margin-bottom: 5px;
            align-self: flex-start;
        }

        h4 {
            position: relative;
            margin-top: 5px;
            margin-bottom: 5px;
        }


        hr {
            width: 100%;
            margin: 20px auto;
            border: 1px solid gray;
        }


        .headerContainer {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            gap: var(--gap);
        }

        #nameHeader {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: var(--gap);
        }

        #updateHeader {
            visibility: hidden;

            font-weight: bold;
            display: flex;
            flex-direction: column;
            color: var(--headerPanel-color);
            font-size: 12px;
            text-align: right;
        }

        .statusContainer {
            gap: var(--gap);
            display: flex;
            justify-self: center;
            justify-content: center;
            align-items: center;
            flex-direction: column;

            background: var(--color-bg);
            padding: 10px 20px;
            border-radius: var(--radius);
        }

        .graphContainer {
            display: flex;
            width: 100%;
            max-width: 1600px;
            flex-direction: column;
            margin-top: 50px;
            margin-bottom: 50px;
            align-items: center;
            justify-self: center;
            padding: 20px;
            background: var(--color-bg);
            border-radius: 10px;
        }

        .sectionTitle {
            margin-top: 0;
        }

        #usbContainer {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: var(--gap);
        }

        #inputNumBaudRateWrapper {
            display: none;
        }

        #inputNumBaudRate {
            width: 148px;
            height: 33px;
            border-radius: 10px;
            padding: 5px;
            border: 1px solid var(--border-color);
            background: #f0f0f0;
            text-align: center;
        }

        #connectionStatus {
            font-weight: bold;
            color: gray;
        }

        .graphBtnWrapper {
            display: flex;
            gap: var(--gap);
        }

        #connectBtnUSB {
            padding: 5px;
            height: 45px;
            width: 160px;
        }

        .btnGraph {
            display: flex;
            min-width: 100px;
            height: 50px;
            padding: 20px;
            align-items: center;
            justify-content: center;
        }

        #thymosLogo {
            width: 50px;
            height: 50px;
        }

        #chartsWrapper {
            width: 100%;
            min-height: min-content;
            margin-top: 10px;
            margin-bottom: 20px;
            gap: 20px;

            color: var(--chart-text);
            background: var(--charts-bg);
            border-radius: 10px;
            border: 2px solid var(--chart-border);
            padding: 10px 0;
        }

        #chartsContainer, #chartsInfoContainer {
            display: flex;
            justify-content: space-between;
            width: 100%;
            min-height: min-content;
            gap: 20px;
        }

        #chartsInfoContainer {
            margin-top: calc(3 * var(--gap));
            justify-content: space-around;
        }


        .chart {
            width: 49%;
            height: 400px;
        }

        /*.chartWrapper {*/
        /*    display: flex;*/
        /*    width: 49%;*/
        /*    height: fit-content;*/
        /*    flex-direction: column;*/
        /*    gap: max(calc(var(--gap) * 2.5), 25px);*/
        /*    justify-content: center;*/
        /*    align-items: center;*/
        /*}*/

        /*.chart {*/
        /*    display: flex;*/
        /*    width: 100%;*/
        /*    height: fit-content;*/
        /*    max-height: 400px;*/
        /*}*/


        #controlContainer {
            display: grid;
            grid-template-columns:  1fr auto;
            gap: 30px;
            width: 100%;
            justify-content: center;
        }

        .controlBtn.moveBtnLeft, .controlBtn.moveBtnRight {
            position: relative;
            touch-action: none;
            background: var(--button2-color);
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
            justify-content: center;
            border-radius: 50vh 0 0 50vh;
            min-width: 0;
            width: 100px;
            height: 50px;
            border: none;
            transform: translateX(1px);
            z-index: 3;

            box-shadow: inset 2px 2px 5px var(--highligth), inset 0 -2px 3px var(--shadow);
        }

        #moveMachineUP {
            padding-top: .2rem; /* men≈°√≠ naho≈ôe */
            padding-bottom: .8rem; /* vƒõt≈°√≠ dole -> text vypad√° v√Ω≈° */
        }

        #moveMachineDOWN {
            padding-top: .6rem; /* vƒõt≈°√≠ naho≈ôe */
            padding-bottom: .4rem; /* men≈°√≠ dole -> text vypad√° n√≠≈æ */
        }


        .controlBtn.moveBtnRight {
            border-radius: 0 50vh 50vh 0;
            font-size: 16px;
            width: 65px;
            font-style: italic;
            transform: translateX(-1px);
            z-index: 2;

            box-shadow: inset 0 2px 5px var(--highligth), inset -2px -2px 3px var(--shadow);
        }


        .movementWrapper {
            /*background: var(--button2-color);*/
            border-radius: 50vh;
            position: relative;
            display: flex;
        }

        .controlBtn.moveBtnRight:not(:disabled):hover {
            transform: scale(1.05) translateX(calc((65px * (0.05 / 2))));
        }

        .controlBtn.moveBtnLeft:not(:disabled):hover {
            transform: scale(1.05) translateX(calc((100px * (-0.05 / 2)) + 2px));
        }

        .controlBtn.moveBtnRight:not(:disabled):active {
            transform: scale(0.9) translateX(calc((65px * (-0.1 / 2)) - 1px));
        }

        .controlBtn.moveBtnLeft:not(:disabled):active {
            transform: scale(0.9) translateX(calc((100px * (0.05 / 2)) + 5px));
        }

        /* svisl√° ƒç√°ra vlevo od 10% do 90% v√Ω≈°ky */
        .movementWrapper::before {
            content: "";
            position: absolute;
            left: calc(100px - 1px / 2); /* p≈ôesnƒõ na lev√©m kraji */
            top: 15%;
            bottom: 15%; /* => v√Ω≈°ka = 80 % */
            width: 3px; /* tlou≈°≈•ka ƒç√°ry */
            background: var(--text-info-2-color); /* nebo nap≈ô. #0ea5e9 */
            border-radius: 2px; /* hezk√© zakonƒçen√≠ */
            pointer-events: none;
            z-index: 6;
        }


        .controllerBtn {
            touch-action: none;
            background: var(--button2-color);
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            justify-content: center;
            border-radius: var(--radius);
            border: none;
        }

        .machineControlContainer {
            display: flex;
            flex-grow: 1;
            flex-direction: column;
            gap: 15px;
            align-items: flex-start;
            justify-content: center;
            margin-top: 20px;

            background: var(--containers-bg);
            border-radius: var(--radius);
            padding: 20px;
        }

        .btnControlWrapper {
            display: flex;
            flex-direction: row;
            width: 100%;
            gap: var(--gap);
            align-items: center;
            justify-content: left;
        }

        .controlBtn {
            display: flex;
            height: 50px;
            width: clamp(100px, 170px, 200px);
            padding: 20px;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        #startExperiment {
            background: var(--startEpx-bg);
            color: var(--startEpx-color);
            border-color: color-mix(in srgb, var(--startEpx-color) 30%, transparent);
        }

        #stopMachine {
            background: var(--stopEpx-bg);
            color: var(--stopEpx-color);
            border-color: color-mix(in srgb, var(--stopEpx-color) 30%, transparent);
        }

        #returnPositionExperimentBtn {
            background: var(--returnEpx-bg);
            color: var(--returnEpx-color);
            border-color: color-mix(in srgb, var(--returnEpx-color) 30%, transparent);
            width: 200px;
        }

        #autoReturnPositionExperiment {
            display: flex;
            height: 50px;
            padding: 20px;
            align-items: center;
            justify-content: center;
        }

        #experimentProgress {
            flex-grow: 1;
            max-width: 450px;
            min-width: 50px;
            height: 15px;
            appearance: none; /* reset of style */
        }

        /* For Chrome, Edge (outer frame of progressbar) */
        progress::-webkit-progress-bar {
            background-color: var(--progress-bg); /* background color */
            border-radius: calc(15px / 2); /* roundness to 50% */
            border: 1px solid var(--border-color);
            box-shadow: inset 2px 2px 3px var(--shadow);
            transition: background 0.3s ease;
            overflow: hidden;
        }

        /* For Chrome, Edge (internal infill part of progressbar) */
        progress::-webkit-progress-value {
            background: var(--progressColor); /* infill color */
            box-shadow: inset 2px 2px 3px var(--shadow);
            border-radius: calc(15px / 2);
            transition: background 0.3s ease;
            overflow: hidden;
        }

        /* For Firefox (internal infill part of progressbar) */
        progress::-moz-progress-bar {
            background: var(--progressColor); /* infill color */
            box-shadow: inset 2px 2px 3px var(--shadow);
            border-radius: calc(15px / 2);
            transition: background 0.3s ease;
            overflow: hidden;
        }

        #experimentProgressLabel {
            font-size: 15px;
            display: inline-block;
            min-width: 65px; /* nebo fixn√≠ width */
            text-align: center; /* voliteln√©, zarovn√°n√≠ obsahu */
        }

        #progressWrapper {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--gap);
            flex-grow: 1;
            width: 100%;
            min-width: 50px;
            padding-left: 5px;
        }

        .experimentContainer {
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: var(--gap);
            left: 0;
            justify-self: center;
            align-items: center;
            width: 100%;
            max-width: 1300px;

            background: var(--color-bg);
            border-radius: var(--radius);
        }

        #experimentInputsContainer {
            display: grid;
            grid-template-columns: max-content minmax(0, 1fr) min-content;
            max-width: 1200px;
            width: 100%;
            min-width: 300px;
            gap: var(--gap);
            justify-items: left;
        }

        #experimentName, #experimentCount {
            flex-grow: 1;
            /*height: 24px;*/
            height: 44px;
            padding: 0 10px;
            /*background: lightgray;*/
        }

        #experimentCount {
            max-width: 65px;
            box-sizing: border-box; /* THIS IS THE MAGIC */
        }

        #convertCSV {
            height: 56px;
        }

        #experimentDesc {
            height: 46px;
        }

        #experimentBtnsWrapper {
            display: flex;
            width: fit-content;
            flex-direction: column;
            gap: var(--gap);
        }

        #saveData {
            width: 150px;
            height: 44px;
        }

        #convertCSV {
            width: 150px;
        }

        .openingContainer {
            position: relative;
            display: flex;
            align-items: flex-start;
            width: 100%;
            background: var(--containers-bg);
            border-radius: calc(1px + 10px);
            border: 1px solid var(--border-color);
        }

        .openingContainerBtn {
            padding: 10px;
        }

        .inputsContainer {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(calc(var(--inputLabelWidth) + var(--gap) + var(--inputMinWidth)), 1fr)); /* Dynamic grid */
            overflow: hidden;
            width: -webkit-fill-available;
            gap: var(--gap);
        }

        .inputsContainer .katex-display {
            margin: 0;
        }

        .katex-display, .katex-display * {
            transition: none !important;
        }


        .inputsContainer button {
            width: 80%;
            max-width: 200px;
        }


        .autoGrid {
            grid-template-columns: repeat(auto-fit, minmax(max-content, 1fr));
            justify-items: center;
        }

        #experimentTypeDropdown {
            flex-grow: 1;
            min-width: 0;
            max-width: 230px;
        }

        #inputPhotoIntervalLabel {
            min-width: fit-content;
            width: 125px;
        }

        #inputPhotoInterval {
            min-width: 25px;
            max-width: 61.5px;
        }

        #inputInitialForceLabel {
            width: 100px;
        }

        #clearStorageButton {
            padding: 20px;
        }

        #regularLog, #loadingLog, #commandInput {
            padding: 10px;
        }

        #consoleContainer {
            display: grid;
            grid-template-columns: 100fr 1fr; /* One column */
            gap: var(--gap);
            padding-top: 20px;
        }

        #regularLogWrapper {
            max-width: 1200px;
            min-width: 300px;
            flex-grow: 1;
            height: 200px;
            background: var(--regular-log-color);
            border: 2px solid var(--regular-log-color);
            margin: 0;
            border-radius: 10px;
            overflow: hidden;
            font-size: 12px;
        }

        #regularLog {
            width: -webkit-fill-available;
            height: -webkit-fill-available;
            overflow-y: auto;
            box-sizing: border-box;
            margin: 0;
        }

        #loadingLog {
            max-width: 1200px;
            min-width: 300px;
            height: 80px;
            background: var(--loading-log-color);
            border-radius: 10px;
            margin: 0;
        }

        .logContainer {
            display: flex;
            flex-direction: column;
            gap: var(--gap);
        }

        .logBtn {
            height: -webkit-fill-available;
            width: 150px;
            background: var(--logBtn-bg);
            color: white;
        }

        #commandInput {
            width: 100%;
            max-width: 1200px;
            min-width: 300px;
            height: 40px;
            border: none;
            background: var(--command-log-color);
            border-radius: 10px;

            padding: 7px 10px;
            font-size: 16px;
            font-family: monospace;

        }

        input[type="range"] {
            accent-color: #007bff; /* zmƒõna barvy na modrou (nov√© prohl√≠≈æeƒçe) */
            box-shadow: inset 2px 2px 5px var(--highligth), inset -2px -2px 3px var(--shadow);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: var(--slider-bg);
            border-radius: 3px;
            outline: none;
            /*border: none;*/
        }

        /* Styl pro slider track (Chrome, Safari) */
        input[type="range"]::-webkit-slider-runnable-track {
            background: var(--slider-fg);
            height: 6px;
            border-radius: 2px;
        }

        /* Styl pro slider thumb (Chrome, Safari) */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 25%;
            background: var(--slider-btn);
            cursor: pointer;
            margin-top: -5px;
        }

        /* Firefox: track */
        input[type="range"]::-moz-range-track {
            /*background: #007bff;*/
            height: 6px;
            border-radius: 3px;
        }

        /* Firefox: thumb */
        input[type="range"]::-moz-range-thumb {
            background: var(--slider-btn);
            height: 16px;
            width: 16px;
            border-radius: 25%;
            cursor: pointer;
        }

        .sliderInputLabel {
            display: flex;
            align-items: center;
            min-width: 1.5em;
            max-width: 4.5em;
            border: 1px solid transparent;
            font-size: 16px !important;
            text-align: right !important;
            color: var(--text-info-2-color) !important;
            font-weight: bold !important;
            background: none !important;
            box-shadow: none !important;
        }

        .sliderInputLabel:not(:disabled):hover {
            cursor: pointer;
            color: var(--text-info-2-color) !important;;
            background: var(--input-bg) !important;
            border: 1px solid var(--border-color);
        }


        .sliderInputLabel:not(:disabled):focus {
            outline: none;
            color: var(--text-color) !important;;
            background: var(--input-bg) !important;
            border: 1px solid var(--text-info-2-color);
        }

        .sliderInputLabel::-webkit-outer-spin-button,
        .sliderInputLabel::-webkit-inner-spin-button {
            -webkit-appearance: none;
        }

        #positionWrapper {
            width: 0.1rem; /* tlou≈°≈•ka ƒç√°ry */
            height: 14px;
            background: black;
            opacity: 65%;
            border-radius: 2px;
            pointer-events: none;
            z-index: 5;
        }

        button {
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
        }

        .units-text {
            font-size: 14px;
            color: #4f4f4f;
        }


    </style>


    <style>
        /* ========== Z√ÅKLAD: sd√≠len√Ω wrapper pro akƒçn√≠ pilulky ========== */
        .action-wrap, .copy-wrap { /* .copy-wrap ponech√°na kv≈Øli zpƒõtn√© kompatibilitƒõ */
            position: relative;
            display: inline-flex;
            flex-grow: 1;
            max-width: 230px;
        }

        /* Z√°klad pilulek (kop√≠rovat / nastavit) */
        .action-pill,
        .copy-pill, .adjust-pill { /* pro kompatibilitu: copy/adjust dƒõd√≠ z action-pill */
            height: clamp(24px, 80%, 40px) !important;
            aspect-ratio: 1/1 !important;
            width: auto !important;

            position: absolute;
            top: 50%;
            right: 5px;
            transform: translateY(-50%) !important;
            z-index: 9999;

            border: 0;
            padding: 6px;
            border-radius: 9999px;

            background: rgba(255, 255, 255, .55);
            -webkit-backdrop-filter: blur(6px);
            backdrop-filter: blur(6px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, .1);

            cursor: pointer;
            line-height: 0;

            opacity: 0;
            pointer-events: none;
            transition: opacity .15s ease, background .2s ease, transform .1s ease;
        }

        .action-pill:hover {
            background: rgba(255, 255, 255, .7);
            transform: translateY(-50%) !important;
        }

        .action-pill:active {
            transform: scale(.95) translateY(calc(-50% + 1px)) translateX(1px) !important;
        }

        .action-wrap:hover .action-pill,
        .action-pill.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .action-pill.hidden {
            display: none !important;
        }

        /* Ikony uvnit≈ô pilulek (z√°klad: schovat, dle stavu uk√°zat) */
        .action-pill svg {
            display: none;
            width: 100%;
            height: 100%;
        }

        /* COPY: ≈°ed√°/OK/ERR */
        .copy-pill[data-state="idle"] .icon-copy {
            display: block;
            stroke: #6b7280;
        }

        .copy-pill[data-state="ok"] .icon-check {
            display: block;
            stroke: #22c55e;
        }

        .copy-pill[data-state="err"] .icon-x {
            display: block;
            stroke: #ef4444;
        }

        /* ADJUST: ≈°ed√°/OK/ERR */
        .adjust-pill[data-state="idle"] .icon-wand {
            display: block;
            stroke: #3b82f6;
        }


        .adjust-pill[data-state="set"] .icon-wand {
            display: block;
            stroke: #6b7280;
        }

        .adjust-pill[data-state="diff"] .icon-wand {
            display: block;
            stroke: #ff8c00;
        }

        .adjust-pill[data-state="ok"] .icon-check {
            display: block;
            stroke: #22c55e;
        }

        .adjust-pill[data-state="err"] .icon-x {
            display: block;
            stroke: #ef4444;
        }

        /* Vizu√°ln√≠ zpƒõtn√° vazba uvnit≈ô wrapperu na hover (jen kdy≈æ nen√≠ fokus/akce) */
        .action-wrap:hover > .copyableInput:not(:focus):not(.action-ok):not(.action-err) {
            outline: none;
            box-shadow: inset 0 0 0 2px #3b82f6;
            transition: box-shadow .1s ease;
        }

        .action-wrap.has-auto:hover > .adjustableInput:not(:focus):not(.action-ok):not(.action-err) {
            outline: none;
            box-shadow: inset 0 0 0 2px #6b7280;
            transition: box-shadow .1s ease;
        }

        /* Po akci */
        .action-wrap > .action-ok {
            outline: none;
            box-shadow: inset 0 0 0 2px #22c55e;
            transition: box-shadow .1s ease;
        }

        .action-wrap > .action-err {
            outline: none;
            box-shadow: inset 0 0 0 2px #ef4444;
            transition: box-shadow .1s ease;
        }

        /* Pomocn√° utilita, pokud ji u≈æ nƒõkde pou≈æ√≠v√°≈° */
        .data-eq {
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
    </style>

</head>

<body>
<noscript>
    <div style="color: red; font-weight: bold; text-align: center; margin-top: 20px;">
        JavaScript is disabled in your browser. Please enable it to use this application.
    </div>
</noscript>

<main id="app" data-bugreporter-root>
    <section class="headerContainer">

        <div id="nameHeader">
            <svg id="thymosLogo" class="custom-icon" viewBox="0 0 177.81437 177.9034"
                 xmlns="http://www.w3.org/2000/svg">
                <style>
                    .rect-bg {
                        fill: var(--logo-bg, white);
                        stroke: var(--logo-bg, white);
                    }

                    .dot-shape, .main-shape {
                        fill: var(--logo-fg, black);
                        stroke: var(--logo-fg, black);
                    }
                </style>

                <g transform="translate(225.12939,129.3157)">
                    <rect class="rect-bg" width="130.01212" height="130.01208" x="-201.22827" y="-105.37005"
                          ry="9.1106987" rx="9.4112854" stroke-width="47.8913"/>
                    <path class="main-shape"
                          d="m -183.53862,7.9393313 0.37992,-28.6806303c -3.46806,-0.838763 -6.47358,-2.670752 -8.82206,-5.154387 -3.35392,-3.546427 -5.32276,-8.431072 -5.32276,-13.618672v -30.30165c 0,-9.89763 4.27076,-21.98757 12.85714,-30.761632 6.93867,-7.09086 16.65032,-12.05614 29.13465,-12.05614h 67.983775l 11.83638,83.692256 -18.4011,0.0017v 60.189316l -3.79175,0.439257c -0.15191,0.02838 -53.466715,6.885861 -53.466715,-57.521684h 8.55402c 0,44.888568 29.48901,49.136615 40.15129,49.207313v -60.833856h 17.131595l -9.42174,-66.617732h -60.575755c -9.92062,0 -17.59527,3.90532 -23.05376,9.483912 -6.93498,7.08604 -10.38374,16.82239 -10.38374,24.78041v 30.30165c 0,2.99757 1.10511,5.78559 2.98196,7.77034 1.70875,1.80842 4.10749,2.95469 6.91965,2.95469h 4.31732l -0.4861,36.8294603 -8.52222,-0.102216 z"
                          stroke-width="4.63292"/>
                    <path class="dot-shape"
                          d="m -115.91317,-44.595488c 5.72369,0 10.36216,-4.63847 10.36216,-10.36102 0,-5.72256 -4.63847,-10.3613 -10.36216,-10.3613 -5.72255,0 -10.36102,4.63874 -10.36102,10.3613 0,5.72255 4.63847,10.36102 10.36102,10.36102"
                          stroke-width="4.63292"/>
                </g>
            </svg>

            <div style="display: flex; flex-direction: column; align-content: space-between;">
                <div style="border-bottom: 2px solid var(--headerPanel-color); margin-bottom: 1px;"><span
                        style="font-weight: bolder; font-size: 24px;"><span
                        style="color: var(--logo-text); text-decoration: none;">THYMOS</span> - ŒúŒø·øñœÅŒ± controller</span>
                </div>
                <span id="softwareInfo"
                      style="color: var(--headerPanel-color); font-size: 12px;">v0.0.0.0, 00.00.0000</span>
            </div>
        </div>
        <div id="updateHeader">
            <a style="font-size: 22px; color: darkorange;">Upgrade available</a>
            <a id="updateHeaderVersion" style="color: coral; font-size: 12px;">[from: v0.0.3 to v0.0.4]</a>
            (press 'F5')
        </div>
    </section>

    <section class="statusContainer outsetShadow">
        <!-- USB Connection Section -->
        <div id="usbContainer">
            <button id="connectBtnUSB" title="Connect to the Thymos machine by selecting USB port.">üîå Connect via USB
            </button>
            <div id="inputNumBaudRateWrapper"><label for="inputNumBaudRate" class="prohibited">Baud-Rate:
                <input data-input-type="intInput" type="number" id="inputNumBaudRate" placeholder="Baud-Rate"
                       value="921600" min="1" class="prohibited">
            </label>
            </div>
        </div>
        <div id="connectionStatus"> üî¥ Disconnected</div>
    </section>

    <section id="debuggingWrapper" style="display: none; width: 100%; gap: 20px; margin-top: 20px; justify-content: center; align-items: center;
                border-radius: 1em; padding: 10px; background: lightpink; box-sizing: border-box;">
        <button id="degubDeleteDisabled"
                style="box-sizing: border-box; justify-self: center; width: 100px; height: 100px;">
            ‚úñÔ∏è<br>Delete 'Disabled' Class
        </button>
        <button id="degubDeleteProhibited"
                style="box-sizing: border-box; justify-self: center; width: 100px; height: 100px;">
            ‚ùå<br>Delete 'Prohibited' Class
        </button>
        <button onclick="sendCommandGeneral('mc service')"
                style="font-weight: bold; box-sizing: border-box; justify-self: center; width: 150px; height: 100px; background: #ff8c00; color:white">
            üõ†Ô∏è<br>Service Mode<br><em style="font-weight: normal;">(MC SERVICE)</em>
        </button>
        <button onclick="sendCommandGeneral('datac')"
                style="font-weight: bold; box-sizing: border-box; justify-self: center; width: 150px; height: 100px; background: #2196F3; color:white">
            üìä<br>Data Measurement<br><em style="font-weight: normal;">(DATAC)</em>
        </button>
        <button id="degubRunTestSequenceBtn"
                style="font-weight: bold; box-sizing: border-box; justify-self: center; width: 150px; height: 100px; background: #4CAF50; color:white">
            üß™<br>Run Test Sequence
        </button>
        <button onclick="clearAndResetAll()"
                style="font-weight: bold; box-sizing: border-box; justify-self: center; width: 150px; height: 100px; background: #607d8b; color:white">
            üóëÔ∏è<br>Clear All Data
        </button>
        <button id="degubEndTestingBtn"
                style="font-weight: bold; box-sizing: border-box; justify-self: center; width: 150px; height: 100px; background: #de364c; color:white">
            üõë<br>End Testing
        </button>

        <pre id="brailleOut"
             style="font-weight: normal; border: 2px solid black;  width: 200px; height: 100px; font-size: 16px; letter-spacing: 0;"></pre>


        <label for="testInput"></label>
        <input id="testInput"
               type="number" inputmode="decimal" step="any"
               style="font-weight: normal; border: 2px solid black;  width: 200px; height: 100px; font-size: 16px; letter-spacing: 0;"
               placeholder="Type here..."/>
    </section>

    <!-- Graph Display Section -->

    <section class="graphContainer outsetShadow">
        <h3 class="sectionTitle">üìà Graphs:</h3>
        <nav class="graphBtnWrapper">
            <button class="btnGraph" id="toggleLive"> ‚ñ∂Ô∏è Activate Charts</button>
            <button id="clearChartBtn" class="btnGraph">üßπ Clear Charts</button>
            <button id="refreshChartBtn" class="btnGraph">üîÑ Refresh Charts</button>
        </nav>


        <div id="chartsWrapper" class="outsetShadow">
            <div id="chartsContainer">
                <div id="timeChart" class="chart"></div>
                <div id="positionChart" class="chart"></div>
            </div>
            <div id="chartsInfoContainer" style="display: none;">
                <div style="display: inline-block; gap: 10px;"><a>Min/Max:</a>
                    <div style="display: inline-block;">
                        <span style="color: #000000;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="display: inline-flex; min-width: 30px;  justify-content: center;">mm</span>
                    </div>
                    <div style="display: inline-block;">
                        <span style="color: #FF3330;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="color: #2196F3;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="color: #4CAF50;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="display: inline-flex; min-width: 30px;  justify-content: center;">N</span>
                    </div>
                </div>
                <div style="display: inline-block; gap: 10px;"><a>Min/Max:</a>
                    <div style="display: inline-block;">
                        <span style="color: #000000;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="display: inline-flex; min-width: 30px;  justify-content: center;">mm</span>
                    </div>
                    <div style="display: inline-block;">
                        <span style="color: #FF3330;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="color: #2196F3;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="color: #4CAF50;display: inline-flex; min-width: 100px; justify-content: center; font-weight: bold;">N/A</span>
                        <span style="display: inline-flex; min-width: 30px;  justify-content: center;">N</span>
                    </div>
                </div>
            </div>
        </div>

        <hr>

        <!-- Progress Bar -->
        <h3 class="sectionTitle">üíª Control Panel:</h3>
        <div style="gap:15px; display: flex; flex-direction: column;">
            <div id="controlContainer">
                <nav class="machineControlContainer outsetShadow">
                    <div class="btnControlWrapper">
                        <!-- Start Experiment Button -->
                        <button id="startExperiment" class="controlBtn movementControlElement">‚ö°<br>Start Experiment
                        </button>

                        <!-- Stop Experiment Button -->
                        <button id="stopMachine" class="controlBtn">üõë<br>Stop Machine</button>

                        <!-- Return to the original position Button -->
                        <button id="returnPositionExperimentBtn"
                                class="controlBtn movementControlElement">‚Ü©Ô∏è Return to start position
                        </button>

                        <!-- Automatic returning to the original position Checkmark -->
                        <div style="
            display: inline-flex;
            gap: var(--gap);
            padding-left: var(--gap);
            align-items: center;
            justify-content: center;"
                             data-eq-type="-InB">
                            <label id="autoReturnPositionExperimentLabel" for="autoReturnPositionExperiment">‚ÜïÔ∏è Final
                                Auto-positioning:</label>
                            <input type="checkbox" id="autoReturnPositionExperiment">
                        </div>
                    </div>

                    <!-- Experiment Progress -->
                    <div id="progressWrapper">
                        <div style="flex-grow: 1; display: flex; align-items: center; gap: 10px; max-width: 630px;">
                            <label for="experimentProgress">Experiment Progress:</label>
                            <progress id="experimentProgress" value="0" max="100"></progress>
                            <span id="experimentProgressLabel"></span>
                        </div>
                        <div style="width: 135px;">
                            <b>Stage:</b>
                            <span id="experimentStage">None</span>
                        </div>
                    </div>
                </nav>

                <nav class="machineControlContainer outsetShadow">
                    <div class="movementWrapper movementControlElement">
                        <button id="moveMachineUP" class="controlBtn moveBtnLeft">ü¢Å</button>
                        <button id="moveUp100" class="controlBtn moveBtnRight">100<br>(mm)</button>
                    </div>

                    <div class="movementWrapper movementControlElement">
                        <button id="moveMachineDOWN" class="controlBtn moveBtnLeft">ü¢É</button>
                        <button id="moveDown100" class="controlBtn moveBtnRight">100<br>(mm)</button>
                    </div>

                </nav>
            </div>
            <nav class="outsetShadow"
                 style="display: flex; flex-direction: row; background: var(--containers-bg); padding: 10px 20px; border-radius: 10px; justify-content: space-between; gap: 10%; font-weight: bold; color: var(--text-info-2-color);">
                <div class="movementControlElement"
                     style="display: flex; flex-direction: row; flex-grow: 1; align-items: center; gap: 10px;">
                    <label for="movementSpeed" style="min-width: max-content; font-weight: normal; color: black;">‚è©
                        Speed:</label>
                    <input type="range" id="movementSpeed" min="0.01" max="25" value="25" step="0.01"
                           style="height: 10px; flex-direction: row; flex-grow: 1; border-radius: var(--radius); touch-action: none;">
                    <label for="labelSpeed"></label>
                    <div style="display: inline-flex; gap: .2em; align-items: center;">
                        <input type="number"
                               data-nonremember="true"
                               placeholder="Num."
                               id="labelSpeed"
                               class="sliderInputLabel"><span>mm/s</span>
                    </div>
                </div>
                <div class="movementControlElement"
                     style="display: flex; flex-direction: row; flex-grow: 1; align-items: center; gap: 10px;">
                    <label for="movementAcceleration" style="min-width: max-content; font-weight: normal; color: black;"
                    >‚è≠Ô∏è Acceleration:</label>
                    <input type="range" id="movementAcceleration" min="10" max="200" value="200" step="0.01"
                           style="height: 10px; flex-direction: row; flex-grow: 1; border-radius: var(--radius); touch-action: none;">
                    <label for="labelAcceleration"></label>
                    <div style="display: inline-flex; gap: .2em; align-items: center;">
                        <input type="number"
                               data-nonremember="true"
                               placeholder="Num."
                               id="labelAcceleration"
                               class="sliderInputLabel"><span>mm/s<sup style="font-size: 65%;">2</sup></span></div>
                </div>
            </nav>

            <nav class="outsetShadow"
                 style="display: flex; flex-direction: row; background: var(--containers-bg); padding: 10px 20px; gap:10px; border-radius: 10px; justify-content: space-between; font-weight: bold; color:  var(--text-info-2-color);">
                <div style="display: flex; flex-direction: row; align-items: center; gap: 40px;" class="prohibited">
                    <div style="display: flex; flex-direction: row; align-items: center; gap: 10px;">
                    <span id=""
                          style="min-width: 50px; text-align: right; color:black;  opacity: 65%;">Position: </span>
                        <span id=""
                              style="color: var(--text-info-1-color); min-width: 50px; text-align: right;">000.00</span>
                        <div id="positionWrapper"></div>
                        <span id="" style="min-width: 60px; text-align: right;">¬±000.00</span>
                        <a>mm</a>
                    </div>
                    <div style="display: flex; flex-direction: row; align-items: center; gap: 10px;">
                        <label for="moveToInput"
                               style="min-width: max-content; font-weight: normal; color: var(--text-info-2-color);">
                            Move to (mm):
                        </label>
                        <input type="number" id="moveToInput" min="0" max="450" step="0.01" placeholder="0.00 mm"
                               style="height: 10px; flex-direction: row; flex-grow: 1; border-radius: var(--radius); touch-action: none;">
                    </div>
                    <button id="moveToBtn" class="movementControlElement controlBtn controllerBtn">‚û°Ô∏è Move</button>

                </div>
                <button id="setUserZeroBtn" class="movementControlElement controlBtn controllerBtn prohibited">üéØ Set
                    Zero
                </button>
                <button id="calibrateBtn" class="movementControlElement controlBtn controllerBtn">üìè
                    Calibrate
                </button>
            </nav>
        </div>
    </section>


    <section class="experimentContainer outsetShadow">
        <h3>üìù Experiment options:</h3>
        <section id="experimentInputsContainer">

            <label for="experimentName">üß™ Experiment Name:</label>
            <div style="display: flex; width: 100%; gap: var(--gap);">
                <input type="text" id="experimentName" placeholder="Experiment name (mandatory) ..."
                       data-nonremember="true">
                <label for="experimentCount">üî¢ Experiment count:</label>
                <input type="number" id="experimentCount" placeholder="Num ..."
                       data-input-type="intInput" data-nonremember="true"
                       value="1" step="1" min="1" max="999">
            </div>

            <button id="saveData">üíæ Save single CSV</button>

            <label for="experimentDesc">üìÑ Experiment description:</label>
            <div class="textareaWrapper">
                <textarea id="experimentDesc" placeholder="Short description of the experiment (optional)..."
                          data-nonremember="true"></textarea>
            </div>

            <button id="convertCSV">
                üìä Convert CSV files to XLSX (MATTES)
            </button>

            <label for="storagePath">üìÅ Handpick the folder:</label>
            <div style="align-items: center; display: flex; gap: var(--gap);">
                <input type="checkbox" id="storagePath" onchange="toggleDirectorySelector()"> (Default folder:
                Downloads)
            </div>

            <div>
                <button type="button" id="btnLoadSettings">üóÉÔ∏è Load experiment data (CSV)</button>
                <div hidden>
                    <span id="loadedFileName" aria-live="polite"></span>
                    <input type="file" id="appFileInput" accept=".csv,text/csv">
                </div>
            </div>
        </section>


        <!--            <div id="experimentBtnsWrapper">-->


        <!--            </div>-->

        <h3>üìë Experiment Results:</h3>
        <section class="openingContainer insetShadow">
            <button id="resultsContainerOpenBtn" class="openingContainerBtn">üîΩ</button>
            <div id="resultsContainer" class="sizeableContainer">
                <h4>‚úèÔ∏è Calculation inputs:</h4>
                <div class="inputsContainer">
                    <div class="input-group data-eq">
                        <label for="inputTareForce">Taring Force \( F_{\mathrm{Tare}} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="number" id="inputTareForce" class="adjustableInput calcInput"
                               value="0" step="any" data-unit="N" data-essence="force">
                    </div>

                    <div class="input-group data-eq">
                        <label for="inputTareDisp">Taring Displacement \( w_{\mathrm{Tare}} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="number" id="inputTareDisp" class="adjustableInput calcInput"
                               value="0" step="any" data-unit="mm" data-essence="position">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx, InB, HBr">
                        <label for="inputForce">Force \( F \)<span class="units-text"></span>: </label>
                        <input type="number" id="inputForce" class="adjustableInput calcInput"
                               value="" step="any" data-unit="N" data-essence="force">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="inputTargetForce">Target force \( F_{T} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="number" id="inputTargetForce" class="adjustableInput calcInput"
                               step="any" data-unit="N" data-essence="force">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx">
                        <label for="inputDisp">Displacement \( w \) at \( F \)<span class="units-text"></span>:
                        </label>
                        <input type="number" id="inputDisp" class="adjustableInput calcInput"
                               value="" step="any" data-unit="mm" data-essence="position">
                    </div>


                    <div class="input-group data-eq" data-eq-type="Flx, InB">
                        <label for="inputWidth">Cross-section width \( b \)<span class="units-text"></span>:
                        </label>
                        <input type="number" id="inputWidth" class="adjustableInput calcInput"
                               value="" step="any" data-unit="mm"
                               data-essence="dimension, cross-section">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx, InB">
                        <label for="inputHeight">Cross-section height \( h \)<span class="units-text"></span>:
                        </label>
                        <input type="number" id="inputHeight" class="adjustableInput calcInput"
                               value="" step="any" data-unit="mm"
                               data-essence="dimension, cross-section">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx">
                        <label for="inputSpan">Span \( L \)<span class="units-text"></span>: </label>
                        <input type="number" id="inputSpan" class="adjustableInput calcInput"
                               value="" step="any" data-unit="mm" data-essence="dimension">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="inputIndDepth">Depth of indentation \( h_{D} \)<span class="units-text"></span>:
                        </label>
                        <input type="number" id="inputIndDepth" class="adjustableInput calcInput"
                               value="" step="any" data-unit="mm" data-essence="position">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="inputIndDiameter">Diameter of Indenter <b>‚åÄ</b> \( D \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="number" id="inputIndDiameter" class="adjustableInput calcInput"
                               step="any" data-unit="mm" data-essence="dimension">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="inputLoadingTime">Target loading time \( t \)<span class="units-text"></span>:
                        </label>
                        <input type="number" id="inputLoadingTime" class="adjustableInput calcInput"
                               step="any" data-unit="s" data-essence="time">
                    </div>

                    <div class="input-group data-eq">
                        <label for="inputMaterialName"><a class="u">Material name</a><span
                                class="units-text"> (text)</span>:
                        </label>
                        <input type="text" id="inputMaterialName" class="adjustableInput calcInput"
                               step="any" data-essence="label">
                    </div>
                </div>

                <div data-eq-type="Flx" style="display: inline-flex; width: 100%">
                    <hr style="width: 85% ; margin: 50px auto 10px;">
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(500px, 1fr)); gap: 20px;">

                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <h4 data-eq-type="Flx" style="margin-left: 10%;">‚òî <a class="u"> Before drying</a>:</h4>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputWidth_BeforeDrying">Cross-section width \( b_{w} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputWidth_BeforeDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension, cross-section">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputHeight_BeforeDrying">Cross-section height \( h_{w} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputHeight_BeforeDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension, cross-section">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputLength_BeforeDrying">Length \( L_{w} \)<span class="units-text"></span>:
                            </label>
                            <input type="number" id="inputLength_BeforeDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputWeight_BeforeDrying">Cross-section weight \( m_{w} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputWeight_BeforeDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="g"
                                   data-essence="weight">
                        </div>

                    </div>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <h4 data-eq-type="Flx" style="margin-left: 10%;">üåÇ <a class="u"> After drying</a>:</h4>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputWidth_AfterDrying">Cross-section width \( b_{0} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputWidth_AfterDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension, cross-section">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputHeight_AfterDrying">Cross-section height \( h_{0} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputHeight_AfterDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension, cross-section">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputLength_AfterDrying">Length \( L_{0} \)<span class="units-text"></span>:
                            </label>
                            <input type="number" id="inputLength_AfterDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="mm"
                                   data-essence="dimension">
                        </div>
                        <div class="input-group data-eq" data-eq-type="Flx">
                            <label for="inputWeight_AfterDrying">Cross-section weight \( m_{0} \)<span
                                    class="units-text"></span>:
                            </label>
                            <input type="number" id="inputWeight_AfterDrying" class="adjustableInput calcInput"
                                   value="" step="any" data-unit="g"
                                   data-essence="weight">
                        </div>

                    </div>
                </div>

                <hr>

                <h4>üî£ Equations:</h4>
                <div class="inputsContainer"
                     style="grid-template-columns: repeat(auto-fit, minmax(430px, 1fr)); padding-left: 50px; gap: 25px 10px;">
                <span class="data-eq">
                    \[
                    F_{i} = F_{j} - F_{\mathrm{Tare}}
                    \]
                </span>
                    <span class="data-eq">
                    \[
                    w_{i} = w_{j} - w_{\mathrm{Tare}}
                    \]
                </span>
                    <span class="data-eq" data-eq-type="Flx">
                    \[
                    I_{y} = \frac{1}{12} \cdot b \cdot h^{3}
                    \]
                </span>
                    <span class="data-eq" data-eq-type="Flx">
                    \[
                    E = \frac{F\,L^{3}}{48\,I_{y}\,w}
                    \]
                </span>
                    <span class="data-eq" data-eq-type="InB">
                    \[
                    A = b \cdot h
                    \]
                </span>
                    <span class="data-eq" data-eq-type="InB">
                    \[ \sigma_{\mathrm{max}} = \dfrac{F_{\mathrm{max}}}{A} \]
                </span>
                    <span class="data-eq" data-eq-type="HBr">
                    \[
                    d = 2\cdot\sqrt{\,h_{D}\,(2D - h_{D})\,}
                    \]
                </span>
                    <span class="data-eq" data-eq-type="HBr">
                    \[
                    H_{BW} = \frac{2F}{\pi D\left( D - \sqrt{D^{2} - d^{2}} \right)}
                    \]
                </span>
                    <span class="data-eq" data-eq-type="HBr">
                    \[
                    v = \frac{w_{T}}{t}
                    \]
                </span>
                </div>

                <hr>

                <h4>üìê Calculated values:</h4>
                <div class="inputsContainer">
                    <div class="input-group data-eq" data-eq-type="-HBr">
                        <label for="outputForceMax">Max Force \( F_{\mathrm{max}} \)<span class="units-text"></span>:
                        </label>
                        <input type="text" id="outputForceMax" class="copyableInput calcInput" readonly
                               data-nonremember="true" data-unit="N" data-essence="force">
                    </div>

                    <div class="input-group data-eq" data-eq-type="-HBr">
                        <label for="outputDisp">Displacement \( w_{F_{\mathrm{max}}} \) at \( F_{\mathrm{max}} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="text" id="outputDisp" class="copyableInput calcInput" readonly
                               data-nonremember="true" data-unit="mm" data-essence="position">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx">
                        <label for="outputIy">Moment of Inertia \( I_{y} \)<span
                                class="units-text"></span>: </label>
                        <input type="text" id="outputIy" class="copyableInput calcInput" readonly
                               data-nonremember="true" data-unit="mm^4"
                               data-essence="dimension, cross-section, moment-of-inertia">
                    </div>

                    <div class="input-group data-eq" data-eq-type="Flx">
                        <label for="outputModulus">Young's Module \( E \)<span class="units-text"></span>:
                        </label>
                        <input type="text" id="outputModulus" class="copyableInput calcInput" readonly
                               data-nonremember="true" data-unit="MPa" data-essence="result, modulus">
                    </div>

                    <div class="input-group data-eq" data-eq-type="InB">
                        <label for="outputArea">Cross-section Area \( A \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="text" id="outputArea" class="copyableInput calcInput" readonly
                               data-nonremember="true" data-unit="mm^2" data-essence="dimension, cross-section, area">
                    </div>

                    <div class="input-group data-eq" data-eq-type="InB">
                        <label for="outputMaxStress">Max Stress \( \sigma_{\mathrm{max}} \)<span
                                class="units-text"></span>: </label>
                        <input type="text" id="outputMaxStress" class="copyableInput calcInput" readonly
                               data-nonremember="true" data-unit="MPa" data-essence="result, stress">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="outputDiameterInd">Diameter of indentation <b>‚åÄ</b> \( d \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="text" id="outputDiameterInd" class="copyableInput calcInput" readonly
                               data-nonremember="true" data-unit="mm" data-essence="dimension">
                    </div>


                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="inputTargetDisp">Displacement \( w_{T} \) at Target force<span
                                class="units-text"></span>:
                        </label>
                        <input type="text" id="inputTargetDisp" class="copyableInput calcInput" readonly
                               data-nonremember="true" data-unit="mm" data-essence="position">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="outputHardness">Hardness (Brinell) \( H_{\mathrm{BW}} \)<span
                                class="units-text"></span>:
                        </label>
                        <input type="text" id="outputHardness" class="copyableInput calcInput" readonly
                               data-nonremember="true" data-unit="-" data-essence="result, hardness, ratio">
                    </div>

                    <div class="input-group data-eq" data-eq-type="HBr">
                        <label for="outputLoadingSpeed">Loading speed \( v \)<span class="units-text"></span>:
                        </label>
                        <input type="text" id="outputLoadingSpeed" class="copyableInput calcInput" readonly
                               data-nonremember="true" data-unit="mm/s" data-essence="speed">
                    </div>
                </div>
            </div>
        </section>


        <!-- Experiment Parameter Inputs -->
        <h3>‚öôÔ∏è Settings:</h3>
        <section class="openingContainer insetShadow">
            <button id="settingsContainerOpenBtn" class="openingContainerBtn">üîΩ</button>
            <div id="settingsContainer" class="sizeableContainer">

                <h4>üõ†Ô∏è Loading settings:</h4>
                <div class="inputsContainer">
                    <div class="input-group">
                        <label for="inputDistance">Distance<span class="units-text"></span>: </label>
                        <input data-input-type="floatInput" type="number" id="inputDistance" class="expInput"
                               value="20" min="0.01" step="any" max="100000000" data-unit="mm" data-essence="position">
                    </div>

                    <div class="input-group">
                        <label for="experimentTypeDropdown">Experiment type: </label>
                        <select id="experimentTypeDropdown" class="expInput" style="font-family: monospace; font-weight: bold;
                                font-size: 16px;">
                            <option value="Option-UP-POS-BASIC" data-essence="move_up">&nbsp;UP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üî∫
                            </option>
                            <option value="Option-UP-POS-Ten" disabled data-essence="tensile">&nbsp;TENSION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚è´
                            </option>
                            <option value="Option-UP-POS-InB" data-essence="internal_bond">&nbsp;INTERNAL BOND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚è´
                            </option>
                            <option value="Option-DOWN-POS-BASIC" data-essence="move_down" selected>&nbsp;DOWN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;üîª
                            </option>
                            <option value="Option-UP-POS-Com" disabled data-essence="compression">&nbsp;COMPRESION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚è¨
                            </option>
                            <option value="Option-DOWN-POS-Flx" data-essence="flexural">&nbsp;FLEXURAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‚è¨
                            </option>
                            <option value="Option-DOWN-POS-HBr" data-essence="hardness_br">&nbsp;HARDNESS (Brinell)&nbsp;‚è¨
                            </option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="inputLoadLimitDropPercent">Force drop limit<span class="units-text"></span>:
                        </label>
                        <input data-input-type="floatInput" type="number" id="inputLoadLimitDropPercent"
                               class="expInput"
                               value="30" min="0" max="1000000" data-unit="%" data-essence="ratio">
                        <!-- % ‚Ä∞ -->
                    </div>


                    <div class="input-group">
                        <label for="inputTakePhotos">Take photos: </label>
                        <input type="checkbox" id="inputTakePhotos" class="expInput" data-essence="switch">
                        <label id="inputPhotoIntervalLabel" for="inputPhotoInterval">Photo Interval<span
                                class="units-text"></span>: </label>
                        <input data-input-type="floatInput" type="number" id="inputPhotoInterval" class="expInput"
                               value="1" min="0" step="any" max="120000000" data-unit="s" data-essence="time">
                    </div>


                    <div class="input-group">
                        <label for="inputLoadLimitDropValue">Force drop limit<span class="units-text"></span>:
                        </label>
                        <input data-input-type="floatInput" type="number" id="inputLoadLimitDropValue" class="expInput"
                               value="5" min="0" step="any" max="100000000" data-unit="N" data-essence="ratio, force">
                    </div>


                    <div class="input-group">
                        <label for="inputSpeedForward">Loading speed<span class="units-text"></span>: </label>
                        <input data-input-type="floatInput" type="number" id="inputSpeedForward" class="expInput"
                               value="1" min="0.01" step="any" max="25" data-unit="mm/s" data-essence="speed">
                    </div>

                    <div class="input-group"> <!-- TODO minimum na 10000 -->
                        <label for="inputDataInterval">Data Interval<span class="units-text"></span>: </label>
                        <input data-input-type="intInput" type="number" id="inputDataInterval" class="expInput"
                               value="30000" min="10000" step="any" max="100000000" data-unit="¬µs" data-essence="time">
                    </div>

                    <div class="input-group" data-eq-type="InB, HBr">
                        <label id="inputInitialSpeedLabel" for="inputInitialSpeed">Initial speed<span
                                class="units-text"></span>:</label>
                        <input data-input-type="floatInput" type="number"
                               id="inputInitialSpeed" class="expInput" style="max-width: 60px; min-width: 25px;"
                               value="1" min="0.01" step="any" max="25" data-unit="mm/s" data-essence="speed">
                        <label id="inputInitialForceLabel" for="inputInitialForce"
                               style="min-width: max-content;">Force lim.
                            <span class="units-text"></span>:</label>
                        <input data-input-type="floatInput" type="number"
                               id="inputInitialForce" class="expInput" style="max-width: 50px; min-width: 25px;"
                               value="1" min="0" step="any" max="100000000" data-unit="N" data-essence="force">
                    </div>

                    <div class="input-group" data-eq-type="HBr">
                        <label id="inputStopForceLabel" for="inputStopForce">Stopping Force Limit<span
                                class="units-text"></span>: </label>
                        <input data-input-type="floatInput" type="number" id="inputStopForce" class="expInput"
                               value="1000" min="0" step="any" max="100000000" data-unit="N" data-essence="force">
                    </div>

                    <div class="input-group" data-eq-type="HBr">
                        <label id="inputEndDelayLabel" for="inputEndDelay">End load delay<span
                                class="units-text"></span>: </label>
                        <input data-input-type="floatInput" type="number" id="inputEndDelay" class="expInput"
                               value="25" min="0" step="any" max="120000000" data-unit="s" data-essence="time">
                    </div>
                </div>

                <hr>

                <h4>üìü Machine settings:</h4>
                <div class="inputsContainer">
                    <div class="input-group">
                        <label for="inputLoadcellCapacity">Loadcell Capacity<span class="units-text"></span>:
                        </label>
                        <input data-input-type="intInput" type="number" id="inputLoadcellCapacity"
                               value="0" step="any" min="0" max="100000000" data-unit="kg"
                               data-essence="scale, conversion">
                    </div>

                    <div class="input-group">
                        <label for="inputLoadcellOutput">Loadcell Rated Output<span class="units-text"></span>:
                        </label>
                        <input data-input-type="floatInput2" type="number" id="inputLoadcellOutput"
                               value="2.0" step="any" min="0" max="100000000" data-unit="mV/V"
                               data-essence="voltage, ratio, scale, conversion">
                    </div>


                    <!--                    <div class="input-group">-->
                    <!--                        <label for="inputLoadcellCapacity1"><b>Loadcell 1</b> Capacity <span-->
                    <!--                                class="units-text">(kg)</span>: </label>-->
                    <!--                        <input data-input-type="intInput" type="number" id="inputLoadcellCapacity1"-->
                    <!--                               value="0" step="any" min="0" max="100000000">-->
                    <!--                    </div>-->

                    <!--                    <div class="input-group">-->
                    <!--                        <label for="inputLoadcellOutput1"><b>Loadcell 1</b> Rated Output <span-->
                    <!--                                class="units-text">(mV/V)</span>: </label>-->
                    <!--                        <input data-input-type="floatInput" type="number" id="inputLoadcellOutput1"-->
                    <!--                               value="0.0"-->
                    <!--                               step="any" min="0" max="100000000">-->
                    <!--                    </div>-->

                    <!--                    <div class="input-group">-->
                    <!--                        <label for="inputLoadcellCapacity2"><b>Loadcell 2</b> Capacity <span-->
                    <!--                                class="units-text">(kg)</span>: </label>-->
                    <!--                        <input data-input-type="intInput" type="number" id="inputLoadcellCapacity2"-->
                    <!--                               value="0" step="any" min="0" max="100000000">-->
                    <!--                    </div>-->

                    <!--                    <div class="input-group">-->
                    <!--                        <label for="inputLoadcellOutput2"><b>Loadcell 2</b> Rated Output <span-->
                    <!--                                class="units-text">(mV/V)</span>: </label>-->
                    <!--                        <input data-input-type="floatInput" type="number" id="inputLoadcellOutput2"-->
                    <!--                               value="0.0" step="any" min="0" max="100000000">-->
                    <!--                    </div>-->

                    <!--                    <div class="input-group">-->
                    <!--                        <label for="inputLoadcellCapacity3"><b>Loadcell 3</b> Capacity <span-->
                    <!--                                class="units-text">(kg)</span>: </label>-->
                    <!--                        <input data-input-type="intInput" type="number" id="inputLoadcellCapacity3"-->
                    <!--                               value="0" step="any" min="0" max="100000000">-->
                    <!--                    </div>-->

                    <!--                    <div class="input-group">-->
                    <!--                        <label for="inputLoadcellOutput3"><b>Loadcell 3</b> Rated Output <span-->
                    <!--                                class="units-text">(mV/V)</span>: </label>-->
                    <!--                        <input data-input-type="floatInput" type="number" id="inputLoadcellOutput3"-->
                    <!--                               value="0.0" step="any" min="0" max="100000000">-->
                    <!--                    </div>-->
                </div>

                <hr>

                <h4>üì∫ App settings:</h4>
                <div class="inputsContainer autoGrid">
                    <!--                    <div class="input-group prohibited">-->
                    <!--                        <label for="inputAppInterval" style="min-width: max-content;">Data Interval <span class="units-text">(¬µs)</span>:</label>-->
                    <!--                        <input data-input-type="intInput" type="number" id="inputAppInterval" value="30000"-->
                    <!--                               min="1000"-->
                    <!--                               step="any"-->
                    <!--                               max="100000000" style="height: 48px; max-width: 100px;">-->
                    <!--                    </div>-->


                    <div class="input-group">
                        <label for="inputAutoSave">
                            Save data after each experiment to CSV automatically:
                        </label>
                        <input type="checkbox" id="inputAutoSave" checked>
                    </div>

                    <div class="input-group">
                        <label for="inputClearCalculations">
                            Clear calculation inputs at the start of each experiment:
                        </label>
                        <input type="checkbox" id="inputClearCalculations" checked>
                    </div>


                    <div class="input-group">
                        <label for="decimalSymbol" style="min-width: max-content;">CSV Decimal Symbol: </label>
                        <select id="decimalSymbol" style="font-family: monospace; font-weight: bold;
                                font-size: 16px; width: max-content; height: 50px;">
                            <option value="Option-Dot" selected>&nbsp;Dot&nbsp;&nbsp;&nbsp;( . )&nbsp;</option>
                            <option value="Option-Comma">&nbsp;Comma&nbsp;( , )&nbsp;</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="delimiterSymbol" style="min-width: max-content;">CSV Delimiter Symbol: </label>
                        <select id="delimiterSymbol" style="font-family: monospace; font-weight: bold;
                                font-size: 16px; width: max-content; height: 50px;">
                            <option value="Option-Semicolon" selected>&nbsp;Semicolon&nbsp;( ; )&nbsp;</option>
                            <option value="Option-Comma">&nbsp;Comma&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( , )&nbsp;
                            </option>
                            <option value="Option-Space">&nbsp;Space&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( _ )&nbsp;
                            </option>
                            <option value="Option-Tab">&nbsp;Tab&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( \t )&nbsp;
                                <!-- ‚Üπ, ‚á•, ‚ÆÇ -->
                            </option>
                        </select>
                    </div>

                    <button id="clearCalculationsButton" class="controlBtn">üßº Clear
                        calculations
                    </button>

                    <button id="darkModeButton" class="controlBtn">üåô Dark mode</button>

                    <!--                    <button id="reportButton" class="controlBtn prohibited"-->
                    <!--                            style="color: var(&#45;&#45;stopEpx-color); font-weight: bold;">-->
                    <!--                        üêû Report bug-->
                    <!--                    </button>-->

                    <button id="aboutButton" class="controlBtn">‚ÑπÔ∏è About
                        app
                    </button>

                    <button id="clearStorageButton" class="controlBtn">üîÅ Reset app
                    </button>
                </div>
            </div>
        </section>

        <!-- Device Console Output Section -->
        <h3>üìã Device Console:</h3>
        <section class="openingContainer insetShadow">
            <button id="consoleContainerOpenBtn" class="openingContainerBtn">üîΩ</button>
            <div id="consoleContainer" class="sizeableContainer">
                <div class="logContainer">
                    <div id="regularLogWrapper">
                        <pre id="regularLog"></pre>
                    </div>
                    <pre id="loadingLog"></pre>
                    <div style="height: 40px;">
                        <label for="commandInput"></label>
                        <textarea id="commandInput" placeholder="Enter command..."></textarea>
                    </div>
                </div>

                <!-- Log Control Buttons -->
                <div class="logContainer">
                    <button id="toggleScrollBtn" class="logBtn">üìå Auto-scroll: ON</button>
                    <button id="toggleLineLockBtn" class="logBtn prohibited">üîí Fix Scroll: ON
                    </button><!--                    prohibited-->
                    <button id="clearRegularLog" class="logBtn">üóëÔ∏è Clear Log</button>
                    <button style="height: 40px; min-height: 40px; max-height: 40px;" id="sendButton" class="logBtn">
                        üì° Send Command
                    </button>

                </div>
            </div>
        </section>

    </section>

</main>

<script>
    const expTypesLabels = {
        "": "No selection",
        "move_up": "Move up",
        "move_down": "Move down",
        "load": "Load test",
        "unload": "Unload test",
        "hold": "Hold test",
        "static": "Static test",
        "dynamic": "Dynamic test",
        "fatigue": "Fatigue test",
        "creep": "Creep test",
        "impact": "Impact test",
        "tensile": "Tensile test",
        "internal_bond": "Internal bond test",
        "compression": "Compression test",
        "pressure": "Compression test",
        "flexural": "Flexural test",
        "bending": "Flexural test",
        "shear": "Shear test",
        "adhesion": "Adhesion test",
        "peel": "Peel test",
        "lap_shear": "Lap shear test",
        "punch_shear": "Punch shear test",
        "tear": "Tear test",
        "burst": "Burst test",
        "puncture": "Puncture test",
        "indentation": "Indentation test",
        "hardness": "Hardness test",
        "hardness_br": "Brinell hardness test",
        "hardness_vh": "Vickers hardness test",
        "hardness_hb": "Rockwell hardness test",
        "hardness_hr": "Rockwell hardness test",
        "hardness_hc": "Rockwell hardness test",
        "hardness_hd": "Rockwell hardness test",
        "hardness_hf": "Rockwell hardness test",
        "hardness_ho": "Rockwell hardness test",
        "hardness_hk": "Knoop hardness test",
        "other": "Other",
    };


    // =====================================================================
    // ====================      HELPERS      ==============================
    // =====================================================================

    const maxPrecision = 12; // max poƒçet platn√Ωch desetinn√Ωch m√≠st u zaokrouhlov√°n√≠
    const precisionTime = 6;
    const precisionPosition = 4;
    const precisionPositionSystem = precisionPosition;
    const precisionForce = 2;
    const precisionForceSystem = 4;
    const precisionSpeed = 2;
    const precisionSpeedSystem = 2;
    const precisionAcceleration = 4;
    const precisionAccelerationSystem = 2;

    const timeConversionDATAC = 1e-6; // p≈ôevod sekund na mikrosekundy
    const timeConversionDSLR = 1e-3; // p≈ôevod sekund na mikrosekundy

    const loadCellNum = 3; // number of load cells supported

    // -------------------- Pomocn√© DOM utilitky --------------------
    const $ = (sel) => document.querySelector(String(sel));
    const $$ = (sel) => document.querySelectorAll(String(sel));
    const $$$ = (id) => document.getElementById(String(id));
    const exists = (id) => !!$$$(id);


    // 1) Z√°kladn√≠ typov√© kontroly
    const isNumber = (x) => typeof x === 'number';
    const isBigInt = (x) => typeof x === 'bigint';
    const isArr = (x) => Array.isArray(x);
    const isNonEmptyArr = (x) => isArr(x) && x.length > 0;
    const isStr = (x) => typeof x === 'string';
    const isBool = (x) => typeof x === 'boolean';
    const isFunc = (x) => typeof x === 'function';
    const isObj = (x) => x !== null && typeof x === 'object' && !isArr(x);
    const isSymbol = (x) => typeof x === 'symbol';
    const isUndefined = (x) => typeof x === 'undefined';
    const isNull = (x) => x === null;
    const isDef = (x) => !isUndefined(x) && !isNull(x);
    const isEmptyStr = (x) => isStr(x) && x.trim() === '';
    const isNonEmptyStr = (x) => isStr(x) && x.trim() !== '';


    const isNum = (x) => isFiniteNumber(x, false); // only Finite numbers
    const isVal = (x) => isNum(x) || !isEmptyStr(x); // only Finite numbers or non-empty strings
    const isAny = (x) => isDef(x) && !Number.isNaN(x); // all except undefined, null and NaN
    const isOk = (x) => isAny(x) && x !== false; // all except undefined, null, NaN and false

    const isValidInput = (x) => isFiniteNumber(x, false) && x > 0;

    const getInputDef = (x, d) => {
        const v = toNumber(x, true);
        return catchVal(v, d);
    }
    const getInputDefAbsFlt = (x, d) => Math.abs(getInputDef(x, d));
    const getInputDefAbsInt = (x, d) => Math.round(getInputDefAbsFlt(x, d));

    const catchVal = (val, def) => {
        return isFiniteNumber(val, false) ? val : def;
    }

    const isNumberOrBigInt = (x) =>
        isNumber(x) || isBigInt(x);

    const isNumberOrInfinity = (x, bigInt = true) =>
        (isNumber(x) && !Number.isNaN(x)) || (isBigInt(x) && bigInt); // true i pro ¬±Infinity

    const isFiniteNumber = (x, bigInt = true) =>
        (isNumber(x) && Number.isFinite(x)) || (isBigInt(x) && bigInt);

    const isFiniteInteger = (x, bigInt = true) =>
        (isNumber(x) && Number.isInteger(x)) || (isBigInt(x) && bigInt);

    // 2) Parsov√°n√≠ stringu na ƒç√≠slo (podpora ƒç√°rky jako desetinn√© teƒçky)
    const toNumber = (x, all = true) => {
        if (isNumber(x)) return x;
        if (isBigInt(x)) return Number(x); // Number(x) pozor na p≈ôesnost u velk√Ωch hodnot
        return strToNumber(x, all); // if (isStr(x))
    };
    const toNumeric = (x, all = true) => {
        if (isNumberOrBigInt(x)) return x;
        return strToNumber(x, all); // if (isStr(x))
    };

    const toRounds = (x, digits = 0, way = 'round') => {
        const n = toNumber(x, true);
        if (!isNumberOrInfinity(n)) return NaN; // NaN/¬±Infinity

        if (way === 'round' || way === 'auto') {

            if (!Number.isFinite(n)) return n; // ¬±Infinity

            digits = Math.min(Math.abs(Math.round(toNumber(digits, true))), maxPrecision);

            if (!isFiniteInteger(digits)) return NaN;
            return roundDecimalFast(n, digits);
        }
        if (way === 'ceil' || way === 'up') return Math.ceil(n);
        if (way === 'floor' || way === 'down') return Math.floor(n);
        if (way === 'trunc' || way === 'drop') return Math.trunc(n);
        return NaN;
    };

    const toInteger = (x, way = 'drop', bigInt = false) => {
        if (isNumber(x) && Number.isInteger(x)) return x;
        if (isBigInt(x) && bigInt) return x;

        const n = toRounds(toNumber(x, true), 0, way);

        if (Number.isInteger(n)) return n;

        return NaN;
    };

    const strToNumber = (x, all = false) => {
        if (isStr(x)) {
            const s = x.trim();
            if (s === '') return NaN;
            const n = s.replaceAll(',', '.').replaceAll('¬±', ' ');
            return all ? parseFloat(n) : Number(n);
        }
        return NaN;
    };

    // 3) ‚ÄûJe to numerick√©‚Äú (vƒçetnƒõ ¬±Infinity)
    const isNumericOrInfinity = (x) => {
        if (isNumberOrInfinity(x)) return true; // true i pro ¬±Infinity
        const n = toNumeric(x, true);
        return !Number.isNaN(n); // true i pro ¬±Infinity
    };

    // 4) ‚ÄûJe to koneƒçn√© numerick√©‚Äú (bez NaN/¬±Infinity)
    const isFiniteNumeric = (x) => {
        if (isFiniteNumber(x, true)) return true;
        const n = toNumeric(x, true);
        return Number.isFinite(n);
    };

    // (voliteln√©) ‚Äûd√° se to s rozumn√Ωm v√Ωsledkem pou≈æ√≠t jako ƒç√≠slo‚Äú ‚Äì alias:
    const isAnyFiniteNumeric = (x) => {
        if (isFiniteNumber(x, true)) return true;
        const n = toNumeric(x, true);
        if (isBigInt(n)) return true; // BigInt je OK
        return Number.isFinite(n);
    };

    // 5) ‚ÄûM√° hodnotu‚Äú ‚Äì pokud pot≈ôebuje≈° zvl√°≈°≈• (0 projde, null/undef/"" ne)
    const hasValue = (x) => isDef(x) && (isNumberOrInfinity(x) || isNonEmptyStr(x));

    // Varianta, kter√° NEpova≈æuje false/true za ‚Äûhodnotu‚Äú
    const hasValueButNotBoolean = (x) => hasValue(x) && !isBool(x) && x.toLowerCase().trim() !== 'false' && x.toLowerCase().trim() !== 'true';

    const isNotEmpty = (x) => {
        if (!isDef(x)) return false;
        if (isBool(x)) return true; // false i true projde
        if (isNumberOrInfinity(x) && !Number.isNaN(x)) return true; // 0 i ¬±Infinity projde,  0n i velk√© hodnoty projdou
        if (isStr(x)) return x.trim() !== '';
        if (isArr(x)) return x.length > 0;
        if (isObj(x)) return Object.keys(x).length > 0;
        return false;
    };


    const isInvalidValue = (x, additionSet = [], use_extended = false) => {
        if (!hasValue(x)) return true;
        if (isNumberOrInfinity(x)) return false;

        const BAD_basic = new Set([
            'false',
            'nil', 'null', 'nullable', 'nullptr',
            'errno', 'error', 'err', 'error 404',
            'none', 'no', 'n/o', 'not', 'nothing', 'never',
            'nan', 'nat', 'n/a', 'na', 'n/d', 'nd',
            'undefined', 'empty', 'missing', 'void', 'voided', 'forgotten', 'out',
            'val', 'inv', 'invalid', 'not valid', 'disabled', 'expired', 'cancelled', 'not applicable', 'deleted', 'del',
            '‚Åø/‚Çê', '‚êÄ', '‚ê§', '‚ê°',
            'x', '‚úñ', '‚úñÔ∏è', '‚ùå',
            '!', '‚Äº',
            '?', '‚Åá',
            '‚ÄΩ', '!?', '?!',

        ]);

        const BAD_extended = new Set([
            '„éÅ',
            '√ó', '‚ï≥', '‚òì', '‚úï', '‚úó', '‚úò', '‚®â', '‚®Ø', 'üóô', 'üó¥', 'üó∂', 'üû©',
            '‚ùé', '‚òí', '‚ÆΩ', 'üóµ', 'üó∑', '‚ä†', '‚åß', 'üù±',
            '‚Ææ', '‚Æø', '‚äó', '‚®Ç', '‚≠ô',
            '‚ö†Ô∏é', '‚ö†', '‚ö†Ô∏è',
            '‚õî', '‚äò', 'üö´',
            '«É', '‚ùï', '‚ùó', '‚ù¢', 'Íúù', '·µé·µé',
            '‚Åâ', '‚Åà', 'üôπ', 'üô∫', 'üôª',
            'Ôπñ', '‚ùî', '‚ùì', '‚ç∞', 'ÔøΩ', '‚Øë', '¬ø', '‚∏Æ', 'Ô∏ñ', 'Ôºü',
            'üö®', 'üí•', 'üöß', 'üÜò', '4Ô∏è‚É£0Ô∏è‚É£4Ô∏è', '‚Å¥‚Å∞‚Å¥',
            'Ôøº',
        ]);


        const norm = v => String(v || '')
            .normalize('NFKD')
            .replace(/\p{Diacritic}/gu, '') // odstran√≠ diakritiku
            .replace(/[.,]/g, '')           // sma≈æe ƒç√°rky a teƒçky
            .replace(/\\/g, '/')            // nahrad√≠ \ za /
            .replace(/\s+/g, ' ')           // zjednodu≈°√≠ v√≠cen√°sobn√© mezery
            .trim()
            .toLowerCase();


        if (use_extended) for (const v of BAD_extended) BAD_basic.add(norm(v));

        if (isNonEmptyArr(additionSet)) for (const v of additionSet) BAD_basic.add(norm(v));

        return BAD_basic.has(norm(x));
    }

    const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    const checkArray = (arr) => {
        if (!isNotEmpty(arr)) return NaN;
        return isArr(arr) ? arr : [arr];
    }

    const checkObject = (obj) => {
        if (!isNotEmpty(obj)) return NaN;
        if (isObj(obj)) return obj;
        if (isArr(obj)) {
            const res = {};
            for (let i = 0; i < obj.length; i++) {
                res[i] = obj[i];
            }
            return res;
        }
        if (isStr(obj) || isNumberOrInfinity(obj) || isBool(obj)) {
            return {0: obj};
        }
        return NaN;
    }

    const decimalSymbol = (num, symbol = '.') => {
        if (!isAnyFiniteNumeric(num)) return "N/A";
        if (!isFiniteNumber(num, true)) num = String(num);
        const s = String(num);
        return symbol === '.' ? s : s.replace('.', symbol);
    };

    const getValue = (x, dec = "none", strOut = false) => {
        const def = strOut ? "N/A" : NaN;

        if (!isNumericOrInfinity(x)) return def;

        // 1) p≈ôevedeme vstup na ƒç√≠slo (tv≈Øj toNumber um√≠ i ƒç√°rku apod.)
        let n = toNumeric(x, true);

        if (strOut && typeof isBigInt(n)) n = Number(n);

        if (dec == null || dec === "none" || isBigInt(n)) {
            // ≈æ√°dn√© dec -> vra≈• n
            return strOut ? String(n) : n;
        }

        // 2) vyhodnot√≠me desetinn√° m√≠sta jen jednou
        if (!isAnyFiniteNumeric(dec)) return def;
        const d = Math.min(Math.round(toNumber(dec, true)), maxPrecision);

        if (d < 0) return def; // neplatn√© dec -> vra≈• NaN/"N/A"

        // 3) zaokrouhlen√≠
        return strOut ? n.toFixed(d) : roundDecimalFast(n, d);
    };

    // Bezpeƒçn√° koerce na BigInt (p≈ôijme number/BigInt/string s ƒç√≠slem)
    const toBigInt = (x) => {
        if (isBigInt(x)) return x;
        let n = toNumber(x, true);
        if (!isFiniteNumber(n, true)) return NaN;
        if (!isFiniteInteger(n)) n = Math.round(n);
        try {
            return BigInt(n);
        } catch (e) {
            return NaN;
        }
    };

    // O≈ô√≠znut√≠ na n bit≈Ø (nap≈ô. 64bit bezznam√©nkov√© ID)
    const toUintN = (n, b) => BigInt.asUintN(n, toBigInt(b));
    // a se znam√©nkem:
    const toIntN = (n, b) => BigInt.asIntN(n, toBigInt(b));

    const decimalToHex = (num) => {
        if (!isFiniteInteger(num) || num < 0) return "N/A";
        return "0x" + num.toString(16).toUpperCase();
    };
    const decimalToBinary = (num) => {
        if (!isFiniteInteger(num) || num < 0) return "N/A";
        return "0b" + num.toString(2);
    };
    const binaryToDecimal = (str) => {
        if (!isStr(str)) return NaN;
        const s = str.trim();
        if (!/^0b[01]+$/i.test(s)) return NaN;
        return parseInt(s.slice(2), 2);
    };
    const hexToDecimal = (str) => {
        if (!isStr(str)) return NaN;
        const s = str.trim();
        if (!/^0x[0-9a-f]+$/i.test(s)) return NaN;
        return parseInt(s.slice(2), 16);
    };


    const getNumValue = (x, dec = "none") => getValue(x, dec, false);
    const getStrFixedValue = (x, dec = "none") => getValue(x, dec, true);
    const getStrValue = (x, dec = "none") => ((n => Number.isNaN(n) ? "N/A" : String(n))(getNumValue(x, dec)));
    const getCustomStrValue = (x, dec = "none", decSym = '.', writeSign = false, fixed = false, customError = "N/A") => {
        const v = fixed ? getStrFixedValue(x, dec) : getStrValue(x, dec);
        if (v === "N/A") return customError;
        let s = v;
        if (!(v === "Infinity" || v === "-Infinity")) s = decimalSymbol(v, decSym);
        s = s.replace('Infinity', '‚àû')
        if (writeSign && !s.startsWith('-')) {
            if (roundDecimalFast(strToNumber(v), 12) === 0) {
                s = '¬±' + s;
            } else {
                s = '+' + s;
            }
        }
        return s;
    };

    function roundDecimalFast(num, decimalPlace) {
        num ||= 0;
        decimalPlace ||= 0;
        const p = Math.pow(10, decimalPlace)
        return Math.round(num * p) / p;
    }

    const arrayWrapper = (arr, func, args) => {
        // console.log(arrayWrapper([0.000, "0", 454214878181871n, 0n, "0n", "900800700600500400300200100", "   -45   ", "   +45   ", "   ¬±45¬±45   ", 488.45, "100.005  ", "100. 005  ", "12,34", "  56.78  ", "text", null, undefined, {}, [], "NaN", "Infinity", "-Infinity"], getCustomStrValue, [12, '.', false, true]));
        if ((!arr && arr !== 0) || !func) return NaN;
        if (!isFunc(func)) return NaN;
        arr = checkArray(arr);
        if (!isNotEmpty(arr)) return NaN;
        args = checkArray(args);
        const res = [];
        for (let i = 0; i < arr.length; i++) {
            res.push(func(arr[i], ...args));
        }
        return res;
    }

    const objectWrapper = (obj, func, args) => {
        if ((!obj && obj !== 0) || !func) return NaN;
        if (!isFunc(func)) return NaN;
        obj = checkObject(obj);
        if (!isNotEmpty(obj)) return NaN;
        args = checkArray(args);
        const res = {};
        for (const key in obj) {
            if (Object.hasOwnProperty.call(obj, key)) {
                res[key] = func(obj[key], ...args);
            }
        }
        return res;
    }

    // =====================================================================
    // S T A T   &   E X T R E M A   U T I L S   (2D, ragged-friendly)
    // =====================================================================

    // ---------- intern√≠ helpery ----------
    /** Normalizace vstupu na 2D pole ≈ô√°dk≈Ø; pr√°zdno -> [] */
    const normalize2D = (input) => {
        const outer = checkArray(input);
        if (Number.isNaN(outer)) return [];
        return outer.map(r => {
            const row = checkArray(r);
            return Number.isNaN(row) ? [] : row;
        });
    };

    /** D√©lka nejdel≈°√≠ho ≈ô√°dku */
    const rowsMaxLen = (rows) => rows.reduce((m, r) => Math.max(m, r.length), 0);

    /** Vyta≈æen√≠ sloupce j jako pole (m≈Ø≈æe obsahovat undefined) */
    const getCol = (rows, j) => rows.map(r => r[j]);

    /** Vr√°t√≠ pouze koneƒçn√° ƒç√≠sla (toNumber(..., true)); ostatn√≠ vyhod√≠ */
    const valuesFinite = (list) => {
        const arr = checkArray(list);
        if (Number.isNaN(arr)) return [];
        const out = [];
        for (const v of arr) {
            const n = toNumber(v, true);
            if (Number.isFinite(n)) out.push(n);
        }
        return out;
    };

    /** Aplikaƒçn√≠ kostra: vezme 1D oper√°tor a aplikuje ho po dimenzi (0/1/2) */
    const aggregateND = (input, dim, op1D) => {
        const rows = normalize2D(input);

        if (dim === 0 || dim == null) {
            const flat = [];
            for (const r of rows) flat.push(...r);
            return op1D(flat);
        }
        if (dim === 1) return rows.map(r => op1D(r));
        if (dim === 2) {
            const W = rowsMaxLen(rows);
            const out = new Array(W);
            for (let j = 0; j < W; j++) out[j] = op1D(getCol(rows, j));
            return out;
        }
        return NaN;
    };

    /** Glob√°ln√≠ argmin/argmax v 2D -> [rowIdx, colIdx] nebo NaN */
    const argExtremum2D = (rows, acceptInf, isMin) => {
        let best = isMin ? Infinity : -Infinity;
        let bi = -1, bj = -1, seen = false;
        for (let i = 0; i < rows.length; i++) {
            const r = rows[i];
            for (let j = 0; j < r.length; j++) {
                const n = toNumber(r[j], true);
                const ok = acceptInf ? !Number.isNaN(n) : Number.isFinite(n);
                if (!ok) continue;
                if ((isMin && n < best) || (!isMin && n > best)) {
                    best = n;
                    bi = i;
                    bj = j;
                    seen = true;
                }
            }
        }
        return seen ? [bi, bj] : NaN;
    };

    // ---------- 1D oper√°tory ----------
    const sum1D = (list) => {
        const v = valuesFinite(list);
        if (!v.length) return NaN;
        let s = 0;
        for (let i = 0; i < v.length; i++) s += v[i];
        return s;
    };

    const mean1D = (list) => {
        const v = valuesFinite(list);
        return v.length ? sum1D(v) / v.length : NaN;
    };

    const median1D = (list) => {
        const v = valuesFinite(list);
        if (!v.length) return NaN;
        v.sort((a, b) => a - b);
        const m = Math.floor(v.length / 2);
        return v.length % 2 ? v[m] : (v[m - 1] + v[m]) / 2;
    };

    /** Smƒõrodatn√° odchylka; sample=true -> Bessel (N-1), jinak populace (N) */
    const std1D = (list, sample = false) => {
        const v = valuesFinite(list);
        const n = v.length;
        if (!n || (sample && n < 2)) return NaN;

        let sum = 0;
        for (let i = 0; i < n; i++) sum += v[i];
        const mu = sum / n;

        let acc = 0;
        for (let i = 0; i < n; i++) {
            const d = v[i] - mu;
            acc += d * d;
        }
        const denom = sample ? (n - 1) : n;
        return Math.sqrt(acc / denom);
    };

    // ---------- 1D extr√©my (sjednocen√©) ----------
    /** Hodnota extr√©mu v 1D podle which='min'|'max' */
    const extremum1DValue = (arr, which = 'min', acceptInf = false) => {
        if (!isArr(arr) || arr.length === 0) return NaN;
        let best = which === 'min' ? Infinity : -Infinity;
        let seen = false;
        for (const v of arr) {
            const n = toNumber(v, true);
            if (Number.isNaN(n)) continue;
            if ((which === 'min' && n < best) || (which === 'max' && n > best)) {
                best = n;
                seen = true;
            }
        }
        if (!seen) return NaN;
        return acceptInf ? best : (Number.isFinite(best) ? best : NaN);
    };

    /** Index extr√©mu v 1D podle which='min'|'max' */
    const extremum1DIndex = (arr, which = 'min', acceptInf = false) => {
        if (!isArr(arr) || arr.length === 0) return NaN;
        let best = which === 'min' ? Infinity : -Infinity;
        let idx = -1;
        for (let i = 0; i < arr.length; i++) {
            const n = toNumber(arr[i], true);
            if (Number.isNaN(n)) continue;
            if ((which === 'min' && n < best) || (which === 'max' && n > best)) {
                best = n;
                idx = i;
            }
        }
        return acceptInf ? idx : (Number.isFinite(best) ? idx : NaN);
    };

    // ---------- ND extr√©my (sjednocen√©) ----------
    const extremumND = (input, dim = 0, which = 'min', acceptInf = false) =>
        aggregateND(input, dim, (list) => extremum1DValue(list, which, acceptInf));

    const extremumNDIdx = (input, dim = 0, which = 'min', acceptInf = false) => {
        const rows = normalize2D(input);

        if (dim === 0 || dim == null) {
            return argExtremum2D(rows, acceptInf, which === 'min');
        }
        if (dim === 1) {
            return rows.map(r => extremum1DIndex(r, which, acceptInf));
        }
        if (dim === 2) {
            const W = rowsMaxLen(rows);
            const out = new Array(W);
            for (let j = 0; j < W; j++) {
                out[j] = extremum1DIndex(getCol(rows, j), which, acceptInf);
            }
            return out;
        }
        return NaN;
    };

    const extremumNDWithIdx = (input, dim = 0, which = 'min', acceptInf = false) => {
        const rows = normalize2D(input);
        const idx = extremumNDIdx(rows, dim, which, acceptInf);
        if (Number.isNaN(idx)) return {value: NaN, index: NaN};

        if (dim === 0 || dim == null) {
            const [i, j] = idx;
            return {value: toNumber(rows[i]?.[j], true), index: [i, j]};
        }

        if (dim === 1) {
            const values = rows.map((r, i) => {
                const j = idx[i];
                return Number.isFinite(j) ? toNumber(r[j], true) : NaN;
            });
            return {value: values, index: idx};
        }

        if (dim === 2) {
            const W = rowsMaxLen(rows);
            const values = new Array(W);
            for (let j = 0; j < W; j++) {
                const i = idx[j];
                values[j] = Number.isFinite(i) ? toNumber(rows[i]?.[j], true) : NaN;
            }
            return {value: values, index: idx};
        }

        return {value: NaN, index: NaN};
    };

    // Najde indexy a hodnoty prvk≈Ø nejbl√≠≈æe k c√≠lov√© hodnotƒõ (1D pole).
    // Vrac√≠ { indexes: number[], values: number[], distance: number }.
    // Pokud nic validn√≠ho, vrac√≠ { indexes: NaN, values: NaN, distance: NaN }.
    const nearest1D = (list, target) => {
        const arr = checkArray(list);
        if (Number.isNaN(arr)) return {indexes: NaN, values: NaN, distance: NaN};

        const t = toNumber(target, true);
        if (Number.isNaN(t)) return {indexes: NaN, values: NaN, distance: NaN};

        // Speci√°l: kdy≈æ c√≠l je +‚àû/-‚àû, smysluplnƒõ zvol√≠me extr√©m
        if (t === Infinity || t === -Infinity) {
            const which = t === Infinity ? 'max' : 'min';
            // najdi extr√©mn√≠ hodnotu (koneƒçnou, pokud existuje)
            let bestVal = extremum1DValue(arr, which, /*acceptInf*/ true);
            if (Number.isNaN(bestVal)) return {indexes: NaN, values: NaN, distance: NaN};

            // seber v≈°echny indexy s touto hodnotou
            const indexes = [];
            const values = [];
            for (let i = 0; i < arr.length; i++) {
                const n = toNumber(arr[i], true);
                if (Object.is(n, bestVal) || (Number.isFinite(n) && Number.isFinite(bestVal) && n === bestVal)) {
                    indexes.push(i);
                    values.push(n);
                }
            }
            return {indexes, values, distance: Math.abs(bestVal - t)}; // bude Infinity u koneƒçn√Ωch bestVal proti ¬±‚àû
        }

        // Bƒõ≈æn√Ω p≈ô√≠pad: koneƒçn√Ω c√≠l
        const EPS = 1e-12;
        let bestDist = Infinity;
        let indexes = [];
        let values = [];

        for (let i = 0; i < arr.length; i++) {
            const n = toNumber(arr[i], true);
            if (!Number.isFinite(n)) continue;

            const d = Math.abs(n - t);
            if (d + EPS < bestDist) {        // lep≈°√≠ kandid√°t
                bestDist = d;
                indexes = [i];
                values = [n];
            } else if (Math.abs(d - bestDist) <= EPS) { // stejnƒõ bl√≠zko ‚Üí p≈ôidej
                indexes.push(i);
                values.push(n);
            }
        }

        if (!indexes.length) return {indexes: NaN, values: NaN, distance: NaN};
        return {indexes, values, distance: bestDist};
    };

    const findFirstHigher = (arr, limit) => {
        for (let i = 0; i < arr.length; i++) {
            const n = toNumber(arr[i], true);
            if (Number.isFinite(n) && n >= limit) {
                return i;
            }
        }
    }

    const findTargetForce = (arr_F, arr_W, target_F) => {
        const idx = findFirstHigher(arr_F, target_F);
        if (idx < 1) return [arr_F[0], 0];
        return [linearInterpolation(arr_F[idx], arr_W[idx], arr_F[idx - 1], arr_W[idx - 1], target_F), idx];
    }


    // ---------- ND oper√°tory ----------
    // Dim = 0 -> global; 1 -> by rows; 2 -> by cols
    const sumND = (input, dim = 0) => aggregateND(input, dim, sum1D);
    const meanND = (input, dim = 0) => aggregateND(input, dim, mean1D);
    const medianND = (input, dim = 0) => aggregateND(input, dim, median1D);
    const stdND = (input, dim = 0) => aggregateND(input, dim, (list) => std1D(list, false)); // stdND: sample = false ‚Üí populace; true ‚Üí v√Ωbƒõr (N-1)
    const stdNDsample = (input, dim = 0) => aggregateND(input, dim, (list) => std1D(list, true)); // Alias pokud chce≈° v√Ωslovnƒõ ‚Äûsample‚Äú signaturu
    const nearestND = (input, dim = 0, target) => aggregateND(input, dim, (list) => nearest1D(list, target));

    // ---------- aliasy ‚Äûmin/max‚Äú pro pohodl√≠ a kompatibilitu ----------
    const minND = (input, dim = 0, acceptInf = false) => extremumND(input, dim, 'min', acceptInf);
    const maxND = (input, dim = 0, acceptInf = false) => extremumND(input, dim, 'max', acceptInf);
    const minNDIdx = (input, dim = 0, acceptInf = false) => extremumNDIdx(input, dim, 'min', acceptInf);
    const maxNDIdx = (input, dim = 0, acceptInf = false) => extremumNDIdx(input, dim, 'max', acceptInf);
    const minNDWithIdx = (input, dim = 0, acceptInf = false) => extremumNDWithIdx(input, dim, 'min', acceptInf);
    const maxNDWithIdx = (input, dim = 0, acceptInf = false) => extremumNDWithIdx(input, dim, 'max', acceptInf);

    const nearest = (arr, target) => nearest1D(arr, target);
    const minimum = (arr, acceptInf = false) => extremum1DValue(arr, 'min', acceptInf);
    const maximum = (arr, acceptInf = false) => extremum1DValue(arr, 'max', acceptInf);
    const minimumIdx = (arr, acceptInf = false) => extremum1DIndex(arr, 'min', acceptInf);
    const maximumIdx = (arr, acceptInf = false) => extremum1DIndex(arr, 'max', acceptInf);


    const invLerp = (a, b, x) => (x - a) / (b - a);
    const lerp = (start, end, t) => start + t * (end - start);
    const mapLetp = (a1, b1, a2, b2, c1) => lerp(a2, b2, invLerp(a1, b1, c1));


    const linearInterpolation = (a1, a2, b1, b2, c1) => {
        if (a1 === b1) return a2; // Avoid division by zero
        return mapLetp(a1, b1, a2, b2, c1);
    }

    // UTF-8 <-> Base64 helpers bez unescape/escape:
    const u8ToB64 = (u8) => {
        let s = "";
        for (let i = 0; i < u8.length; i++) s += String.fromCharCode(u8[i]);
        return btoa(s);
    };
    const b64ToU8 = (b64) => {
        const bin = atob(b64);
        const u8 = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
        return u8;
    };
    const te = new TextEncoder();
    const td = new TextDecoder();

    // =====================================================================
    // =====================================================================

    // ===================================
    // ======= Calculation helpers =======

    const calc_val_tare = (x, x_tare = 0) => x - x_tare;
    const calc_area = (b, h) => b * h;
    const calc_moment_of_inertia = (b, h) => 1 / 12 * b * (h * h * h);
    const calc_bend_modulus = (L, I, F, w) => (F * (L * L * L)) / (48 * I * w);
    const calc_stress = (F, A) => F / A;
    const calc_speed = (d, t) => d / t;
    const calc_indentation_diameter = (h, D) => 2 * Math.sqrt(h * (D - h));
    const calc_hardness_brinell = (F, D, d) => (2 * F) / (Math.PI * D * (D - Math.sqrt((D * D) - (d * d))));

    // =====================================================================
    // =====================================================================


    // ƒçten√≠ ƒç√≠sla z inputu p≈ôes tvoje utility
    const readNum = (id, positiveOnly = false) => {
        const el = $$$(id);
        if (!el) return NaN;
        const val = getNumValue(el.value, "none");  // umo≈æn√≠ ƒç√°rku, ¬±, apod.
        return !positiveOnly ? val : (val < 0 ? NaN : val);
    };

    // z√°pis do outputu jako ƒç√≠sla s fixn√≠ p≈ôesnost√≠
    const writeOut = (id, value, dec = 3) => {
        const el = $$$(id);
        if (!el) return;
        el.value = getCustomStrValue(value, dec, '.', false, false, "‚Åø/‚Çê");
    };

    // -------------------- Hlavn√≠ p≈ôepoƒçet --------------------
    function recomputeAll() {
        if (!pageLoaded) return;

        fillComputableInputs();

        // --- naƒçten√≠ spoleƒçn√Ωch vstup≈Ø (tare) ---
        const F_tare = readNum("inputTareForce");      // N
        const w_tare = readNum("inputTareDisp");       // mm

        // --- B/IB/HB spoleƒçn√© ---
        const F_raw = readNum("inputForce");           // N
        const w_raw = readNum("inputDisp");            // mm
        const F = calc_val_tare(F_raw, F_tare);
        const w = calc_val_tare(w_raw, w_tare);

        const expType = $$$("experimentTypeDropdown")?.value.toLowerCase();

        const isB = expType.endsWith("-flx");
        const isIB = expType.endsWith("-inb");
        const isHB = expType.endsWith("-hbr");

        if (!isB && !isIB && !isHB) return; // nic dal≈°√≠ho nep≈ôepoƒç√≠t√°me

        const b = readNum("inputWidth", true);   // mm
        const h = readNum("inputHeight", true);  // mm


        // -------------------- IB: pr≈Ø≈ôez + napƒõt√≠ --------------------
        if (isIB) {
            // A = b*h
            const A = calc_area(b, h); // mm^2
            if (exists("outputArea")) writeOut("outputArea", A, 3);


            // œÉ_max = F / A
            const sigma = calc_stress(F, A); // N/mm^2 = MPa
            if (exists("outputMaxStress")) writeOut("outputMaxStress", sigma, 4);

        }

        // -------------------- B: ohyb (I_y, E) --------------------
        if (isB) {
            const I = calc_moment_of_inertia(b, h); // mm^4
            if (exists("outputIy")) writeOut("outputIy", I, 3);

            // E = (F * L^3) / (48 * I * w)   (3-bodov√Ω ohyb uprost≈ôed)
            const L = readNum("inputSpan", true); // mm
            const E = calc_bend_modulus(L, I, F, w); // vych√°z√≠ v N/mm^2 = MPa
            if (exists("outputModulus")) writeOut("outputModulus", E, 4);

            const b_dry = readNum("inputWidth_AfterDrying", true);     // mm
            applyAdjust('inputWidth', b_dry);
            applyAdjust('inputWidth_AfterDrying', b);

            const h_dry = readNum("inputHeight_AfterDrying", true);   // mm
            applyAdjust('inputHeight', h_dry);
            applyAdjust('inputHeight_AfterDrying', h);

            const L_dry = readNum("inputLength_AfterDrying", true);       // mm
            applyAdjust('inputSpan', L_dry);
            applyAdjust('inputLength_AfterDrying', L);
        } else {
            adjustDel('inputWidth');
            adjustDel('inputHeight');
            adjustDel('inputWidth_AfterDrying');
            adjustDel('inputHeight_AfterDrying');
            adjustDel('inputSpan');
            adjustDel('inputLength_AfterDrying');
        }

        // -------------------- HB: Brinell --------------------
        if (isHB) {
            const D = readNum("inputIndDiameter", true); // mm (‚åÄ indenteru)
            const hD = readNum("inputIndDepth", true);    // mm (hloubka vtisku)

            // d = 2 * sqrt( h * (2r - h) )  ;  2r = D  ; d = 2 * sqrt( h * (D - h) )
            const d = calc_indentation_diameter(hD, D);

            if (exists("outputDiameterInd")) writeOut("outputDiameterInd", (hD > D / 2) ? NaN : d, precisionPositionSystem);

            // HB = (2*F) / (œÄ*D*(D - sqrt(D^2 - d^2)))
            const HB = calc_hardness_brinell(F, D, d);
            if (exists("outputHardness")) writeOut("outputHardness", (hD > D / 2) ? NaN : HB, 4);


            // Rychlost zatƒõ≈æov√°n√≠: v = w_T / t
            const wT = readNum("inputTargetDisp", true);  // mm
            const t = readNum("inputLoadingTime", true); // s
            const v = calc_speed(wT, t);
            if (exists("outputLoadingSpeed")) writeOut("outputLoadingSpeed", v, precisionSpeedSystem + 2);

        }
    }

    // -------------------- Event wiring --------------------
    function bindRecalcOnInputs() {
        if (!exists("experimentTypeDropdown")) return;

        // jak√Ωkoli input/number v bloc√≠ch s class .data-eq spust√≠ p≈ôepoƒçet
        const inputs = $$('.data-eq input[type="number"]');
        inputs?.forEach((el) => {
            // "input" je plynulej≈°√≠; "change" je a≈æ po opu≈°tƒõn√≠ pole. D√°me oboje.
            el.addEventListener('input', async () => recomputeAll());
        });

        $$$('experimentTypeDropdown')?.addEventListener('change', async () => recomputeAll());
    }

    const applyAdjust = (id, value) => (exists(id) && adjustGet(id) !== value) ? adjustSet(id, (!isInvalidValue(value) ? value : NaN)) : null;

    function fillComputableInputs() {
        const forces = sumND(forceData, 2); // souƒçet sil ze v≈°ech kan√°l≈Ø
        const displacements = positionData;
        // const minimalForceID = minimumIdx(forces);
        const maximalForceID = maximumIdx(forces);

        const F_tare = readNum("inputTareForce");      // N
        const w_tare = readNum("inputTareDisp");       // mm

        const Fmax_raw = forces[maximalForceID];            // N
        const w_Fmax_raw = displacements[maximalForceID];   // mm

        const Fmax = calc_val_tare(Fmax_raw, F_tare)
        const w_Fmax = calc_val_tare(w_Fmax_raw, w_tare)

        // Zapi≈° z√°kladn√≠ "max" (rozumƒõj aktu√°ln√≠ zadan√©) hodnoty, pokud v√Ωstupy existuj√≠
        if (exists("outputForceMax")) writeOut("outputForceMax", Fmax, precisionForceSystem);
        if (exists("outputDisp")) writeOut("outputDisp", w_Fmax, precisionPositionSystem);

        const Ftarget_goal = readNum("inputTargetForce"); // N
        const [w_Ftarget_raw, FtargetInd] = findTargetForce(forces, displacements, Ftarget_goal);
        const w_Ftarget = calc_val_tare(w_Ftarget_raw, w_tare);
        if (exists("inputTargetDisp")) writeOut('inputTargetDisp', w_Ftarget, precisionPositionSystem + 1);

        const inputForce = readNum("inputForce");
        const foundForce = nearest(forces, inputForce);
        const foundForceInd = foundForce.indexes;
        const isCloseForce = (foundForce.distance < Math.max((inputForce * 0.02), (1 / Math.pow(10, Math.round(precisionForce / 2)))));
        const w_inputForce = isCloseForce ? roundDecimalFast(displacements[foundForceInd], precisionPositionSystem) : NaN; // mm
        applyAdjust('inputDisp', w_inputForce);


        if ($$$("experimentTypeDropdown")?.value.toLowerCase().endsWith("-hbr")) {
            const finalForce = roundDecimalFast(mean1D(forces.slice(FtargetInd)), precisionForceSystem);
            applyAdjust('inputForce', finalForce);
        } else {
            const inputDisp = readNum("inputDisp");
            const foundDisp = nearest(displacements, inputDisp);
            const foundDispInd = foundDisp.indexes;
            const isCloseDisp = (foundDisp.distance < Math.max((inputDisp * 0.02), (1 / Math.pow(10, Math.round(precisionPosition / 2)))));
            const F_inputDisp = isCloseDisp ? roundDecimalFast(forces[foundDispInd], precisionForceSystem) : NaN; // N
            applyAdjust('inputForce', F_inputDisp);
        }
        const depthIndentation = roundDecimalFast(displacements[displacements.length - 1] - displacements[FtargetInd], precisionPositionSystem);
        applyAdjust('inputIndDepth', depthIndentation);

    }

    function clearCalculations() {

        $$$('inputTareForce').value = '0';
        $$$('inputTareDisp').value = '0';
        $$$('inputMaterialName').value = '';
        $$(".data-eq[data-eq-type]")?.forEach(el => {
            el.querySelectorAll('input')?.forEach(input => {
                input.value = '';
            });
        });
        recomputeAll();
    }

    // -------------------- Init --------------------
    document.addEventListener('DOMContentLoaded', () => {

        $$$('inputStopForce')?.addEventListener('change', async (event) => applyAdjust('inputTargetForce', event.target.value));

        if (exists("inputLoadingTime")) adjustSet('inputLoadingTime', 15);
        if (exists("inputIndDiameter")) adjustSet('inputIndDiameter', 10);

        bindRecalcOnInputs();

        (() => {
            const allButtons = $$('button');

            allButtons?.forEach(button => {
                // block right-click context menu on buttons
                button.addEventListener('contextmenu', event => event.preventDefault());
            });
        })();
    });


    function toggleDarkMode() {
        const body = document.body;
        const currentTheme = body.dataset.theme;
        const newTheme = currentTheme === "dark" ? "light" : "dark";
        $$$('darkModeButton').innerText = currentTheme === "dark" ? "üåô Dark mode" : "‚òÄÔ∏è Light mode";
        body.dataset.theme = newTheme;
        localStorage.setItem("theme", newTheme); // Save the theme to localStorage
        console.info("Theme changed to:", newTheme);
    }


    // Load the saved theme from localStorage on initialization
    const savedTheme = localStorage.getItem("theme") || "light";
    if (exists('darkModeButton')) $$$('darkModeButton').innerText = savedTheme === "dark" ? "‚òÄÔ∏è Light mode" : "üåô Dark mode"
    document.body.dataset.theme = savedTheme;

    // serviceWorkerRegistration();
    //
    // async function serviceWorkerRegistration() {
    //
    //     if ('serviceWorker' in navigator) {
    //         console.info('‚òëÔ∏è Service Worker is supported.');
    //
    //         navigator.serviceWorker.getRegistration()
    //             .then(reg => {
    //                 const match = reg && reg.active && reg.active.scriptURL.includes('service-worker.js');
    //
    //                 if (match) {
    //                     // serviceWorkerRegistrationStatus = true;
    //                     console.info('‚úÖ Service worker is registered:', reg);
    //                 } else {
    //                     navigator.serviceWorker.register('service-worker.js').then(function (registration) {
    //                         console.info('üÜï Service Worker was registered', registration);
    //                     }).catch(function (error) {
    //                         console.info('‚ùå Registration failed.', error);
    //                     });
    //                 }
    //             })
    //             .catch(err => {
    //                 console.error('‚ö†Ô∏è Error checking service worker registration:', err);
    //             });
    //     } else {
    //         console.info('üö´ Service Worker is not supported.');
    //     }
    //
    //     await sleep(10);  // Stop
    //
    //     // console.info(serviceWorkerRegistrationStatus);
    //     // if (!serviceWorkerRegistrationStatus) window.location.reload();
    // }

    const storageKey = "formData"; // Key in localStorage

    // /////// Log Settings /////////

    isMeasuring = false;// Tracks whether the device is currently measuring
    let isAutoScroll = true;// Enables automatic scrolling of log output
    let isLineLimit = true;// Limits the number of stored log lines
    let isLineLocker = true;// Locks the view at a fixed position when scrolling is disabled
    let logContentMaxLines = 150;// Maximum number of log lines to keep in memory
    let isScrolledToBottom = true;// Tracks whether the user has scrolled to the bottom of the log
    let logCount = 0; // Counter for received messages
    let logContentLines = []; // Array storing the log content


    let parsedData = {time: null, position: null, value: null, force: Array(loadCellNum).fill(null), photoIndex: null}; // Last data log


    // /////// Live Data Update and Chart Configuration /////////

    // Live update flag (disabled by default)
    let liveUpdate = false;
    let liveUpdatePaused = false;

    // Maximum number of data points displayed in the charts
    let maxDataPoints = 1e5;

    let isReadingSerial = false;


    let dataFormat = null; // Data format for parsing incoming data
    let waitingForDataFormat = false; // Flag for waiting for data format response
    let onDataMatch = null; // Callback function for data matching


    // /////// Experiment Configuration /////////
    let forceLimitDropPercent = 0;
    let forceLimitDropValue = 0;
    let zero_speed_counter = 0;
    let over_limitForce_counter = 0;
    let startPosition = 0;
    let experimentEndLimits = {position: null, force: null, time: null};
    let expControl = '';

    let checkSpeed = true;
    let isExperimentRunning = false;
    let machineOccupation = false;

    let maxForces = Array(loadCellNum).fill(null);

    let measureForces = Array(loadCellNum).fill(0).map(() => []);
    let takeMeasurements = false;
    let meanForces = Array(loadCellNum).fill(0);


    // MOVING
    let movingTimeout = null;

    // /////// UI Elements /////////
    const UI = {
        regularLogContainer: $$$("regularLog"),// Reference to the log display container
        loadingLogContainer: $$$("loadingLog"),// Reference to the loading log display container
        toggleScrollBtn: $$$("toggleScrollBtn"), // Button to toggle automatic scrolling
        lineLockBtn: $$$("toggleLineLockBtn"), // Button to lock the log view
        commandInput: $$$('commandInput'),// Input elements for command entry and settings
        sendButton: $$$('sendButton'),// Input elements for command entry and settings
        chartsLiveButton: $$$('toggleLive'),// Input elements for command entry and settings
        connectionStatus: $$$("connectionStatus"), // Display for connection status
        USB: $$$("connectBtnUSB"), // Button to connect via USB

        progressBar: $$$("experimentProgress"), // Progress bar for experiment status
        progressLabel: $$$("experimentProgressLabel"), // Label for progress percentage
        experimentStageLabel: $$$("experimentStage"), // Label for current experiment stage

        timeChartContainer: $$$("timeChart"),
        positionChartContainer: $$$("positionChart"),
        chartsContainer: $$$("chartsContainer"),

        autoReturnPosition: $$$("autoReturnPositionExperiment"),
        autoReturnPositionLabel: $$$("autoReturnPositionExperimentLabel"),

        moveUpBtn: document.getElementById("moveMachineUP"), // Button to move the device up
        moveDownBtn: document.getElementById("moveMachineDOWN"), // Button to move the device down
        moveUp100Btn: document.getElementById("moveUp100"), // Button to move the device up
        moveDown100Btn: document.getElementById("moveDown100"), // Button to move the device down


        moveToBtn: document.getElementById("moveToBtn"), // Button to move to a specific position
        moveToInput: document.getElementById("moveToInput"), // Input field for target position

        calibrateBtn: document.getElementById("calibrateBtn"), // Button to calibrate the device

        speedSlider: document.getElementById("movementSpeed"), // Slider for speed adjustment
        speedLabel: document.getElementById("labelSpeed"), // Label for speed value
        accelerationSlider: document.getElementById("movementAcceleration"), // Slider for acceleration adjustment
        accelerationLabel: document.getElementById("labelAcceleration"), // Label for acceleration value
    };

    // Connection status messages and colors
    const connectionStates = {
        connected: {text: "üü¢ Connected", color: "green"},
        reconnecting: {text: "üü† Reconnecting...", color: "orange"},
        disconnected: {text: "üî¥ Disconnected", color: "red"}
    };


    // /////// Event Listeners for UI Buttons /////////
    // These were commented out, but they could be used to attach click events
    (() => {
        const addControlContainer = (name) => {
            const btn = $$$(name + "OpenBtn");
            const el = $$$(name);
            btn?.addEventListener('click', async () => controlContainer(btn, el));
            window.addEventListener('resize', async () => controlContainerWidth(el));
        };

        addControlContainer("resultsContainer");
        addControlContainer("settingsContainer");
        addControlContainer("consoleContainer");
    })();


    // /////// Auto-scroll Toggle /////////
    UI.toggleScrollBtn.addEventListener('click', async () => {
        isAutoScroll = !isAutoScroll;
        UI.toggleScrollBtn.classList.toggle('active', isAutoScroll);
        UI.toggleScrollBtn.textContent = `üìå Auto-scroll: ${isAutoScroll ? "ON" : "OFF"}`;
        if (isAutoScroll) {
            UI.regularLogContainer.scrollTop = UI.regularLogContainer.scrollHeight;
        }
    });


    // Detects manual scrolling by the user
    let lastAutoScroll = null;
    let rafId = null;
    UI.regularLogContainer.addEventListener('scroll', () => {
        if (rafId) return;
        rafId = requestAnimationFrame(() => {
            const atBottom = checkScrolledToBottom();
            if (atBottom !== lastAutoScroll) {
                lastAutoScroll = atBottom;
                isAutoScroll = atBottom;
                UI.toggleScrollBtn.textContent = `üìå Auto-scroll: ${atBottom ? "ON" : "OFF"}`;
                UI.toggleScrollBtn.classList.toggle('active', atBottom);
            }
            rafId = null;
        });
    }, {passive: true}); // scroll je sice necancelovateln√Ω, ale passive=hint

    function controlContainerWidth(container) {
        if (!container) return;
        if (isStr(container)) container = $$$("resultsContainer");
        if (window.getComputedStyle(container).maxHeight !== "0px") {
            container.style.maxHeight = container.scrollHeight + "px"; // Adjust height on window resize
        }
    }


    function controlContainer(btn, container) {
        if (!container || !btn) return;

        if (window.getComputedStyle(container).maxHeight === "0px") {
            container.style.visibility = 'visible';
            container.style.maxHeight = container.scrollHeight + "px"; // Open the container and get real height
            container.style.opacity = "1";
            btn.textContent = "üîº";
        } else {
            container.style.maxHeight = "0"; // Close the container
            container.style.opacity = "0";
            btn.textContent = "üîΩ";
            setTimeout(() => container.style.visibility = 'hidden', 550);
        }
    }

    // /////// Log Control Functions /////////

    // Toggles whether the log view is locked at a specific position
    function lineLock() {
        isLineLocker = !isLineLocker;
        if (isLineLocker) {
            UI.lineLockBtn.textContent = "üîí Fix Scroll: ON";
        } else {
            UI.lineLockBtn.textContent = "üîì Fix Scroll: OFF";
        }
    }

    // Clears the log completely
    function clearLog() {
        logContentLines = [];
        logCount = 0;
        UI.regularLogContainer.textContent = "";
    }


    // /////// Input Validation and Adjustment /////////

    // Ensures user input is within a valid min / max range
    function checkInput(element, valueType, decimalPlaces) {
        if (!element) return;

        const val = parseFloat(element.value);
        const min = parseFloat(element.min);
        const max = parseFloat(element.max);
        let newVal = val;

        // Validate input: if empty, set to a minimum or 0
        if (!isNum(val)) {
            if (isNum(min)) newVal = min;
            else if (isNum(max)) newVal = max;
            else return;
        } else if (typeof valueType === "string") {
            if (valueType === "intInput") {
                newVal = Math.round(val);
            }

            // Enforce min/max constraints
            if (isNum(min) && newVal < min) {
                newVal = min;
            }
            if (isNum(max) && newVal > max) {
                newVal = max;
            }

            if (valueType.includes("floatInput")) {

                decimalPlaces = toNumber(decimalPlaces);
                let roundTo =
                    isNum(decimalPlaces) ? decimalPlaces : parseFloat(valueType.replace('floatInput', ''));

                if (!isNum(roundTo)) {
                    roundTo = maxPrecision;
                    const step = element.step.trim();

                    if (step && !step.includes("any")) { // step !== "any" && step !== "any,any"
                        const decimals = (step.replace(',', '.').split(".")[1] || "").length;
                        const stepVal = Math.abs(parseFloat(step));

                        if (isNum(stepVal) && stepVal > 0) {
                            if (stepVal < 1 && decimals > 0) roundTo = decimals;
                            if (stepVal >= 1) roundTo = stepVal;
                        }
                    }

                    roundTo = Math.max(roundTo, 5);
                }


                if (!isNum(roundTo)) roundTo = maxPrecision;

                roundTo = Math.abs(Math.min(Math.round(roundTo), maxPrecision));

                if (roundTo >= 0) newVal = roundDecimalFast(newVal, roundTo);
            }
        }
        if (val !== newVal) {
            element.value = newVal;
            element.dispatchEvent(new Event("change", {bubbles: true}));
        }
    }


    // /////// Command Input Handling /////////

    // Listens for the Enter key in the command input field and sends command
    UI.commandInput.addEventListener("keydown", async (event) => {
        if (event.key === "Enter") {
            event.preventDefault();
            await sendCommandConsole(UI.commandInput.value.trim());
        }
    });

    // Sends command when clicking the send-button
    UI.sendButton.addEventListener('click', async () => {
        await sendCommandConsole(UI.commandInput.value.trim());
    });

    // /////// Auto-scroll Detection /////////

    // Checks if the user is scrolled to the bottom of the log
    function checkScrolledToBottom(scrollTop = UI.regularLogContainer.scrollTop, clientHeight = UI.regularLogContainer.clientHeight, scrollHeight = UI.regularLogContainer.scrollHeight) {
        return Math.abs(scrollTop + clientHeight - scrollHeight) < 2;
    }

    function updateConnectionStatus(status, type = null) {
        if (!connectionStates[status]) return;
        UI.connectionStatus.innerHTML = `${connectionStates[status].text} ${type ? `via ${type}` : ""}`;
        UI.connectionStatus.style.color = connectionStates[status].color;
    }


    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////


    // /////// IndexedDB Database Configuration /////////


    const DB_NAME = "SerialPortData";// Database name
    const STORE_NAME = "LastLog";// Store name for saving log entries
    let db;// Database instance

    // /////// Opening IndexedDB /////////

    /**
     * Opens the IndexedDB database and initializes it if needed.
     */
    async function openDB() {
        let request = indexedDB.open(DB_NAME, 1);

        request.onupgradeneeded = function (event) {
            db = event.target.result;

            // Creates a new object store with an auto-incremented key
            db.createObjectStore(STORE_NAME, {keyPath: "id", autoIncrement: true});
            console.info("%c\n‚úÖ IndexedDB created", "color: green; font-weight: bold;");
        };

        request.onsuccess = function (event) {
            db = event.target.result;
            console.info("%c\n‚úÖ IndexedDB opened", "color: green; font-weight: bold;");
            checkExistingLog();
        };
    }

    // /////// Checking for Existing Log Entries /////////

    /**
     * Checks if there are existing log entries in IndexedDB.
     * If logs exist, prompts the user to either save or delete them.
     */
    let pageLoaded = false;
    let dataLoaded = false;
    let allLoaded = false;
    let pageLoadTimeout = 0;

    async function onLoad() {
        pageLoadTimeout = 0;

        while (!(pageLoaded && dataLoaded)) {
            await sleep(300);
            pageLoadTimeout += 300;
            if (pageLoadTimeout > 10_000) break;
        }


        if (pageLoaded && dataLoaded) {
            recomputeAll();

            await sleep(100);

            await startSerial(false);


            if (timeData.length > 1) {
                console.info("\t\n‚ÑπÔ∏è %cPrevious log loaded.", "color: #0078d7; font-style: italic; font-weight: normal;");
                alert("\n‚ÑπÔ∏è Found previous unsaved logged data.\n     It has been successfully loaded into the charts.\n\n     You can now save it as a CSV file if desired.");
            } else {
                console.info("\t\nüÜï %cNo previous log found.", "color: #0078d7; font-style: italic; font-weight: normal;");
                $$$("experimentName").value = "";
                $$$("experimentDesc").value = "";
                await clearCalculations();
            }

            allLoaded = true;
        }
    }

    function removeLoadingDirection(text) {
        if (typeof text !== 'string') return text;

        const normalized = text.trim(); // Odstran√≠ okoln√≠ mezery

        const prefixUp = "Loading direction: UP;";
        const prefixDown = "Loading direction: DOWN;";

        if (normalized.startsWith(prefixUp)) {
            return normalized.slice(prefixUp.length).trim();
        } else if (normalized.startsWith(prefixDown)) {
            return normalized.slice(prefixDown.length).trim();
        }

        return text.trim();
    }


    function checkExistingLog() {
        const transaction = db.transaction(STORE_NAME, "readonly");
        const store = transaction.objectStore(STORE_NAME);
        const request = store.count();

        request.onsuccess = async function () {
            await loadDataFromDBToChart(false);

            if (request.result > 0) {
                // TODO: p≈ôem√≠stit dotaz na 'star√° data' a≈æ po naƒçten√≠ v≈°eho a upravit dotaz, aby se ptal na smaz√°n√≠ a chtƒõl to 2x potvrdit
                // if (confirm("üîÑ Old log exists. Keep it or delete?\nOK = Keep\nCancel = Delete")) {
                //     saveCSV();
                // } else {


                // transaction = db.transaction(STORE_NAME, "readonly");
                // store = transaction.objectStore(STORE_NAME);
                const request2 = store.getAll();
                request2.onsuccess = async function () {
                    let dataEntries = request2.result;
                    const experimentInfo = dataEntries[0];


                    let date = "Unknown date";
                    const expDate = experimentInfo.experimentDate;
                    if (expDate) {
                        const dateFormat = getLocaleOrder();
                        date = `${expDate} [${dateFormat.date} ${dateFormat.time}]`;
                        console.info(`\t\nüïí %cLast log date: ${date}`, "color: #0078d7; font-style: italic; font-weight: normal;");
                    }

                    const loadDirection = experimentInfo.loadDirection === -1 ? "DOWN" : (experimentInfo.loadDirection === 1 ? "UP" : "N/A");

                    const experimentLabel = experimentInfo.experimentLabel || "";

                    const expBasicInformation = "¬ß " + `(${date}); ` + "Loading direction: " + loadDirection + ";  " + experimentLabel + " ¬ß";

                    // replace any original Basic Information in description - up new lines and ¬ß...¬ß
                    const description = expBasicInformation + ";  " + experimentInfo.experimentDescription.replace(/(\r\n|\n|\r)/gm, " ").replace(/¬ß.*¬ß;/gm, "").trim();

                    $$$("experimentCount").value = experimentInfo.experimentCounter || "1";
                    $$$("experimentName").value = experimentInfo.experimentName || "";
                    $$$("experimentDesc").value = description || "";

                    // TODO: odstranit?  "  + (removeLoadingDirection(experimentInfo.experimentDescription) || "")  "
                    dataLoaded = true;
                };
                // }
            } else {
                dataLoaded = true;
            }
        };
    }

    // /////// Clearing the Database Log /////////

    /**
     * Clears all log entries from IndexedDB.
     */
    function clearDBLog() {
        const transaction = db.transaction(STORE_NAME, "readwrite");
        const store = transaction.objectStore(STORE_NAME);
        store.clear().onsuccess = () => console.info("üóëÔ∏è Old log deleted.");
    }

    // /////// Adding Data to the Log /////////

    const dbQueue = [];
    let dbFlushTimer = null;

    /**
     * Adds a new data entry to IndexedDB.
     *@param {Object} data - The data object to be stored.
     * @param id
     */
    function addDataToLog(data, id = undefined) {
        dbQueue.push({data, id});
        if (!dbFlushTimer) dbFlushTimer = setTimeout(flushDB, 500); // flush ~2√ó za sekundu
    }

    function flushDB() {
        if (dbQueue.length === 0) {
            dbFlushTimer = null;
            return;
        } else {
            if (!db || !(pageLoaded && dataLoaded)) {
                console.warn("\n‚ùå IndexedDB not ready, cannot flush log.");
                // Wait for another 5 seconds and try again
                dbFlushTimer = setTimeout(flushDB, 5_000);
                return;
            }
        }

        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const keyPath = store.keyPath || null; // m≈Ø≈æe b√Ωt i pole, zde p≈ôedpokl√°d√°me single keyPath

        // vyber v≈°e z fronty (atomicky v jedn√© transakci)
        const items = dbQueue.splice(0);

        for (const {data, id} of items) {
            // pozor: id m≈Ø≈æe b√Ωt 0 => kontrola na null/undefined
            const hasId = id !== undefined && id !== null;

            if (hasId) {
                // Upsert se zadan√Ωm kl√≠ƒçem
                if (keyPath === 'id') {
                    const value = (data && typeof data === 'object')
                        ? {...data, id} : {id, value: data};
                    store.put(value); // kl√≠ƒç je v objektu (keyPath)
                } else {
                    store.put(data, id); // kl√≠ƒç p≈ôed√°n samostatnƒõ
                }
            } else {
                // ƒçist√Ω add => autoIncrement/autoKey
                store.add(data);
            }
        }

        tx.oncomplete = () => {
            dbFlushTimer = null;
        };
        tx.onerror = (e) => {
            console.error('‚ùå flushDB error:', e?.target?.error || e);
            dbFlushTimer = null;
        };
    }

    /**
     * Update (merge) z√°znamu podle id. Vrac√≠ Promise<boolean> (true = zaps√°no).
     * - Pokud z√°znam neexistuje a upsert=true, vytvo≈ô√≠ se.
     * - patch se merguje p≈ôes st√°vaj√≠c√≠ hodnotu.
     */
    function updateLogById(id, patch, {upsert = true} = {}) {
        if (id == null) return Promise.resolve(false);
        if (!(dataLoaded && pageLoaded)) return Promise.resolve(false);
        if (!db) return Promise.resolve(false);
        return new Promise((resolve, reject) => {
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            const keyPath = store.keyPath || null;


            // 1) Zjisti, jestli v≈Øbec existuj√≠ nƒõjak√© logy
            const countReq = store.count();
            countReq.onsuccess = () => {
                const total = countReq.result || 0;
                if (total > 1) {
                    // 2) Pokraƒçuj v update
                    const getReq = store.get(id);
                    getReq.onsuccess = () => {
                        const current = getReq.result;
                        if (!current && !upsert) {
                            resolve(false);
                            return;
                        }

                        // slo≈æ updated z√°znam (zachovat kl√≠ƒç)
                        let updated;
                        if (keyPath === 'id') {
                            updated = {...(current || {}), ...(patch || {}), id};
                            store.put(updated);
                        } else {
                            updated = {...(current || {}), ...(patch || {})};
                            store.put(updated, id);
                        }
                    };


                    getReq.onerror = (err) => reject(err);
                } else {
                    // nic nen√≠, nelze update
                    resolve(false);
                }
            };
            countReq.onerror = (err) => reject(err);

            tx.oncomplete = () => resolve(true);
            tx.onerror = (e) => {
                console.error('‚ùå updateById error:', e?.target?.error || e);
                reject(e);
            };
        });
    }


    async function clearDatabase() {
        if (!db) {
            console.warn("\n‚ùå IndexedDB not ready, cannot clear database.");
            return;
        }
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(STORE_NAME, "readwrite");
            const store = transaction.objectStore(STORE_NAME);
            const clearRequest = store.clear();

            clearRequest.onsuccess = () => {
                console.info("üóëÔ∏è Database cleared successfully.");
                resolve(true);
            };

            clearRequest.onerror = (event) => {
                console.error("‚ùå Error clearing database:", event.target.error);
                reject(event.target.error);
            };
        });
    }


    // /////// Saving Log to File /////////

    /**
     * Saves the stored log entries from IndexedDB to a downloadable CSV file.
     */
    // Event listener for the save button
    $$$("saveData")?.addEventListener("click", saveCSV);


    let handFolderSelect = false;

    function toggleDirectorySelector() {
        handFolderSelect = !handFolderSelect;
    }

    function collectExpSettings(selector, schema = null) {
        if (isEmptyStr(selector)) return [];
        const nodes = Array.from($$(selector));
        const inputs = {};

        for (const el of nodes) {
            const key = el.dataset.key || el.name || el.id; // preferuj data-key
            if (!key) continue;

            let val;
            if (el.type === "checkbox") val = !!el.checked;
            else if (el.type === "number") val = el.value === "" ? null : +el.value;
            else if (el.tagName === "SELECT") val = el.value;
            else val = el.value;

            const essence = (el?.tagName === "SELECT") ? ((el.selectedOptions[0]?.dataset.essence) ? el.selectedOptions[0]?.dataset.essence : el?.dataset.essence) : el?.dataset.essence;


            inputs[key] = {
                value: isInvalidValue(val) ? "N/A" : (isStr(val) ? val.replace('‚àû', "Inf").replace('¬±', '') : val), // null pro pr√°zdn√©/invalidn√≠ hodnoty
                type: el.type || el.tagName.toLowerCase(),         // nap≈ô. "number", "checkbox", "text", "select"
                label: el.dataset.label || el.placeholder || key,  // volitelnƒõ pro hezƒç√≠ zobrazen√≠
                classes: el.className || null,                     // volitelnƒõ pro dal≈°√≠ filtrov√°n√≠

                extra: {
                    unit: el.dataset.unit || null,  // jednotka
                    essence: essence || null, // nap≈ô. "force", "disp", "stress", "modulus", "area", "iy", "hardness"
                    description: el.dataset.description || null, // voliteln√Ω popis
                }
            };
        }

        return {
            selector: selector,
            schema: schema,
            version: 1,
            timestamp: new Date().toISOString(),
            inputs,
        };
    }

    async function restoreExpSettingsToUI(settings, {
        customSelector = undefined,
        customKey = undefined,
        fireEvents = false,
    } = {}) {

        const keys = [];
        if (customKey) {
            keys.push(String(customKey));
        } else {
            if (settings?.generalSettings) keys.push('generalSettings');
            if (settings?.machineSettings) keys.push('machineSettings');
            if (settings?.deviceSettings) keys.push('deviceSettings');
            if (settings?.chartSettings) keys.push('chartSettings');
            if (settings?.expSettings) keys.push('expSettings');
            if (settings?.calcSettings) keys.push('calcSettings');
        }

        const results = [];
        for (const key of keys) {
            if (!settings[key]) continue;
            const r = await restoreSettingsToUI(settings[key], {customSelector, fireEvents});
            results.push({key, ...r});
        }

        const ok = results.some(r => r.ok);
        const summary = results.reduce((acc, r) => {
            acc.tried += 1;
            acc.ok |= r.ok;
            acc.totalNodes += r.foundNodes || 0;
            acc.applied += r.appliedCount || 0;
            acc.missingKeys += (r.missingKeys?.length || 0);
            return acc;
        }, {tried: 0, ok: false, totalNodes: 0, applied: 0, missingKeys: 0});

        return {ok, results, summary};
    }

    const setElValue = (el, val, fire) => {
        const tag = el.tagName.toLowerCase();
        const type = (el.type || "").toLowerCase();

        if (fire == null) fire = (el) => {
            if (!fireEvents) return;
            el.dispatchEvent(new Event("input", {bubbles: true}));
            el.dispatchEvent(new Event("change", {bubbles: true}));
            el.dispatchEvent(new Event("blur", {bubbles: true}));
        };

        if (type === "checkbox") {
            el.checked = !!val;
            fire(el);
            return true;
        }
        if (type === "radio" && el.name) {
            $$(`input[type="radio"][name="${CSS.escape(el.name)}"]`)
                ?.forEach(r => {
                    r.checked = (String(r.value) === String(val));
                    fire(r);
                });
            return true;
        }
        if (tag === "select") {
            if (el.multiple && isArr(val)) {
                const set = new Set(val.map(String));
                Array.from(el.options)?.forEach(opt => {
                    opt.selected = set.has(String(opt.value));
                });
            } else {
                el.value = val || "";
            }
            fire(el);
            return true;
        }
        if (type === "number" || type === "range") {
            let v = val;
            if (typeof v === "string" && v.includes(",")) v = v.replace(",", ".");
            if (v == null || v === "") el.value = "";
            else if (Number.isFinite(+v)) ("valueAsNumber" in el) ? el.valueAsNumber = +v : el.value = String(+v);
            else el.value = "";
            fire(el);
            return true;
        }
        el.value = (val || "");
        fire(el);
        return true;
    };

    async function restoreSettingsToUI(settings, {
        customSelector = undefined,
        fireEvents = false,
    } = {}) {

        const report = {
            ok: false,
            selector: null,
            foundNodes: 0,
            appliedCount: 0,
            missingKeys: [],
            unusedEls: [],
            details: [] // {key, found, applied, reason}
        };

        let selector = customSelector;
        if (!settings?.inputs) {
            report.details.push({key: null, found: 0, applied: false, reason: 'no-inputs'});
            return report;
        }
        if (!customSelector || isEmptyStr(customSelector)) selector = settings.selector;
        report.selector = selector;
        if (!selector || isEmptyStr(selector)) {
            report.details.push({key: null, found: 0, applied: false, reason: 'no-selector'});
            return report;
        }

        const nodes = Array.from($$(selector));
        report.foundNodes = nodes.length;
        if (!nodes.length) {
            report.details.push({key: null, found: 0, applied: false, reason: 'no-nodes'});
            return report;
        }

        // index dle data-key | name | id
        const index = new Map();
        for (const el of nodes) {
            const key = el.dataset.key || el.name || el.id;
            if (!key) {
                report.unusedEls.push(el);
                continue;
            }
            (index.get(key) || index.set(key, []).get(key)).push(el);
        }

        const fire = (el) => {
            if (!fireEvents) return;
            el.dispatchEvent(new Event("input", {bubbles: true}));
            el.dispatchEvent(new Event("change", {bubbles: true}));
            el.dispatchEvent(new Event("blur", {bubbles: true}));
        };


        // aplikuj hodnoty
        for (const [key, meta] of Object.entries(settings.inputs)) {
            const els = index.get(key);
            if (!els?.length) {
                report.missingKeys.push(key);
                report.details.push({key, found: 0, applied: false, reason: 'no-match'});
                continue;
            }

            try {
                if (els[0].type === "radio") {
                    setElValue(els[0], meta.value, fire);
                } else if (els[0].tagName.toLowerCase() === "select" && els[0].multiple) {
                    setElValue(els[0], isArr(meta.value) ? meta.value : [meta.value], fire);
                } else {
                    setElValue(els[0], meta.value, fire);
                }
                report.appliedCount += 1;
                report.details.push({key, found: els.length, applied: true});
            } catch (e) {
                report.details.push({key, found: els.length, applied: false, reason: String(e?.message || e)});
            }
        }

        report.ok = report.appliedCount > 0;
        return report;
    }

    async function applyCsvToUI(csvText, opts) {
        const settings = await parseSettingsFromCsv(csvText);
        if (!settings) return {ok: false, reason: 'parse-failed', settings: null, results: []};
        const res = await restoreExpSettingsToUI(settings, opts); // { ok, results, summary }
        return {ok: !!res.ok, settings, ...res};
    }

    async function processFile(file) {
        const text = await file.text();
        const res = await applyCsvToUI(text, {fireEvents: true});

        const nameEl = $$$("loadedFileName");

        if (res.ok) {
            nameEl.textContent = `‚úÖ Loaded: ${file.name} ‚Äî applied ${res.summary.applied} fields`;
            console.groupCollapsed(`‚úîÔ∏è Settings applied (${file.name})`);
            console.table(res.results.map(r => ({
                key: r.key,
                selector: r.selector,
                nodes: r.foundNodes,
                applied: r.appliedCount,
                missingKeys: r.missingKeys.length
            })));
            res.results?.forEach(r => {
                if (r.missingKeys.length) {
                    console.groupCollapsed(`‚ö†Ô∏è Missing keys in ${r.key}`);
                    console.info(r.missingKeys);
                    console.groupEnd();
                }
            });
            console.groupEnd();
        } else {
            nameEl.textContent = `‚ö†Ô∏è In file ${file.name} are no settings meta data`;
            console.warn('\nDetails:', res);
            alert("‚ö†Ô∏è In file are missing or are invalid meta data: (##MOIRA_EMETA=...).");
        }
    }

    // ===== Ovl√°dac√≠ logika tlaƒç√≠tka =====
    const btnLoadCSV = $$$("btnLoadSettings");
    const inputLoadCSV = $$$("appFileInput");

    btnLoadCSV.addEventListener("click", async () => {
        if ("showOpenFilePicker" in window) {
            try {
                const [handle] = await window.showOpenFilePicker({
                    types: [{description: "CSV", accept: {"text/csv": [".csv"]}}],
                    excludeAcceptAllOption: false,
                    multiple: false
                });
                const file = await handle.getFile();
                await processFile(file);
                return;
            } catch (e) {
                if (e?.name === "AbortError") return; // u≈æivatel zru≈°il
                console.warn("showOpenFilePicker failed, falling back to <input type=file>:", e);
            }
        }
        // fallback
        inputLoadCSV.click();
    });

    inputLoadCSV.addEventListener("change", async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        await processFile(file);
        inputLoadCSV.value = ""; // reset pro dal≈°√≠ v√Ωbƒõr stejn√©ho souboru
    });


    // --- gzip / gunzip (preferuj nativn√≠ streamy; fallback pako) ---
    async function gzipBytes(u8) {
        if (typeof CompressionStream !== "undefined") {
            const stream = new Blob([u8]).stream().pipeThrough(new CompressionStream("gzip"));
            const buf = await new Response(stream).arrayBuffer();
            return new Uint8Array(buf);
        } else if (self.pako?.gzip) {
            // level 6 je rychl√° a rozumnƒõ kompaktn√≠ volba
            return self.pako.gzip(u8, {level: 6});
        }
        throw new Error("No gzip available (CompressionStream/pako).");
    }

    function looksLikeGzip(u8) {
        return u8 && u8.length >= 2 && u8[0] === 0x1f && u8[1] === 0x8b;
    }

    async function gunzipBytes(u8) {
        if (!looksLikeGzip(u8)) throw new Error("Data do not look like gzip format.");
        if (typeof DecompressionStream !== "undefined") {
            const stream = new Blob([u8]).stream()
                .pipeThrough(new DecompressionStream("gzip"));
            const buf = await new Response(stream).arrayBuffer();
            return new Uint8Array(buf);
        } else if (self.pako?.ungzip) {
            return self.pako.ungzip(u8); // pako fallback
        }
        throw new Error("No gunzip available (DecompressionStream/pako).");
    }

    // --- tvorba preambule (vybere krat≈°√≠ z gzip/plain) ---
    async function settingsToCsvPreamble(settings) {
        const json = JSON.stringify(settings);
        const plainB64 = u8ToB64(te.encode(json));

        let gzipB64 = null;
        try {
            const gz = await gzipBytes(te.encode(json));
            gzipB64 = u8ToB64(gz);
        } catch {
            // nem√°me gzip => z≈Østaneme u plain
        }

        if (gzipB64 && gzipB64.length < plainB64.length) {
            return `##MOIRA_METAZ=${gzipB64}`;
        } else {
            return `##MOIRA_METAP=${plainB64}`;
        }
    }

    // --- ƒçten√≠ preambule z 1. ≈ô√°dku ---
    async function readSettingsFromPreamble(line) {
        // odstra≈à BOM na zaƒç√°tku, kdyby se vyskytl
        line = line.replace(/^\uFEFF/, "");

        if (line.startsWith("##MOIRA_METAZ=")) {
            const b64 = line.slice("##MOIRA_METAZ=".length).trim();
            const u8 = b64ToU8(b64);
            const unz = await gunzipBytes(u8);
            return JSON.parse(td.decode(unz));
        }
        if (line.startsWith("##MOIRA_METAP=")) {
            const b64 = line.slice("##MOIRA_METAP=".length).trim();
            const json = td.decode(b64ToU8(b64));
            return JSON.parse(json);
        }
        throw new Error("Unknown MOIRA_META prefix.");
    }

    // --- parsing z cel√©ho CSV textu (vr√°t√≠ objekt nebo null) ---
    async function parseSettingsFromCsv(csvText) {
        if (!csvText) return null;
        // vezmi jen prvn√≠ ≈ô√°dku; split(limit=1) vrac√≠ pole => [0]
        const firstLine = (csvText.split(/\r?\n/, 1)[0] || "").replace(/^\uFEFF/, "");
        // rozpoznej prefix a zbytek jako Base64
        const m = firstLine.match(/^##MOIRA_META([ZP])=([A-Za-z0-9+/=]+)\s*$/);
        if (!m) return null;

        try {
            return await readSettingsFromPreamble(firstLine);
        } catch (e) {
            console.error("‚ùå Invalid settings JSON in MOIRA_META:", e);
            return null;
        }
    }


    async function saveCSV() {
        let dirHandle = null;
        // Delimiter for CSV file "\t" = tab, "," = comma, ";" = semicolon
        const delimiterSymbolVal = await $$$("delimiterSymbol").value || "Option-Semicolon";
        let delimiter = await (delimiterSymbolVal === "Option-Comma" ? "," : delimiterSymbolVal === "Option-Semicolon" ? ";" : delimiterSymbolVal === "Option-Tab" ? "\t" : delimiterSymbolVal === "Option-Space" ? " " : ";") || ";";
        // Decimal symbol for CSV file "." = dot, "," = comma
        const decimalSymbol = await ($$$("decimalSymbol").value === "Option-Comma" ? "," : ".") || ".";

        // 6 of random symbols that are unlikely to be in the data
        const delimiterPlaceHolder = "¬ß" + Math.random().toString(36).substring(2, 4) + Math.random().toString(36).substring(2, 4) + Math.random().toString(36).substring(2, 4) + "¬ß";

        if (decimalSymbol === "," && delimiter === ",") delimiter = ";"; // If comma is selected as decimal symbol, use semicolon as delimiter to avoid conflicts


        const expNum = parseInt($$$("experimentCount").value.trim()) || 0;
        const experimentName = $$$("experimentName").value.trim();
        const experimentDesc = $$$("experimentDesc").value.replaceAll(/(\r\n|\n|\r)/gm, " ").trim();

        handFolderSelect = $$$("storagePath").checked || false;

        if (!experimentName) {
            alert("Unable to save the data.\n    Please enter the experiment type.");
            return;
        }

        let experimentCount
        if (expNum) {
            experimentCount = `_${expNum.toString().padStart(3, "0")}`;
        } else {
            experimentCount = "";
        }
        const fileName = `${experimentName}${experimentCount}.csv`;

        let fileHandle;
        if (handFolderSelect) {
            try {
                dirHandle = await window.showDirectoryPicker(); // User selects a folder
            } catch (error) {
                console.error("‚ùå Folder selection canceled or error occurred:", error);
                return;
            }
            fileHandle = await dirHandle.getFileHandle(fileName, {create: true});

        } else {
            fileHandle = {name: `${fileName}`}; // Simulated save outside File System Access API
        }

        let transaction = db.transaction(STORE_NAME, "readonly");
        let store = transaction.objectStore(STORE_NAME);
        let request = store.getAll();

        // Helper rounding functions
        const getRoundVal = (x, dec, decSym) => getCustomStrValue(x, dec, decSym, false, true, "");

        const rTime = (num) => getRoundVal(num, precisionTime, decimalSymbol);
        const rDist = (num) => getRoundVal(num, precisionPosition, decimalSymbol);
        const rForce = (num) => getRoundVal(num, precisionForce, decimalSymbol);
        const rSpeed = (num) => getRoundVal(num, precisionSpeed, decimalSymbol);
        const rPhoto = (num) => getRoundVal(num, 0, decimalSymbol);

        request.onsuccess = async function () {
            let dataEntries = request.result;

            if (!dataEntries || dataEntries.length === 0) {
                console.warn("\n‚ö†Ô∏è No data to save.");
                alert("‚ö†Ô∏è No data to save. Ensure experiment has been run.");
                return;
            }
            const experimentInfo = dataEntries[0];

            dataEntries.shift(); // Skip the first entry (initial values)

            const settings = experimentInfo || {};
            settings.id = undefined; // Remove id from metadata

            // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            settings.headerVersion = 1;
            settings.columns = 6;
            settings.skipRows = 6;
            // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

            settings.calcSettings = collectExpSettings(".calcInput", "Moira-calc-settings") || {};
            settings.decimalSymbol = decimalSymbol;
            settings.delimiter = delimiter;

            let content = '';

            const dateFormat = getLocaleOrder();

            const basicInfo = [
                `Date [${dateFormat.date} ${dateFormat.time}]:`, experimentInfo.experimentDate,
                'Experiment type:', experimentInfo.experimentLabel,
                'Experiment end:', experimentInfo.endStatus,
                'Loading speed (mm/s):', experimentInfo.loadSpeed,
                'Load distance (mm):', experimentInfo.loadDistance,
                'Loadcell capacity (kg):', experimentInfo.loadcellCapacity.join('/'),
                'Software version:', `v${experimentInfo.appSoftWare}`,
                'Firmware version:', `v${experimentInfo.machineFirmware}`,
            ];

            const head = [
                'Time [s]', 'Displacement [mm]', 'Speed [mm/s]', 'Loadcell 1 [N]', 'Loadcell 2 [N]', 'Loadcell 3 [N]', 'Photo Index'
            ];


            console.log(settings);
            content += (await settingsToCsvPreamble(settings)).replace(/ /g, "").replace(/^\uFEFF/, "");
            content += '\n';
            content += `\n${basicInfo.join(delimiterPlaceHolder)}`;
            content += `\nDescription:${delimiterPlaceHolder}${experimentDesc}`;
            content += '\n';
            content += `\n${head.join(delimiterPlaceHolder)}`;


            if (delimiter === ",") experimentDesc.replaceAll(",", ".");
            // Remove delimiter from description to avoid confusion in space-delimited files (CSV)
            if (delimiter === " ") {
                content = content.replaceAll(/ /g, "_");
            } else {
                content = content.replaceAll(delimiter, "|");

            }

            content = content.replaceAll(delimiterPlaceHolder, delimiter); // Replace placeholder with actual delimiter

            dataEntries?.forEach(entry => {
                const dataRow = [rTime(entry.time), rDist(entry.position), rSpeed(entry.speed), ...entry.force.map(rForce), rPhoto(entry.photoIndex)];
                if (dataRow.some(d => d !== "")) content += `\n${dataRow.join(delimiter)}`; // Only add rows with at least one non-empty value
            });

            if (handFolderSelect) {
                // Save the file to the selected folder using File System Access API
                const writable = await fileHandle.createWritable();
                await writable.write(`\uFEFF${content}`); // Add BOM for correct UTF-8 encoding
                await writable.close();
            } else {
                // Simulated file download (browsers don't allow direct writes)
                const blob = new Blob([`\uFEFF${content}`], {type: "text/csv;charset=utf-8"});
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = fileHandle.name.split("/").pop();
                link.click();
            }

            if (expNum) {
                $$$("experimentCount").value = expNum + 1;
                $$$("experimentCount")?.dispatchEvent(new Event("change", {bubbles: true}));
            }

            console.info(`‚úÖ Data saved to file: ${fileName}`);

            // Clear IndexedDB after saving
            let deleteTransaction = db.transaction(STORE_NAME, "readwrite");
            let deleteStore = deleteTransaction.objectStore(STORE_NAME);
            deleteStore.clear().onsuccess = () => console.info("üóëÔ∏è Data from IndexedDB cleared after saving.");
        };
    }


    function getLocaleOrder(locales, {
        timeZone = undefined,           // nech pr√°zdn√© pro aktu√°ln√≠ z√≥nu
        force24h = false                // true => vynut√≠ 24h (H), i kdy≈æ je locale 12h
    } = {}) {
        const opts = {
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            timeZone
        };

        // vytvo≈ô form√°tovaƒç a p≈ôeƒçti meta
        const dtf = new Intl.DateTimeFormat(locales, opts);
        const ro = dtf.resolvedOptions();

        // zji≈°tƒõn√≠, zda je 12h form√°t (nebo vynucenƒõ 24h)
        const is12h = !force24h && (ro.hour12 === true || /^h1[12]$/.test(ro.hourCycle || ""));
        const hourSymbol = is12h ? "h" : "H";

        // pou≈æij ‚Äûrozli≈°iteln√©‚Äú datum/ƒças (kv≈Øli po≈ôad√≠ je jedno, ale a≈• jsou ƒç√≠sla jasn√°)
        const d = new Date(Date.UTC(2001, 10, 21, 13, 14, 15)); // 21.11.2001 13:14:15

        // rozpitvej form√°t na ƒç√°sti
        const parts = dtf.formatToParts(d);

        // poskl√°dej po≈ôad√≠
        const mapDate = {day: "D", month: "M", year: "Y"};
        const mapTime = {hour: hourSymbol, minute: "m", second: "s"};

        const dateOrder = parts
            .filter(p => p.type === "day" || p.type === "month" || p.type === "year")
            .map(p => mapDate[p.type])
            .join(",");

        const timeOrder = parts
            .filter(p => p.type === "hour" || p.type === "minute" || p.type === "second")
            .map(p => mapTime[p.type])
            .join(",");

        const hasDayPeriod = parts.some(p => p.type === "dayPeriod");

        return {
            locale: ro.locale,                 // skuteƒçnƒõ pou≈æit√Ω locale (po fallbacku)
            date: dateOrder || null,           // nap≈ô. "D,M,Y" | "M,D,Y" | "Y,M,D"
            time: hasDayPeriod ? `${timeOrder},a` : timeOrder, // nap≈ô. "H,m,s" nebo "h,m,s,a"
            hourCycle: ro.hourCycle || (is12h ? "h12" : "h23"),
        };
    }


    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////


    // /////// Serial Connection Variables /////////

    // Variables for handling serial (USB) communication
    let serialPort, serialWriter, serialReader;

    // Connection status flags
    let isConnected = false;
    let isSerial = false;

    // Reconnection attempts for serial connection
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    let isReconnecting = false;

    // /////// Serial Connection Handling /////////

    UI.USB.addEventListener("click", async () => startSerial());

    /**
     * Starts the Serial (USB) connection by opening the database and initiating the connection.
     */
    async function startSerial(userRequest = true) {
        if (!('serial' in navigator)) {
            alert('This broswer do not support serialPorts, try using Chrome/Edge.');
            return;
        }

        UI.USB.classList.add("disabled");

        if (isConnected) {
            console.info("Already connected, disconnecting...");
            await disconnectSerial();
        } else {
            console.info("üöÄ Starting application...");
            await connectSerial(userRequest);

        }

    }


    // /////// Sending Commands /////////

    /**
     * Sends a command to the connected device.
     * Works with Serial (USB) connection;
     * @param {string} command - The command string to send.
     * @param timeOut
     * @param type
     */
    async function sendCommand(command, type = "general", timeOut = 1) {
        switch (type) {
            case "console":
                await sendCommandConsole(command);
                break;
            case "app":
                await sendCommandApp(command);
                break;
            case "user":
                await sendCommandUser(command);
                break;
            case "silent":
                await sendCommandSilent(command);
                break;
            case "general":
            default:
                await sendCommandGeneral(command, timeOut);
        }
    }

    async function sendCommandGeneral(command, timeOut = 1) {
        if (!checkCommand(command)) return;

        await writeCommand(command);

        if (!isNum(timeOut)) timeOut = 1;
        timeOut = Math.max(0, Math.round(timeOut));

        if (command.toLowerCase() !== "syswr" && command.toLowerCase() !== "misc watchdog_reset") {
            await logMessage("üì§ General-Command sent: " + command);
        }
        await sleep(timeOut);  // Stop for at least 1 ms
    }

    async function sendCommandConsole(command) {
        if (!checkCommand(command)) return;


        switch (command.trim().toLowerCase()) {
            case "toggle port filter":
                useFilteredPort = !useFilteredPort;
                await logMessage(`\nüîÄ Toggled port filter: ${useFilteredPort ? "ON" : "OFF"}`);
                return;

            case "toggle port autoconnect":
                usePortAutoConnect = !usePortAutoConnect;
                await logMessage(`\nüîÄ Toggled port auto-connect: ${usePortAutoConnect ? "ON" : "OFF"}`);
                return;

            default:
                await writeCommand(command);
        }

        // User feedback in console
        await logMessage("  üó£Ô∏è User-Command sent: " + command);
    }

    async function sendCommandApp(command) {
        if (!checkCommand(command)) return;

        await writeCommand(command);

        // User feedback in console
        await logMessage("üëæ App-Command sent: " + command);
    }

    async function sendCommandUser(command) {
        if (!checkCommand(command)) return;

        await writeCommand(command);

        // User feedback in console
        await logMessage("üïπÔ∏è User-Command sent: " + command);
    }

    async function sendCommandSilent(command) {
        if (!checkCommand(command)) return;

        await writeCommand(command);
    }


    async function writeCommand(text) {
        try {
            const encoder = new TextEncoder();

            //  Ensure a writer exists before writing
            if (!serialWriter) {
                serialWriter = serialPort.writable.getWriter();
            }

            await serialWriter.write(encoder.encode(text + "\n"));

            return true;
        } catch (error) {
            await handleError(error, "sendCommand");

            return false;
        }
    }

    function checkCommand(command) {
        if (debugging) console.log("Preparing to send command:", command);
        if (!isConnected || !serialPort?.writable) {
            logMessage("\n‚ö†Ô∏è No device is connected or port is unavailable!");
            return false;
        }

        if (command.toLowerCase().includes(" nan")) {
            logMessage("\n‚ö†Ô∏è Command contains 'NaN' values. Please check the input.");
            console.error("‚ö†Ô∏è Command contains 'NaN' values. Please check the input.");
            alert("‚ö†Ô∏è Aborted command due to 'NaN' values in the input.");
            return false;
        }

        return true;
    }

    let watchdogTimer = null;
    let activeWatchDog = false;
    const WATCHDOG_INTERVAL_MS = 500; // min 500 ms


    async function sendMoveCommand(command, pauseMs = 1) {
        // ovƒõ≈ôen√≠ kalibrace
        calibrationStatus = await getCalibrationStatus(2000);
        await sleep(50);

        if (!calibrationStatus) {
            const msg = "\n‚ö†Ô∏è Motors are not calibrated.";
            await lockMovementExcept(UI.calibrateBtn);
            console.warn(msg);
            await logMessage(msg);
            await endedMoving();
            alert(msg);
            return;
        }

        // Watchdog ≈ôe≈°√≠ beganMoving/endedMoving, tady jen po≈°li p≈ô√≠kaz
        await sendCommandGeneral(command, pauseMs);
    }


    async function moveToOriginalPosition() {
        if (!isConnected) return;
        if (isExperimentRunning || machineOccupation) return;

        const endPosition = await measurePosition();
        if (!(isNum(startPosition) && isNum(endPosition))) {
            endedMoving();
            return;
        }

        const distance = startPosition - endPosition;
        if (Math.abs(distance) < 1e-2) {
            endedMoving();
            console.info("üö© Already at the original position.");
            return;
        }

        console.info("‚¨ÖÔ∏è Moving backward...");
        await moveBy(distance);
        console.info("üö© Returning to original position completed.");
    }

    function disableInputsAndLabelsIn(root) {
        root.querySelectorAll?.("input")?.forEach(inp => {
            inp.disabled = true;
        });

        root.querySelectorAll?.("*")?.forEach(el => {
            if (el.shadowRoot) disableInputsAndLabelsIn(el.shadowRoot);
        });
    }

    function enableInputsAndLabelsIn(root) {
        root.querySelectorAll?.("input[disabled]")?.forEach(inp => {
            inp.disabled = false;
        });

        root.querySelectorAll?.("*")?.forEach(el => {
            if (el.shadowRoot) enableInputsAndLabelsIn(el.shadowRoot);
        });
    }


    const movementElements = $$(".movementControlElement");

    function lockMovement() {
        movementElements?.forEach((el) => {
            el?.classList.add("disabled");
            disableInputsAndLabelsIn(el);
        });
    }


    function lockMovementExcept(exceptEl) {
        movementElements?.forEach(el => {
            const isExcept = el === exceptEl || el?.contains?.(exceptEl);
            if (!isExcept) {
                el?.classList?.add("disabled");
                disableInputsAndLabelsIn(el);
            } else {
                el?.classList?.remove?.("disabled");
                enableInputsAndLabelsIn(el);
            }
        });
    }

    function unlockMovement() {
        movementElements?.forEach((el) => {
            el?.classList.remove("disabled");
            enableInputsAndLabelsIn(el);
        });
    }

    // ------- Watchdog (bƒõ≈æ√≠ jen p≈ôi pohybu) -------
    function startWatchdog(intervalMs = WATCHDOG_INTERVAL_MS) {
        const interval = Math.max(100, Number(intervalMs) || WATCHDOG_INTERVAL_MS);
        if (watchdogTimer) return; // u≈æ bƒõ≈æ√≠

        activeWatchDog = true;

        // Nastaven√≠ watchdog HW (p≈ôedstihem ~5% + 10ms)
        const hwInterval = Math.ceil(interval * 1.05) + 10;
        // nezdr≈æujeme ‚Äî fire and forget
        sendCommandGeneral(`MISC SET WATCHDOG_INTERVAL ${hwInterval}`, 5);
        sendCommandGeneral(`MISC SET WATCHDOG_ENABLED 1`, 5);
        console.info("üêï Watchdog is active.");

        watchdogTimer = setInterval(() => {
            // pos√≠lej SYSWR pouze kdy≈æ je to smyslupln√©
            if (!isConnected || !activeWatchDog || !machineOccupation) return;
            sendCommandGeneral("SYSWR");
        }, interval);
    }

    function stopWatchdog() {
        activeWatchDog = false;
        if (watchdogTimer) {
            clearInterval(watchdogTimer);
            watchdogTimer = null;
        }
        // HW watchdog vyp√≠nat nemus√≠me ‚Äî ale m≈Ø≈æeme:
        if (isConnected) sendCommandGeneral(`MISC SET WATCHDOG_ENABLED 0`);
    }

    // ------- Spr√°va pohybu -------
    async function beganMoving(timeoutMs = null) {
        if (machineOccupation) return; // u≈æ bƒõ≈æ√≠
        machineOccupation = true;
        startWatchdog(WATCHDOG_INTERVAL_MS);

        // napl√°nuj automatick√© ukonƒçen√≠ (voliteln√©)
        if (timeoutMs != null) {
            const delay = toInteger(timeoutMs, "round");
            if (!isNumber(delay)) {
                console.warn("\nInvalid delay for beganMoving:", timeoutMs);
                endedMoving();
                return;
            }
            if (movingTimeout != null) {
                clearTimeout(movingTimeout);
                movingTimeout = null;
            }
            movingTimeout = setTimeout(() => {
                endedMoving();
            }, delay);
        }
    }

    function setSpeed(speed, timeOut = 1) {
        if (!isConnected) return;

        if (!isValidInput(speed)) return;

        if (!isValidInput(timeOut)) timeOut = 1;

        if (currentSpeed !== speed) sendCommandGeneral(`MC SET SPEEDMM ${speed}`, timeOut);

        currentSpeed = speed;
        UI.speedSlider.value = speed;
        UI.speedLabel.value = `${speed.toFixed(2)}`;
    }

    function setAcceleration(acceleration, timeOut = 1) {
        if (!isConnected) return;

        if (!isValidInput(acceleration)) return;
        if (!isValidInput(timeOut)) timeOut = 1;

        if (currentAcceleration !== acceleration) sendCommandGeneral(`MC SET ACCELMM ${acceleration}`, timeOut);

        currentAcceleration = acceleration;
        UI.accelerationSlider.value = acceleration;
        UI.accelerationLabel.value = `${acceleration.toFixed(2)}`;
    }

    function setSpeedAndAcceleration(speed, acceleration, timeOut = 1) {
        if (!isConnected) return;

        timeOut = Math.max(Math.abs(Math.round(timeOut / 2)), 1);
        setSpeed(speed, timeOut);
        setAcceleration(acceleration, timeOut);
    }

    function endedMoving() {
        // idempotence
        if (movingTimeout != null) {
            clearTimeout(movingTimeout);
            movingTimeout = null;
        }

        machineOccupation = false;
        stopWatchdog();

        setSpeedAndAcceleration(currentSpeed, currentAcceleration, 10);

        if (calibrationStatus) unlockMovement();
        if (!calibrationStatus && isConnected) lockMovementExcept(UI.calibrateBtn);
    }

    function speedFromDistance(goal, dMax = 100, sMin = 1, sMax = 25) { // 25 u≈æ od 100 mm
        const d = Math.max(0, Math.abs(toNumber(goal)) || 0);
        const t = Math.min(1, d / dMax);              // 0..1
        const v = sMin + (sMax - sMin) * t;           // line√°rnƒõ 1..25
        return roundDecimalFast(v, 2);                    // float f.2
    }

    async function moveBy(dist, requiredSpeed = null, requiredAcceleration = null) {
        if (!isConnected) return;
        if (isExperimentRunning) return;
        if (machineOccupation) {
            console.warn("\nMachine is already busy. Please wait.");
            return;
        }

        try {
            // ovƒõ≈ôen√≠ kalibrace
            calibrationStatus = await getCalibrationStatus(2000);
            await sleep(50);

            if (!calibrationStatus) {
                const msg = "\n‚ö†Ô∏è Motors are not calibrated.";
                await lockMovementExcept(UI.calibrateBtn);
                console.warn(msg);
                await logMessage(msg);
                endedMoving();
                return;
            }

            currentSpeed = (await getSpeed()) || 15;
            currentAcceleration = (await getAcceleration()) || 150;
            await sleep(5);


            const acceleration = requiredSpeed || 100; // mm/s¬≤
            const speed = requiredAcceleration || await speedFromDistance(dist, acceleration, 0.5, 25); // mm/s

            if (!speed || !acceleration) {
                console.warn("\n‚ö†Ô∏è Invalid speed or acceleration values.");
                endedMoving();
                return;
            }

            await setSpeedAndAcceleration(speed, acceleration, 10);


            lockMovement();               // u bƒõ≈æn√Ωch krok≈Ø zamkni celou pohybovou sekci
            await beganMoving();          // bez timeoutu ‚Äî dopoƒç√≠t√°me a nastav√≠me n√≠≈æ


            const movingTime =
                Math.ceil((computeMotionTime(dist, speed, acceleration) * 1000) + 250);


            // nastav/obnov timeout ukonƒçen√≠ pohybu
            if (movingTimeout != null) {
                clearTimeout(movingTimeout);
                movingTimeout = null;
            }
            movingTimeout = setTimeout(() => endedMoving(), movingTime);

            await sendMoveCommand(`MC MOVEBY USER ${dist}`, 5);
        } catch (e) {
            console.error("Error during moveBy:", e);
            endedMoving();
        }
    }


    // /////// Logging Messages /////////

    // Global array for storing log messages in memory for display on the canvas
    // let logs = [];

    // // /////// Canvas DPI Adjustment /////////
    // function adjustCanvasDPI(canvas) {
    //     const ctx = canvas.getContext('2d', {willReadFrequently: true}); // Optimized for frequent reading
    //     const dpi = (window.devicePixelRatio || 1) * 1.5;
    //
    //     // Get the size of the canvas in CSS pixels.
    //     const width = canvas.clientWidth;
    //     const height = canvas.clientHeight;
    //
    //     // Store the current transformation matrix
    //     const savedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    //
    //     // Scale the canvas up by the device pixel ratio
    //     canvas.width = width * dpi;
    //     canvas.height = height * dpi;
    //     ctx.scale(dpi, dpi);
    //
    //     // Restore the old transformation matrix
    //     ctx.putImageData(savedImageData, 0, 0);
    //
    //     // Redraw the text on the canvas
    //     redrawCanvasText();
    //
    //     console.info(`üé® Canvas DPI changed: ${dpi}`);
    // }
    //
    // // Redraws the text on the canvas
    // function redrawCanvasText() {
    //     const ctx = UI.loadingLogContainer.getContext('2d');
    //     ctx.clearRect(0, 0, UI.loadingLogContainer.width, UI.loadingLogContainer.height);
    //
    //     ctx.font = '14px monospace';
    //     ctx.textBaseline = 'top';
    //
    //     const lineHeight = 16;
    //     const visibleLines = Math.floor(UI.loadingLogContainer.clientHeight / lineHeight);
    //     let scrollOffset = Math.max(0, logs.length - visibleLines);
    //
    //     for (let i = scrollOffset; i < logs.length; i++) {
    //         let msg = logs[i];
    //
    //         // üî• Change color to yellow if a message starts with "ds" (case-insensitive)
    //         if (msg.toLowerCase().startsWith("ds")) {
    //             ctx.fillStyle = 'yellow';
    //         } else {
    //             ctx.fillStyle = 'white';
    //         }
    //
    //         ctx.fillText(msg, 5, (i - scrollOffset + 0.5) * lineHeight);
    //     }
    // }
    //
    // // Function to log measurements to the canvas
    // function logMeasurements(msg) {
    //     if (!msg || typeof msg !== 'string') return;
    //
    //     logs.push(msg);
    //     if (logs.length > 100) logs.shift(); // Keep only the last 100 messages
    //
    //     redrawCanvasText();
    // }
    //
    // // Initial DPI adjustment for the canvas
    // adjustCanvasDPI(UI.loadingLogContainer);
    //
    // // Event listener for resizing the window and adjusting the canvas DPI
    // window.addEventListener("resize", () => adjustCanvasDPI(UI.loadingLogContainer));


    const visibleLines = Math.floor(UI.loadingLogContainer.clientHeight / 16);
    UI.loadingLogContainer.style.fontFamily = "monospace";
    UI.loadingLogContainer.style.fontSize = "14px";
    UI.loadingLogContainer.style.overflow = "hidden";

    function logMeasurements(msg) {
        if (!msg || typeof msg !== 'string') return;

        // Check if a message starts with "ds" and apply yellow color, else use white
        let formattedMsg = msg.toLowerCase().startsWith("ds")
            ? `<span style="color:yellow;">${msg}</span>` // Highlight DSLR data
            : `<span style="color:white;">${msg}</span>`; // Normal log

        // Append the formatted message directly
        UI.loadingLogContainer.innerHTML += formattedMsg + "<br>";

        // Auto-scroll to the bottom for the latest logs
        UI.loadingLogContainer.scrollTop = UI.loadingLogContainer.scrollHeight;

        // Limit logs to 100 lines for performance
        let lines = UI.loadingLogContainer.innerHTML.split("<br>");
        if (lines.length > visibleLines) {
            UI.loadingLogContainer.innerHTML = lines.slice(lines.length - visibleLines).join("<br>");
        }
    }

    // Logs a message to the regular log container
    const logLineHeight = 1.2 * parseInt(window.getComputedStyle(UI.regularLogContainer).fontSize);


    function logMessage(msg) {
        if (!(msg && debugging)) return;

        isScrolledToBottom = checkScrolledToBottom();

        while (isLineLimit && (logCount >= logContentMaxLines)) {
            logContentLines.shift();
            logCount--;
        }


        logContentLines.push(msg);
        logCount++;
        UI.regularLogContainer.textContent = logContentLines.join("\n");


        if (isAutoScroll) {
            UI.regularLogContainer.scrollTop = UI.regularLogContainer.scrollHeight;
        }

        // // TODO : change to remember scrollPosition and scrollHeight, and scroll to it minus the new scrollHeight
        // if (isLineLocker) {
        //     UI.regularLogContainer.scrollTop -= Math.floor(UI.regularLogContainer.scrollHeight / (logCount - 1)); // UI.regularLogContainer.scrollHeight / logContentLines.length; // logCount;
        //     // console.info(UI.regularLogContainer.scrollHeight, logLineHeight * logCount, UI.regularLogContainer.scrollHeight / (logLineHeight * (logCount + 1)))
        //     // UI.regularLogContainer.scrollTop -= logLineHeight; // UI.regularLogContainer.scrollHeight / logContentLines.length; // logCount;
        // }

        if (isScrolledToBottom) {
            UI.regularLogContainer.scrollTop = UI.regularLogContainer.scrollHeight;
        }
    }

    // /////// Loading Commands from JSON /////////

    /**
     * Loads commands from an external JSON file and creates buttons for each command.
     */
    async function loadCommands() {
        try {
            const response = await fetch("commands.json");
            const commands = await response.json();

            for (const [name, command] of Object.entries(commands)) {
                const btn = document.createElement("button");
                btn.innerText = name;
                btn.onclick = () => sendFunction(name, command);
                // $$("buttons").appendChild(btn);
            }
        } catch (error) {
            await handleError(error, "loadCommands");
        }
    }

    // /////// Command Handling /////////

    /**
     * Sends a command to the ESP device.
     * If the command is for reading a specific LoadCell, it replaces the placeholder with the selected ID.
     * @param {string} name - The command name.
     * @param {string} inputCommand - The raw command string.
     */
    async function sendFunction(name, inputCommand) {
        let command;

        if (name === "read Loadcell[#]") { // LC GET FORCE 0-2
            let loadcellId = parseInt($$$("inputNumLoadID").value);
            command = replaceVariables(inputCommand, {loadcellId: loadcellId});
        } else {
            command = inputCommand;
        }

        await sendCommandGeneral(command);
    }

    // /////// Template Variable Replacement /////////

    /**
     * Replaces variables inside a command template with actual values.
     * @param {string} template - The command template containing placeholders.
     * @param {Object} variables - An object mapping variable names to their actual values.
     * @returns {string} - The command string with replaced values.
     */
    function replaceVariables(template, variables) {
        return template.replace(/{{(.*?)}}/g, (match, key) => variables[key.trim()] || match);
    }


    /////////////////////////////////////////////////////////////////

    const serialFunctionGetPorts = async () => {
        try {
            const ports = await navigator.serial.getPorts();
            return ports.length ? ports : null;
        } catch (error) {
            console.error("Error getting serial ports:", error);
            return null;
        }
    };

    const serialFunctionRequestPort = async () => {
        try {
            return await navigator.serial.requestPort(
                {
                    // Example: 'xx:yy' => usbVendorId: xx, usbProductId: yy
                    filters: useFilteredPort ? [
                        ...thymosFingerprints.map(fp => {
                            const [vendorId, productId] = fp.split(":").map(id => parseInt(id, 16));
                            return {usbVendorId: vendorId, usbProductId: productId};
                        })
                    ] : []
                }
            );
        } catch (error) {
            if (error.name === "NotFoundError") {
                console.warn("\n‚ö†Ô∏è No port selected.");
                await logMessage("\n‚ö†Ô∏è No port selected.");
                return null;
            } else {
                throw new Error("Error requesting serial port:", error);
            }
        }
    };


    function checkAllPorts() {
        let thymosPorts = [];
        navigator.serial.getPorts().then(ports => {
            ports?.forEach(port => {
                if (port.manufacturer === "Thymos") {
                    thymosPorts.push(port);
                }
            });


            return port
        }).catch(_ => {
            return null
        });
    }


    // /////// Serial (USB) Connection to ESP /////////

    /**
     * Establishes a connection with the ESP device via USB.
     */
    async function connectSerial(userRequest = true) {
        isSerial = true;
        try {
            let ports = null;

            if (usePortAutoConnect) {
                ports = await serialFunctionGetPorts();
                console.info("üîç Searching for available ports...");
            }


            if (isArr(ports) && ports.length === 1) {
                serialPort = ports[0];
                console.info("\t... Only one port found.");

            } else {
                let founds = false;

                if (isArr(ports) && ports.length > 1) {
                    console.info("Multiple ports found. Select one.");

                    // serialPort = checkAllPorts();

                    for (let port of ports) {
                        await port.close();
                    }
                    founds = true;
                }

                if (userRequest) {
                    if (!serialPort) serialPort = await serialFunctionRequestPort();
                }

                if (serialPort == null) {
                    isSerial = false;
                    if (userRequest) {
                        console.info("‚ö†Ô∏è No port selected, connection canceled.");
                        await logMessage("\n‚ö†Ô∏è No port selected, connection canceled.");
                    } else {
                        if (founds) {
                            console.info("‚ö†Ô∏è Multiple ports found, please select one.");
                            await logMessage("\n‚ö†Ô∏è Multiple ports found, please select one.");
                        } else {
                            console.info("\n\t‚ùé No previously connected devices found.");
                            await logMessage("\n‚ùé No previously connected devices found.");
                        }
                    }

                    console.info("üîå Connecting canceled.");
                    await disconnectSerial(true);
                    return;
                }
            }

            if (!serialPort) throw new Error("No serial port available.");


            await openPort(serialPort);

        } catch (error) {

            await handleError(error, "connectSerial");
            isSerial = false;
            isConnected = false;
            activeWatchDog = false;
            await disconnectSerial(true);
        }
    }

    /**
     * Opens a serial port for communication.
     *  SerialPort => comPort - The selected serial port.
     */
    let machineFirmware = "NaN";
    let fingerprint = null;

    const thymosFingerprints = [
        // "6790:29987",   // Thymos ESP32-S3
        // "6790:29986",   // Thymos ESP32-C3
        // "6790:29985",   // Thymos ESP32-C6
        "12346:4097",   // Thymos ESP32-C6 old
        "0x303a:0x1001" // Thymos ESP32-S2
    ];
    let useFilteredPort = true;
    let usePortAutoConnect = true;

    async function openPort(comPort, retry = false) {
        try {
            activeWatchDog = false;

            if (!comPort) {
                console.error("‚ö†Ô∏è No available port.");
                await logMessage("\n‚ö†Ô∏è No available port.");
                return;
            }

            // If the port is already open, close it first
            if (comPort.opened) {
                console.info("üîå Closing existing port...");
                await comPort.close();
            }

            const {usbVendorId, usbProductId} = comPort.getInfo();
            fingerprint = `${usbVendorId}:${usbProductId}`;
            console.info(`üÜî Port Fingerprint:\n\t\tusbVendorId:${usbVendorId}\n\t\tusbProductId:${usbProductId}`);

            localStorage.setItem("lastFingerprint", fingerprint);

            await sleep(5);

            console.info("üîå Opening new port...");
            try {
                await comPort.open({
                    baudRate: parseInt($$$("inputNumBaudRate").value)
                });
            } catch (error) {
                return;
            }

            // Get the writer and reader for the port after opening
            if (serialWriter) {
                serialWriter.releaseLock();
                serialWriter = null;
            }

            serialWriter = comPort.writable.getWriter(); // üî•  writer
            serialReader = comPort.readable.getReader(); // üî•  reader

            isConnected = true;
            reconnectAttempts = 0;

            await sendCommandGeneral("DATAC 0"); // Stop data collection

            readSerial();

            await checkSerialSignals(comPort);

            await setSerialSignals(comPort, true, false); // Set DTR to true and RTS to false

            await logMessage("\n");


            await sendCommandGeneral("MC STOP"); // Stop movement
            await sendCommandGeneral("MC ENDSTOPS ENABLE");
            await sendCommandGeneral("DSLR STOP CYCLIC"); // Stop DSLR cyclic
            await sendCommandGeneral("DATA SET INTERVAL 50000"); // Stop data collection

            await logMessage("\n");


            // ovƒõ≈ôen√≠ kalibrace
            calibrationStatus = await getCalibrationStatus(2000);
            await sleep(50);

            if (calibrationStatus) await unlockMovement();
            if (!calibrationStatus) await lockMovementExcept(UI.calibrateBtn);

            machineFirmware = `${await getFirmwareVersion()}`;

            /* TODO: implement getting machine name
                // const machineName = await getMachineName(2000) || "UnnamedMachine";
                // const machineID = await getMachineID(2000) || "1";
             */

            const speed = (await getSpeed(2000)) || 15;
            const acceleration = (await getAcceleration(2000)) || 150;

            setSpeedAndAcceleration(speed, acceleration);

            await sleep(5); // Stop for 5 ms

            await updateConnectionStatus("connected", "USB");
            UI.USB.innerText = "‚ùå Disconnect ESP (USB)";
            await logMessage("\n‚úÖ Connected to ESP via USB\n");

            UI.USB.classList.remove("disabled");

        } catch (error) {
            activeWatchDog = false;
            if (!(error.name === "InvalidStateError" && retry)) {
                await handleError(error, "openPort");
                await disconnectSerial(true);
            }
        }
    }


    async function checkSerialSignals(port) {
        if (!port) return;

        try {
            const signals = await port.getSignals();
            console.info("üì° Serial port signals...");
            console.info("\tüö¶ Signals:", signals);
        } catch (error) {
            console.error("‚ùå Error reading serial signals:", error);
        }
    }


    async function setSerialSignals(port, dtrState, rtsState, brkState) {
        if (!port) return;

        try {
            await port.setSignals({
                dataTerminalReady: dtrState,
                requestToSend: rtsState,
                break: brkState
            });

            console.info(`‚úÖ DTR: ${dtrState}, RTS: ${rtsState}, BRK: ${brkState}`);
        } catch (error) {
            console.error("‚ùå Error setting serial signals:", error);
        }
    }


    /**
     * Disconnects from the ESP device via USB.
     */
    async function disconnectSerial(override = false) {
        if (!override && !isConnected) {
            console.warn("\n‚ö†Ô∏è Port is not connected.");
            return;
        }

        try {
            try {
                if (serialPort?.writable) {
                    await sendCommandGeneral("MC STOP"); // Stop movement
                    await sendCommandGeneral("DSLR STOP CYCLIC"); // Stop DSLR cyclic
                    await sendCommandGeneral("DATAC 0"); // Stop data collection
                }
            } catch (error) {
                console.warn("\n‚ö†Ô∏è Error stopping data collection:", error);
            } finally {
                machineOccupation = false;
                isExperimentRunning = false;
            }

            await sleep(5);

            // Stop data reading before releasing the reader
            if (serialReader) {
                console.info("üìå Stopping data reading...");
                try {
                    await serialReader.cancel(); // Cancel reading safely
                } catch (err) {
                    console.warn("\n‚ö†Ô∏è Error canceling reader:", err);
                }
                serialReader.releaseLock(); // Release reader lock
                serialReader = null;
            }

            // Release the writer before closing the port
            if (serialWriter) {
                console.info("üìå Releasing writer...");
                serialWriter.releaseLock();
                serialWriter = null;
            }

            // Now close the port safely
            if (serialPort) {
                console.info("üìå Closing serial port...");
                try {
                    await serialPort.close();
                } catch (error) {
                    // console.error("‚ùå Error setting serial signals:", error);
                }
                serialPort = null;
            }

            await logMessage("‚úñÔ∏è Disconnected from ESP\n\n");

            console.info("‚úÖ Disconnected successfully.");
        } catch (error) {
            console.error("‚ùå disconnectSerial error:", error);
        } finally {
            isConnected = false;
            isSerial = false;
            activeWatchDog = false;
            await resetValues();
            await endedMoving();
            UI.USB.classList.remove("disabled");
        }
    }


    function resetValues() {
        parsedData = {time: null, position: null, value: null, force: Array(loadCellNum).fill(null), photoIndex: null};
        liveUpdate = false

        UI.USB.innerText = "üîå Connect via USB";
        updateConnectionStatus("disconnected");

        isExperimentRunning = false;
        machineOccupation = false;
        UI.loadingLogContainer.style.background = "#323232";

        experimentEndLimits = {position: null, force: null, time: null};
        expControl = '';
        startTime = null;
        pendingDSLR = null;
        dataCount = null;
        maxForces = Array(loadCellNum).fill(null);
        // timeData = [];
        // positionData = [];
        measureForces = Array(loadCellNum).fill(0).map(() => []);
        // forceData = Array(loadCellNum).fill(0).map(() => []);
        meanForces = Array(loadCellNum).fill(0);
        // markersTime = [];
        // markersDist = [];
        aggregatedDataBetweenSteps = [];
        zero_speed_counter = 0;
        over_limitForce_counter = 0;
        startPosition = 0;
        minimumConditionCount = 2;
        endMeasurement = false;
        clearTimeout(endMeasurementCounter)
        endMeasurementCounter = null;
        checkSpeed = true;


        displacementSignCorrection = 0;
        loadSignCorrections = Array(loadCellNum).fill(0);

        loadcellErrRate = null;
        measurementErrRate = null;
        totalErrRate = null;


        activeWatchDog = false;

        isSerial = false;
        isConnected = false;
        serialPort = null;
        serialReader = null;
        serialWriter = null;
        // reconnectAttempts = 0;
    }

    async function clearAndResetAll() {
        await disconnectSerial();
        // clear DB
        if (liveUpdate) await chartUpdate();
        await clearDatabase();
        await clearLocalStorage();

        parsedData = {time: null, position: null, value: null, force: Array(loadCellNum).fill(null), photoIndex: null};

        isExperimentRunning = false;
        machineOccupation = false;
        UI.loadingLogContainer.style.background = "#323232";

        experimentEndLimits = {position: null, force: null, time: null};
        expControl = '';
        startTime = null;
        pendingDSLR = null;
        dataCount = null;
        maxForces = Array(loadCellNum).fill(null);
        timeData = [];
        positionData = [];
        measureForces = Array(loadCellNum).fill(0).map(() => []);
        forceData = Array(loadCellNum).fill(0).map(() => []);
        meanForces = Array(loadCellNum).fill(0);
        photoData = [];
        // markersDist = [];
        aggregatedDataBetweenSteps = [];
        zero_speed_counter = 0;
        over_limitForce_counter = 0;
        startPosition = 0;
        minimumConditionCount = 2;
        endMeasurement = false;
        clearTimeout(endMeasurementCounter)
        endMeasurementCounter = null;
        checkSpeed = true;


        displacementSignCorrection = 0;
        loadSignCorrections = Array(loadCellNum).fill(0);

        loadcellErrRate = null;
        measurementErrRate = null;
        totalErrRate = null;


        activeWatchDog = false;

        isSerial = false;
        isConnected = false;
        serialPort = null;
        serialReader = null;
        serialWriter = null;
        reconnectAttempts = 0;

        // --------------------------------
        // Experiment parameters
        speedForward_mmps = 0;
        currentSpeed = null;
        currentAcceleration = null;
        takePhotos = false;
        dataInterval_us = null;
        initialForceLim_N = null;
        experimentDoubleSpeed = false;
        stoppingForceLimit = null;
        holdForceTimeMs = null;
        // --------------------------------
    }


    // /////// Reading Data from ESP /////////

    /**
     * Reads incoming data from the ESP device over a serial connection.
     */


    async function readSerial() {
        let buffer = "";

        if (!serialPort.readable) {
            await logMessage("\n‚ùå Port is unavailable.\n");
            return;
        }

        if (serialReader) {
            try {
                serialReader.releaseLock(); // Ensure only one active reader
            } catch (err) {
                console.error("Reader lock error:", err);
            }
        }

        serialReader = serialPort.readable.getReader(); // Get a reader only once
        isReadingSerial = true;

        try {
            while (isConnected) {
                const {value, done} = await serialReader.read();
                if (done) break; // Stop the loop if the stream is closed

                buffer += td.decode(value, {stream: true});

                let lastNewline = buffer.lastIndexOf("\n");
                if (lastNewline !== -1) {
                    let dataChunk = buffer.slice(0, lastNewline).split("\n");
                    buffer = buffer.slice(lastNewline + 1);

                    await handleIncomingChunkQueued(dataChunk);
                }
            }
        } catch (error) {
            activeWatchDog = false;
            await handleError(error, "readSerial"); // Handle any errors
        } finally {
            if (serialReader) {
                await stopMachine();
                await serialReader.cancel(); //  Immediately stop reading !!!!
                serialReader.releaseLock();
                isReadingSerial = false;
            }
            await logMessage("\n‚úÖ Reading stopped.\n");
        }
    }


    async function findPreferredPortIndex(showMessage = false) {
        if (!fingerprint) {
            console.warn("\n‚ö†Ô∏è No fingerprint available.");
            return null;
        }
        const ports = await navigator.serial.getPorts();

        for (let i = 0; i < ports.length; i++) {
            const info = ports[i].getInfo();
            const currentFingerprint = `${info.usbVendorId}:${info.usbProductId}`;
            if (currentFingerprint === fingerprint) {
                console.info("‚úÖ Matched port at index:", i);
                return ports[i];
            }
        }

        if (showMessage) {
            console.warn("\n‚ö†Ô∏è No matching port found.");
            await logMessage("\n‚ö†Ô∏è No matching port found.");
        }
        return null;
    }

    async function attemptReconnect() {
        console.info("%c\nüîÑ Attempting to reconnect...", "color: blue; font-weight: bold;");

        if (isConnected || isReconnecting) {
            console.warn("\nüöß Reconnect aborted - Already connected or disconnect was expected.");
            return;
        }

        if (reconnectAttempts >= maxReconnectAttempts) {
            console.warn("\n‚ö†Ô∏è Stopping auto-reconnect. Maximum attempts reached.");
            await logMessage("\n‚ö†Ô∏è Stopping auto-reconnect.\n");
            isReconnecting = false;
            await disconnectSerial();
            await resetValues();
            return;
        }

        // Reset the connection status
        // await serialReader.cancel();
        // await serialReader.releaseLock();
        // await serialPort.close();
        // serialReader = null;
        // serialPort = null;

        isConnected = false;
        await disconnectSerial(true);


        activeWatchDog = false;
        isReconnecting = true;
        reconnectAttempts++;
        UI.USB.innerText = "üîÑ Reconnecting...";
        await updateConnectionStatus("reconnecting");
        await logMessage(`\nüîÑ Attempting reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);

        try {

            // TODO: implement also using machine name
            const port = await findPreferredPortIndex();

            if (port) {
                serialPort = port; // Update the serialPort reference
                await openPort(port, true);
            }


            if (isConnected) {
                console.info("‚úÖ Reconnected successfully!");
                isReconnecting = false;
                await updateConnectionStatus("connected");
                await logMessage("‚úÖ Reconnected successfully!\n");
                await unlockMovement();
            } else {
                throw new Error("Reconnect failed: not connected after openPort");
            }
        } catch (error) {
            console.warn("\n‚ö†Ô∏è Reconnection failed:", error);
            await logMessage("\n‚ùå Reconnection failed: " + error.message);

            if (reconnectAttempts < maxReconnectAttempts) {
                setTimeout(() => {
                    isReconnecting = false; // Allow another reconnection attempt
                    attemptReconnect();
                }, 3000);
            } else {
                console.warn("\n‚ö†Ô∏è Max reconnect attempts reached. Stopping.");
                await logMessage("\n‚ùå Max reconnect attempts reached. Stopping.\n");
                await resetValues();
                isReconnecting = false;
            }
        }
    }


    /////////////////////////////////////////////////////////////////


    // /////// Optimized Measurement Processing /////////
    /**
     * Processes incoming measurement data.
     * @param {Array} dataChunk - An array of measurement data lines.
     */
    async function processMessage(dataChunk) {
        if (!dataChunk || !dataChunk.length) return;

        for (let raw of dataChunk) {
            const msg = String(raw).trim();


            if (msg === "S0:WR") continue; // ignore

            // If 'alarm' or 'alarmed' is in the message, log it and skip further processing
            if (/alarm(ed)?/i.test(msg)) {
                await logMessage("üö®\t" + msg);
                if (isExperimentRunning) {
                    isExperimentRunning = false;
                    await stopMachine("alarm");
                    logMessage("‚ö†Ô∏è Experiment stopped due to alarm.");
                }
                continue;
            }

            // First, try to match and resolve waiting messages in the queue
            const consumed = _tryMatchAndResolve(msg);
            if (consumed) {
                if (debugging) logMessage(" üìØ\t" + msg);
                continue;             // If a message is consumed, skip further processing
            }

            // ostatn√≠ logiky
            // TODO: rozmyslet co pou≈æ√≠vat:         split(":") // substring(measurementPrefix.length)
            const measurementPrefix = "DS"; // "S205:"
            if (msg.startsWith(measurementPrefix)) {
                await processMeasurements(msg.substring(measurementPrefix.length));
            } else {
                logMessage("üì©\t" + msg);
            }
        }
    }

    let _msgQueue = Promise.resolve();

    function handleIncomingChunkQueued(dataChunk) {
        _msgQueue = _msgQueue
            .then(() => processMessage(dataChunk))
            .catch(err => console.error('processMessage failed:', err));
    }


    function timeStepCheck(previous, current, stepSize, tolerance = null) {
        if (!isNum(tolerance)) tolerance = (stepSize * 0.01); // set default tolerance to 2x 1% of step size

        // TODO: optimalizovat tolerance dle rychlosti zpracov√°n√≠ dat
        tolerance = clamp(roundDecimalFast(Math.abs(tolerance), 9), 0.001, 0.1);


        const actualStep = current - previous;

        if (!((stepSize - tolerance) <= actualStep && actualStep <= (stepSize + tolerance))) {
            console.warn("‚ö†Ô∏è Step size mismatch:", {previous, current, actualStep, stepSize, tolerance});
            return previous + stepSize;
        }

        return current
    }

    // TODO: - je to ≈°patnƒõ
    function timeStepCheckNEW(prev, curr, step, tol = step * 0.1) {
        if (curr >= prev) {
            const delta = curr - prev;
            const n = Math.round(delta / step);
            if (Math.abs(delta - n * step) <= Math.max(tol, step * 0.25)) {
                return prev + n * step; // posu≈à o cel√© n√°sobky kroku
            }
        }
        // fallback: vƒõ≈ô p≈ôijat√©mu ƒçasu, a≈• pozn√°≈° drift/drop
        return curr;
    }

    function interpolateDSLRDataNEW(dslrEvent, nextData, prevData) {
        if (!prevData || !nextData || !dslrEvent) {
            console.info("‚ö†Ô∏è No valid data for interpolation.");
            return null;
        }

        // TODO: zkontrolovat DSLR time relativnƒõ ke startu mƒõ≈ôen√≠
        const dslrTime = roundDecimalFastNEW(dslrEvent.time - startTime, precisionTime);
        const photoIndex = dslrEvent.photoIndex;

        if (!(prevData.time < nextData.time)) {
            console.error("‚ö†Ô∏è Not enough data for interpolation.");
            return null;
        }

        let interpolatedData;

        if (prevData.time <= dslrTime && dslrTime <= nextData.time) {
            const t1 = prevData.time, t2 = nextData.time;
            const factor = (dslrTime - t1) / (t2 - t1);

            const interpPos = roundDecimalFast(prevData.position + factor * (nextData.position - prevData.position), precisionPosition);
            const interpSpeed = roundDecimalFast(prevData.speed + factor * (nextData.speed - prevData.speed), precisionSpeed);

            const interpForce = prevData.force.map((v1, i) => {
                const v2 = nextData.force[i];
                if (isNum(v1) && isNum(v2)) return roundDecimalFast(v1 + factor * (v2 - v1), precisionForce);
                if (isNum(v1)) return v1;
                if (isNum(v2)) return v2;
                return null;
            });

            interpolatedData = {
                time: dslrTime,
                position: interpPos,
                speed: interpSpeed,
                force: interpForce,
                photoIndex
            };

        } else {
            console.warn("‚ö†Ô∏è DSLR time out of [prev,next] ‚Äî using midpoint.");
            const midT = roundDecimalFast((prevData.time + nextData.time) / 2, precisionTime);
            const midPos = roundDecimalFast((prevData.position + nextData.position) / 2, precisionPosition);
            const midSpeed = roundDecimalFast((prevData.speed + nextData.speed) / 2, precisionSpeed);
            const midForce = prevData.force.map((v1, i) => {
                const v2 = nextData.force[i];
                if (isNum(v1) && isNum(v2)) return roundDecimalFast((v1 + v2) / 2, precisionForce);
                return isNum(v1) ? v1 : (isNum(v2) ? v2 : null);
            });

            interpolatedData = {
                time: midT,
                position: midPos,
                speed: midSpeed,
                force: midForce,
                photoIndex
            };
        }

        console.info("üì∏ DSLR Interpolated Data @", interpolatedData.time);
        return interpolatedData;
    }


    // /////// Data Parsing /////////
    function interpolateDSLRData(dslrEvent, nextData, prevData) {
        if (!prevData || !nextData || !dslrEvent) {
            console.info("‚ö†Ô∏è No valid data for interpolation.");
            return;
        }

        const dslrTime = roundDecimalFast(dslrEvent.time - startTime, precisionTime);

        const photoIndex = dslrEvent.photoIndex;

        // Ensure valid data for interpolation
        if (prevData.time >= nextData.time) {
            console.error("‚ö†Ô∏è Not enough data for interpolation.");
            return;
        }

        let interpolatedData;

        if ((prevData.time <= dslrTime) && (dslrTime <= nextData.time)) {
            // Linear interpolation factor
            const t1 = prevData.time, t2 = nextData.time;
            const factor = (dslrTime - t1) / (t2 - t1);

            const interpolatedPosition = roundDecimalFast(prevData.position + factor * (nextData.position - prevData.position), precisionPosition);
            const interpolatedSpeed = roundDecimalFast(prevData.speed + factor * (nextData.speed - prevData.speed), precisionSpeed);
            const interpolatedForce = prevData.force.map((f1, i) => {
                const f2 = nextData.force[i];
                if (isNum(f1) && isNum(f2)) return roundDecimalFast(f1 + factor * (f1 - v1), precisionForce);
                if (isNum(f1)) return f1;
                if (isNum(f2)) return f2;
                return null;
            });

            interpolatedData = {
                time: dslrTime,
                position: interpolatedPosition,
                speed: interpolatedSpeed,
                force: interpolatedForce,
                photoIndex: photoIndex // Store DSLR photo order
            };

        } else {
            console.error("‚ö†Ô∏è Invalid interpolation range.");

            interpolatedData = {
                time: roundDecimalFast((prevData.time + nextData.time) / 2, precisionTime),
                position: roundDecimalFast((prevData.position + nextData.position) / 2, precisionPosition),
                speed: roundDecimalFast((prevData.speed + nextData.speed) / 2, precisionSpeed),
                force: prevData.force.map((val, i) => roundDecimalFast((val + nextData.force[i]) / 2, precisionForce)),
                photoIndex: photoIndex // Store DSLR photo order
            };
        }


        // Log interpolated data
        // logMeasurements(`${Math.round(dslrEvent.time * 10e6)},${(interpolatedPosition + startPosition).toFixed(4)},${interpolatedSpeed.toFixed(2)},${interpolatedForce[0].toFixed(2)},${interpolatedForce[1].toFixed(2)},${interpolatedForce[2].toFixed(2)},    ${photoIndex}`);
        addDataToLog(interpolatedData);

        // addMarker(timeChart, markersTime, interpolatedData.time);
        // addMarker(positionChart, markersDist, interpolatedData.position);
        photoData.push(0);
        timeData.push(interpolatedData.time);
        positionData.push(interpolatedData.position);
        for (let i = 0; i < loadCellNum; i++) {
            forceData[i].push(interpolatedData.force[i]);
        }

        //TODO: zv√°≈æit zda dƒõlat p≈ôid√°v√°n√≠ dat do pr≈Ømƒõr≈Ø:
        dataCount++;
        aggregatedDataBetweenSteps.push(interpolatedData);
        pendingDSLR = null;


        console.info("üì∏ DSLR Interpolated Data:", interpolatedData.time);
    }


    /**
     * Parses raw measurement data into a structured object.
     * @param {string} dataString - The raw data string received from ESP.
     * @returns {Object} - Parsed data object containing time, position, value, and load values.
     */

    let pendingDSLR = null; // Store DSLR event until the next data arrives
    let dataCount = null;
    let dataChartInterval = 1; // Interval for live chart update
    let startTime = null;

    // let firstPhoto = 0;


    function calculateAverageParsedData(parsedDataList) {
        const totalEntries = parsedDataList.length;

        if (totalEntries === 0) return {
            time: 0,
            position: 0,
            force: Array(loadCellNum).fill(0)
        }; // Return zero values if no data

        let sumTime = 0;
        let sumPosition = 0;
        let sumForce = Array(loadCellNum).fill(0); // Empty list of `force` values

        parsedDataList?.forEach(data => {
            sumTime += data.time;
            sumPosition += data.position;

            // Sum all values in `load` list
            data.force?.forEach((value, index) => {
                sumForce[index] += value;
            });
        });

        return {
            time: roundDecimalFast(sumTime / totalEntries, precisionTime),
            position: roundDecimalFast(sumPosition / totalEntries, precisionPosition),
            force: sumForce.map(value => roundDecimalFast(value / totalEntries, precisionForce)) // Average of `force` list values (per index)
        };
    }


    let aggregatedDataBetweenSteps = [];
    let minimumConditionCount = 2;
    let displacementSignCorrection = 1;
    let loadSignCorrections = [-1, -1, -1];

    let loadcellErrRate = null;
    let measurementErrRate = null;
    let totalErrRate = null;

    let endMeasurement = false;
    let endMeasurementCounter = null;
    const delayMsAfterEndMeasurement = 100; // microseconds

    let positionProgress = 0;

    let endedBy = null;

    async function endMeasuring(timeoutMs = 0, ednStatus = null, endText = '‚õî Experiment stopped.', immediateText = '', command = '') {
        if (endMeasurement) return;
        endMeasurement = true;

        const delayFixMs = 5; // fix for setTimeout delays

        if (endMeasurementCounter) {
            clearTimeout(endMeasurementCounter);
            endMeasurementCounter = null;
        }

        if (timeoutMs == null || !isNumber(timeoutMs)) timeoutMs = 0;

        if (isNonEmptyStr(command)) {
            await sendCommandGeneral(command);
        }
        if (isNonEmptyStr(immediateText)) {
            console.info(immediateText);
            logMessage(immediateText);
        }

        const totDelayMs = Math.max(0, timeoutMs - delayFixMs);

        console.info(`üïê Ending in ${totDelayMs} miliseconds...`);
        logMessage(`üïê Ending in ${totDelayMs} miliseconds...`);


        endMeasurementCounter = setTimeout(async () => {
            if (isNonEmptyStr(endText)) {
                console.info(endText);
                logMessage(endText);
            }

            await sendCommandGeneral("MC STOP");
            await sendCommandGeneral("DSLR STOP CYCLIC");
            await sendCommandGeneral("DATAC 0");

            isExperimentRunning = false;
            dataCount = null;
            dataChartInterval = 1;

            UI.loadingLogContainer.style.background = "#323232";

            if (aggregatedDataBetweenSteps.length > 0) {
                console.info("‚ö†Ô∏è Data not sent to chart.", aggregatedDataBetweenSteps.length);
                await updateChart(calculateAverageParsedData(aggregatedDataBetweenSteps));
            }

            // progress UI
            if (positionProgress >= 99.99990) {
                positionProgress = 100;
                document.documentElement.style.setProperty('--progressColor', 'var(--progressDone-color)');
                UI.experimentStageLabel.textContent = `Finished`;
                UI.progressBar.value = 100;
                UI.progressLabel.textContent = `100%`;
                document.title = `ŒúŒø·øñœÅŒ±‚Äá-‚ÄáExperiment done (100%)`;
                if (debugging) console.info("‚úÖ Experiment done üíØ");
            }

            aggregatedDataBetweenSteps = [];

            // const lastData = await calculateAverageParsedData(aggregatedDataBetweenSteps);
            // console.warn(lastData);
            // aggregatedDataBetweenSteps.forEach(data => {
            //     updateChart(data);
            // });

            clearTimeout(endMeasurementCounter);
            endMeasurementCounter = null;

            if (ednStatus) endedBy = ednStatus;

            await sleep(1000); // Allow any final data processing

            await refreshCharts();

        }, totDelayMs);
    }

    function progressCalculate(current, end) {
        let progress = clamp((current / end) * 100, 0, 100);
        return roundDecimalFast(progress, 6);
    }

    let lastAcceptedTime = null;

    async function processMeasurements(dataString) {
        if (!takeMeasurements && !isExperimentRunning) {
            logMeasurements(dataString);
            return;
        }

        const parts = dataString.split(",");

        // Detect DSLR shoot event
        const DSLRPrefix = "LR shoot:";
        if (takePhotos && dataString.startsWith(DSLRPrefix)) {
            const [dslrTime, photoIndex] = dataString.split(":")[1].split(",");
            pendingDSLR = {time: parseFloat(dslrTime) * timeConversionDSLR, photoIndex: parseInt(photoIndex) - 1};
            logMeasurements("Photo" + dataString.substring(2));
            return;
        }

        if (parts.length !== 6) {
            logMessage("üå°Ô∏è DS" + dataString);
            return;
        } else {
            logMeasurements(dataString);
        }

        // Common parsing logic
        let forceVal = parts.slice(3).map(num => num === "0" ? null : parseFloat(num)); // LoadCell values

        if (takeMeasurements) {
            forceVal?.forEach((value, index) => measureForces[index].push(value * loadSignCorrections[index])); // Handle takeMeasurements
            return;
        }

        let timeVal = parseFloat(parts[0]) * timeConversionDATAC; // Convert microseconds to seconds
        let distVal = roundDecimalFast((parseFloat(parts[1]) - startPosition) * displacementSignCorrection, precisionPosition); // Position value
        const speedVal = roundDecimalFast(parseFloat(parts[2]) * displacementSignCorrection, precisionSpeed); // Speed value

        if (!isNum(timeVal) || !isNum(distVal)) {
            console.warn("‚ö†Ô∏è Invalid data received:", {timeVal, distVal});
            endMeasuring(0, 'data error', "‚èπÔ∏è Movement stopped due to data error.", '', "MC STOP");
            document.documentElement.style.setProperty('--progressColor', 'var(--progressError-color)');
            UI.experimentStageLabel.textContent = `Error`;
            return;
        }


        // Handle regular data (not DSLR)
        if (startTime === null) {
            startTime = timeVal;
            timeVal = 0;
            lastAcceptedTime = 0;
        } else {
            // TODO => check if this is correct (step must be same), must be bigger than 0, process as UINT, process as FLOAT in export/saving and charts, BIGINT???
            const rawCurrent = (timeVal - startTime);
            const corrected = timeStepCheck(lastAcceptedTime ?? parsedData.time, rawCurrent, dataInterval_us * timeConversionDATAC);
            timeVal = roundDecimalFast(corrected, precisionTime);
            lastAcceptedTime = timeVal; // okam≈æitƒõ posu≈à "previous"
        }


        // TODO: do only Present loadcellls
        forceVal = forceVal.map((value, index) => roundDecimalFast((value * loadSignCorrections[index]) - meanForces[index], precisionForce));


        const newData = {time: timeVal, position: distVal, speed: speedVal, force: forceVal, photoIndex: null};

        // If a pending DSLR timestamp exists, interpolate values
        if (takePhotos && pendingDSLR) {
            const clone = structuredClone(parsedData); // TODO: zkontrolovat zda to m√° smysl a funguje
            interpolateDSLRData(pendingDSLR, newData, clone);
        }

        parsedData = newData;

        if (experimentDoubleSpeed && forceVal.some(value => isNum(value) && value >= initialForceLim_N)) {
            setSpeed(speedForward_mmps);
            experimentDoubleSpeed = false;
            document.documentElement.style.setProperty('--progressColor', 'var(--progressSecondary-color)');
            UI.experimentStageLabel.textContent = `Loading`;
        }

        const sumForce = forceVal.reduce((acc, val) => acc + (isNum(val) ? val : 0), 0);

        if (sumForce >= stoppingForceLimit) {
            over_limitForce_counter++;

            if (over_limitForce_counter > minimumConditionCount) {
                checkSpeed = false; // disable speed check
                endMeasuring(holdForceTimeMs, 'force limit', `‚èπÔ∏è Movement stopped due to force limit (${stoppingForceLimit} N).`, '', "MC STOP");
                document.documentElement.style.setProperty('--progressColor', 'var(--progressOnHold-color)');
                UI.experimentStageLabel.textContent = `Holding`;
            }
        } else {
            over_limitForce_counter = 0;
        }


        // Handle speed checks and experiment stopping
        if (checkSpeed && (speedVal < (1 / 1e2) && timeVal > 1)) { // speedVal < 0.01 m/s <= speed value is limited to 2 decimal places // (timeVal - startTime) > 1 second => handled in 'timeStepCheck'
            zero_speed_counter++;

            if (zero_speed_counter > minimumConditionCount) {
                endMeasuring(Math.max(delayMsAfterEndMeasurement / 2, 10), 'zero speed', "üõë Experiment stopped due to zero speed.");
                document.documentElement.style.setProperty('--progressColor', 'var(--progressStoppedcolor)');
                UI.experimentStageLabel.textContent = `Stopped`;
                if (takePhotos) setTimeout(() => sendCommandGeneral("DSLR STOP CYCLIC"), 30); // small delay to allow data processing
            }
        } else {
            zero_speed_counter = 0;
        }


        // Handle LoadCell limit checks
        for (let i = 0; i < 3; i++) {
            if (isNum(forceVal[i])) {
                const currForce = forceVal[i];
                if (currForce > maxForces[i]) maxForces[i] = currForce;
                if (maxForces[i] || maxForces[i] === 0) {
                    if ((maxForces[i] - currForce) > (Math.abs(maxForces[i]) * forceLimitDropPercent) && (maxForces[i] - currForce) > forceLimitDropValue) {
                        endMeasuring(50, `loadCell[${i + 1}] drop`, `üõë Experiment stopped due to LoadCell ${i + 1} drop:\n\tPercentage: ${(maxForces[i] - currForce)} > ${(Math.abs(maxForces[i]) * forceLimitDropPercent)} and Absolute: ${maxForces[i] - currForce} > ${forceLimitDropValue}.`, '', "MC STOP");
                        if (takePhotos) setTimeout(() => sendCommandGeneral("DSLR STOP CYCLIC"), 30); // small delay to allow data processing
                        break; // Stop checking other LoadCells if one fails
                    }
                }
            }
        }

        addDataToLog(newData);

        // Update Progress Bar
        let progressValue;
        progressValue = progressCalculate(newData[expControl], experimentEndLimits[expControl]);

        if (progressValue >= 100) {
            if (positionProgress < 100) {
                const delayMs = endMeasurement ? 0 : delayMsAfterEndMeasurement;
                endMeasurement = false; // Overwrite to allow ending
                endMeasuring(delayMs, 'end position', "üèÅ Experiment finished.");
                if (takePhotos) setTimeout(() => sendCommandGeneral("DSLR STOP CYCLIC"), 30); // small delay to allow data processing
            }
        }
        positionProgress = progressValue;

        // Live chart update
        dataCount++;
        aggregatedDataBetweenSteps.push(newData);
        if (liveUpdate) {
            if (dataChartInterval === 1) {
                await updateChart(newData);
                photoData.push(null);
            } else if (dataCount % dataChartInterval === 0) {
                await updateChart(calculateAverageParsedData(aggregatedDataBetweenSteps));
                photoData.push(null);
            }
        }
        if (dataCount % dataChartInterval === 0) {
            aggregatedDataBetweenSteps = [];
        }
    }

    let lastTitle = document.title;

    async function UIupdate() {
        lastTitle = document.title;
        while (isExperimentRunning) {
            UI.progressBar.value = positionProgress;
            UI.progressLabel.innerText = `${positionProgress.toFixed(2)}%`; // .padStart(5, "0")
            const newTitle = `ŒúŒø·øñœÅŒ±‚Äá-‚Äá${Math.floor(positionProgress)}%`;
            if (lastTitle !== newTitle) {
                document.title = newTitle;
                lastTitle = newTitle;
            }
            await sleep(50);
        }
    }


    /////////////////////////////////////////////////////////////////


    // /////// Page Initialization /////////

    /**
     * Runs when the page loads.
     * - Logs a message to the console.
     * - Loads available commands from the JSON file.
     */
    window.onload = async () => {
        console.info("Page loaded");
        await openDB();
        // await loadCommands();
    };


    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////


    // Store dataset
    let timeData = [];
    let positionData = [];
    let forceData = Array(loadCellNum).fill(0).map(() => []);


    let photoData = []; // List of time markers
    // let markersDist = []; // List of position markers


    let timeChart;
    let positionChart;


    // /////// Toggle Live Update /////////
    function chartUpdate() {
        if (!liveUpdate) loadDataFromDBToChart(!liveUpdate);

        liveUpdate = !liveUpdate;

        UI.chartsLiveButton.textContent = liveUpdate ? "‚è∏Ô∏è Disable Charts" : "‚ñ∂Ô∏è Activate Charts";
        $$$("chartsWrapper").style.background = liveUpdate ? "var(--charts-bg-active)" : "var(--charts-bg)";
    }


    let isPageVisible = true; // Visibility status of the page
    let hideTimeout = null; // Timeout for hiding the page
    const MIN_HIDE_TIME = 20_000; // 20 seconds

    // Event listener for page visibility change
    document.addEventListener("visibilitychange", async () => {
        if (!isExperimentRunning) return;
        if (!liveUpdate && !liveUpdatePaused) return;

        isPageVisible = !document.hidden;

        if (!isPageVisible) {
            console.info("\nüìÑ - ‚è∏Ô∏è Page is hidden.");


            // üïí Set timeout for hiding the page
            if (hideTimeout) {
                clearTimeout(hideTimeout);
                hideTimeout = null; // Reset the timeout
            }
            hideTimeout = setTimeout(() => {
                if (!isPageVisible) {
                    console.info(`‚è≥ Page is hidden longer than ${roundDecimalFast(MIN_HIDE_TIME / 1000, 2)}+ seconds. Hiding...`);

                    if (liveUpdate && !liveUpdatePaused) {
                        console.info("‚è∏Ô∏è Pause live update of charts.");
                        liveUpdatePaused = true;
                        liveUpdate = false;
                    }
                }
            }, MIN_HIDE_TIME);

        } else {

            if (hideTimeout) {
                clearTimeout(hideTimeout); // Clear the hide timeout
                hideTimeout = null;
            }

            console.info("\nüìÑ - ‚ñ∂Ô∏è Page is visible");
            if (liveUpdatePaused) {
                console.info("üîÑ Resuming live update of charts.");
                await loadDataFromDBToChart(true);
                liveUpdatePaused = false;
                liveUpdate = true;
            }
        }
    });


    function aggregateData(dataEntries, chunkSize, timeData, positionData, forceData, photoData, overflowData) {
        if (!isNum(chunkSize)) chunkSize = 1;
        chunkSize = Math.max(1, Math.round(chunkSize));

        // const photoValidStep = dataEntries.findIndex((entry, i) => isFiniteNumber(entry.photoIndex, false) && i > 0);
        // if (photoValidStep > 0 && chunkSize > photoValidStep) {
        //     chunkSize = photoValidStep; // Ensure chunkSize does not exceed the first photo event step
        //     console.warn(`‚ö†Ô∏è Adjusted chunkSize to ${chunkSize} to capture first photo event.`);
        // }

        if (chunkSize === 1) {
            // If chunkSize = 1, no aggregation is needed (1:1 mapping)
            for (let i = 0; i < dataEntries.length; i++) {
                let entry = dataEntries[i];
                timeData[i] = entry.time;
                positionData[i] = entry.position;
                entry.force?.forEach((value, index) => forceData[index][i] = value);
                photoData[i] = isNum(entry.photoIndex) ? 0 : null; // Mark photo event
            }
            return;
        }

        // const photosCount = dataEntries.reduce((count, entry) => count + (isNum(entry.photoIndex) ? 1 : 0), 0);

        let fullChunks = Math.floor(dataEntries.length / chunkSize) * chunkSize;
        // let chunkCount = Math.floor(dataEntries.length / chunkSize) + photosCount; // Block count
        let remainderStart = fullChunks; // First index of data

        // Predefine array size to match the new chunk count
        // timeData.length = chunkCount;
        // positionData.length = chunkCount;
        // photoData.length = chunkCount;
        // forceData?.forEach(arr => arr.length = chunkCount);

        let sumTime = 0, sumPosition = 0;
        let sumForce = Array(loadCellNum).fill(0);
        let count = 0, chunkIndex = 0;

        for (let i = 0; i < fullChunks; i++) {
            const entry = dataEntries[i];
            sumTime += entry.time;
            sumPosition += entry.position;
            entry.force?.forEach((value, index) => sumForce[index] += value);
            count++;

            if (isNum(entry.photoIndex)) {
                // If a photo event is detected, add data immediately to the current chunk
                // timeData[chunkIndex] = entry.time;
                // positionData[chunkIndex] = entry.position;
                // sumForce?.forEach((value, index) => {
                //     forceData[index][chunkIndex] = value;
                // });
                timeData[chunkIndex] = null;
                positionData[chunkIndex] = null;
                forceData[index] = [...Array(loadCellNum).fill(null)];
                photoData[chunkIndex] = 0; // Mark photo event
                chunkIndex++;
            }

            if (count === chunkSize) {
                let invCount = 1 / count; // Inverse count: quicker than '%' division operation
                timeData[chunkIndex] = sumTime * invCount;
                positionData[chunkIndex] = sumPosition * invCount;
                sumForce?.forEach((value, index) => {
                    forceData[index][chunkIndex] = value * invCount;
                    sumForce[index] = 0; // Reset for next chunk
                });
                photoData[chunkIndex] = isNum(entry.photoIndex) ? 0 : null; // Mark photo event

                sumTime = sumPosition = 0;
                count = 0;
                chunkIndex++;
            }
        }

        // Add remaining data to an overflow array
        // console.info("Overflow: ", dataEntries.length - remainderStart);
        for (let i = remainderStart; i < dataEntries.length; i++) {
            let entry = dataEntries[i];
            overflowData.push({
                time: entry.time,
                position: entry.position,
                force: [...entry.force]
            });
        }
    }


    async function loadDataFromDBToChart(stateAtEnd = false) {
        if (!db) {
            console.error("‚ö†Ô∏è IndexedDB is not available (not opened).");
            return;
        }

        liveUpdate = false;

        await clearCharts();

        console.info("\n%cüîÑ Loading data from IndexedDB to charts...", "color: blue;");

        let transaction = db.transaction(STORE_NAME, "readonly");
        let store = transaction.objectStore(STORE_NAME);
        let request = store.getAll();

        request.onsuccess = async function () {
            let dataEntries = request.result;
            if (!dataEntries || dataEntries.length === 0) {
                return;
            } else if (dataEntries.length < 3) {
                console.warn("\n‚ö†Ô∏è Not enough data to load.");
                return;
            }

            // remove first element from entry
            dataEntries.shift();


            console.info(`üìâ Loaded ${dataEntries.length} data points`);


            // // ‚è© **Use `filter` to reduce the number of data points**
            // const filteredEntries = dataEntries.filter((_, index) => index % dataChartInterval === 0);
            //
            // // ‚è© **Use `map` to extract specific data fields**
            // timeDataTemp = filteredEntries.map(entry => entry.time);
            // positionDataTemp = filteredEntries.map(entry => entry.position);
            // forceDataTemp = Array(loadCellNum).fill().map((_, i) => filteredEntries.map(entry => entry.force[i]));

            const timeDataTemp = [];
            const positionDataTemp = [];
            const forceDataTemp = Array(loadCellNum).fill(0).map(() => []);
            const aggregatedDataBetweenStepsTemp = [];
            const photoDataTemp = [];

            aggregateData(dataEntries, dataChartInterval, timeDataTemp, positionDataTemp, forceDataTemp, photoDataTemp, aggregatedDataBetweenStepsTemp);


            const minTime = minND(timeDataTemp) || 0;
            const maxTime = maxND(timeDataTemp) || 1e-10;
            const timeRange = (maxTime - minTime) * 0.005;
            const minDist = minND(positionDataTemp) || 0;
            const maxDist = maxND(positionDataTemp) || 1e-10;
            const distRange = (maxDist - minDist) * 0.005;
            const forceMin = minND(forceDataTemp) || 0;
            const forceMax = maxND(forceDataTemp) || 1e-10;
            const forceRange = (forceMax - forceMin) * 0.005;


            // dataEntries?.forEach(entry => {
            //     if (isNum(entry.photoIndex)) {
            //         // markersTimeTemp.push(entry.time); // Add `time` value to markersTime list
            //         // markersDistTemp.push(entry.position); // Add `position` value to markersTime list
            // });


            timeData = timeDataTemp;
            positionData = positionDataTemp;
            forceData = forceDataTemp;
            photoData = photoDataTemp;

            liveUpdate = stateAtEnd;

            timeChart.setData([timeDataTemp, ...forceDataTemp, photoDataTemp]);
            positionChart.setData([positionDataTemp, ...forceDataTemp, photoDataTemp]);

            timeChart.setScale("x", {min: minTime - timeRange, max: maxTime + timeRange});
            positionChart.setScale("x", {min: minDist - distRange, max: maxDist + distRange});
            timeChart.setScale("y", {min: forceMin - forceRange, max: forceMax + forceRange});
            positionChart.setScale("y", {min: forceMin - forceRange, max: forceMax + forceRange});

            // // üîÑ Redraw graphs
            // timeChart.redraw();
            // positionChart.redraw();


            console.info("\n\t‚òëÔ∏è Graph data loaded successfully.");
        };
    }


    // Attach live update toggle to button
    UI.chartsLiveButton.addEventListener("click", async () => chartUpdate());


    // /////// uPlot Chart Initialization /////////

    function addMarker(uplotInstance, list, xValue) {
        list.push(xValue); // Add a marker to the list
        // uplotInstance.redraw(); // Redraw graph
    }

    function createChart(containerID, seriesLabels, title = "Graph", labelX = "", labelY = "") {
        // Get the container element
        let container = $$$(containerID);
        if (!container) {
            console.error(`‚ùå Error: container s ID "${containerID}" not found.`);
            return null;
        }


        // Get the container dimensions
        let width = container.clientWidth || 400; // Default width if the container is empty
        let height = container.clientHeight || 300; // Default height if the container is empty

        // Configurations for uPlot chart
        const options = {
            title: title,
            width: width,
            height: height,
            axes: [
                {
                    label: labelX, // Axis label X
                },
                {
                    label: labelY, // Axis label Y
                }
            ],
            scales: {
                x: {time: false},
                y: {auto: true}
            },
            series: [...seriesLabels.map((label, index) => ({
                label: label,
                stroke: index === 0 ? "000000" : ["#FF2730", "#2196F3", "#4CAF50"][index - 1] || "#555555"
            })),
                {
                    label: "Photo",          // pou≈æijeme pro nalezen√≠ ≈ô√°dku legendy a skryjeme ho n√≠≈æe
                    // points-only: nejefektivnƒõj≈°√≠ je vypnout cesty (≈æ√°dn√° ƒç√°ra)
                    // points-only: nejefektivnƒõj≈°√≠ je vypnout cesty (≈æ√°dn√° ƒç√°ra)
                    paths: () => null,      // ofiko doporuƒçen√≠ pro ‚Äûpouze body‚Äú
                    points: {show: true, size: 8, width: 2.5}, // velikost a tlou≈°≈•ka bod≈Ø
                    stroke: "#FF8C00", fill: "#FF8C00", // u bod≈Ø staƒç√≠ points.show
                },],

            // hooks: {
            //     init: [
            //         (u) => {
            //             // najdi ≈ô√°dek s textem "Photo" a schovej ho
            //             u.root.querySelectorAll(".u-legend tr").forEach((tr) => {
            //                 if (tr.textContent?.trim().startsWith("Photo")) tr.style.display = "none";
            //             });
            //         },
            //     ],
            // },

        };

        // Create the uPlot chart
        let chart = new uPlot(options, [[], ...seriesLabels.slice(1).map(() => [])], container);

        // Dynamic resizing of the chart
        window.addEventListener("resize", async () => onResize(container, chart));

        // Initial resize to fit container
        onResize(container, chart);

        return chart;
    }

    function onResize(container, chart) {
        const newWidth = container.clientWidth || 400;
        const newHeight = container.clientHeight || 300;
        chart.setSize({width: newWidth, height: newHeight});
        UI.chartsContainer.style.height = getChartHeightIncludingLegend() + "px";
    }

    function getChartHeightIncludingLegend() {
        let charts = $$(".uplot");
        let maxHeight = 0;

        charts?.forEach(chart => {
            maxHeight = Math.max(maxHeight, chart.clientHeight);
        });

        return maxHeight;

    }


    // /////// Chart Update Function /////////

    /**
     * Updates the charts with new data.
     */

    function updateChart(data) {

        // Check if the data is valid
        if (!isNum(data.time) || !isNum(data.position) || data.force.every(x => !isNum(x))) { //  || data.force.some(!isNum)
            return;
        }

        // Add new data points
        timeData.push(data.time);
        positionData.push(data.position);
        data.force?.forEach((value, index) => forceData[index].push(value));


        // Maintain max data points
        if (timeData.length > maxDataPoints) {
            timeData.shift();
            positionData.shift();
            forceData?.forEach(dataset => dataset.shift());
        }

        // Update charts
        timeChart.setData([timeData, ...forceData, photoData]);
        positionChart.setData([positionData, ...forceData, photoData]);

    }

    async function refreshCharts() {
        await loadDataFromDBToChart(liveUpdate);  // Load data from DB to charts will wait for the data to be loaded
        timeChart.redraw();
        positionChart.redraw();
        console.info("üîÅ Charts refreshed.");
    }

    async function clearCharts() {

        // Reset axis X and Y
        await timeChart.setScale("x", {min: 0, max: 1e-10});
        await positionChart.setScale("x", {min: 0, max: 1e-10});

        // timeData = [];
        // positionData = [];
        // photoData = [];
        // forceData?.forEach((_) => []);

        await timeChart.setData(Array(loadCellNum + 1 + 1).fill(0).map(() => []));
        await positionChart.setData(Array(loadCellNum + 1 + 1).fill(0).map(() => []));

        await timeChart.setScale("y", {min: 0, max: 1e-10});
        await positionChart.setScale("y", {min: 0, max: 1e-10});


        console.info("üßπ Charts cleared!");
    }


    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////


    async function handleError(error, context = "Unknown") {
        // üìå Connection Errors Handling Identifiers
        const connectionErrors = [
            "NetworkError",
            "The device was lost.",
            "The port is no longer available."
        ];

        if (connectionErrors.some(msg => error.message.includes(msg)) || error.name === "NetworkError") {

            if (isExperimentRunning) {
                await endMeasuring(0, 'connection lost', "‚ùå Experiment stopped due to connection loss.", "Connection lost! Stopping experiment...");
                UI.experimentStageLabel.textContent = `Error`;
                document.documentElement.style.setProperty('--progressColor', 'var(--progressError-color)');
            }

            console.warn("\n‚ö†Ô∏è Connection lost! Attempting to reconnect...");
            isConnected = false;
            await attemptReconnect();
        } else {
            stopMachine();
            console.error(`‚ùå ${context} error:`, error);
            await logMessage(`‚ùå ${context} error: ${error}`);
        }

    }


    // -------------------------
    // Fronta ƒçekaj√≠c√≠ch po≈æadavk≈Ø
    // -------------------------
    /** @typedef {{
     *   id: number,
     *   regex: RegExp,
     *   valueIndex: number,
     *   resolve: (v:any)=>void,
     *   timeoutId: ReturnType<typeof setTimeout>
     * }} PendingReq
     */

    let _reqId = 0;
    const _pending = /** @type {PendingReq[]} */([]);

    /** Pomocn√°: odstran√≠ po≈æadavek z fronty podle id */
    function _removePending(id) {
        const idx = _pending.findIndex(p => p.id === id);
        if (idx !== -1) _pending.splice(idx, 1);
    }

    /** P≈ôid√° po≈æadavek do fronty a nastav√≠ timeout */
    function _enqueue(format, valueIndex, timeoutMs) {
        const regex = (format instanceof RegExp)
            // zajist√≠me "global" a "m" pro p≈ô√≠pad v√≠ce ≈ô√°dk≈Ø; zachov√°me i p≈Øvodn√≠ flagy:
            ? new RegExp(format.source, new Set((format.flags + "gm").split(""))
                .size ? Array.from(new Set((format.flags + "gm").split(""))).join("") : "gm")
            : new RegExp(String(format), "gm");

        const id = ++_reqId;

        let resolveRef;
        const p = new Promise((resolve) => {
            resolveRef = resolve;
        });

        // timeout: po vypr≈°en√≠ odstran√≠me z fronty a resolve(null)
        const timeoutId = setTimeout(() => {
            _removePending(id);
            resolveRef(null);
        }, Math.max(0, timeoutMs || 0));

        /** @type {PendingReq} */
        const entry = {id, regex, valueIndex, resolve: resolveRef, timeoutId};
        _pending.push(entry);

        return {id, promise: p};
    }

    /** Zpracuje jednu p≈ô√≠choz√≠ zpr√°vu: zkus√≠ ji sp√°rovat s frontou.
     *  Vrac√≠ true, pokud zpr√°va byla spot≈ôebovan√° (sp√°rovala se s nƒõkter√Ωm po≈æadavkem).
     */
    function _tryMatchAndResolve(msg) {
        // Pozn√°mka: zpr√°vu m√°me porovnat ‚Äûse v≈°√≠m ve frontƒõ‚Äú, ale jakmile JEDEN souhlas√≠,
        // zpr√°vu u≈æ d√°l neporovn√°v√°me.
        for (let i = 0; i < _pending.length; i++) {
            const req = _pending[i];

            // reset lastIndex kv≈Øli flagu "g"
            req.regex.lastIndex = 0;
            const match = req.regex.exec(msg);
            if (match) {
                clearTimeout(req.timeoutId);
                _pending.splice(i, 1); // odstranit z fronty
                const val = match[req.valueIndex];
                req.resolve(val);
                return true; // zpr√°vu u≈æ d√°l neporovn√°v√°me
            }
        }
        return false;
    }


    function cancelAllPending() {
        while (_pending.length) {
            const p = _pending.pop();
            clearTimeout(p.timeoutId);
            p.resolve(null);
        }
    }


    function waitForFormat(format, valueIndex, timeout = 5000) {
        const {promise} = _enqueue(format, valueIndex, timeout);
        return promise;
    }


    /**
     * Ode≈°le p≈ô√≠kaz a ƒçek√° na hodnotu vyta≈æenou z prvn√≠ zpr√°vy,
     * kter√° odpov√≠ dan√©mu form√°tu (regex). Pokud nic nep≈ôijde
     * do `timeout` ms, vr√°t√≠ `null`.
     *
     * @param {string} command - co poslat ven
     * @param {RegExp|string} format - regex nebo string pattern
     * @param {number} valueIndex - index z match pole (0 = cel√Ω match, 1.. = skupiny)
     * @param {number} [timeout=5000]
     * @returns {Promise<any|null>}
     */
    async function getPromisedValue(command, format, valueIndex, timeout = 5000) {
        // 1) First, set up the expected data format and create a promise to wait for it
        const p = waitForFormat(format, valueIndex, timeout);

        // 2) Then, send the command to request the data
        await sendCommandGeneral(command);

        // 3)
        return p;
    }


    function setExpectedDataFormat(regexPattern, callback) {
        waitingForDataFormat = true;
        dataFormat = new RegExp(regexPattern);
        onDataMatch = callback;
        console.info(`üîç Waiting for data in format: ${regexPattern}`);
    }


    // === Firmware version ===
    async function getFirmwareVersion(timeOut = 1000) {
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet firmware version...");
            const version = `${await getPromisedValue("MISC GET LIBINFO", /Firmware:\s*([^,]+)/, 1, timeOut)}`;

            if (!version) {
                throw new Error("Version is empty.", version);
            }
            console.info(`\tüì¶ Firmware version: ${version}`);
            return version;
        } catch (error) {
            console.error(error.message);
            throw new Error(`Firmware version not received. ${error}`);
        }
    }

    // === Measure Position ===
    async function measurePosition(timeOut = 2000) {
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet position...");
            const position = toNumber(await getPromisedValue("MC GET POS", /^Motor position:\s(-?\d+(\.\d+)?)\smm$/, 1, timeOut), true);
            // const position = parseFloat(await getPromisedValue("MC GET POS", /S0:([+-]?\d+\.\d{4})/, 1, timeOut));

            if (!isNum(position)) {
                throw new Error("Position is not a number.", position);
            }
            console.info(`\tüìå Current position: ${position} mm`);
            return roundDecimalFast(position, precisionPosition);
        } catch (error) {
            console.error(error.message);
            throw new Error("Position not received.", error);
        }
    }

    // === Measure Position ===
    async function readLoadcell(loadcellID, timeOut = 2000) {
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        const ldID = toInteger(loadcellID);
        try {
            if (debugging) logMessage(` üì¢\tGet Loadcell ${ldID} reading...`);

            if (ldID < 0 || ldID > (loadCellNum - 1)) throw new Error(`Loadcell ID must be between 0 and ${loadCellNum - 1}: ${ldID} given.`);

            const force = toNumber(await getPromisedValue(`LC READ LOADCELL[${ldID}]`, /.../, 1, timeOut), true);

            if (!isNum(force)) {
                throw new Error("Load is not a number.", force);
            }
            return roundDecimalFast(force, precisionForce);
        } catch (error) {
            console.error(error.message);
            throw new Error(`Load on Loadcell${ldID} not received.`, error);
        }
    }

    async function isLoadcellsPresent(timeOut = 2000) {
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tCheck Loadcells presence...");

            const isPresent = [];
            for (let i = 0; i < 3; i++) {
                const force = await getPromisedValue(`LC READ LOADCELL[${i}]`, /.../, 1, timeOut);

                if (!(!isVal(force) || force === '0' || force === '-0')) {
                    isPresent.push(true);
                    continue;
                }

                isPresent.push(false);
            }
            return isPresent;
        } catch (error) {
            console.error(error.message);
            throw new Error(`Load on Loadcells not received.`, error);
        }
    }

    // === Get Calibration Status ===
    let calibrationStatus = false;

    async function getCalibrationStatus(timeOut = 2000) { // 30000
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet calibration status...");

            return await getPromisedValue("MC GET ISCALIBRATED", /^Motors calibrated:\s(Yes|No)$/, 1, timeOut) === "Yes";
            // return await getPromisedValue("MC GET ISCALIBRATED", /S0:([01])/, 1, timeOut) === "1";
        } catch (error) {
            console.error(error.message);
            throw new Error("Calibration status not received.", error);
        }
    }


    async function getSpeed(timeOut = 2000) { // 30000
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet speed...");

            const speed = toNumber(await getPromisedValue("MC GET SPEED", /Motor speed:\s(-?\d+(\.\d+)?)\smm\/s/, 1, timeOut), true);
            // const speed = parseFloat(await getPromisedValue("MC GET SPEED", /S0:([+-]?\d+\.\d{4})/, 1, timeOut));
            if (!isNum(speed)) {
                throw new Error("Speed is not a number.", speed);
            }
            console.info(`\tüöÖ Current speed: ${speed} mm/s`);

            return roundDecimalFast(speed, precisionSpeed);
        } catch (error) {
            console.error(error.message);
            throw new Error("Speed not received.", error);
        }
    }


    async function getAcceleration(timeOut = 2000) { // 30000
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet acceleration...");

            const acceleration = toNumber(await getPromisedValue("MC GET ACCEl", /Motor acceleration:\s(-?\d+(\.\d+)?)\smm\/s\^2/, 1, timeOut), true);
            // const acceleration = parseFloat(await getPromisedValue("MC GET ACCEl", /S0:([+-]?\d+\.\d{4})/, 1, timeOut));
            if (!isNum(acceleration)) {
                throw new Error("Acceleration is not a number.", acceleration);
            }
            console.info(`\tüöù Current acceleration: ${acceleration} mm/s¬≤`);

            return roundDecimalFast(acceleration, precisionAcceleration);
        } catch (error) {
            console.error(error.message);
            throw new Error("Acceleration not received.", error);
        }
    }

    async function isMoving(timeOut = 100) {
        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }
        try {
            if (debugging) logMessage(" üì¢\tGet moving status...");

            return await getPromisedValue("MC GET RUNNING", /Motor running:\s[01]/, 1, timeOut) === "1";
            // return await getPromisedValue("MC GET RUNNING", /S0:([01])/, 1, timeOut) === "1";
        } catch (error) {
            console.error(error.message);
            throw new Error("Moving status not received.", error);
        }
    }

    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////

    // === Experiment Data Saving ===
    $$$("startExperiment")?.addEventListener('click', async () => startExperiment());

    $$$("stopMachine")?.addEventListener('click', async () => stopMachine('user'));

    $$$("inputLoadLimitDropPercent")?.addEventListener('change', async (event) => {
        // forceLimitDropPercent = parseFloat(event.target.value) / 100;
    });
    $$$("inputLoadLimitDropValue")?.addEventListener('change', async (event) => {
        // forceLimitDropValue = parseFloat(event.target.value);
    });

    // #TODO do better disabling of elements //////////////////////////////////////////////////
    $$('.prohibited')?.forEach(element => {
        element.readOnly = true;
        element.tabIndex = -1;

        element.addEventListener("selectstart", async (e) => e.preventDefault());
        element.addEventListener("mousedown", async (e) => e.preventDefault());
        element.addEventListener("keydown", async (e) => e.preventDefault());
    })

    $$$("inputTakePhotos")?.addEventListener('change', async (event) => {
        if (event.target.checked) {
            // disable photo interval input
            $$$("inputPhotoInterval")?.classList.remove("disabled");
            $$$("inputPhotoInterval").readOnly = false;
            $$$("inputPhotoInterval").tabIndex = 1;

            // disable photo interval input label
            $(`label[for='${"inputPhotoInterval"}']`)?.classList.remove("disabled");
        } else {
            // disable photo interval input
            $$$("inputPhotoInterval")?.classList.add("disabled");
            $$$("inputPhotoInterval").readOnly = true;
            $$$("inputPhotoInterval").tabIndex = -1;
            // disable photo interval input label
            $(`label[for='${"inputPhotoInterval"}']`)?.classList.add("disabled");
        }
    });

    function calculateStep(frequencyMicroseconds, updateIntervalMs = 200, minimum = 1) {
        return Math.max(1, minimum, Math.ceil((updateIntervalMs * 1000) / frequencyMicroseconds));
    }

    function computeMotionTime(distance, speed, acceleration) {
        const t_accel = speed / acceleration;               // time acceleration
        const s_accel = 0.5 * acceleration * t_accel ** 2;  // distance during acceleration

        distance = Math.abs(distance);

        if (2 * s_accel >= distance) {
            // üö© Triangular profile ‚Äì only acceleration and deceleration
            return 2 * Math.sqrt(distance / acceleration);
        } else {
            // üö© Trapezoidal profile ‚Äì acceleration, constant speed, and deceleration
            const s_cruise = distance - 2 * s_accel;
            const t_cruise = s_cruise / speed;
            return 2 * t_accel + t_cruise;
        }
    }


    function stopMachine(type = 'machine') {
        if (isConnected) {
            setAcceleration(200); // Set acceleration to 200 mm/s¬≤
            sendCommandGeneral("MC STOP"); // Stop movement
            sendCommandGeneral("DSLR STOP CYCLIC"); // Stop DSLR cyclic
            sendCommandGeneral("DATAC 0"); // Stop data collection
        }

        switch (type) {
            case 'user':
                if (isExperimentRunning) {
                    document.documentElement.style.setProperty('--progressColor', 'var(--progressError-color)');
                    UI.experimentStageLabel.textContent = `Stopped`;
                    endedBy = "user stop";
                }
                break;
            case 'machine':
                if (isExperimentRunning) {
                    document.documentElement.style.setProperty('--progressColor', 'var(--progressWarning-color)');
                    UI.experimentStageLabel.textContent = `Stopped`;
                    endedBy = "machine stop";
                }
                break;
            case 'error':
                if (isExperimentRunning) {
                    document.documentElement.style.setProperty('--progressColor', 'var(--progressError-color)');
                    UI.experimentStageLabel.textContent = `Stopped`;
                    endedBy = "error";
                }
                break;
            case 'alarm':
                if (isExperimentRunning) {
                    document.documentElement.style.setProperty('--progressColor', 'var(--progressError-color)');
                    UI.experimentStageLabel.textContent = `Stopped`;
                    endedBy = "machine alarm";
                }
                break;
            default:
                if (isExperimentRunning) {
                    document.documentElement.style.setProperty('--progressColor', 'var(--progressError-color)');
                    UI.experimentStageLabel.textContent = `Stopped`;
                    endedBy = "unknown";
                }
        }

        isExperimentRunning = false;
        activeWatchDog = false;

        if (isConnected) endedMoving();
    }


    async function softStopMachine() {
        setAcceleration(200); // Set acceleration to 200 mm/s¬≤

        await rampSpeed(currentSpeed, 0.05);

        await sendCommandUser("MC STOP");

        if (currentSpeed) await sendCommandGeneral(`MC SET SPEEDMM ${currentSpeed}`);
        if (currentAcceleration) await sendCommandGeneral(`MC SET ACCEL ${currentAcceleration}`);

        activeWatchDog = false;

        if (isConnected) endedMoving();
    }

    /**
     * Ramping rychlosti s pevn√Ωmi rozestupy 20ms, max. ~300ms celkem.
     * @param {number} currentSpeed - aktu√°ln√≠ rychlost (mm/s)
     * @param {(cmd:string)=>any|Promise<any>} sendCommand - funkce pro odesl√°n√≠ p≈ô√≠kazu
     * @param {number} targetSpeed - c√≠lov√° rychlost (mm/s), default 0.05
     */
    async function rampSpeed(currentSpeed, targetSpeed = 0.05) {
        const INTERVAL_MS = 20;
        const MAX_INTERVALS = 15; // 15 * 20ms = 300ms mezi 1. a posledn√≠m sendem
        const PREFERRED_STEP = 1;   // mm/s
        const MIN_STEP = 0.5;       // mm/s

        const delta = targetSpeed - currentSpeed;
        const dir = Math.sign(delta);
        const absDelta = Math.abs(delta);

        // Pokud u≈æ jsme na c√≠li (nebo velmi bl√≠zko), po≈°li rovnou p≈ôesn√Ω p≈ô√≠kaz.
        if (absDelta < 1e-9) {
            return sendCommandSilent(`MC SET SPEEDMM ${targetSpeed.toFixed(3)}`);
        }

        // Zvol krok: preferuj 1 mm/s; pokud by to nestihlo do 300 ms, krok zvƒõt≈°i.
        // Max. poƒçet SEND≈Ø je 16 (15 interval≈Ø + fin√°ln√≠ p≈ô√≠kaz).
        let step = PREFERRED_STEP;
        const neededWithPreferred = Math.ceil(absDelta / step);
        // Poƒçet interval≈Ø je (poƒçet_send≈Ø - 1). Tj. max 16 send≈Ø => 15 interval≈Ø.
        if (neededWithPreferred - 1 > MAX_INTERVALS) {
            step = Math.max(MIN_STEP, absDelta / MAX_INTERVALS); // m≈Ø≈æe b√Ωt >1, kdy≈æ je pot≈ôeba
        }

        // Kolik mezikrok≈Ø stihneme s vybran√Ωm krokem v r√°mci 15 interval≈Ø
        let intermediateSteps = Math.min(Math.floor(absDelta / step), MAX_INTERVALS);

        // Pro jistotu zaokrouhluj v√Ωstup na 3 desetinn√° m√≠sta (0.001 mm/s)
        const fmt = (v) => Number(v).toFixed(3);

        let curr = currentSpeed;

        // Pos√≠lej mezikroky po 20 ms (ka≈æd√Ω krok m√° velikost >= 0.5 mm/s)
        for (let i = 0; i < intermediateSteps; i++) {
            curr += dir * step;

            // O≈°et≈ôi p≈ôest≈ôelen√≠
            if ((dir > 0 && curr > targetSpeed) || (dir < 0 && curr < targetSpeed)) {
                curr = targetSpeed;
            }

            await sleep(INTERVAL_MS);
            await sendCommandSilent(`MC SET SPEEDMM ${fmt(curr)}`);

            // Kdy≈æ jsme u≈æ na c√≠li, skonƒçi d≈ô√≠v
            if (Math.abs(curr - targetSpeed) < 1e-9) {
                return;
            }
        }

        // Pokud je≈°tƒõ nejsme p≈ôesnƒõ na c√≠li, po≈°li fin√°ln√≠ p≈ôesn√Ω p≈ô√≠kaz.
        // Tohle je posledn√≠ SEND (celkem max 16), opƒõt s odstupem 20ms od p≈ôedchoz√≠ho.
        if (Math.abs(curr - targetSpeed) >= 1e-9) {
            await sleep(INTERVAL_MS);
            await sendCommandGeneral(`MC SET SPEEDMM ${fmt(targetSpeed)}`);
        }
    }


    function analyzeForces(fields) {
        return fields.map(arr => {
            let found = false;
            let min = Infinity, max = -Infinity;

            for (const v of arr) {
                if (isNum(v)) {
                    found = true;
                    if (v < min) min = v;
                    if (v > max) max = v;
                }
            }

            if (!found) return {min: NaN, max: NaN, allInvalid: true};
            if (Math.abs(min) === 0 && Math.abs(max) === 0) return {min: NaN, max: NaN, allInvalid: true};
            if (min === max) {
                logMessage(`‚ö†Ô∏è Warning: min and max forces are equal: ${min}, ${max}`);
                console.warn("‚ö†Ô∏è Warning: min and max forces are equal:", min, max);
                return {min: NaN, max: NaN, allInvalid: true};
            }
            return {min, max, allInvalid: false};
        });
    }

    function hasRequiredParsedKeys(experimentEndLimits, parsedData) {
        if (!isObj(experimentEndLimits) || !isObj(parsedData)) return false;

        // kl√≠ƒçe, kter√© opravdu vy≈æadujeme (hodnota nen√≠ null ani NaN)
        const required = Object.entries(experimentEndLimits).filter(([, v]) => !isNum(v));

        // mus√≠ existovat aspo≈à jeden po≈æadovan√Ω kl√≠ƒç
        if (required.length === 0) return false;

        // v≈°echny po≈æadovan√© kl√≠ƒçe mus√≠ b√Ωt v parsedData
        return required.every(([k]) => Object.prototype.hasOwnProperty.call(parsedData, k));
    }


    let speedForward_mmps = 0;
    let currentSpeed = null;
    let currentAcceleration = null;
    let takePhotos = false;
    let dataInterval_us = null;
    let initialForceLim_N = null;
    let experimentDoubleSpeed = false;
    let stoppingForceLimit = null;
    let holdForceTimeMs = null;

    let presentLoadcells = [];

    async function startExperiment() {

        if (!isConnected) {
            console.warn("\n‚ö†Ô∏è ESP is not connected!");
            await logMessage("‚ö†Ô∏è ESP is not connected!");
            return;
        }

        if (isExperimentRunning) {
            console.warn("\n‚ö†Ô∏è Experiment is already running.");
            await logMessage("‚ö†Ô∏è Experiment is already running.");
            return;
        }

        if (machineOccupation) {
            console.warn("\n‚ö†Ô∏è Machine is currently moving. Please wait until it stops.");
            await logMessage("‚ö†Ô∏è Machine is currently moving. Please wait until it stops.");
            return;
        }


        // === System Limits ===
        const minDistance = 5e-3;
        const minFSpeed = 0.025;
        const maxFSpeed = 25;
        const minPhotoInt = 5e-6;
        const minLoadCap = 5e-4;
        const minLoadOut = 5e-4;


        try {
            UI.experimentStageLabel.textContent = `Starting`;

            await lockMovement();
            await beganMoving()

            await console.clear();
            await console.log("\n\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NEW EXPERIMENT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n\n");
            await console.groupCollapsed("New Experiment Section");

            // === Retrieve Parameters from Inputs ===
            const distance_mm = getInputDefAbsFlt($$$("inputDistance").value, NaN);
            const experimentType = $$$("experimentTypeDropdown").value.toLowerCase();
            displacementSignCorrection = experimentType.includes("down") ? 1 : -1;
            speedForward_mmps = getInputDefAbsFlt($$$("inputSpeedForward").value, NaN);
            // const speedBackward_mmps = parseFloat($$("inputSpeedBackward").value);
            dataInterval_us = Math.max(getInputDefAbsInt($$$("inputDataInterval").value, NaN), 100);
            const loadcellCapacity = getInputDefAbsInt($$$("inputLoadcellCapacity").value, NaN);
            const loadcellOutput = getInputDefAbsFlt($$$("inputLoadcellOutput").value, NaN);
            takePhotos = $$$("inputTakePhotos").checked;
            const photoInterval_ms = Math.round(getInputDefAbsFlt($$$("inputPhotoInterval").value, NaN) * 1000);
            forceLimitDropPercent = catchVal((toNumber($$$("inputLoadLimitDropPercent").value) / 100), Infinity);
            forceLimitDropValue = getInputDefAbsFlt($$$("inputLoadLimitDropValue").value, Infinity);


            // TODO: temporary disable loadcells
            const loadcellCapacities = Array(loadCellNum).fill(loadcellCapacity);
            const loadcellOutputs = Array(loadCellNum).fill(loadcellOutput);

            let initialSpeed_mmps = speedForward_mmps;
            initialForceLim_N = null;
            experimentDoubleSpeed = false;
            stoppingForceLimit = Number.POSITIVE_INFINITY;
            holdForceTimeMs = null;
            presentLoadcells = [];


            const suffixes = ["-inb", "-hbr"];
            if (suffixes.some(suf => experimentType.endsWith(suf))) {
                initialSpeed_mmps = Math.abs(parseFloat($$$("inputInitialSpeed").value));
                initialForceLim_N = Math.abs(parseFloat($$$("inputInitialForce").value));
                experimentDoubleSpeed = true;

                if (experimentType.endsWith("-hbr")) {
                    stoppingForceLimit = Math.abs(parseFloat($$$('inputStopForce').value));
                    holdForceTimeMs = Math.abs(parseFloat($$$('inputEndDelay').value)) * 1000;
                }
            }

            if (experimentType.includes("-pos-")) {
                experimentEndLimits = {position: distance_mm, force: null, time: null};  // The total distance to be moved; force and time limits are not used now
                expControl = 'position'; // Control the experiment by position
                console.info("\n\t\t‚û°Ô∏è Experiment type: Position controlled");
                await logMessage("\t\t‚û°Ô∏è Experiment type: Position controlled");
            } else {
                throw new Error("Unknown Experiment type error");
            }


            await sleep(5); // Stop for 5 ms

            if (expControl === 'position') {
                if (!isValidInput(distance_mm) || distance_mm < minDistance) {
                    console.warn(`\n‚ö†Ô∏è Distance must be greater than ${minDistance} mm.`);
                    await logMessage(`‚ö†Ô∏è Distance must be greater than ${minDistance} mm.`);
                    alert(`‚ö†Ô∏è Distance must be greater than ${minDistance} mm.`);
                    throw new Error("Distance error");
                }
            }

            if (!isNum(speedForward_mmps) || speedForward_mmps < minFSpeed) {
                console.warn(`\n‚ö†Ô∏è Speed must be greater than ${minFSpeed} mm.`);
                await logMessage(`‚ö†Ô∏è Speed must be greater than ${minFSpeed} mm.`);
                alert(`‚ö†Ô∏è Speed must be greater than ${minFSpeed} mm.`);
                throw new Error("Speed error");
            } else if (speedForward_mmps > maxFSpeed) {
                console.warn(`\n‚ö†Ô∏è Speed must be less than ${maxFSpeed} mm/s.`);
                await logMessage(`‚ö†Ô∏è Speed must be less than ${maxFSpeed} mm/s.`);
                alert(`‚ö†Ô∏è Speed must be less than ${maxFSpeed} mm/s.`);
                throw new Error("Speed error");
            }

            if (!isNum(dataInterval_us) || dataInterval_us < 1) {
                console.warn(`\n‚ö†Ô∏è Data interval must be greater than 1 ¬µs.`);
                await logMessage(`‚ö†Ô∏è Data interval must be greater than 1 ¬µs.`);
                alert(`‚ö†Ô∏è Data interval must be greater than 1 ¬µs.`);
                throw new Error("Data interval error");
            }

            if (!isArr(loadcellCapacities) || loadcellCapacities.some(cap => !isNum(cap) || cap < minLoadCap)) {
                console.warn(`\n‚ö†Ô∏è Loadcell capacity must be greater than ${minLoadCap} N.`);
                await logMessage(`‚ö†Ô∏è Loadcell capacity must be greater than ${minLoadCap} N.`);
                alert(`‚ö†Ô∏è Loadcell capacity must be greater than ${minLoadCap} N.`);
                throw new Error("Loadcell capacity error");
            } else if (!isArr(loadcellOutputs) || loadcellOutputs.some(out => !isNum(out) || out < minLoadOut)) {
                console.warn(`\n‚ö†Ô∏è Loadcell output must be greater than ${minLoadOut} mV/V.`);
                await logMessage(`‚ö†Ô∏è Loadcell output must be greater than ${minLoadOut} mV/V.`);
                alert(`‚ö†Ô∏è Loadcell output must be greater than ${minLoadOut} mV/V.`);
                throw new Error("Loadcell output error");
            }

            if (experimentType.endsWith("-hbr")) {
                if (!isValidInput(stoppingForceLimit)) {
                    console.warn(`\n‚ö†Ô∏è Stopping force must be greater than 0 N.`);
                    await logMessage(`‚ö†Ô∏è Stopping force must be greater than 0 N.`);
                    alert(`‚ö†Ô∏è Stopping force must be greater than 0 N.`);
                    throw new Error("Stopping force error");
                } else if (!isNum(holdForceTimeMs) || (holdForceTimeMs / 1000) < 0) {
                    console.warn(`\n‚ö†Ô∏è Hold force time must be equal or greater than 0 s.`);
                    await logMessage(`‚ö†Ô∏è Hold force time must be equal or greater than 0 s.`);
                    alert(`‚ö†Ô∏è Hold force time must be equal or greater than 0 s.`);
                    throw new Error("Hold force time error");
                }
            }

            if (experimentDoubleSpeed) {
                if (!isNum(initialSpeed_mmps) || initialSpeed_mmps < minFSpeed) {
                    console.warn(`\n‚ö†Ô∏è Initial speed must be greater than ${minFSpeed} mm/s.`);
                    await logMessage(`‚ö†Ô∏è Initial speed must be greater than ${minFSpeed} mm/s.`);
                    alert(`‚ö†Ô∏è Initial speed must be greater than ${minFSpeed} mm/s.`);
                    throw new Error("Initial speed error");
                } else if (initialSpeed_mmps > maxFSpeed) {
                    console.warn(`\n‚ö†Ô∏è Initial speed must be less than ${maxFSpeed} mm/s.`);
                    await logMessage(`‚ö†Ô∏è Initial speed must be less than ${maxFSpeed} mm/s.`);
                    alert(`‚ö†Ô∏è Initial speed must be less than ${maxFSpeed} mm/s.`);
                    throw new Error("Initial speed error");
                } else if (!isValidInput(initialForceLim_N)) {
                    console.warn(`\n‚ö†Ô∏è Initial force load must be greater than 0 N.`);
                    await logMessage(`‚ö†Ô∏è Initial force load must be greater than 0 N.`);
                    alert(`‚ö†Ô∏è Initial force load must be greater than 0 N.`);
                    throw new Error("Initial force load error");
                }
            }

            if (takePhotos) {
                if (!isNum(photoInterval_ms) || photoInterval_ms < minPhotoInt) {
                    console.warn(`\n‚ö†Ô∏è Photo interval must be greater than ${minPhotoInt * 1000} s.`);
                    await logMessage(`‚ö†Ô∏è Photo interval must be greater than ${minPhotoInt * 1000} s.`);
                    alert(`‚ö†Ô∏è Photo interval must be greater than ${minPhotoInt * 1000} s.`);
                    throw new Error("Photo interval error");
                }
                if (photoInterval_ms * 1000 < dataInterval_us) {
                    console.warn("\n‚ö†Ô∏è Photo interval must be bigger than data interval.");
                    await logMessage("‚ö†Ô∏è Photo interval must be bigger than data interval.");
                    await logMessage(`‚ùó Changing data interval from ${dataInterval_us} to ${photoInterval_ms * 1000 * 0.9} ¬µs ‚ùó`);
                    dataInterval_us = photoInterval_ms * 1000 * 0.9;
                    $$$("inputDataInterval").value = dataInterval_us;
                }
            }

            if (isEmptyStr(expControl)) throw new Error("Experiment control is not set.");
            if (experimentEndLimits[expControl] === undefined) throw new Error(`Experiment end limit for ${expControl} is not set.`);
            if (parsedData[expControl] === undefined) throw new Error(`Parsed data for ${expControl} is not available.`);
            if (!hasRequiredParsedKeys(experimentEndLimits, parsedData)) throw new Error("Experiment end limits are not properly set.");


            const settings = await collectExpSettings(".expInput", "Moira-exp-settings") || {};

            await sleep(5); // Stop for 5 ms

            // === Ensure Serial Reading is Running ===
            if (!isReadingSerial) {
                isReadingSerial = true;
                readSerial();
            }

            dataChartInterval = calculateStep(dataInterval_us, 150, 1);
            minimumConditionCount = calculateStep(dataInterval_us, 50, 3);

            await sleep(5); // Stop for 5 ms


            calibrationStatus = await getCalibrationStatus(2000);
            await sleep(5); // Stop for 5 ms
            if (!calibrationStatus) {
                // if (confirm("‚ö†Ô∏è Motors are not calibrated. Calibrate the motor?\n\nOK = Calibrate\tCancel = Not Calibrate")) {
                //     let confirmCalibrationCount = 0;
                //
                //     await logMessage("‚ö†Ô∏è Motors are not calibrated. Calibrating the motor...");
                //     console.warn("\n‚ö†Ô∏è Motors are not calibrated. Calibrating the motor...");
                //     await sendCommandGeneral('MC CALIBRATE');
                //     await sleep(5); // Stop for 5 ms
                //
                //
                //     while (!calibrationStatus) {
                //         await sleep(2500);
                //         calibrationStatus = await getCalibrationStatus(500);
                //
                //         // log time
                //         // console.info("üïí Time: ", new Date().toLocaleTimeString());
                //
                //         if (confirmCalibrationCount > 50) {
                //             await logMessage("‚ùå Calibration timeout reached. Please check the motor.\n\tMotors are not calibrated.");
                //             console.error("‚ùå Calibration timeout. Please check the motor.\n\tMotors are not calibrated.");
                //             await sleep(5); // Stop for 5 ms
                //         } else {
                //             confirmCalibrationCount++;
                //         }
                //
                //         if (!isSerial || !isConnected) {
                //             console.warn("\n‚ö†Ô∏è Serial connection lost during calibration.");
                //             await logMessage("‚ö†Ô∏è Serial connection lost during calibration.");
                //             throw new Error("Serial connection lost during calibration.");
                //         }
                //     }

                // console.info("üìê Machine is calibrated.");
                // await logMessage("üìê Machine is calibrated.\n\tüîÉ Please restart the experiment.");
                // alert("üìê Machine is calibrated.\n\tüîÉ Please restart the experiment.");
                // } else {
                await lockMovementExcept(UI.calibrateBtn);
                await logMessage("‚ùå Calibration is required to start the experiment.");
                console.error("‚ùå Calibration is required to start the experiment.");
                alert("‚ùå Calibration is required to start the experiment.");
                // }
                throw new Error("Calibration is required to start the experiment.");
            }

            await sleep(5); // Stop for 5 ms

            await clearDBLog();
            await clearCharts();

            if (!liveUpdate) await chartUpdate();

            await sleep(10); // Stop for 10 ms


            UI.loadingLogContainer.style.background = "black";


            await sleep(10); // Stop for 10 ms

            await logMessage(`\nüéØ Starting experiment ${takePhotos ? "with photos üì∏" : ""}`);
            await console.info("üß™ Starting experiment...");

            // === Progress Bar Setup ===
            document.documentElement.style.setProperty('--progressColor', 'var(--progressPrimary-color)');
            UI.experimentStageLabel.textContent = `Running`;
            UI.progressBar.value = 0;
            UI.progressLabel.textContent = `0%`;

            // === Experiment Parameters ===
            if (await $$$('inputClearCalculations').checked) await clearCalculations();


            // === Reset Variables ===
            startTime = null;
            maxForces = Array(loadCellNum).fill(null);
            // firstPhoto = 0;
            timeData = [];
            positionData = [];
            forceData = Array(loadCellNum).fill(0).map(() => []);
            measureForces = Array(loadCellNum).fill(0).map(() => []);
            meanForces = Array(loadCellNum).fill(0);
            photoData = [];

            await clearCharts();

            aggregatedDataBetweenSteps = [];
            dataCount = 0;
            zero_speed_counter = 0;
            over_limitForce_counter = 0;
            startPosition = 0;
            checkSpeed = true;
            endedBy = null;
            pendingDSLR = null;
            parsedData = {
                time: 0,
                position: 0,
                speed: 0,
                force: Array(loadCellNum).fill(0),
                photoIndex: takePhotos ? 0 : null // Store DSLR photo order
            };


            currentSpeed = (await getSpeed()) || 15;
            currentAcceleration = (await getAcceleration()) || 150;
            await sleep(5); // Stop for 5 ms


            // === LoadCell Configuration ===
            for (let i = 0; i < loadCellNum; i++) {
                await sendCommandGeneral(`LC SET CAP ${i} ${loadcellCapacities[i]}`);
                await sendCommandGeneral(`LC SET RO ${i} ${loadcellOutputs[i]}`);
            }

            // === Prepare Motor ===
            await sendCommandGeneral("MC STOP");
            await setSpeedAndAcceleration(initialSpeed_mmps, 200);


            // === Prepare Data Collection ===
            startPosition = await measurePosition();
            $$$("returnPositionExperimentBtn")?.classList.remove("disabled");
            $$$("returnPositionExperimentBtn").readOnly = false;
            $$$("returnPositionExperimentBtn").tabIndex = 1;
            $$$("returnPositionExperimentBtn").textContent = `‚Ü©Ô∏è Return to start position: ${startPosition} mm`;
            await sleep(5); // Stop for 5 ms


            if (takePhotos) {
                await sendCommandGeneral('DSLR RESET COUNTERS', 2);
                await sendCommandGeneral('DSLR SHOOT');
            }

            loadSignCorrections = Array(loadCellNum).fill(displacementSignCorrection * -1);
            for (let i = 0; i < loadCellNum; i++) {
                if (loadcellCapacities[i] <= 50) loadSignCorrections[i] *= -1; // Reverse direction if loadcell capacity is less than or equal to 50 N
            }
            const expInfoV = settings.version;
            let experimentKey = null;
            if (expInfoV === 1) {
                experimentKey = settings.inputs.experimentTypeDropdown.extra.essence;
            }
            const experimentLabel = expTypesLabels[experimentKey] || "";

            await addDataToLog({
                expSettings: settings,
                experimentName: $$$("experimentName").value.trim(),
                experimentLabel: experimentLabel.trim(),
                experimentCounter: $$$("experimentCount").value.trim(),
                experimentDescription: $$$("experimentDesc").value.trim(),
                experimentDate: (new Date().toLocaleString()).replaceAll(". ", "."),
                loadDirection: displacementSignCorrection,
                loadDistance: distance_mm,
                loadSpeed: speedForward_mmps,
                loadcellCapacity: loadcellCapacities,
                loadcellType: 'Unknown',
                appSoftWare: softwareVersion,
                machineFirmware: machineFirmware,
                endStatus: endedBy,
                positionProgress: positionProgress,
                precisions: {
                    time: precisionTime,
                    position: precisionPosition,
                    speed: precisionSpeed,
                    acceleration: precisionAcceleration,
                    force: precisionForce,
                },
                experimentLimits: experimentEndLimits,
                experimentControl: expControl,
            }, 0);


            await addDataToLog(parsedData);
            if (takePhotos) {
                photoData.push(0);
            }
            await updateChart(parsedData);

            UI.experimentStageLabel.textContent = `Tarring`;

            await sleep(5); // Stop for 5 ms


            await sendCommandGeneral('DATA SET INTERVAL 2000');

            // --- 1) Take measurements ---
            takeMeasurements = true;
            await sendCommandGeneral("DATAC 1");

            // Take measurements for 1.5 second
            await sleep(1500); // Wait

            takeMeasurements = false;
            await sendCommandGeneral("DATAC 0");

            // --- 2) Mean forces ---
            meanForces = measureForces.map(force => roundDecimalFast(force.reduce((a, b) => a + b, 0) / force.length, 2));

            // --- 3) Analysis ---
            const forceAnalysis = await analyzeForces(measureForces);
            console.info("Force analysis:");
            console.table(forceAnalysis);

            // --- 4) Valid fields ---
            const validFields = await forceAnalysis.filter(r => !r.allInvalid);

            // indexes of valid fields => presentLoadcells
            presentLoadcells = forceAnalysis.flatMap((r, i) => r.allInvalid ? [] : i);


            await sleep(5);

            // --- 5) Check for errors ---
            // If more one force is not eaqule to zero, than Stop and Alert
            if (!experimentType.endsWith("-basic")) {
                if (validFields.length > 1) {
                    console.warn("\n‚ö†Ô∏è Multiple loadcells are connected.");
                    await logMessage("‚ö†Ô∏è Multiple loadcells are connected. Please check the loadcell connections and connect only one loadcell.");
                    alert("‚ö†Ô∏è Multiple loadcells are connected. Please check the loadcell connections and connect only one loadcell.");
                    throw new Error("Multiple loadcells connected");

                } else if (validFields.length === 0) {
                    console.warn("\n‚ö†Ô∏è No loadcell is connected.");
                    await logMessage("‚ö†Ô∏è No loadcell is connected. Please check the loadcell connection and try again.");
                    alert("‚ö†Ô∏è No loadcell is connected. Please check the loadcell connection and try again.");
                    throw new Error("No loadcell connected");
                }
            }

            const setChart = (chart) => chart ? forceAnalysis?.forEach((r, i) => chart.setSeries((i + 1), {show: !r?.allInvalid})) : null;
            setChart(timeChart);
            setChart(positionChart);

            // --- 6) Valid dispersion ---
            const diffs = validFields.flatMap(({
                                                   min, max
                                               }) => (isNum(min) && isNum(max)) ? [max - min] : []);
            console.info("Valid dispersions:", diffs);

            // --- 7) Error rates ---
            measurementErrRate = await roundDecimalFast(await diffs.reduce((a, b) => a + b, 0) / diffs.length, precisionForce);
            console.info("Measurement error rate:", measurementErrRate, "N");

            loadcellErrRate = await (loadcellCapacity * 9.81) / 2000; // 0.05% of the capacity
            console.info("Loadcell error rate:", loadcellErrRate, "N");

            // --- 8) Final error rate ---
            const alpha = 0.65; // Weighting factor between measurement and loadcell error rates
            totalErrRate = alpha * measurementErrRate + (1 - alpha) * loadcellErrRate;
            console.info("Final error rate:", totalErrRate, "N");

            // --- 9) Clear force fields ---
            measureForces = Array(loadCellNum).fill(0).map(() => []);

            await sleep(5); // Stop for 5 ms


            // ==================================
            // === Reset Experiment Variables ===

            positionProgress = 0
            startTime = null;
            isExperimentRunning = true;
            endMeasurement = false;
            clearTimeout(endMeasurementCounter)
            endMeasurementCounter = null;

            await sleep(10); // Stop for 10 ms

            UIupdate();


            await sleep(5); // Stop for 5 ms

            if (experimentDoubleSpeed) UI.experimentStageLabel.textContent = `Initial`;
            else UI.experimentStageLabel.textContent = `Loading`;

            await sleep(10); // Stop for 10 ms

            // ==================================
            // ==================================


            // === Enable Data Streaming and DSLR Shooting ===
            await sendCommandGeneral(`DATA SET INTERVAL ${dataInterval_us}`, 5);
            await sendCommandGeneral("DATAC 1");
            if (takePhotos) await sendCommandGeneral(`DSLR START CYCLIC ${photoInterval_ms}`);

            // === Move Forward ===
            await console.info("‚û°Ô∏è Moving forward...");
            await sendCommandGeneral(`MC MOVEBY USER ${distance_mm * displacementSignCorrection}`);


            // === Data Collection Loop ===
            while (isExperimentRunning) {
                await sleep(1_000); // Prevents excessive CPU usage
            }


            isExperimentRunning = false;

            // === Stop Data Streaming and DSLR Shooting ===
            await sendCommandGeneral('MC STOP');
            await sendCommandGeneral('DSLR STOP CYCLIC');
            await sendCommandGeneral('DATAC 0');

            await logMessage("üé¨ Measurements stopped.");
            await console.info("üé¨ Measurements stopped.");


            await sleep(10); // Stop for 10 ms


            if (experimentType.endsWith("-inb")) {
                // // === Move Further ===
                // // TODO: Make sure, that it will not break sample (window to user to accept)
                // if (UI.autoReturnPosition.checked) {
                //     await sleep(2000); // Stop for 2 s
                //
                //     let endPosition = await measurePosition();
                //
                //     const shift = Math.abs(100);
                //
                //     console.info(`‚û°Ô∏è Moving further to ${endPosition - shift} mm...`);
                //
                //     await sendCommandGeneral(`MC MOVEBY USER -${shift}`);
                //     await sleep(((computeMotionTime(shift, returningSpeed, returningAcceleration) * 1000) + 500)); // Wait
                //
                //     endPosition = await measurePosition();
                //
                //     console.info(`üö© Reached position: ${endPosition} mm`);
                // }
            } else {
                // === Move Back ===
                if (UI.autoReturnPosition.checked) {
                    UI.experimentStageLabel.textContent = `Returning`;
                    await moveToOriginalPosition();
                }
            }

            machineOccupation = false;

            // === Save Data ===
            if ($$$('inputAutoSave').checked) {
                UI.experimentStageLabel.textContent = `Saving`;
                await console.info("üíæ Saving data...");
                await saveCSV();
            }

            UI.experimentStageLabel.textContent = `Finalizing`;

            await sleep(5);

            await console.info("\n‚òëÔ∏è Experiment finished.");
            await showNotification("Experiment Finished", "The experiment has been completed successfully.");

        } catch (error) {
            await handleError(error, "Experiment");
            document.documentElement.style.setProperty('--progressColor', 'var(--progressError-color)');
            UI.experimentStageLabel.textContent = `Error`;
            endedBy = 'error';
            await alert(`Experiment Finished\n     ‚ùå Experiment failed. Please check the logs and machine.\n\n     Error:${error.message || error}`);

        } finally {
            await endMeasuring(0, null, '', '', '', '');

            await sleep(10);

            clearTimeout(dbFlushTimer);
            dbFlushTimer = null;
            await flushDB();
            await recomputeAll();
            if (endedBy != null) await updateLogById(0, {endStatus: endedBy, positionProgress: positionProgress});
            if (isConnected) endedMoving();    // unlock UI and watchdog
            document.title = initialTitle;

            UI.experimentStageLabel.textContent = `Idle`;
            await console.info("‚úÖ Experiment completed.");

            await console.groupEnd();

        }
    }


    // Function Clear `localStorage`
    function clearLocalStorage() {
        setSerialSignals(serialPort, true, true);


        disconnectSerial();

        sleep(200); // Wait (200 ms)

        localStorage.removeItem(storageKey); // Remove the saved data
        console.info("LocalStorage cleared.");

        window.location.reload();
    }


    let notificationsAllowed = false;

    function showNotification(title = "Notification", message = "This is a notification.") {
        if (!("Notification" in window)) {
            alert("Your browser does not support notifications.");
            return;
        }

        if (notificationsAllowed) {
            // Show notification immediately
            new Notification(title, {body: message});
        } else {
            // Request permission if not yet granted
            Notification.requestPermission().then(permission => {
                if (permission === "granted") {
                    notificationsAllowed = true;
                    new Notification(title, {body: message});
                } else {
                    alert("Notifications were not allowed.");
                }
            });
        }
    }

    (function ensureBlinkStyles() {
        if (document.getElementById('blink-border-style')) return;
        const style = document.createElement('style');
        style.id = 'blink-border-style';
        style.textContent = `
    .blink-border-on {
      border-color: orange !important;
      background-color: Moccasin !important;
      /* border-width: 3px !important; */
      /* volitelnƒõ: transition: none !important;  // aby neprobƒõhly CSS p≈ôechody */
    }
  `;
        document.head.appendChild(style);
    })();

    // Glob√°ln√≠ (nebo modulov√°) mapa bƒõ≈æ√≠c√≠ch blik√°n√≠ pro konkr√©tn√≠ elementy
    const _blinkLocks = new WeakMap();

    /**
     * Kr√°tk√© "bliknut√≠" r√°meƒçku libovoln√©ho elementu.
     * - target: Element nebo CSS selektor
     * - options:
     *   - color           (default: 'orange')
     *   - backgroundOn    (default: 'Moccasin')
     *   - blinks          (default: 4)   // kolikr√°t blikne
     *   - interval        (default: 200) // ms mezi stavy
     *   - borderWidthOn   (default: null) // nap≈ô. '3px'
     *   - restart         (default: false) // kdy≈æ u≈æ bƒõ≈æ√≠, restartuje
     * @returns {boolean} true = spu≈°tƒõno; false = ignorov√°no (u≈æ bƒõ≈æelo a restart=false / chyb√≠ element)
     */
    async function blinkBorder(target, options = {}) {
        if (!allLoaded) return;
        const el = typeof target === 'string' ? document.querySelector(target) : target;
        if (!el) return false;

        const {
            color = 'orange',
            backgroundOn = 'Moccasin',
            blinks = 4,
            interval = 200,
            borderWidthOn = null,
            restart = false,
        } = options;

        // prevent-spam: pokud u≈æ bƒõ≈æ√≠
        const running = _blinkLocks.get(el);
        if (running) {
            if (!restart) return false;
            clearInterval(running.id);
            running.restore?.();
            _blinkLocks.delete(el);
        }

        // Snapshot p≈Øvodn√≠ho vizu√°ln√≠ho stavu
        const cs = getComputedStyle(el);
        const original = {
            borderColor: cs.borderColor,
            borderWidth: cs.borderWidth,
            backgroundColor: cs.backgroundColor,
            transition: el.style.transition,
        };

        let ticks = 0;
        let on = false;

        const restore = () => {
            // vypnout p≈ôechody, tvrdƒõ vr√°tit, a zase zapnout
            el.style.transition = 'none';
            void el.offsetWidth; // reflow
            el.style.borderColor = original.borderColor;
            el.style.borderWidth = original.borderWidth;
            el.style.backgroundColor = original.backgroundColor;
            void el.offsetWidth; // reflow
            el.style.transition = original.transition;
            _blinkLocks.delete(el);
        };

        const id = setInterval(() => {
            // kdy≈æ element zmiz√≠ z DOMu, ukliƒè
            if (!document.contains(el)) {
                clearInterval(id);
                restore();
                return;
            }

            on = !on;
            if (on) {
                el.style.borderColor = color;
                if (borderWidthOn) el.style.borderWidth = borderWidthOn;
                el.style.backgroundColor = backgroundOn;
            } else {
                el.style.borderColor = original.borderColor;
                el.style.borderWidth = original.borderWidth;
                el.style.backgroundColor = original.backgroundColor;
            }

            ticks++;
            if (ticks >= blinks * 2) {
                clearInterval(id);
                restore(); // ‚Üê po dobƒõhnut√≠ v≈ædy stejn√© barvy jako na zaƒç√°tku
            }
        }, interval + 50);

        _blinkLocks.set(el, {id, restore});
        return true;
    }

    // Volitelnƒõ: ruƒçn√≠ ukonƒçen√≠/obnova
    blinkBorder.stop = function (target) {
        const el = typeof target === 'string' ? document.querySelector(target) : target;
        if (!el) return false;
        const running = _blinkLocks.get(el);
        if (!running) return false;
        clearInterval(running.id);
        running.restore?.();
        _blinkLocks.delete(el);
        return true;
    };

    // --- p≈ôevod jednotkov√© notace na HTML (povoleno jen <sub>/<sup>) ---
    function unitMarkupToHTML(str = '') {
        // escape v≈°eho‚Ä¶
        let out = String(str).replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

        // ‚Ä¶a povol jen tyto formy z√°pisu sub/sup:

        // [sub]x[/sub], [sup]x[/sup]
        out = out.replace(/\[sub\]([\s\S]*?)\[\/sub\]/gi, '<sub>$1</sub>')
            .replace(/\[sup\]([\s\S]*?)\[\/sup\]/gi, '<sup>$1</sup>');

        // entity &lt;sub&gt;x&lt;/sub&gt; a &lt;sup&gt;‚Ä¶&lt;/sup&gt;
        out = out.replace(/&lt;(sub|sup)&gt;([\s\S]*?)&lt;\/\1&gt;/gi, '<$1>$2</$1>');

        // podtr≈æ√≠tko / st≈ô√≠≈°ka: _{...}, _x, ^{...}, ^x
        out = out.replace(/_\{([^}]+)\}/g, '<sub>$1</sub>')
            .replace(/_([A-Za-z0-9+\-‚àí¬±]+)/g, '<sub>$1</sub>')
            .replace(/\^\{([^}]+)\}/g, '<sup>$1</sup>')
            .replace(/\^([A-Za-z0-9+\-‚àí¬±]+)/g, '<sup>$1</sup>');

        return out;
    }

    // --- doplnƒõn√≠ labelu ---
    function updateUnitsLabel(input) {
        if (!input || !input.id) return;
        const unitRaw = (input.dataset.unit || '').trim();
        const span = document.querySelector(`label[for="${input.id}"] .units-text`);
        if (!span) return;
        span.innerHTML = unitRaw ? ` (${unitMarkupToHTML(unitRaw)})` : '';
    }

    lockMovement();
    UI.USB.classList.add("disabled");


    document.addEventListener("DOMContentLoaded", function () {

        Notification.requestPermission().then(permission => {
            if (permission === "granted") {
                notificationsAllowed = true;
            }
        });

        // Initialization of uPlot charts
        timeChart = createChart("timeChart", ["Time (s)", "Loadcell 1", "Loadcell 2", "Loadcell 3"], "Force-Time Graph", "Time [s]", "Force [N]");
        positionChart = createChart("positionChart", ["Position (mm)", "Loadcell 1", "Loadcell 2", "Loadcell 3"], "Force-Position Graph", "Position [mm]", "Force [N]");


        // Function to save ONE input to localStorage
        function saveInputToLocalStorage(event) {
            const input = event.target; // Get the input element
            let formData = JSON.parse(localStorage.getItem(storageKey)) || {}; // Load the saved data

            // Save the input value to the formData object or select the checked state for checkboxes
            formData[input.id] = (input.type === "checkbox") ? input.checked : input.value;

            localStorage.setItem(storageKey, JSON.stringify(formData)); // Save the updated data
        }


        // Function to save ALL inputs to localStorage
        function saveAllInputsToLocalStorage() {
            let formData = {};

            optionsElements?.forEach(input => {
                if (input.dataset.nonremember !== "true") {
                    formData[input.id] = (input.type === "checkbox") ? input.checked : input.value;
                }

            });

            localStorage.setItem(storageKey, JSON.stringify(formData));
            console.info("All data saved to localStorage.");
        }


        // Function to load inputs from localStorage
        function loadInputsFromLocalStorage() {
            const formData = JSON.parse(localStorage.getItem(storageKey)) || NaN; // Load the saved data
            if (!formData) saveAllInputsToLocalStorage();

            optionsElements?.forEach(input => {
                if (formData.hasOwnProperty(input.id)) {
                    if (input.type === "checkbox") {
                        input.checked = formData[input.id]; // Restore the checkbox state
                    } else if (input.tagName.toLowerCase() === "select") {
                        if ([...input.options].some(option => option.value === formData[input.id])) {
                            input.value = formData[input.id]; // Restore the select value if it exists
                        }
                    } else {
                        input.value = formData[input.id]; // Restore the input value
                    }
                }

                // Trigger change event to update the UI
                input.dispatchEvent(new Event("change", {bubbles: true}));
                input.dispatchEvent(new Event("input", {bubbles: true}));
                input.dispatchEvent(new Event("blur", {bubbles: true}));
            });
        }


        const optionsElements = $$("input, select");

        // Listen for changes in all inputs
        optionsElements?.forEach(input => {
            if (input.dataset.nonremember !== "true") {
                input.addEventListener("change", async (event) => saveInputToLocalStorage(event));
            }
        });


        [...optionsElements].filter(el => el.matches('[id][data-unit]'))?.forEach((input) => {
            updateUnitsLabel(input);

            // Use examples:
            //      <input id="a" data-unit="m/s^2">
            //      <!-- -> (m/s<sup>2</sup>) -->
            //
            //      <input id="b" data-unit="CO_2">
            //      <!-- -> (CO<sub>2</sub>) -->
            //
            //      <input id="c" data-unit="10^{‚àí3} mol¬∑L^{‚àí1}">
            //      <!-- -> (10<sup>‚àí3</sup> mol¬∑L<sup>‚àí1</sup>) -->
            //
            //      <input id="d" data-unit="[sup]2[/sup]¬∑m">
            //      <!-- -> (<sup>2</sup>¬∑m) -->
            //
            //      <!-- pokud chce≈° ps√°t p≈ô√≠mo HTML, v atributu pou≈æij entity: -->
            //      <input id="e" data-unit="m/s&lt;sup&gt;2&lt;/sup&gt;">
            //      <!-- -> (m/s<sup>2</sup>) -->

            // Pokud by se data-unit mƒõnilo dynamicky, hl√≠dej zmƒõnu atributu:
            const mo = new MutationObserver((muts) => {
                for (const m of muts) {
                    if (m.type === 'attributes' && m.attributeName === 'data-unit') {
                        updateUnitsLabel(input);
                    }
                }
            });
            mo.observe(input, {attributes: true, attributeFilter: ['data-unit']});
        });


        $$$("experimentName")?.addEventListener("change", async (event) => {
            const countInput = $$$("experimentCount");
            if (countInput && countInput.value !== '1') {
                blinkBorder(countInput, {restart: true});
                countInput.value = 1;
            }
            await updateLogById(0, {experimentName: event.target.value.trim()});
        });

        $$$("experimentCount")?.addEventListener("change", async (event) => {
            blinkBorder(event.target, {
                restart: true,
                color: '#2196F3',
                backgroundOn: '#a7e7ff',
                blinks: 2,
            });
        });

        $$$("experimentDesc")?.addEventListener("change", async (event) => {
            await updateLogById(0, {experimentDescription: event.target.value.trim()});
        });

        $$$("clearChartBtn")?.addEventListener("click", async () => clearCharts());

        // TODO:  $$$("saveChartBtn")?.addEventListener("click", async () => saveChartsAsPNG());

        $$$("refreshChartBtn")?.addEventListener("click", async () => refreshCharts());

        $$$("convertCSV")?.addEventListener("click", async () => convertCSVtoXLSX_MATTES());

        $$$("clearCalculationsButton")?.addEventListener("click", async () => clearCalculations());

        $$$("darkModeButton")?.addEventListener("click", async () => toggleDarkMode());

        $$$("aboutButton")?.addEventListener("click", async () => window.location.href = 'about.html');

        $$$("clearStorageButton")?.addEventListener("click", async () => {
            if (confirm("‚ö†Ô∏è This will clear all settings and disconnect the machine.\n\n     Are you sure?")) {
                clearLocalStorage();
            }
        });

        $$$("toggleLineLockBtn")?.addEventListener("click", async () => lineLock());

        $$$("clearRegularLog")?.addEventListener("click", async () => clearLog());

        // TODO: $$$("saveRegularLog")?.addEventListener("click", async () => saveLogAsText());

        function attachHoldHandlers(element, onStart) {
            let isHolding = false;

            const start = async () => {
                if (isHolding) return;
                isHolding = true;
                lockMovementExcept(element);  // zamkni v≈°e krom pr√°vƒõ dr≈æn√©ho
                await beganMoving();          // spust√≠ watchdog
                onStart();
            };

            const stop = async () => {
                if (!isHolding) return;
                isHolding = false;
                await softStopMachine();          // po pu≈°tƒõn√≠ zastav a ukonƒçi pohyb
            };

            // My≈°
            element.addEventListener("mousedown", start);
            element.addEventListener("mouseup", stop);
            element.addEventListener("mouseleave", () => {
                if (isHolding) stop();
            });

            // Dotyk
            element.addEventListener("touchstart", start, {passive: true});
            element.addEventListener("touchend", stop);
            element.addEventListener("touchcancel", stop);
        }


        attachHoldHandlers(UI.moveUpBtn, async () => sendMoveCommand("MC HOME"));
        attachHoldHandlers(UI.moveDownBtn, async () => sendMoveCommand("MC END"));

        $$$("returnPositionExperimentBtn").addEventListener('click', async () => moveToOriginalPosition());

        UI.moveUp100Btn.addEventListener("click", async () => moveBy(-100));
        UI.moveDown100Btn.addEventListener("click", async () => moveBy(100));


        UI.calibrateBtn.addEventListener("click", async () => {
            calibrationStatus = false;
            await lockMovement();

            await sendCommandGeneral('MC ENDSTOPS ENABLE');
            await sendCommandGeneral('MISC SET WATCHDOG_ENABLED 0');
            await sendCommandGeneral('MC CALIBRATE');

            let confirmCalibrationCount = 0;
            // maximal 1 minute
            const maxConfirmCalCount = 60 / 2.5;

            while (!calibrationStatus) {
                await sleep(2500);
                calibrationStatus = await getCalibrationStatus(500);
                if (!isSerial || !isConnected) {
                    calibrationStatus = false;
                    console.warn("\n‚ö†Ô∏è Serial connection lost during calibration.");
                    await logMessage("‚ö†Ô∏è Serial connection lost during calibration.");
                    break;
                }
                if (confirmCalibrationCount > maxConfirmCalCount) {
                    calibrationStatus = false;
                    await logMessage("‚ùå Calibration timeout reached. Please check the machine.\n\tMotors are not calibrated.");
                    console.error("‚ùå Calibration timeout. Please check the machine.\n\tMotors are not calibrated.");
                    break;
                }
                confirmCalibrationCount++;
            }
            if (calibrationStatus) await unlockMovement();
            if (!calibrationStatus) await lockMovementExcept(UI.calibrateBtn);
        });


        // Set both elements' limits to match
        [[UI.speedSlider, UI.speedLabel], [UI.accelerationSlider, UI.accelerationLabel]]?.forEach(pair => {
            pair[1].min = pair[0].min;
            pair[1].max = pair[0].max;
            pair[1].value = pair[0].value;
            pair[1].step = pair[0].step;

            pair[1].dispatchEvent(new Event("input", {bubbles: true}));
        });

        $$('.sliderInputLabel')?.forEach(input => {
            input.addEventListener("change", (event) => {
                checkInput(event.target, 'floatInput', 2);
                const slider = document.getElementById(event.target.id.replaceAll("label", "movement"));
                const value = parseFloat(event.target.value).toFixed(2); // Round to 2 decimal places
                if (slider) {
                    slider.value = value;
                    event.target.value = value; // Update the input value to match the slider
                    slider.dispatchEvent(new Event("change", {bubbles: true})); // Trigger input event to update the slider
                }
            });
        });

        // Attaches validation checks to numeric inputs
        $$("input[type=number]")?.forEach(input => {
            input.addEventListener("change", async (event) => {
                checkInput(event.target, event.target.dataset.inputType);
            });
            input.addEventListener("keydown", async (event) => {
                if (event.key === "Enter") {
                    checkInput(event.target, event.target.dataset.inputType);
                    event.target.blur();
                }
            });
        });


        const decSymbolElement = $$$('decimalSymbol');
        const delimSymbolElement = $$$('delimiterSymbol');

        decSymbolElement.addEventListener("change", (event) => {
            const isValueComma = event.target.value === "Option-Comma";
            const currentValue = delimSymbolElement.value;
            const commaOptions = delimSymbolElement.querySelectorAll('option[value="Option-Comma"]');
            if (isValueComma) {
                commaOptions?.forEach(o => o.disabled = true);
            } else {
                commaOptions?.forEach(o => o.disabled = false);
            }
            if (isValueComma === currentValue) {
                delimSymbolElement.value = "Option-Semicolon";
                delimSymbolElement.dispatchEvent(new Event("change", {bubbles: true}));
            }
        });
        delimSymbolElement.addEventListener("change", (event) => {
            const isValueComma = event.target.value === "Option-Comma";
            const currentValue = decSymbolElement.value;
            const commaOptions = decSymbolElement.querySelectorAll('option[value="Option-Comma"]');
            if (isValueComma) {
                commaOptions?.forEach(o => o.disabled = true);
            } else {
                commaOptions?.forEach(o => o.disabled = false);
            }
            if (isValueComma === currentValue) {
                decSymbolElement.value = "Option-Dot";
                decSymbolElement.dispatchEvent(new Event("change", {bubbles: true}));
            }
        });


        // Sliders
        UI.speedSlider.addEventListener("input", () => {
            currentSpeed = roundDecimalFast(parseFloat(UI.speedSlider.value) || 15, precisionSpeedSystem);
            UI.speedLabel.value = `${currentSpeed.toFixed(precisionSpeedSystem)}`;
        });
        UI.speedSlider.addEventListener("change", async () => isConnected ? sendCommandGeneral(`MC SET SPEEDMM ${UI.speedSlider.value}`) : null);

        UI.accelerationSlider.addEventListener("input", () => {
            currentAcceleration = roundDecimalFast(parseFloat(UI.accelerationSlider.value) || 150, precisionAccelerationSystem);
            UI.accelerationLabel.value = currentAcceleration.toFixed(precisionAccelerationSystem);
        });
        UI.accelerationSlider.addEventListener("change", async () => isConnected ? sendCommandGeneral(`MC SET ACCELMM ${UI.accelerationSlider.value}`) : null);

        // pouze ty .data-eq, kter√© maj√≠ data-eq-type
        const experiment_result_elements = $$("[data-eq-type]");
        $$$("experimentTypeDropdown")?.addEventListener("change", async (event) => {
            // vyt√°hne typ ze suffixu hodnoty (oddƒõlovaƒçe - _ / mezera)
            const typeFrom = s =>
                (String(s || '').toLowerCase().match(/(?:^|[-_\/\s])(inb|hbr|flx)$/)?.[1]) || '';

            // rozparsuje data-eq-type na inkluze/exkluze; podporuje "HB,IB", "HB|IB", "HB IB", "HB/IB", "-HBR"
            const parseEqRule = attr => {
                const tokens = String(attr || '')
                    .split(/[,\s;|/]+/)
                    .map(t => t.trim().toLowerCase())
                    .filter(Boolean);

                const includes = new Set();
                const excludes = new Set();

                for (const t of tokens) {
                    if (t.startsWith('-')) {
                        const x = t.slice(1).trim();
                        if (x) excludes.add(x);
                    } else {
                        includes.add(t);
                    }
                }
                return {includes, excludes};
            };

            // vyhodnot√≠ shodu se zvolen√Ωm typem
            const matchesRule = (rule, selType) => {
                const hasIncl = rule.includes.size > 0;
                const hasExcl = rule.excludes.size > 0;

                if (hasIncl) {
                    return rule.includes.has(selType);
                }
                if (hasExcl) {
                    return !rule.excludes.has(selType);
                }

                return true; // Empty rule matches all
            };

            const selectedValue = (event.target.value || '').toLowerCase();
            const selectedType = typeFrom(selectedValue); // "inb" | "hbr" | "flx" | ""

            const speedInput = $$$("inputInitialSpeed");
            const forceInput = $$$("inputInitialForce");
            const speedLabel = $$$("inputInitialSpeedLabel");
            const forceLabel = $$$("inputInitialForceLabel");

            experiment_result_elements?.forEach(el => {
                const rule = parseEqRule(el.dataset.eqType);
                const isType = matchesRule(rule, selectedType);

                el.style.display = isType ? 'inline-flex' : 'none';
                el.style.visibility = isType ? 'visible' : 'hidden';

                if (!isType) {
                    el.querySelectorAll('input')?.forEach(input => {
                        // input.value = '';
                        input.dispatchEvent(new Event("change", {bubbles: true}));
                    });
                }
            });
            // ------------------------------------------------------------------------

            requestAnimationFrame(() => {
                controlContainerWidth($$$("resultsContainer"));
            });
        });


        // Load saved data when the page loads
        loadInputsFromLocalStorage();
        pageLoaded = true;

        setTimeout(() => window.dispatchEvent(new Event('resize', {bubbles: true})), 0);

        onLoad();
    });


    function waitForXLSX() {
        return new Promise((resolve, reject) => {
            const ok = () => window.XLSX ? resolve() : setTimeout(ok, 50);
            ok();
            setTimeout(() => reject(new Error("XLSX failed to load")), 5000);
        });
    }

    // TODO: Implement the function to parse CSV data based on preambleMetaData and import it into XLSX and UI
    async function getDataFromCsv(data, preambleMetaData) {
        const delimiter = preambleMetaData?.delimiter || ";";
        const skipRows = preambleMetaData?.skipRows; // (Experiment settings) // (Empty) // (Info) // (Description) // (Empty) // (Header)
        const columns = preambleMetaData?.columns;

    }


    async function convertCSVtoXLSX_MATTES() {
        try {
            await waitForXLSX();
        } catch (e) {
            alert("‚ùå Failed to load XLSX library. Please check the logs and your internet connection and try again.");
            return;
        }

        const input = document.createElement('input');

        const mattesMaxLines = 20_000; // Maximum number of lines in one file
        const preferFoundDelimiter = false;


        input.type = 'file';
        input.accept = '.csv';
        input.multiple = true; // Allow multiple file selection
        input.onchange = async function (event) {
            let files = Array.from(event.target.files); // Convert FileList to Array
            if (!files.length) {
                console.warn("\n‚ùå No files selected.");
                alert("‚ùå No files were selected. Please select one or more CSV files and try again.");
                return;
            } else {
                files.sort((a, b) => {
                    let nameA = a.name.toLowerCase();
                    let nameB = b.name.toLowerCase();

                    // Regular expression to extract the base name and optional index
                    let regex = /(.*?)(?:\s\((\d+)\))?\.csv$/;

                    let matchA = nameA.match(regex);
                    let matchB = nameB.match(regex);

                    if (!matchA || !matchB) return 0; // Skip if no match

                    let baseA = matchA[1]; // Base name
                    let indexA = matchA[2] ? parseInt(matchA[2]) : -1; // Index (if present) or -1

                    let baseB = matchB[1];
                    let indexB = matchB[2] ? parseInt(matchB[2]) : -1;

                    // Sort by base name first
                    if (baseA !== baseB) return baseA.localeCompare(baseB);

                    // Sort by index if base names are the same
                    if (indexA === -1) return -1;
                    if (indexB === -1) return 1;

                    // Sort by index
                    return indexA - indexB;
                });

                console.info("üìÇ Sorted files:", files.map(f => f.name)); // Log sorted file names
            }

            const measurementName = files[0].name.replace(/\.csv$/, "").replace(/\s*\(\d+\)\s*$/, "").replace(/^(.*)_(\d{1,})$/, "$1").trim(); // Measurement name
            let wb = XLSX.utils.book_new(); // Create a new Excel workbook
            let sheetName = ("P-" + measurementName).slice(0, (31 - 8)); // Sheet name

            // ==================== FILES LIST ==================== //

            // TODO: lep≈°√≠ n√°zev promƒõnn√©
            const HEAD = ["File Order", "File name", "Experiment type", "Material",
                "b (mm)", "h (mm)", "L (mm)", "E (MPa)",
                "F_max (N)", "w_Fmax (mm)", "œÉ_max (MPa)",
                "F_T (N)", "h_D (mm)", "H_BW (-)"];

            const resultsData = [HEAD]; // Third sheet data

            // ================== LOADING DATA ================== //

            const formattedData = []; // First sheet data  -   Array to store ALL formatted measurement data
            let columnOffset = 0; // Column shift for each section


            // ================== SAMPLES TABLE ================== //


            const samplesTable = [
                ["Code", "Method", "W", "Number", "Dimensions, weight, before drying", "", "", "", "Dimensions, weight, after drying", "", "", "", "lo (mm)"], // row 0
                ["", "", "", "", "hw", "lw", "ww", "mw", "h0", "l0", "w0", "m0", ""], // row 1
                ["", "", "", "", "height (mm)", "length (mm)", "width (mm)", "(g)", "height (mm)", "length (mm)", "width (mm)", "(g)", ""] // row 2
            ];// Second sheet data

            const outputsOpts = {
                time: {key: 'time', unit: 's', precision: 12},
                position: {key: 'dist, disp, position', unit: 'mm', precision: 12},
                force: {key: 'force, load', unit: 'N', precision: 12},
            };

            const delimiters = [";", ",", "\t", " "];
            const getMetaValue = (metaData, key, unit = null) => {
                if (!isObj(metaData)) return "";
                if (metaData.hasOwnProperty(key)) {
                    const value = metaData[key]?.value || "";
                    if (!hasValue(value)) return "";
                    const valUnit = metaData[key].unit || null;
                    if (isNonEmptyStr(unit) && isNonEmptyStr(valUnit)) {
                        return convertUnits(value, valUnit, unit) || "";
                    }
                    return value || "";
                }
                return "";
            };

            function setupParsers(head, fileSet, outputs) {
                // --- sanity checks ---
                if (!isArr(head)) {
                    console.warn("\n‚ö†Ô∏è Cannot setup parsers, head is not an array.");
                    return {};
                }
                if (!fileSet || !fileSet.delimiter) {
                    console.warn("\n‚ö†Ô∏è Cannot setup parsers, missing delimiter or fileSet.");
                    return {};
                }
                if (!fileSet.dataTypes) fileSet.dataTypes = {};

                // --- helpers ---
                const getUnitFromHeader = (header) => {
                    if (isEmptyStr(header)) return null;
                    // nech√°v√°m tv≈Øj vzor; p≈ô√≠padnƒõ roz≈°√≠≈ôit o ƒç√≠slice, lom√≠tka apod.
                    const match = String(header).match(/[\(\[]\s*([a-zA-Z%ŒºŒºmNnkgkPaasS]+)\s*[\)\]]/);
                    return match ? match[1] : null;
                };

                // --- 1) hlaviƒçka ---
                const headerRowIdx = Math.max(0, ((fileSet.skipRows | 0) - 1));
                if (headerRowIdx >= head.length) {
                    console.warn("\n‚ö†Ô∏è Cannot setup parsers, header row index out of bounds.");
                    return {};
                }

                const headerParts = String(head[headerRowIdx]).split(fileSet.delimiter).map(s => String(s).trim());
                const headerUnits = headerParts.map(part => getUnitFromHeader(part) || '');

                // mapa synonym z outputs[*].key (ƒç√°rkami oddƒõlen√©)
                const types = Object.keys(outputs || {});
                const keysByType = Object.fromEntries(
                    types.map(t => [
                        t,
                        String(outputs[t]?.key || t)
                            .toLowerCase()
                            .split(',')
                            .map(s => s.trim())
                            .filter(Boolean),
                    ])
                );

                // pro ka≈æd√Ω sloupec rozhodni typ dle substring≈Ø
                const headerTypes = headerParts.map(part => {
                    const p = String(part).toLowerCase();
                    for (const t of types) {
                        if (keysByType[t].some(k => k && p.includes(k))) return t;
                    }
                    return null;
                });

                // --- 2) dopl≈à/nen√°silnƒõ nastav fileSet.dataTypes[*] ---
                function ensureType(t) {
                    const prev = fileSet.dataTypes[t] || {};
                    const outCfgUnit = outputs[t]?.unit || '';

                    // 2.1 Indexy
                    let indexes = isArr(prev.indexes) && prev.indexes.length > 0
                        ? prev.indexes.slice() // respektuj p≈ôedem zadan√© indexy
                        : headerTypes
                            .map((tt, i) => (tt === t ? i : -1))
                            .filter(i => i >= 0);

                    // 2.2 C√≠lov√° jednotka (preferuj u≈æ d≈ô√≠v nastavenou)
                    const targetUnit = isNonEmptyStr(prev.unit) ? prev.unit : outCfgUnit;

                    // 2.3 Udr≈æ jednotn√Ω "fromUnit" pro 1 spoleƒçn√Ω conversion
                    let fromUnit = '';
                    if (!isNonEmptyArr(prev.indexes) && isNonEmptyArr(indexes)) {
                        if (targetUnit) {
                            // najdi prvn√≠ jednotku mezi kandid√°ty
                            for (const i of indexes) {
                                if (headerUnits[i]) {
                                    fromUnit = headerUnits[i];
                                    break;
                                }
                            }
                            if (fromUnit) {
                                // filtruj jen na sloupce se shodn√Ωm fromUnit
                                indexes = indexes.filter(i => (headerUnits[i] || '') === fromUnit);
                            }
                        } else {
                            // bez targetUnit ‚Äì dr≈æ jednotnost dle prvn√≠ nalezen√© (nebo pr√°zdn√©)
                            fromUnit = headerUnits[indexes[0]] || '';
                            indexes = indexes.filter(i => (headerUnits[i] || '') === fromUnit);
                        }
                    } else if (isNonEmptyArr(prev.indexes)) {
                        // indexy d√°ny u≈æivatelem ‚Üí odvoƒè fromUnit (pokud jde)
                        const i0 = prev.indexes[0];
                        if (Number.isInteger(i0) && i0 >= 0 && i0 < headerUnits.length) {
                            fromUnit = headerUnits[i0] || '';
                        }
                    }

                    // 2.4 Konverze (preferuj p≈ôedvyplnƒõnou)
                    let conversion = isDef(prev.conversion) ? toNumber(prev.conversion) : undefined;
                    if (!isDef(conversion) || !isNum(conversion)) {
                        if (targetUnit && fromUnit) {
                            try {
                                conversion = convertUnits(1, fromUnit, targetUnit) || 1;
                            } catch (_) {
                                conversion = 1;
                            }
                        } else {
                            conversion = 1;
                        }
                    }

                    // 2.5 Z√°pis (zachovej p≈ô√≠padn√© dal≈°√≠ kl√≠ƒçe v prev)
                    fileSet.dataTypes[t] = {
                        ...prev,
                        indexes: isNonEmptyArr(prev.indexes) ? prev.indexes : indexes,
                        unit: isNonEmptyStr(prev.unit) ? prev.unit : targetUnit,
                        conversion,
                    };
                }

                for (const t of types) ensureType(t);

                // --- 3) gettery (p≈ôesnost z outputs[*].precision) ---
                const getters = {};
                for (const t of types) {
                    const precision = outputs[t]?.precision ?? 12;

                    getters[t] = (entry) => {
                        const spec = fileSet.dataTypes[t];
                        if (!spec || !isNonEmptyArr(spec.indexes)) return 0;

                        const convRaw = toNumber(spec.conversion, true);
                        const conv = Number.isFinite(convRaw) ? convRaw : 1;

                        // vezmi prvn√≠ nenulovou / ƒç√≠selnou hodnotu
                        for (let i = 0; i < spec.indexes.length; i++) {
                            const idx = spec.indexes[i];
                            const vRaw = toNumber(entry[idx], true);
                            const v = Number.isFinite(vRaw) ? vRaw : 0;
                            if (v !== 0) {
                                return roundDecimalFast(v * conv, precision);
                            }
                        }
                        return 0;
                    };

                    // metadata/utility metody (ne-s√©riovateln√© a bezpeƒçn√©)
                    Object.defineProperties(getters[t], {
                        indexes: {
                            value: () => (fileSet.dataTypes?.[t]?.indexes ? [...fileSet.dataTypes[t].indexes] : []),
                            enumerable: false
                        },
                        count: {
                            value: () => (fileSet.dataTypes?.[t]?.indexes?.length ?? 0),
                            enumerable: false
                        },
                        unit: {
                            value: () => (fileSet.dataTypes?.[t]?.unit ?? ''),
                            enumerable: false
                        },
                        conv: {
                            value: () => {
                                const c = toNumber?.(fileSet.dataTypes?.[t]?.conversion, false);
                                return Number.isFinite(c) ? c : (fileSet.dataTypes?.[t]?.conversion ?? 1);
                            },
                            enumerable: false
                        }
                    });
                }


                return getters;
            }

            // ≈°√≠≈ôky sloupc≈Ø podle d√©lky hlaviƒçek
            const PAD = 2;      // rezerva, a≈• to nen√≠ nalepen√©
            const MIN = 6;      // minim√°ln√≠ ≈°√≠≈ôka

            function fitToCols(rows, {pad = 2, min = 6} = {}) {
                const cols = rows[0]?.length ?? 0;
                const out = Array.from({length: cols}, () => ({wch: min}));
                for (let c = 0; c < cols; c++) {
                    let maxLen = 0;
                    for (let r = 0; r < rows.length; r++) {
                        const v = rows[r][c];
                        const s = v == null ? "" : String(v);
                        if (s.length > maxLen) maxLen = s.length;
                    }
                    out[c].wch = Math.max(min, maxLen + pad);
                }
                return out;
            }

            function setNumFmt(colIndex, fmt, data, ws) {
                for (let r = 1; r < data.length; r++) {
                    const addr = XLSX.utils.encode_cell({r, c: colIndex});
                    const cell = ws[addr];
                    if (cell && typeof cell.v === 'number') cell.z = fmt; // nap≈ô. "0.00"
                }
            }


            // ----------------- LOOPING THROW CSV FILES ----------------- //
            let fileCount = 0;
            for (let file of files) {
                fileCount++;
                const raw = await file.text();
                const text = raw.replace(/\r\n?/g, "\n");


                let fileType = null;                // Determine the file type
                let fileVersion = null;

                const fileOpts = {
                    delimiter: null,
                    skipRows: 0,
                    columns: null,
                    dataTypes: {},
                }; // Options for parsing the file

                const samplesInfo = {
                    method: 3,  // Method (place 3)
                    W: 0,       // W (place 0)
                    hw: "",
                    lw: "",
                    ww: "",
                    mw: "",
                    h0: "",
                    l0: "",
                    w0: "",
                    m0: "",
                    lo: "",     // lo (empty)
                }; // Sample information

                const expResults = {
                    experimentType: "", // Experiment type
                    material: "",       // Material
                    b: "",              // b (mm)
                    h: "",              // h (mm)
                    L: "",              // L (mm)
                    E: "",              // E (MPa)
                    F_max: "",          // F_max (N)
                    w_Fmax: "",        // w_Fmax (mm)
                    sigma_max: "",     // œÉ_max (MPa)
                    F_T: "",           // F_T (N)
                    h_D: "",           // h_D (mm)
                    H_BW: ""           // H_BW (-)
                }; // Experiment results


                let rows = text.split("\n"); // Split text into lines

                rows = rows.map(r => r.trim().toLowerCase());

                const firstLine = rows[0].toLowerCase() || "";
                if (firstLine.startsWith("##moira")) fileType = "moira";              // MOIRA
                else if (firstLine.startsWith("date:")) fileType = "moira-legacy";    // MOIRA legacy
                else if (firstLine.startsWith("timestamp_us")) fileType = "matlab";   // MATLAB
                else fileType = "unknown";                                       // Unknown file type


                const getDelimiter = (rows, minParts = 3) => {
                    const testLine = rows[Math.ceil(2 * rows.length / 3)]; // data line of CSV file
                    let delimiter = null; // Delimiter of data in a a CSV file

                    for (const separator of delimiters) {
                        const parts = testLine.split(separator);
                        if (parts.length >= minParts) {
                            delimiter = separator;
                            break; // Found the delimiter
                        }
                    }

                    return delimiter;
                };

                switch (fileType) {
                    case "moira":
                        console.info(`üìÅ Processing MOIRA file: ${file.name}`);

                        const preambleMetaData = await parseSettingsFromCsv(text) || {};

                        fileVersion = preambleMetaData?.version || 0;

                        fileOpts.delimiter = preambleMetaData?.delimiter || ";";
                        if (preambleMetaData?.headerVersion === 1) fileOpts.skipRows = preambleMetaData?.skipRows; // (Experiment settings) // (Empty) // (Info) // (Description) // (Empty) // (Header)
                        fileOpts.columns = preambleMetaData?.columns;


                        const precisions = preambleMetaData?.precisions || {};
                        if (isObj(outputsOpts) && isNotEmpty(precisions)) {
                            Object.keys(outputsOpts)?.forEach(key => {
                                const n = toRounds(precisions[key]);
                                if (isDef(n) && isNum(n)) outputsOpts[key].precision = clamp(Math.abs(n), 0, 12);
                            });
                        }

                        const expInfoV = await preambleMetaData.expSettings?.version || 0;
                        const calcSettingsInputs = await preambleMetaData.calcSettings.inputs || {};

                        if (expInfoV >= 1) {
                            expResults.experimentType = await preambleMetaData?.experimentLabel || "";
                            expResults.material = getMetaValue(calcSettingsInputs, "inputMaterialName");
                            expResults.b = getMetaValue(calcSettingsInputs, "inputWidth", "mm");
                            expResults.h = getMetaValue(calcSettingsInputs, "inputHeight", "mm");
                            expResults.L = getMetaValue(calcSettingsInputs, "inputLength", "mm");
                            expResults.E = getMetaValue(calcSettingsInputs, "outputModulus", "MPa");
                            expResults.F_max = getMetaValue(calcSettingsInputs, "outputForceMax", "N");
                            expResults.w_Fmax = getMetaValue(calcSettingsInputs, "outputDisp", "mm");
                            expResults.sigma_max = getMetaValue(calcSettingsInputs, "outputMaxStress", "MPa");
                            expResults.F_T = getMetaValue(calcSettingsInputs, "inputTargetForce", "N");
                            expResults.h_D = getMetaValue(calcSettingsInputs, "inputIndDepth", "mm");
                            expResults.H_BW = getMetaValue(calcSettingsInputs, "outputHardness");
                        }

                        const calcInfoV = await preambleMetaData.calcSettings?.version || 0;
                        if (calcInfoV >= 1) {
                            samplesInfo.hw = getMetaValue(calcSettingsInputs, "inputHeight_BeforeDrying", "mm");
                            samplesInfo.lw = getMetaValue(calcSettingsInputs, "inputLength_BeforeDrying", "mm");
                            samplesInfo.ww = getMetaValue(calcSettingsInputs, "inputWidth_BeforeDrying", "mm");
                            samplesInfo.mx = getMetaValue(calcSettingsInputs, "inputWeight_BeforeDrying", "g");
                            samplesInfo.h0 = getMetaValue(calcSettingsInputs, "inputHeight_AfterDrying", "mm");
                            samplesInfo.l0 = getMetaValue(calcSettingsInputs, "inputLength_AfterDrying", "mm");
                            samplesInfo.w0 = getMetaValue(calcSettingsInputs, "inputWidth_AfterDrying", "mm");
                            samplesInfo.m0 = getMetaValue(calcSettingsInputs, "inputWeight_AfterDrying", "g");
                        }

                        break;

                    case "moira-legacy":
                        console.info(`üìÅ Processing MOIRA legacy file: ${file.name}`);

                        fileOpts.delimiter = ";";
                        fileOpts.skipRows = 3; // (Info) // (Description) // (Header)
                        fileOpts.columns = 6;

                        break;

                    case "matlab":
                        console.info(`üìÅ Processing MATLAB file: ${file.name}`);

                        fileOpts.delimiter = ";";
                        fileOpts.skipRows = 1;  // (Header)
                        fileOpts.columns = 5;
                        fileOpts['dataTypes']['time']['conversion'] = 1e-6; // Convert time from microseconds to seconds

                        break;

                    case "unknown":
                    default:
                        console.info(`üìÅ Processing unknown format file: ${file.name}`);

                        // find first row that starts with text 'time'
                        const headerRowIndex = rows.findIndex(row => row.trim().startsWith("time"));
                        fileOpts.skipRows = headerRowIndex !== -1 ? headerRowIndex : 0;
                        fileOpts.columns = 4;
                        // TODO: skip for now
                        fileCount--;
                        console.info(`‚ùå Skipping unknown file: ${file.name}`);
                        continue;
                }

                if (rows.length <= fileOpts.skipRows) {  // Skip if the file has no data
                    logMessage(`‚ùå Not enough data in file: ${file.name}`);
                    console.warn(`\n‚ùå Not enough data in file: ${file.name}`);
                    fileCount--;
                    console.info(`‚ùå Skipping empty or invalid file: ${file.name}`);
                    continue;
                }


                const head = rows.slice(0, fileOpts.skipRows);
                rows = rows.slice(fileOpts.skipRows).filter(r => r.length > 0); // Remove header rows and remove empty ones

                const foundDelimiter = getDelimiter(rows, fileOpts.columns);

                if (foundDelimiter !== fileOpts.delimiter) {
                    logMessage(`‚ùå Unexpected delimiter in file: ${file.name}. Expected '${fileOpts.delimiter}', but found '${foundDelimiter || "none"}'.`);
                    console.warn(`\n‚ùå Unexpected delimiter in file: ${file.name}. Expected '${fileOpts.delimiter}', but found '${foundDelimiter || "none"}'.`);

                    if (!preferFoundDelimiter) {
                        fileCount--;
                        console.info(`‚ùå Skipping file due to delimiter mismatch: ${file.name}`);
                        continue;
                    }
                    fileOpts.delimiter = foundDelimiter;
                }

                if (!fileOpts.delimiter) {
                    logMessage(`‚ùå Delimiter not found in file: ${file.name}`);
                    console.warn(`\n‚ùå Delimiter not found in file: ${file.name}`);
                    fileCount--;
                    console.info(`‚ùå Skipping file due to missing delimiter: ${file.name}`);
                    continue;
                }


                const getters = setupParsers(head, fileOpts, outputsOpts);


                if (Object.keys(outputsOpts).some(k => !getters[k] || getters[k].count() === 0)) {
                    logMessage(`‚ùå Cannot parse required data columns in file: ${file.name}. Check the delimiter and file format.`);
                    console.warn(`\n‚ùå Cannot parse required data columns in file: ${file.name}. Check the delimiter and file format.`);
                    fileCount--;
                    continue;
                }

                if (getters['time'].count() !== 1) {
                    logMessage(`‚ùå Ambiguous time column in file: ${file.name}. Expected exactly one time column, but found ${getters['time'].count()}.`);
                    console.warn(`\n‚ùå Ambiguous time column in file: ${file.name}. Expected exactly one time column, but found ${getters['time'].count()}.`);
                    fileCount--;
                    continue;
                }
                if (getters['position'].count() !== 1) {
                    logMessage(`‚ùå Ambiguous position column in file: ${file.name}. Expected exactly one position column, but found ${getters['position'].count()}.`);
                    console.warn(`\n‚ùå Ambiguous position column in file: ${file.name}. Expected exactly one position column, but found ${getters['position'].count()}.`);
                    fileCount--;
                    continue;
                }

                const getTime = (cells) => getters['time'](cells);
                const getPosition = (cells) => getters['position'](cells);
                const getForce = (cells) => getters['force'](cells);


                rows = rows.map(row => row.split(fileOpts.delimiter)); // Parse CSV lines into an array

                let maxTries = 10;
                let validRowFound = false;

                while (maxTries-- > 0 && rows.length > 0) {
                    const firstRow = rows[0];
                    const values = firstRow.slice(0, 6).map(val => parseFloat(val));

                    if (!firstRow || values.length < 6) {
                        rows.shift();
                        continue;
                    }

                    const allValid = values.every(val => isNum(val));

                    if (allValid) {
                        validRowFound = true;
                        break; // Found a valid row
                    } else {
                        rows.shift(); // Remove the first row
                    }
                }

                if (!validRowFound) {
                    logMessage(`‚ùå No valid data found in file: ${file.name}`);
                    console.warn("\n‚ùå No valid data found in file:", file.name);
                    fileCount--;
                    continue;
                }

                const originalLength = rows.length; // Original number of rows

                const dataSize = rows.length; // Number of rows in one file


                if (dataSize === 0) {
                    logMessage(`‚ùå No data found in file: ${file.name}`);
                    console.warn("\n‚ùå No data found in file:", file.name);
                    fileCount--;
                    continue;
                }

                console.info(file.name, ": üìä Rows in file:", originalLength, "üì¶ Rows to process:", dataSize);


                if (dataSize > mattesMaxLines) {
                    // Data (rows) reduction
                    const step = Math.ceil(dataSize / mattesMaxLines);
                    rows = rows.filter((_, i) => i % step === 0);

                    logMessage(`‚ùó Too many lines in file: ${file.name} (${dataSize} > ${mattesMaxLines})\n\tData (rows) reduction: ${dataSize} -> ${rows.length} lines\n\tData step: ${step}`);
                    console.info(`‚ùó Too many lines in file: ${file.name} (${dataSize} > ${mattesMaxLines})\n\tData (rows) reduction: ${dataSize} -> ${rows.length} lines\n\tData step: ${step}`);
                }


                // ==================== FILES LIST ==================== //

                resultsData.push([
                    fileCount,
                    file.name.replace(/\.csv$/i, ""),
                    expResults.experimentType,
                    expResults.material,
                    expResults.b,
                    expResults.h,
                    expResults.L,
                    expResults.E,
                    expResults.F_max,
                    expResults.w_Fmax,
                    expResults.sigma_max,
                    expResults.F_T,
                    expResults.h_D,
                    expResults.H_BW,
                ]);


                // ================== SAMPLES TABLE ================== //

                samplesTable.push([
                    file.name.replace(/\.csv$/i, ""),   // Code
                    samplesInfo.method,                 // Method (place 3)
                    samplesInfo.W,                      // W (place 0)
                    fileCount,                          // Number (file count)
                    samplesInfo.hw, samplesInfo.lw,     // hw, lw,
                    samplesInfo.ww, samplesInfo.mx,     // ww, mw
                    samplesInfo.h0, samplesInfo.l0,     // h0, l0,
                    samplesInfo.w0, samplesInfo.m0,     // w0, m0
                    samplesInfo.lo                      // lo (empty)
                ]);


                // ================== LOADING DATA ================== //
                // let firstShiftAbove1 = null; // Track first shift where force > 1 N (for deformation calculation)
                const firstTime = getTime(rows[0]); // First time value
                const firstShift = getPosition(rows[0]); // First shift value
                const firstForce = getForce(rows[0]); // First force value

                // Define headers for this section
                let sectionHeader1 = [], sectionHeader2 = [], sectionHeader3 = [], sectionHeader4 = [];
                sectionHeader1[columnOffset] = fileCount; // Section number
                sectionHeader2[columnOffset] = "Measured values from testing machine";
                sectionHeader3[columnOffset] = "Time";
                sectionHeader3[columnOffset + 1] = "Total distance covered by loading pin";
                sectionHeader3[columnOffset + 2] = "Force";
                sectionHeader3[columnOffset + 3] = "Deformation from F > 1N";
                sectionHeader4[columnOffset] = outputsOpts.time.unit;
                sectionHeader4[columnOffset + 1] = outputsOpts.position.unit;
                sectionHeader4[columnOffset + 2] = outputsOpts.force.unit;
                sectionHeader4[columnOffset + 3] = outputsOpts.position.unit;

                // Ensure headers are fully added for every section
                if (formattedData.length === 0) {
                    formattedData.push(sectionHeader1, sectionHeader2, sectionHeader3, sectionHeader4);
                } else {
                    formattedData[0][columnOffset] = sectionHeader1[columnOffset];
                    formattedData[1][columnOffset] = sectionHeader2[columnOffset];
                    formattedData[2][columnOffset] = sectionHeader3[columnOffset];
                    formattedData[3][columnOffset] = sectionHeader4[columnOffset];

                    // Ensure other section headers also extend fully in the new columns
                    for (let i = 0; i < 4; i++) {
                        for (let j = 1; j <= 3; j++) {
                            formattedData[i][columnOffset + j] = [sectionHeader1, sectionHeader2, sectionHeader3, sectionHeader4][i][columnOffset + j];
                        }
                    }
                }

                // Add data to the section
                for (let rowIndex = 0; rowIndex < dataSize; rowIndex++) {
                    const dataRow = formattedData[rowIndex + 3] || [];

                    const entry = rows[rowIndex];
                    if (entry.length >= 6) {
                        if (!entry[0]) continue; // Skip empty rows

                        const time = (getTime(entry) - firstTime) || 0; // Time (s)

                        const force = (getForce(entry) - firstForce) || 0; // Force sum

                        // if (firstShiftAbove1 == null && force >= 1) firstShiftAbove1 = shift; // Save first shift above 1 N

                        const shift = (getForce(entry) - firstShift) || 0; // Displacement (mm)

                        // deformation = (firstShiftAbove1 == null) ? 0 : (shift - firstShiftAbove1); // Calculate deformation
                        const deformation = shift; // Calculate deformation

                        dataRow[columnOffset] = time;
                        dataRow[columnOffset + 1] = shift;
                        dataRow[columnOffset + 2] = force;
                        dataRow[columnOffset + 3] = deformation;
                    }
                    formattedData[rowIndex + 3] = dataRow;
                }

                columnOffset += 5; // Shift by 4 columns + 1 empty column
            }


            if (fileCount === 0 || !isNotEmpty(formattedData)) {
                console.error("\n‚ùå No valid files were processed.");
                alert("‚ùå No valid files were processed. Please check the file formats and try again.");
                return;
            }

            // Create the first sheet with data
            const wsMattes = await XLSX.utils.aoa_to_sheet(formattedData); // Convert data to Excel sheet
            wsMattes["!merges"] = (wsMattes['!merges'] || []);
            // Create the second with file order index
            const wsSamples = await XLSX.utils.aoa_to_sheet(samplesTable, {raw: true});  // Convert data to Excel sheet
            wsSamples["!merges"] = (wsSamples['!merges'] || []); // Merge cells
            // Create the third sheet with file order index
            const wsResults = await XLSX.utils.aoa_to_sheet(resultsData);  // Convert data to Excel sheet


            columnOffset = 0; // Column shift for each section
            for (let f = 0; f < fileCount; f++) {
                wsMattes["!merges"].push({
                    s: {r: 0, c: columnOffset}, e: {r: 0, c: columnOffset + 3} // merge 'fileCount' over 4 columns in line 0
                });
                wsMattes["!merges"].push({
                    s: {r: 1, c: columnOffset}, e: {r: 1, c: columnOffset + 3} // merge "Measured values from testing machine" over 4 columns in line 1
                });
                columnOffset += 5; // Shift by 4 columns + 1 empty column
            }


            wsSamples['!merges'].push(
                {s: {r: 0, c: 0}, e: {r: 2, c: 0}}, // Code
                {s: {r: 0, c: 1}, e: {r: 2, c: 1}}, // Method
                {s: {r: 0, c: 2}, e: {r: 2, c: 2}}, // W
                {s: {r: 0, c: 3}, e: {r: 2, c: 3}}, // Number
                {s: {r: 0, c: 4}, e: {r: 0, c: 7}}, // Dimensions before drying
                {s: {r: 0, c: 8}, e: {r: 0, c: 11}}, // Dimensions after drying
                {s: {r: 0, c: 12}, e: {r: 2, c: 12}} // lo (mm)
            );


            const range = XLSX.utils.decode_range(wsSamples['!ref']); // Get table size

            for (let R = range.s.r; R <= range.e.r; ++R) {
                for (let C = range.s.c; C <= range.e.c; ++C) {
                    const cellAddress = XLSX.utils.encode_cell({r: R, c: C});
                    const cell = wsSamples[cellAddress];
                    if (!cell) continue; // Empty cells

                    cell.s = cell.s || {};

                    // Set cell style
                    cell.s = {
                        font: {
                            bold: R <= 2 // First three line in Bold text (0,1,2)
                        },
                        border: {
                            top: {style: "thin", color: {auto: 1}},
                            bottom: {style: "thin", color: {auto: 1}},
                            left: {style: "thin", color: {auto: 1}},
                            right: {style: "thin", color: {auto: 1}}
                        }
                    };


                    cell.s.alignment = {
                        horizontal: "center",
                        vertical: "center"
                    };

                    // Bold text for the first three lines if the cell is not empty
                    if (R <= 2) {
                        cell.s.font = {bold: true};
                    }
                }
            }

            wsResults['!ref'] = XLSX.utils.encode_range(
                {s: {r: 0, c: 0}, e: {r: resultsData.length - 1, c: HEAD.length - 1}}
            );

            // autofilter p≈ôes hlaviƒçku
            // wsResults['!autofilter'] = {ref: XLSX.utils.encode_range(0, 0, resultsData.length - 1, HEAD.length - 1)};

            wsResults['!cols'] = fitToCols(resultsData, {pad: PAD, min: MIN}); // wsResults['!cols'] = HEAD.map(h => ({wch: Math.max(MIN, h.length + PAD)}));


            setNumFmt(4, "0.00", resultsData, wsResults);      // b (mm)
            setNumFmt(5, "0.00", resultsData, wsResults);      // h (mm)
            setNumFmt(6, "0.00", resultsData, wsResults);      // L (mm)
            setNumFmt(7, "0.000", resultsData, wsResults);     // E (MPa)
            setNumFmt(8, "0.00", resultsData, wsResults);      // F_max (N)
            setNumFmt(9, "0.00", resultsData, wsResults);      // w_Fmax (mm)
            setNumFmt(10, "0.000", resultsData, wsResults);    // œÉ_max (MPa)
            setNumFmt(11, "0.00", resultsData, wsResults);     // F_T (N)
            setNumFmt(12, "0.00", resultsData, wsResults);     // h_D (mm)
            setNumFmt(13, "0.000", resultsData, wsResults);    // H_BW (-)


            XLSX.utils.book_append_sheet(wb, wsMattes, sheetName); // Append a sheet to workbook

            XLSX.utils.book_append_sheet(wb, wsSamples, (sheetName + "-objects").slice(0, 31)); // Append a sheet to workbook

            XLSX.utils.book_append_sheet(wb, wsResults, "File Order"); // Append a sheet to workbook

            // Save the file
            XLSX.writeFile(wb, `${measurementName.slice(0, 31)}.xlsx`);
            console.info("‚úÖ Excel file created.");
        };

        input.click(); // Open the file selection dialog
    }
</script>

<script>
    (() => {
        /* ======= KONFIG ======= */
        const COPY_SELECTOR = '.copyableInput';
        const ADJUST_SELECTOR = '.adjustableInput';
        const LINGER_MS = 1000; // jak dlouho z≈Østane pilulka viditeln√° po akci/opu≈°tƒõn√≠

        /* ======= POMOCN√â FUNKCE (bezpeƒçn√© fallbacky) ======= */
        const normalize = (v) => String(v || '').toLowerCase()
            .replaceAll('\\', '/').replaceAll('.', '').replaceAll(',', '').trim();

        /* ======= GLOB√ÅLN√ç EXKLUZIVITA POSLEDN√ç AKCE ======= */
        let currentActive = null; // { el, btn }

        const cancelFadeListener = (btn) => {
            if (btn._onFadeEnd) {
                btn.removeEventListener('transitionend', btn._onFadeEnd);
                btn._onFadeEnd = null;
            }
        };
        const cancelHideTimer = (btn) => {
            if (btn._hideTimer) {
                clearTimeout(btn._hideTimer);
                btn._hideTimer = null;
            }
        };
        const deactivateCurrent = () => {
            if (!currentActive) return;
            const {el, btn} = currentActive;
            cancelHideTimer(btn);
            cancelFadeListener(btn);
            el.classList.remove('action-ok', 'action-err');
            btn.classList.remove('visible');
            btn.dataset.state = 'idle';
            currentActive = null;
        };

        const setStateExclusive = (el, btn, state) => {
            if (!currentActive || currentActive.btn !== btn) {
                deactivateCurrent();
                currentActive = {el, btn};
            }
            cancelFadeListener(btn);
            btn.dataset.state = state;
            btn.classList.add('visible');
        };

        const checkAdjustBtn = (btn, wrap) => {
            if (!btn) return;
            if (!wrap || !wrap.classList.contains('has-auto')) return;
            if (btn.dataset.state === 'idle' || btn.dataset.state === 'set' || btn.dataset.state === 'diff') {
                const input = wrap.querySelector(ADJUST_SELECTOR);
                if (!input) return;
                const id = input.id || normalize(input.name) || normalize(input.dataset.adjustId);
                if (!id) return;
                const inputValue = input.value;
                const autoValue = adjustRegistryAPI.get(id);
                if (hasValue(autoValue) && hasValue(inputValue)) {
                    if (toNumber(autoValue) === toNumber(inputValue)) {
                        btn.dataset.state = 'set'; // already set
                    } else {
                        btn.dataset.state = 'diff'; // can be set
                    }
                } else {
                    btn.dataset.state = 'idle'; // no auto-value
                }
            }
        };

        const showBtn = (btn, wrap) => {
            cancelHideTimer(btn);
            cancelFadeListener(btn);
            btn.classList.add('visible');
            checkAdjustBtn(btn, wrap);
        };

        const hideBtnLater = (btn) => {
            cancelHideTimer(btn);
            btn._hideTimer = setTimeout(() => {
                btn.classList.remove('visible');
                cancelFadeListener(btn);
                btn._onFadeEnd = (ev) => {
                    if (ev.propertyName === 'opacity') {
                        const op = getComputedStyle(btn).opacity;
                        if (op === '0') {
                            btn.dataset.state = 'idle';
                            cancelFadeListener(btn);
                        }
                    }
                };
                btn.addEventListener('transitionend', btn._onFadeEnd);
            }, LINGER_MS - 100);
        };

        // wand (idle)
        const iconWand = '<svg class="icon-wand" viewBox="0 0 24 24" fill="none" stroke-width="2.75" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"> <path stroke="none" d="M0 0h24v24H0z" fill="none"/> <path d="M4 8v-2a2 2 0 0 1 2 -2h2"/> <path d="M4 16v2a2 2 0 0 0 2 2h2"/> <path d="M16 4h2a2 2 0 0 1 2 2v2"/> <path d="M16 20h2a2 2 0 0 0 2 -2v-2"/> <path d="M9 16v-5.5a2 2 0 1 1 6 0v5.5"/> <path d="M9.5 13h5"/></svg>';
        // Copy (idle)
        const iconCopy = '<svg class="icon-copy" viewBox="0 0 24 24" fill="none" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"> <rect width="13" height="16" x="8" y="7" rx="1.5" ry="1.5"/> <path d="M 3,15.5 V 3.5 C 3,2.7 3.7,2 4.5,2 H 15"/></svg>';
        // check
        const iconOK = '<svg class="icon-check" viewBox="0 0 24 24" fill="none" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"> <path d="M 4.8,13.4 9,17.6 19.6,7"/> </svg>';
        // X
        const iconX = '<svg class="icon-x" viewBox="0 0 24 24" fill="none" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"> <path d="M6 6 L18 18 M18 6 L6 18"/> </svg>';


        /* ======= VYTVO≈òEN√ç WRAPPERU ======= */
        const ensureWrap = (el) => {
            const parent = el.parentElement;
            if (parent && (parent.classList.contains('action-wrap') || parent.classList.contains('copy-wrap'))) {
                // kompatibilita: pokud u≈æ existuje copy-wrap, pov√Ω≈°√≠me ho na action-wrap
                parent.classList.add('action-wrap');
                return parent;
            }
            const wrap = document.createElement('span');
            wrap.className = 'action-wrap';
            el.insertAdjacentElement('beforebegin', wrap);
            wrap.appendChild(el);
            return wrap;
        };

        /* ======= PILULKY ======= */
        const makeCopyButton = () => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'action-pill copy-pill';
            btn.dataset.state = 'idle';
            btn.setAttribute('aria-label', 'Zkop√≠rovat hodnotu');
            btn.title = 'Copy value';
            btn.innerHTML = `${iconCopy} ${iconOK} ${iconX}`;
            return btn;
        };

        const makeAdjustButton = () => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'action-pill adjust-pill';
            btn.dataset.state = 'idle';
            btn.setAttribute('aria-label', 'Automaticky nastavit hodnotu');
            btn.title = 'Set automatic value';
            btn.innerHTML = `${iconWand} ${iconOK} ${iconX}`;
            return btn;
        };

        /* ======= REGISTR AUTO-HODNOT ======= */
        const _registry = {};
        const ensureId = (el, prefix = 'adj') => {
            if (el.id && el.id.trim().length) return el.id;
            const auto = `${prefix}-${Math.random().toString(36).slice(2, 8)}`;
            el.id = auto;
            return auto;
        };

        // ve≈ôejn√© API
        const adjustRegistryAPI = {
            get(id) {
                return _registry[id];
            },
            set(id, value) {
                _registry[id] = value;
                refreshAdjustButtonsFor(id); // UI refresh jen pro dan√Ω input
            },
            all() {
                return Object.assign({}, _registry);
            }
        };
        window.adjustRegistry = adjustRegistryAPI;        // ƒçti/zapisuj p≈ôes metody

        window.adjustSet = (id, v) => {
            const el = $$$(id);
            const val = toNumber(v);

            if (!hasValue(el.value) && isNum(val)) blinkBorder(el, {
                restart: true,
                color: '#2196F3',
                backgroundOn: '#a7e7ff',
                blinks: 3,
            });

            else if (isNum(val) && val === toNumber(el.value)) blinkBorder(el, {
                restart: true,
                color: '#4CAF50',
                backgroundOn: '#a9ffa9',
                blinks: 3,
            });

            else if (isNum(val) && val !== adjustGet(id)) blinkBorder(el, {restart: true});

            else if (!isNum(val) && isNum(adjustGet(id))) blinkBorder(el, {
                restart: true,
                color: '#DC143C',
                backgroundOn: '#ffaeb9',
                blinks: 3,
            });

            adjustRegistryAPI.set(id, val);
        };
        window.adjustGet = (id) => adjustRegistryAPI.get(id);
        window.adjustDel = (id) => {
            if (adjustRegistryAPI.get(id) !== undefined) {
                adjustRegistryAPI.set(id, NaN);
            }
        };

        /* ======= VAZBA ID -> tlaƒç√≠tko pro rychl√Ω refresh ======= */
        const idToAdjustBtn = new Map();

        const refreshAdjustButtonsFor = (id) => {
            const btn = idToAdjustBtn.get(id);
            if (!btn) return;
            const val = adjustRegistryAPI.get(id);
            const valid = !isInvalidValue(val);

            const input = $$$(id);
            const wrap = input?.closest('.action-wrap');

            if (valid) {
                btn.classList.remove('hidden');
                wrap?.classList.add('has-auto');
                checkAdjustBtn(btn, wrap);
            } else {
                btn.classList.add('hidden');
                btn.dataset.state = 'idle';
                wrap?.classList.remove('has-auto');
            }
        };

        // window.adjustRefresh = () => idToAdjustBtn.forEach((_, id) => refreshAdjustButtonsFor(id));

        /* ======= KOP√çROVAC√ç LOGIKA ======= */
        const bindCopy = (wrap, el) => {
            const btn = makeCopyButton();
            wrap.appendChild(btn);

            const copyValue = async () => {
                let ok = false;
                const val = (el.value || el.textContent || '').toString().trim();
                try {
                    if (!hasValue(val)) throw new Error('Empty');
                    const testVal = normalize(val);
                    if (!isInvalidValue(testVal)) {
                        await navigator.clipboard.writeText(val);
                        ok = true;
                    }
                } catch {
                    try {
                        if (el.select) {
                            const s = el.selectionStart, e = el.selectionEnd;
                            el.focus();
                            el.select();
                            ok = document.execCommand('copy');
                            if ((s != null && e != null) && (s <= e) && e !== 0) {
                                el.setSelectionRange(s, e);
                                ok = true;
                            } else {
                                ok = false;
                            }
                            el.blur();
                        }
                    } catch {
                        ok = false;
                    }
                } finally {
                    el.classList.remove('action-err', 'action-ok');
                    if (ok) {
                        el.classList.add('action-ok');
                        setStateExclusive(el, btn, 'ok');
                    } else {
                        el.classList.add('action-err');
                        setStateExclusive(el, btn, 'err');
                    }
                    setTimeout(() => {
                        el.classList.remove('action-ok', 'action-err');
                        btn.dataset.state = 'idle';
                    }, LINGER_MS);
                    hideBtnLater(btn);
                }
            };

            wrap.addEventListener('mouseenter', () => showBtn(btn, wrap));
            wrap.addEventListener('mouseleave', () => hideBtnLater(btn));
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                copyValue();
            });
            el.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || (e.ctrlKey && e.key.toLowerCase() === 'c')) {
                    e.preventDefault();
                    showBtn(btn, wrap);
                    copyValue();
                }
            });
        };

        /* ======= NASTAVOVAC√ç LOGIKA (.adjustableInput) ======= */
        const bindAdjust = (wrap, el) => {
            const id = ensureId(el);
            if (!(_registry).hasOwnProperty(id)) _registry[id] = NaN; // init registru

            const btn = makeAdjustButton();
            idToAdjustBtn.set(id, btn);
            wrap.appendChild(btn);

            el.addEventListener('input', () => checkAdjustBtn(btn, wrap));

            const applyValue = () => {
                const raw = adjustRegistryAPI.get(id);
                const valid = !isInvalidValue(raw);
                if (!valid) {
                    // ikona se nem√° zobrazit ani nic vkl√°dat
                    btn.classList.add('hidden');
                    btn.dataset.state = 'idle';
                    return false;
                }
                const str = String(raw);
                // vlo≈æit
                try {
                    const prev = {s: el.selectionStart, e: el.selectionEnd};
                    el.value = str;
                    // vyvolat standardn√≠ eventy
                    el.dispatchEvent(new Event('input', {bubbles: true}));
                    el.dispatchEvent(new Event('change', {bubbles: true}));
                    // navr√°tit caret pokud d√°v√° smysl
                    if (prev.s != null && prev.e != null && el.setSelectionRange) {
                        const end = str.length;
                        el.setSelectionRange(end, end);
                    }
                    btn.dataset.state = 'set';
                    return true;
                } catch {
                    return false;
                }
            };

            const doAdjust = () => {
                const ok = applyValue();
                el.classList.remove('action-ok', 'action-err');
                blinkBorder.stop(el);
                if (ok) {
                    el.classList.add('action-ok');
                    setStateExclusive(el, btn, 'ok');
                } else {
                    el.classList.add('action-err');
                    setStateExclusive(el, btn, 'err');
                }
                setTimeout(() => {
                    el.classList.remove('action-ok', 'action-err');
                    btn.dataset.state = 'idle';
                    refreshAdjustButtonsFor(id); // po animaci znovu zhodnotit viditelnost
                }, LINGER_MS);
                hideBtnLater(btn);
            };

            // poƒç√°teƒçn√≠ viditelnost dle registru
            refreshAdjustButtonsFor(id);

            // interakce
            wrap.addEventListener('mouseenter', () => showBtn(btn, wrap));
            wrap.addEventListener('mouseleave', () => hideBtnLater(btn));
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                doAdjust();
            });
            el.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    showBtn(btn, wrap);
                    doAdjust();
                }
            });
        };

        /* ======= SCAN & INIT ======= */
        const setupOne = (el) => {
            const wrap = ensureWrap(el);
            // Pokud je to copyable, p≈ôidej copy pilulku
            if (el.matches(COPY_SELECTOR) && !wrap.querySelector('.copy-pill')) bindCopy(wrap, el);
            // Pokud je to adjustable, p≈ôidej adjust pilulku
            if (el.matches(ADJUST_SELECTOR) && !wrap.querySelector('.adjust-pill')) bindAdjust(wrap, el);
        };

        const scan = () => {
            $$(`${COPY_SELECTOR}, ${ADJUST_SELECTOR}`)?.forEach(setupOne);
        };

        // Ve≈ôejn√© API pro dynamick√© DOM zmƒõny
        window.adjustScan = scan;

        // INIT
        scan();

    })
    ();
</script>


<script>

    // ==========================
    // Jednotky, prefixy, parser
    // ==========================

    // --- Rozmƒõry a operace ---
    const ZERO = [0, 0, 0, 0, 0, 0, 0]; // L, M, T, I, Œò, N, J
    const DIMS = {L: 0, M: 1, T: 2, I: 3, Th: 4, N: 5, J: 6};

    const dim = (...d) => d;
    const addDim = (a, b) => a.map((v, i) => v + b[i]);
    const mulDim = (a, k) => a.map(v => v * k);
    const sameDim = (a, b) => a.every((v, i) => v === b[i]);

    // --- SI p≈ôedpony (vƒç. '¬µ' a fallback 'u') ---
    const PREFIX = new Map(Object.entries({
        Y: 1e24, Z: 1e21, E: 1e18, P: 1e15, T: 1e12, G: 1e9, M: 1e6,
        k: 1e3, h: 1e2, da: 1e1,
        d: 1e-1, c: 1e-2, m: 1e-3, u: 1e-6, '¬µ': 1e-6,
        n: 1e-9, p: 1e-12, f: 1e-15, a: 1e-18, z: 1e-21, y: 1e-24
    }));

    // --- Textov√© p≈ôedpony (slova) ‚Üí symbol p≈ôedpony ---
    const TEXT_PREFIX_ALIASES = new Map(Object.entries({
        yotta: 'Y', zetta: 'Z', exa: 'E', peta: 'P', tera: 'T',
        giga: 'G', mega: 'M', kilo: 'k', hecto: 'h', deka: 'da', deca: 'da',
        deci: 'd', centi: 'c', milli: 'm', micro: 'u', nano: 'n',
        pico: 'p', femto: 'f', atto: 'a', zepto: 'z', yocto: 'y'
    }));

    // --- Datab√°ze jednotek ---
    const UNITS = new Map(); // sym -> { dim, factor }
    const def = (sym, dimv, factor = 1) => UNITS.set(sym, {dim: dimv, factor});

    /* Z√°kladn√≠ SI + p√°r bƒõ≈æn√Ωch */
    def('m', dim(1, 0, 0, 0, 0, 0, 0));
    def('s', dim(0, 0, 1, 0, 0, 0, 0));
    def('A', dim(0, 0, 0, 1, 0, 0, 0));
    def('K', dim(0, 0, 0, 0, 1, 0, 0));
    def('mol', dim(0, 0, 0, 0, 0, 1, 0));
    def('cd', dim(0, 0, 0, 0, 0, 0, 1));

    def('kg', dim(0, 1, 0, 0, 0, 0, 0), 1);
    def('g', dim(0, 1, 0, 0, 0, 0, 0), 1e-3); // 1 g = 1e-3 kg

    // ƒåasov√© zkratky
    def('min', dim(0, 0, 1, 0, 0, 0, 0), 60);
    def('h', dim(0, 0, 1, 0, 0, 0, 0), 3600);

    // Odvozen√© (faktor 1, jen dimenze)
    const mD = UNITS.get('m').dim;
    const sD = UNITS.get('s').dim;
    const AD = UNITS.get('A').dim;
    const kgD = UNITS.get('kg').dim;
    const cdD = UNITS.get('cd').dim;

    const HzD = mulDim(sD, -1);
    def('Hz', HzD, 1);

    const ND = addDim(kgD, addDim(mD, mulDim(sD, -2)));
    def('N', ND, 1);

    const PaD = addDim(ND, mulDim(mD, -2));
    def('Pa', PaD, 1);

    const JD = addDim(ND, mD);
    def('J', JD, 1);

    const WD = addDim(JD, mulDim(sD, -1));
    def('W', WD, 1);

    const VD = addDim(WD, mulDim(AD, -1));
    def('V', VD, 1);

    // C, F, Œ©/ohm, T, lx
    const CD = addDim(AD, sD);
    def('C', CD, 1);

    const FD = addDim(CD, mulDim(VD, -1));
    def('F', FD, 1);

    const OhmD = addDim(VD, mulDim(AD, -1));
    def('Œ©', OhmD, 1);
    def('ohm', OhmD, 1);
    def('Ohm', OhmD, 1);

    const TD = addDim(ND, addDim(mulDim(AD, -1), mulDim(mD, -1)));
    def('T', TD, 1);

    // Lux = cd / m^2
    const lxD = addDim(cdD, mulDim(mD, -2));
    def('lx', lxD, 1);

    // Bezrozmƒõrn√© pomocn√©
    def('1', ZERO.slice(), 1);
    def('%', ZERO.slice(), 0.01);
    def('‚Ä∞', ZERO.slice(), 0.001);
    def('ppm', ZERO.slice(), 1e-6);
    def('ppb', ZERO.slice(), 1e-9);

    // Den, t√Ωden, mƒõs√≠c(30d), rok(365d)
    const SECONDS_PER_DAY = 24 * 60 * 60;
    def('d', dim(0, 0, 1, 0, 0, 0, 0), SECONDS_PER_DAY);
    def('day', dim(0, 0, 1, 0, 0, 0, 0), SECONDS_PER_DAY);
    def('wk', dim(0, 0, 1, 0, 0, 0, 0), 7 * SECONDS_PER_DAY);
    def('week', dim(0, 0, 1, 0, 0, 0, 0), 7 * SECONDS_PER_DAY);
    def('mo', dim(0, 0, 1, 0, 0, 0, 0), 30 * SECONDS_PER_DAY);
    def('month', dim(0, 0, 1, 0, 0, 0, 0), 30 * SECONDS_PER_DAY);
    def('yr', dim(0, 0, 1, 0, 0, 0, 0), 365 * SECONDS_PER_DAY);
    def('year', dim(0, 0, 1, 0, 0, 0, 0), 365 * SECONDS_PER_DAY);

    // Teploty ‚Äì symbolick√©; afinn√≠ p≈ôevod ≈ôe≈°√≠ convertUnits
    def('degC', UNITS.get('K').dim, 1); // ¬∞C
    def('degF', UNITS.get('K').dim, 1); // ¬∞F

    // Seznam symbol≈Ø (nejdel≈°√≠ nap≈ôed)
    let UNIT_SYMBOLS = Array.from(UNITS.keys()).sort((a, b) => b.length - a.length);

    // --- Textov√© aliasy jednotek (plur√°ly, n√°zvy, p≈ôeklepy) ‚Üí kanonick√© symboly ---
    const TEXT_UNIT_ALIASES = new Map(Object.entries({
        // ƒças
        sec: 's', secs: 's', second: 's', seconds: 's',
        mins: 'min', minute: 'min', minutes: 'min',
        hr: 'h', hrs: 'h', hour: 'h', hours: 'h',
        day: 'd', days: 'd',
        wks: 'wk', week: 'wk', weeks: 'wk',
        mos: 'mo', month: 'mo', months: 'mo',
        yrs: 'yr', year: 'yr', years: 'yr',

        // d√©lka / hmota
        meter: 'm', meters: 'm', metre: 'm', metres: 'm',
        gram: 'g', grams: 'g',

        // z√°kladn√≠ SI
        ampere: 'A', amperes: 'A',
        kelvin: 'K',
        mole: 'mol', moles: 'mol',
        candela: 'cd',

        // odvozen√©
        newton: 'N', newtons: 'N',
        pascal: 'Pa', pascals: 'Pa',
        joule: 'J', joules: 'J',
        watt: 'W', watts: 'W',
        volt: 'V', volts: 'V',
        coulomb: 'C', coulombs: 'C',
        farad: 'F', farads: 'F',
        ohm: 'ohm', ohms: 'ohm', Ohm: 'ohm',
        tesla: 'T', teslas: 'T',
        lux: 'lx',

        // teploty (text)
        celsius: 'degC', 'degree celsius': 'degC', degreecelsius: 'degC', 'degrees celsius': 'degC',
        fahrenheit: 'degF', 'degree fahrenheit': 'degF', degreefahrenheit: 'degF', 'degrees fahrenheit': 'degF'
    }));

    const TEXT_UNIT_TYPO_ALIASES = new Map(Object.entries({
        secnd: 's', minut: 'min', houer: 'h',
        gramm: 'g',
        nevtonn: 'N', newtonn: 'N', newtons: 'N',
        pascalss: 'Pa', jouless: 'J', wattss: 'W', voltss: 'V',
        coulombss: 'C', faradss: 'F', teslass: 'T',
        luxx: 'lx', luxes: 'lx',
        metre: 'm', metres: 'm' // (duplicitnƒõ pro jistotu)
    }));

    // --- Normalizace vstupu p≈ôed parsov√°n√≠m ---
    // 1) nahrad√≠ ¬∞C/¬∞F ‚Üí degC/degF
    // 2) nahrad√≠ textov√© p≈ôedpony & jednotky & p≈ôeklepy
    // 3) slep√≠ "<prefix><mezera><unit>" ‚Üí "<prefix><unit>" (nap≈ô. "k m" ‚Üí "km")
    function normalizeUnitsString(input) {
        if (input == null) return input;
        let s = String(input);

        // ¬∞C / ¬∞F ‚Üí degC / degF
        s = s.replace(/¬∞\s*[cC]/g, 'degC')
            .replace(/¬∞\s*[fF]/g, 'degF');

        const replaceWordMap = (map) => {
            const keys = Array.from(map.keys()).sort((a, b) => b.length - a.length);
            for (const k of keys) {
                const re = new RegExp(`\\b${k}\\b`, 'gi');
                s = s.replace(re, map.get(k));
            }
        };

        // nejd≈ô√≠v slova-p≈ôedpony, pak jednotky a p≈ôeklepy
        replaceWordMap(TEXT_PREFIX_ALIASES);
        replaceWordMap(TEXT_UNIT_ALIASES);
        replaceWordMap(TEXT_UNIT_TYPO_ALIASES);

        // slep "prefix symbol"+"mezera"+"unit" ‚Üí "prefix+unit"
        const prefixSymbols = ['Y', 'Z', 'E', 'P', 'T', 'G', 'M', 'k', 'h', 'da', 'd', 'c', 'm', 'u', '¬µ', 'n', 'p', 'f', 'a', 'z', 'y'];
        for (const pre of prefixSymbols) {
            for (const u of UNIT_SYMBOLS) {
                if (u === 'kg') continue; // kg je speci√°l
                const re = new RegExp(`\\b${pre}\\s+${u}\\b`, 'g');
                s = s.replace(re, `${pre}${u}`);
            }
        }

        return s;
    }

    // --- Parser jednotkov√©ho v√Ωrazu ---
    function parseUnitExpr(input) {
        if (!input || String(input).trim() === '' || input === '1') {
            return {dim: ZERO.slice(), factor: 1};
        }

        // normalizace
        let s = normalizeUnitsString(input);

        s = String(s)
            .replace(/[¬∑‚ãÖ‚Ä¢√ó]/g, '*')
            .replace(/[‚Äì‚Äî‚àí]/g, '-')   // r≈Øzn√© minusy
            .replace(/\s+/g, '*')     // mezery jako n√°soben√≠
            .replace(/[()]/g, '');    // bez z√°vorek

        const parts = s.split('/');
        let acc = {dim: ZERO.slice(), factor: 1};

        parts.forEach((segment, idx) => {
            const sign = (idx === 0) ? +1 : -1; // ƒçitatel / jmenovatel
            const tokens = segment.split('*').filter(Boolean);
            tokens.forEach(tok => {
                const {dim, factor} = parseUnitToken(tok);
                acc.dim = addDim(acc.dim, mulDim(dim, sign));
                acc.factor *= Math.pow(factor, sign);
            });
        });

        return acc;
    }

    function parseUnitToken(tok) {
        let t = String(tok).trim();
        if (!t) throw new Error(`Invalid unit token: "${tok}"`);
        let exp = 1;

        // exponent ^{...} nebo ^...
        const mPow = t.match(/\^(?:\{([^}]+)\}|(.+))$/);
        if (mPow) {
            const raw = (mPow[1] || mPow[2]).trim();
            exp = parseInt(raw, 10);
            t = t.slice(0, mPow.index);
            if (!Number.isInteger(exp)) throw new Error(`Invalid exponent: "${raw}"`);
        }

        // unicode mocniny
        t = t.replace(/¬≤/g, '^2').replace(/¬≥/g, '^3');
        if (exp === 0) return {dim: ZERO.slice(), factor: 1};
        if (t === '1') return {dim: ZERO.slice(), factor: 1};

        // speci√°l: "kg" ‚Äì nesm√≠ se rozpadnout na k + g
        if (t === 'kg') {
            return {dim: mulDim(UNITS.get('kg').dim, exp), factor: 1};
        }

        // nejdel≈°√≠ zn√°m√Ω symbol jednotky jako sufix
        const unit = UNIT_SYMBOLS.find(u => t.endsWith(u));
        if (!unit) throw new Error(`Unknown unit: "${t}"`);

        const base = UNITS.get(unit);
        if (!base) throw new Error(`Unit "${unit}" is not supported`);

        const prefixStr = t.slice(0, t.length - unit.length);
        let pf = 1;
        if (prefixStr) {
            pf = PREFIX.get(prefixStr);
            if (pf == null && prefixStr === 'da') pf = 10; // fallback
            if (pf == null) throw new Error(`Unknown prefix: "${prefixStr}" in "${tok}"`);
        }

        return {
            dim: mulDim(base.dim, exp),
            factor: Math.pow(base.factor * pf, exp)
        };
    }

    // --- Teplotn√≠ helpery (ƒçist√© teploty jen) ---
    const isPureTempUnit = (u) => {
        const s = String(u).trim();
        return s === 'K' || s === 'degC' || s === 'degF';
    };
    const toKelvin = (value, sym) => {
        switch (sym) {
            case 'K':
                return value;
            case 'degC':
                return value + 273.15;
            case 'degF':
                return (value - 32) * (5 / 9) + 273.15;
            default:
                throw new Error(`Unsupported temperature unit: ${sym}`);
        }
    };
    const fromKelvin = (valueK, sym) => {
        switch (sym) {
            case 'K':
                return valueK;
            case 'degC':
                return valueK - 273.15;
            case 'degF':
                return (valueK - 273.15) * (9 / 5) + 32;
            default:
                throw new Error(`Unsupported temperature unit: ${sym}`);
        }
    };

    // --- Ve≈ôejn√© API: konverze hodnoty mezi jednotkami ---
    function convertUnits(value, fromUnit, toUnit) {
        const fNorm = normalizeUnitsString(fromUnit);
        const tNorm = normalizeUnitsString(toUnit);

        const fIsTemp = isPureTempUnit(fNorm);
        const tIsTemp = isPureTempUnit(tNorm);

        if (fIsTemp || tIsTemp) {
            // afinn√≠ p≈ôevod sm√≠ b√Ωt jen mezi ƒçist√Ωmi teplotami
            if (!(fIsTemp && tIsTemp)) {
                throw new Error(`Temperature units cannot be combined with other units: "${fromUnit}" ‚Üí "${toUnit}"`);
            }
            const k = toKelvin(value, fNorm);
            return fromKelvin(k, tNorm);
        }

        const a = parseUnitExpr(fNorm);
        const b = parseUnitExpr(tNorm);
        if (!sameDim(a.dim, b.dim)) {
            throw new Error(`Noncompatible units: "${fromUnit}" vs "${toUnit}"`);
        }
        return value * (a.factor / b.factor);
    }

    // ==========================
    // TESTY & V√ùPIS DO KONZOLE
    // ==========================
    // function runTests() {
    //     console.log('--- TEST: ¬∞C / ¬∞F / K ---');
    //     console.log('normalize "¬∞C" ->', normalizeUnitsString('¬∞C')); // oƒçek√°v√°me "degC"
    //     console.log('normalize "¬∞F" ->', normalizeUnitsString('¬∞F')); // oƒçek√°v√°me "degF');
    //
    //     const tC = 25;
    //     console.log(`25 ¬∞C -> K: `, convertUnits(tC, '¬∞C', 'K'));     // 298.15
    //     console.log(`25 ¬∞C -> ¬∞F:`, convertUnits(tC, '¬∞C', '¬∞F'));    // 77
    //     console.log(`300 K -> ¬∞C:`, convertUnits(300, 'K', 'degC'));  // 26.85
    //     console.log(`77 ¬∞F -> ¬∞C:`, convertUnits(77, 'degF', 'degC')); // 25
    //
    //     console.log('\n--- TEST: textov√© n√°zvy & p≈ôeklepy ---');
    //     console.log('normalize "seconds" ->', normalizeUnitsString('seconds')); // s
    //     console.log('normalize "metres"  ->', normalizeUnitsString('metres'));  // m
    //     console.log('normalize "gramm"   ->', normalizeUnitsString('gramm'));   // g
    //     console.log('normalize "nevtonn" ->', normalizeUnitsString('nevtonn')); // N
    //
    //     console.log('\n--- TEST: textov√© p≈ôedpony ---');
    //     console.log('normalize "kilo meter" ->', normalizeUnitsString('kilo meter')); // km
    //     console.log('parse "kilo meter / second" == "km/s":',
    //         JSON.stringify(parseUnitExpr('kilo meter / second')) === JSON.stringify(parseUnitExpr('km/s'))
    //     );
    //
    //     console.log('\n--- TEST: bƒõ≈æn√© SI konverze ---');
    //     console.log('1 km -> m:', convertUnits(1, 'km', 'm'));           // 1000
    //     console.log('500 g -> kg:', convertUnits(500, 'g', 'kg'));       // 0.5
    //     console.log('1 N¬∑m -> J:', convertUnits(1, 'N*m', 'J'));         // 1
    //     console.log('1 Pa -> N/m^2:', convertUnits(1, 'Pa', 'N/m^2'));   // 1
    //
    //     console.log('\n--- TEST: chybov√© stavy ---');
    //     try {
    //         console.log('degC/s ‚Üí K/s (nemƒõlo by proj√≠t):', convertUnits(1, 'degC/s', 'K/s'));
    //     } catch (e) {
    //         console.log('Oƒçek√°van√° chyba (afinn√≠ teplota v pomƒõru):', e.message);
    //     }
    //     try {
    //         console.log('nezn√°m√° jednotka:', convertUnits(1, 'smurf', 'm'));
    //     } catch (e) {
    //         console.log('Oƒçek√°van√° chyba (unknown unit):', e.message);
    //     }
    //
    //
    //     convertUnits(2, 'min', 's');             // 120
    //     convertUnits(1, 'h', 'min');             // 60
    //
    //     convertUnits(1, 'mV/V', '1');            // 0.001  (bezrozmƒõrn√©)
    //     convertUnits(1, 'mV/V', '%');            // 0.1    (%)
    //     convertUnits(2.5, 'mV/V', '‚Ä∞');          // 2.5    (promile)
    //     convertUnits(500, 'ppm', '%');           // 0.05
    //
    //     convertUnits(1, 'kŒ©', 'ohm');            // 1000
    //     convertUnits(1, 'mA', 'A');              // 0.001
    //     convertUnits(1, 'C', 'A*s');             // 1
    //     convertUnits(1, 'F', 'C/V');             // 1
    //     convertUnits(1, 'T', 'N/(A*m)');         // 1
    //     convertUnits(1, 'lx', 'cd/m^2');         // 1
    //
    //     convertUnits(2, 'mm/min', 'mm/s');
    //     convertUnits(2.5, 'mV/GV', 'GV/mV');
    //     convertUnits(4, 'mV/V', 'MV/GV');
    //     convertUnits(4, 'mV/V', 'GV/GV');
    //     convertUnits(4, 'mm^2', 'cm^2');
    //     convertUnits(4, '¬µm^4', 'm^4');
    //     convertUnits(4, '¬µm^4', 'm^4');
    //
    //     convertUnits(1, 'd', 's');           // 86400
    //     convertUnits(2, 'wk', 'd');          // 14
    //     convertUnits(60, 'mo', 'd');         // 1800 (2 mƒõs√≠ce po 30 dnech)
    //     convertUnits(1, 'yr', 'h');          // 365 * 24 = 8760
    //     convertUnits(1, 'km/yr', 'm/d');      // ‚âà 0.27778 (beze zmƒõny)
    //     convertUnits(1, 'mm/wk', 'mm/day');   // 60
    //
    //     convertUnits(1, 'N', 'kg*m/s^2');     // 1
    //     convertUnits(10, 'N', 'kN');          // 0.01
    //
    //     convertUnits(1, 'J', 'N*m');          // 1
    //     convertUnits(1, 'J', 'kg*m^2/s^2');   // 1
    //     convertUnits(500, 'kJ', 'MJ');        // 0.5
    //
    //     convertUnits(1, 'W', 'J/s');          // 1
    //     convertUnits(2.5, 'kW', 'W');         // 2500
    //     convertUnits(1, 'W', 'kg*m^2/s^3');   // 1
    // }

</script>

<script>

</script>

</body>
</html>
