<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP Firmware Update</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            max-width: 800px;
            width: 100%;
            padding: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .connection-section {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .chip-info-section {
            background: #f0f8ff;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid #4a90e2;
            display: none;
        }

        .chip-info-section.active {
            display: block;
        }

        .chip-info-section h3 {
            color: #2c5aa0;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .boot-mode-indicator {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }

        .boot-mode-indicator.boot {
            background: #d4edda;
            color: #155724;
        }

        .boot-mode-indicator.normal {
            background: #fff3cd;
            color: #856404;
        }

        .boot-mode-indicator.unknown {
            background: #f8d7da;
            color: #721c24;
        }

        .info-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 6px;
            overflow: hidden;
        }

        .info-table tr {
            border-bottom: 1px solid #e0e0e0;
        }

        .info-table tr:last-child {
            border-bottom: none;
        }

        .info-table td {
            padding: 10px 15px;
        }

        .info-table td:first-child {
            font-weight: 600;
            color: #555;
            width: 180px;
            background: #f8f9fa;
        }

        .info-table td:last-child {
            color: #333;
            font-family: 'Courier New', monospace;
        }

        .file-section {
            margin-bottom: 20px;
        }

        .version-selector {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid #dcdcdc;
        }

        .version-selector h4 {
            margin-bottom: 10px;
            color: #6c6c6c;
        }

        #versionSelectWrapper {
            margin-bottom: 10px;
        }

        .custom-file-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .custom-file-actions.hidden {
            display: none;
        }

        .file-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid #e0e0e0;
            transition: all 0.3s;
        }

        .file-item.active {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .file-item.valid {
            border-color: #27ae60;
            background: #e8f8f0;
        }

        .file-item.invalid {
            border-color: #e74c3c;
            background: #fdecea;
        }


        .file-item.empty {
            border-color: #f39c12;
            background: #fef5e7;
        }

        .file-item.ignored {
            opacity: 0.6 !important;
            border-color: #95a5a6 !important;;
            background: #ecf0f1 !important;;
        }

        .file-item.hidden {
            display: none;
        }

        .file-header {
            display: flex;
            align-items: center;
        }

        .file-header input[type="checkbox"] {
            margin-right: 10px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .file-header label {
            font-weight: 600;
            color: #333;
            cursor: pointer;
            flex: 1;
            align-self: baseline;
            margin-bottom: 0;
        }

        .validation-badge {
            display: none;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 10px;
        }

        .validation-badge.show {
            display: inline-block;
        }

        .validation-badge.valid {
            background: #d4edda;
            color: #155724;
        }

        .validation-badge.invalid {
            background: #f8d7da;
            color: #721c24;
        }

        .validation-badge.ignored {
            background: #e2e3e5 !important;;
            color: #383d41 !important;;
        }

        .file-info {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            font-size: 12px;
            color: #555;
        }

        .file-info.show {
            display: block;
        }

        .file-info-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .file-info-row:last-child {
            border-bottom: none;
        }

        .file-info-label {
            font-weight: 600;
            color: #666;
        }

        .file-info-value {
            font-family: 'Courier New', monospace;
            color: #333;
        }

        .file-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 500;
            color: #555;
            margin-bottom: 5px;
            font-size: 14px;

            pointer-events: none;
            cursor: default;
        }

        input[type="text"],
        input[type="file"],
        select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus,
        input[type="file"]:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        input[type="file"] {
            padding: 8px;
            cursor: pointer;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:disabled {
            opacity: 0.5 !important;
            cursor: not-allowed !important;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
        }

        .btn:active:not(:disabled) {
            transform: none;
            box-shadow: none;
        }


        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #5568d3;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:active:not(:disabled) {
            background: #364179;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #7f8c8d;
            box-shadow: 0 5px 15px rgba(149, 165, 166, 0.3);
        }

        .btn-secondary:active:not(:disabled) {
            background: #606e6f;
        }

        .btn-third {
            background: #8e44ad;
            color: white;
        }

        .btn-third:hover:not(:disabled) {
            background: #732d91;
            box-shadow: 0 5px 15px rgba(142, 68, 173, 0.3);
        }

        .btn-third:active:not(:disabled) {
            background: #5e216f;
        }

        .btn-fourth {
            background: #16a085;
            color: white;
        }

        .btn-fourth:hover:not(:disabled) {
            background: #138d75;
            box-shadow: 0 5px 15px rgba(22, 160, 133, 0.3);
        }

        .btn-fourth:active:not(:disabled) {
            background: #0e6655;
        }

        .btn-fifth {
            background: #f57c00;
            color: white;
        }

        .btn-fifth:hover:not(:disabled) {
            background: #ff9800;
            box-shadow: 0 5px 15px rgba(245, 124, 0, 0.3);
        }

        .btn-fifth:active:not(:disabled) {
            background: #e65100;
        }

        .btn-sixth {
            background: #d35400;
            color: white;
        }

        .btn-sixth:hover:not(:disabled) {
            background: #ba4a00;
            box-shadow: 0 5px 15px rgba(211, 84, 0, 0.3);
        }

        .btn-sixth:active:not(:disabled) {
            background: #873600;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #c0392b;
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
        }

        .btn-danger:active:not(:disabled) {
            background: #922b21;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #229954;
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.3);
        }

        .btn-success:active:not(:disabled) {
            background: #1e8449;
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover:not(:disabled) {
            background: #e67e22;
            box-shadow: 0 5px 15px rgba(243, 156, 18, 0.3);
        }

        .btn-warning:active:not(:disabled) {
            background: #b9770e;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .log-section {
            color: #d4d4d4;
            margin-top: 30px;
            margin-bottom: 20px;
            background: #1e1e1e;
            border: 1px solid #3c3c3c;
            border-radius: 8px;
            overflow: hidden;
        }

        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 15px 5px 10px;

            background: #2d2d30;
            border-bottom: 1px solid #3c3c3c;
            font-weight: bold;
        }

        .input-container {
            display: flex;
            border-top: 1px solid #3c3c3c;
            background: #2d2d30;
        }

        .input-container input {
            flex: 1;
            margin: 0;
            padding: 10px;
            border: none;
            border-radius: 0;
            color: #d4d4d4;
            font-size: 14px;
        }

        .input-container input::placeholder {
            color: #d4d4d4;
            opacity: 1;
        }

        .input-container input:disabled {
            opacity: 0.5 !important;
            cursor: not-allowed !important;
        }

        .input-container .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 0;
            background: #667eea;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .input-container .btn:hover:not(:disabled) {
            background: #5568d3;
            box-shadow: none;
            transform: none;
        }

        .input-container .btn:active:not(:disabled) {
            background: #364179;
            box-shadow: none;
            transform: none;
        }


        .log-wrapper {
            padding: 0 7px 10px 5px;
            height: 300px;
            overflow: hidden;
        }

        .log-container {
            padding: 0 15px 0 10px;
            height: 100%;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
        }

        .log-container::-webkit-scrollbar {
            width: 10px;
        }

        .log-container::-webkit-scrollbar-track {
            background: #323232;
            border-radius: 5px;
        }

        .log-container::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 5px;
        }

        .log-container::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        .log-container::-webkit-scrollbar-thumb:active {
            background: #999;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 3px 0;
            color: #d4d4d4;
        }

        .log-entry.info {
            color: #4ec9b0;
        }

        .log-entry.error {
            color: #f48771;
        }

        .log-entry.success {
            color: #89d185;
        }

        .log-entry.taken {
            color: #a3bffa;
        }

        .log-entry.accepted {
            color: #667eea;
        }

        .log-entry.valid {
            color: #2196f3;
        }

        .log-entry.warning {
            color: #dcdcaa;
        }

        .log-entry.machineIn {
            color: #c586c0;
        }

        .log-entry.machineOut {
            color: #ce9178;
        }

        .progress-section {
            margin-top: 15px;
            display: none;
        }

        .progress-section.active {
            display: block;
        }

        .progress-bar-container {
            background: #e0e0e0;
            border-radius: 10px;
            height: 30px;
            position: relative;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-bar {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            width: 0;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-text-inner {
            color: white;
            font-size: 14px;
            padding: 0 10px;
            white-space: nowrap;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-weight: bold;
            transition: opacity 0.2s;
        }

        .progress-text-outer-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            pointer-events: none;
        }

        .progress-text-outer {
            position: absolute;
            left: 100%;
            color: #333;
            font-size: 14px;
            padding-left: 10px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            height: 100%;
            font-weight: bold;
        }

        /* When text doesn't fit inside, hide inner and show outer */
        .progress-bar-container.text-outside .progress-text-inner {
            opacity: 0;
        }

        .progress-bar-container.text-outside .progress-text-outer {
            opacity: 1;
        }

        /* Responsive text wrapping for very long text */
        @media (max-width: 600px) {
            .progress-text-outer {
                white-space: normal;
                word-break: break-word;
                max-width: 150px;
                font-size: 12px;
            }
        }

        .status-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }

        .status-badge.connected {
            background: #d4edda;
            color: #155724;
        }

        .status-badge.disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #1565c0;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #856404;
            display: none;
        }

        .warning-box.active {
            display: block;
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }

            .file-controls {
                grid-template-columns: 1fr;
            }

            .action-buttons {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            .info-table td:first-child {
                width: 120px;
                font-size: 13px;
            }
        }

        select {
            cursor: pointer;
            font-weight: bold !important;
        }

        /* Add to existing CSS */
        #statusBadgeFiles {
            min-width: 100px;
            text-align: center;
        }

        .status-success {
            border: 2px solid #27ae60 !important;
        }

        .status-badge.status-success {
            color: #27ae60 !important;
            font-weight: bold !important;
            background-color: #e8f8f0 !important;
        }

        .status-warning {
            border: 2px solid #f39c12 !important;
        }

        .status-badge.status-warning {
            color: #f39c12 !important;
            font-weight: bold !important;
            background-color: #fef5e7 !important;
        }

        .status-error {
            border: 2px solid #e74c3c !important;
        }

        .status-badge.status-error {
            color: #e74c3c !important;
            font-weight: bold !important;
            background-color: #fdecea !important;
        }

        .status-unknown {
            border: 2px solid #95a5a6 !important;
        }

        .status-badge.status-unknown {
            color: #95a5a6 !important;
            font-weight: bold !important;
            background-color: #ecf0f1 !important;
        }

        .flash-ready-indicator {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 10px;
        }

        .flash-ready-indicator.ready {
            background: #d4edda;
            color: #155724;
        }

        .flash-ready-indicator.not-ready {
            background: #f8d7da;
            color: #721c24;
        }

        .file-progress-bar-container {
            background: #e0e0e0;
            border-radius: 4px;
            height: 8px;
            overflow: hidden;
            width: 100%;
            margin-top: 10px;
            display: none;
        }

        .file-progress-bar-container.active {
            display: block;
        }

        .file-progress-bar {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            width: 0;
            transition: width 0.3s;
        }

        .file-progress-bar.complete {
            background: #27ae60;
        }

        .file-item.manifest-mode .file-header input[type="checkbox"] {
            visibility: hidden;
            width: 0;
            margin: 0;
        }
    </style>
</head>
<body>
<noscript>
    <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.95); display: flex; align-items: center; justify-content: center; z-index: 9999;">
        <div style="background: white; padding: 40px; border-radius: 12px; max-width: 500px; text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
            <h2 style="color: #e74c3c; margin-bottom: 20px;">‚ö†Ô∏è JavaScript Required</h2>
            <p style="color: #666; margin-bottom: 20px; line-height: 1.6;">This ESP Firmware Updater requires JavaScript
                to function properly.</p>
            <p style="color: #666; line-height: 1.6;">Please enable JavaScript in your browser settings and reload the
                page.</p>
        </div>
    </div>
</noscript>

<main id="mainContent">
    <div class="container">
        <h1>üîß ESP Firmware Update Tool</h1>
        <p class="subtitle">Web interface for uploading firmware to ESP devices</p>

        <div class="info-box">
            ‚ÑπÔ∏è Connect the ESP device via USB and click "Connect". Select a firmware version or upload your own
            files.
        </div>

        <div class="warning-box" id="bootModeWarning">
            ‚ö†Ô∏è ESP is not in bootloader mode! Before uploading firmware, click "Enter Boot Mode".
        </div>

        <!-- Connection Section -->
        <div class="connection-section">
            <div style="margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;">
                <h3>
                    Connection to device
                    <span class="status-badge disconnected" id="statusBadge">Disconnected</span>
                    <span class="boot-mode-indicator unknown" id="bootModeBadge"
                          style="display: none;">Unknown mode</span>
                </h3>
                <div>
                    <b>Time:</b>
                    <span id="connectionTimer"
                          style="margin-left: 10px; font-family: monospace; font-size: 0.9em; opacity: 0.8;">
                    --:--:--
                    </span>
                </div>
            </div>
            <div class="form-group">
                <label for="baudRate">Baudrate:</label>
                <select id="baudRate">
                    <option value="115200" selected>115200</option>
                    <option value="230400">230400</option>
                    <option value="460800">460800</option>
                    <option value="921600">921600</option>
                </select>
            </div>
        </div>

        <!-- Chip Info Section -->
        <div class="chip-info-section" id="chipInfoSection">
            <h3>üìü Chip information</h3>
            <table class="info-table" id="chipInfoTable">
                <tr>
                    <td>Chip type</td>
                    <td id="infoChipType">-</td>
                </tr>
                <tr>
                    <td>Features</td>
                    <td id="infoFeatures">-</td>
                </tr>
                <tr>
                    <td>Crystal</td>
                    <td id="infoCrystal">-</td>
                </tr>
                <tr>
                    <td>MAC address</td>
                    <td id="infoMac">-</td>
                </tr>
                <tr>
                    <td>Flash size</td>
                    <td id="infoFlashSize">-</td>
                </tr>
                <tr>
                    <td>Manufacturer</td>
                    <td id="infoManufacturer">-</td>
                </tr>
                <tr>
                    <td>Device ID</td>
                    <td id="infoDevice">-</td>
                </tr>
                <tr>
                    <td>Vendor ID</td>
                    <td id="infoVendorId">-</td>
                </tr>
                <tr>
                    <td>Product ID</td>
                    <td id="infoProductId">-</td>
                </tr>
            </table>
        </div>

        <!-- File Upload Section -->
        <div class="file-section">
            <h3 style="margin-bottom: 15px;">Firmware files</h3>

            <!-- Version Selector -->
            <div class="version-selector">
                <div id="versionSelectWrapper">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4 style="width: max-content;">üì¶ Firmware version selection</h4>
                        <h5 style="width: max-content">Files:
                            <span class="status-badge status-unknown" id="statusBadgeFiles">Unknown</span>
                        </h5>
                    </div>
                    <div class="form-group">
                        <label for="versionSelect">Version:</label>
                        <select id="versionSelect" onchange="handleVersionChange()">
                        </select>
                    </div>
                </div>

                <!-- Custom file actions -->
                <div class="custom-file-actions" id="customFileActions">
                    <button class="btn btn-secondary btn-small" onclick="selectFolder()">
                        üìÅ Select folder
                    </button>
                    <button class="btn btn-secondary btn-small" onclick="clearAllFiles()">
                        üóëÔ∏è Clear all
                    </button>
                </div>
            </div>

            <!-- File 1 -->
            <div class="file-item hidden" id="fileItem1">
                <div class="file-header">
                    <input type="checkbox" id="fileEnable1" onchange="toggleFileItem(1)">
                    <label for="fileEnable1">Bootloader / Merged</label>
                    <span class="validation-badge" id="validationBadge1"></span>
                </div>
                <div class="file-progress-bar-container">
                    <div class="file-progress-bar"></div>
                </div>
                <div class="file-controls" id="fileControls1" style="display: none;">
                    <div class="form-group">
                        <label for="file1">Select file:</label>
                        <input type="file" id="file1" accept=".ino.bootloader.bin, .ino.merged.bin"
                               onchange="selectFile(1)">
                    </div>
                    <div class="form-group">
                        <label for="address1">Address (hex):</label>
                        <input type="text" id="address1" placeholder="0x0000" value="0x0000">
                    </div>
                </div>
                <div class="file-info" id="fileInfo1"></div>
            </div>

            <!-- File 2 -->
            <div class="file-item hidden" id="fileItem2">
                <div class="file-header">
                    <input type="checkbox" id="fileEnable2" onchange="toggleFileItem(2)">
                    <label for="fileEnable2">Partitions</label>
                    <span class="validation-badge" id="validationBadge2"></span>
                </div>
                <div class="file-progress-bar-container">
                    <div class="file-progress-bar"></div>
                </div>
                <div class="file-controls" id="fileControls2" style="display: none;">
                    <div class="form-group">
                        <label for="file2">Select file:</label>
                        <input type="file" id="file2" accept=".ino.partitions.bin" onchange="selectFile(2)">
                    </div>
                    <div class="form-group">
                        <label for="address2">Address (hex):</label>
                        <input type="text" id="address2" placeholder="0x8000" value="0x8000">
                    </div>
                </div>
                <div class="file-info" id="fileInfo2"></div>
            </div>

            <!-- File 3 -->
            <div class="file-item hidden" id="fileItem3">
                <div class="file-header">
                    <input type="checkbox" id="fileEnable3"
                           onchange="toggleFileItem(3)">
                    <label for="fileEnable3">Application</label>
                    <span class="validation-badge" id="validationBadge3"></span>
                </div>
                <div class="file-progress-bar-container">
                    <div class="file-progress-bar"></div>
                </div>
                <div class="file-controls" id="fileControls3" style="display: none;">
                    <div class="form-group">
                        <label for="file3">Select file:</label>
                        <input type="file" id="file3" accept=".ino.bin" onchange="selectFile(3)">
                    </div>
                    <div class="form-group">
                        <label for="address3">Address (hex):</label>
                        <input type="text" id="address3" placeholder="0x10000" value="0x10000">
                    </div>
                </div>
                <div class="file-info" id="fileInfo3"></div>
            </div>
        </div>

        <!-- Progress Section -->
        <div class="progress-section" id="progressSection">
            <h3 style="margin-bottom: 10px;">Upload progress</h3>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar">
                    <span class="progress-text-inner" id="progressTextInner">0%</span>
                </div>
                <div class="progress-text-outer-wrapper" id="progressTextOuterWrapper">
                    <span class="progress-text-outer" id="progressTextOuter">0%</span>
                </div>
            </div>
            <h5 style="margin-bottom: 10px;">Task: <span style="font-weight: normal" id="taskLabel">None</span></h5>

        </div>

        <!-- Action Buttons -->
        <div class="action-buttons">
            <button class="btn btn-primary" id="connectBtn" onclick="espConnect()">
                üì° Connect
            </button>
            <button class="btn btn-danger" id="disconnectBtn" onclick="safeDisconnect()" disabled>
                ‚ùå Disconnect
            </button>
            <button class="btn btn-warning" id="bootModeBtn" onclick="enterBootMode()" disabled>
                ‚ö° Enter Boot Mode
            </button>
            <button class="btn btn-fifth" id="resetBtn" onclick="hardReset()" disabled>
                üîÑ Hard Reset
            </button>
        </div>
        <div class="action-buttons">
            <!-- In the action-buttons section, change the flash button: -->
            <button class="btn btn-success" id="flashBtn" onclick="flashFirmware()" disabled>
                üíæ Upload Firmware
                <span class="flash-ready-indicator not-ready" id="flashReadyIndicator">Not ready</span>
            </button>
            <button class="btn btn-secondary" onclick="clearLog()">
                üóëÔ∏è Clear log
            </button>
        </div>
        <div class="action-buttons">
            <button class="btn btn-fourth" id="flashAllBtn" onclick="flashAllVersions()">
                üöÄ Flash all versions
            </button>
            <button class="btn btn-third" id="testBtn" onclick="test()">
                üß™ Test ESP
            </button>
        </div>

        <!-- Log Section -->
        <div class="log-section">
            <div class="log-header" style="margin-bottom: 10px;">
                <h3>Console log</h3>
                <div>Lines: <span id="lineCount-app">0</span></div>
            </div>
            <div class="log-wrapper">
                <div class="log-container" id="appLogContainer">
                    <div class="log-entry success" style="font-weight: bold">Ready to connect ESP device...</div>
                </div>
            </div>
        </div>
        <div class="log-section">
            <div class="log-header" style="margin-bottom: 10px;">
                <h3>Device log</h3>
                <div>Lines: <span id="lineCount-device">0</span></div>
            </div>
            <div class="log-wrapper" style="height: 160px;">
                <div class="log-container" id="deviceLogContainer">
                </div>
            </div>
            <div class="input-container">
                <input type="text" id="messageInput" placeholder="Type a message to send to the device..."
                       onkeypress="handleKeyPress(event)">
                <label for="messageInput"></label>
                <button class="btn" id="sendBtn" onclick="sendMessage()">
                    ‚û§ Send
                </button>
            </div>
        </div>
    </div>

    <!-- Hidden file input for folder selection -->
    <div style="display: none;">
        <label for="folderInput"></label>
        <input type="file" id="folderInput" webkitdirectory directory multiple onchange="handleFolderSelect()">
    </div>
</main>

<!-- Import maps for better module support -->
<script type="importmap">
    {
      "imports": {
        "buffer": "./packages/external/node/buffer/buffer.esm.js",
        "esptool": "./packages/external/esp/esptool.min.js"
      }
    }
</script>


<script type="module">
    // Check Web Serial API support
    if (!("serial" in navigator)) {
        addLog('‚ùå Web Serial API is not supported in this browser!', 'error');
        addLog('‚ö†Ô∏è Please use Chrome, Edge or Opera.', 'warning');
        document.getElementById('connectBtn').disabled = true;

        const mainContent = document.getElementById('mainContent');
        mainContent.innerHTML = `
        <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.95); display: flex; align-items: center; justify-content: center; z-index: 9999;">
            <div style="background: white; padding: 40px; border-radius: 12px; max-width: 500px; text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
                <h2 style="color: #e74c3c; margin-bottom: 20px;">‚ùå Web Serial API is not supported</h2>
                <p style="color: #666; margin-bottom: 20px; line-height: 1.6;">This ESP firmware update tool requires the Web Serial API.</p>
                <p style="color: #666; line-height: 1.6;">Please use a Chromium-based browser (Chrome, Edge or Opera) and reload the page.</p>
            </div>
        </div>
        `;

        throw new Error('Web Serial API not supported');
    }

    // Polyfill for Buffer               "https://cdn.jsdelivr.net/npm/buffer@6.0.3/+esm"
    import {Buffer} from 'buffer';

    // Make Buffer globally available
    window.Buffer = Buffer;

    // ESPTool.js library               "https://unpkg.com/esptool-js@0.4.0/bundle.js"
    import * as esptool from 'esptool';

    // safe getters
    const ESPLoader = esptool.ESPLoader;
    const Transport = esptool.Transport;

    if (!ESPLoader || !Transport) {
        alert('‚ùå Failed to load ESPTool.js library. Check your internet connection and reload the page.');
        throw new Error('ESPLoader or Transport not loaded');
    }


    let doPreCommands = false; // Set to true to run pre-commands before flashing
    let doPostCommands = true; // Set to true to run post-commands after flashing

    const useFilteredPort = true;
    const thymosFingerprints = [
        "12346:4097", //  ‚âà "0x303a:0x1001"
    ];

    let endBuffer = '';
    let logReader = false;

    let espLoader;
    let espTransport;
    let espChip = null;
    let connected = false;
    let inBootMode = false;
    let chipInfo = {};
    let serialPort = null;
    let lastPortInfo = null;
    let manifestData = null;
    let currentMode = 'custom'; // 'custom' or 'manifest'

    const machineInfo = {};
    let flashReady = false;
    let serialReader = null;
    let serialWriter = null;
    let isReading = false;
    let readBuffer = '';
    let readableStreamClosed = null;
    let writableStreamClosed = null;

    // File validation state
    const fileValidation = {
        1: {valid: false, info: null},
        2: {valid: false, info: null},
        3: {valid: false, info: null}
    };

    let totalFilesToFlash = 0;
    let currentPhase = '';

    let lineCount = {
        app: 0,
        device: 0
    };
    let connectionStartTime = null;
    let connectionTimerInterval = null;

    // Make functions globally accessible
    window.toggleFileItem = toggleFileItem;
    window.selectFile = selectFile;
    window.handleVersionChange = handleVersionChange;
    window.selectFolder = selectFolder;
    window.handleFolderSelect = handleFolderSelect;
    window.clearAllFiles = clearAllFiles;
    window.espConnect = espConnect;
    window.enterBootMode = enterBootMode;
    window.flashFirmware = flashFirmware;
    window.hardReset = hardReset;
    window.safeDisconnect = safeDisconnect;
    window.clearLog = clearLog;


    window.test = test;
    window.flashAllVersions = flashAllVersions;

    window.addEventListener('beforeunload', async (e) => {
        if (connected) {
            e.preventDefault();
            e.returnValue = '';
            await safeDisconnect();

            await delay(500);

            window.close();
        }
    });

    async function test() {
        if (!connected) {
            addLog('Test function: ‚ùå Device is not connected!', 'error');
            return;
        }

        if (inBootMode) {
            addLog('‚ö†Ô∏è ESP is in boot mode, performing hard reset...', 'warning');
            await hardReset();
            await delay(500);
        }

        try {
            addLog('üß™ Starting communication test...', 'info');

            // Initialize serial
            if (!await initializeSerial()) {
                return;
            }

            startSerialRead();
            await delay(3_000);

            // Test commands
            await writeSerial('help');
            await delay(2_000);

            // const result = await sendCommandAndWait(
            //     'misc get name',
            //     3_000,
            //     {
            //         regex: /\s*(.+):\s*(.+)/,
            //         position: 'any',
            //         description: 'Machine name'
            //     }
            // );
            //
            // if (result?.success && result?.groups) {
            //     console.log(result);
            //     addLog(`üìå Name: ${result.groups[1]}`, 'success');
            // }
            //
            // await delay(3_000 + 2_000);

            await writeSerial('misc get libinfo');
            await delay(2_000);
            await writeSerial('mc get iscalibrated');
            await delay(2_000);


            await delay(4_000);
            addLog('‚úÖ Test completed', 'success');
        } catch (error) {
            addLog(`‚ùå Error during test: ${error.message}`, 'error');
        } finally {
            await stopSerialRead();
            await closeSerial();
        }
    }

    async function flashAllVersions() {
        if (!connected) {
            addLog('Flash all versions: ‚ùå Device is not connected!', 'error');
            return;
        }

        const versionSelect = document.getElementById('versionSelect');
        const totalVersions = versionSelect.options.length - 2;

        for (let i = 0; i < totalVersions; i++) {
            try {
                const selValue = versionSelect.options[i]?.value;
                if (selValue === 'custom' || selValue?.includes('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ')) continue;

                versionSelect.selectedIndex = i;

                const current = `Flashed version [${i + 1} / ${totalVersions}]: ${selValue.textContent} ; {${selValue}}`;

                endBuffer += '\n========================';
                // log selected version
                endBuffer += `\n${current}`;
                endBuffer += '\n------------------------\n';
                console.log(current);
                addLog(current);

                await handleVersionChange();
                await delay(200); // Wait for UI update
                await flashFirmware();
                await delay(300); // Wait between flashes
            } catch (error) {
                endBuffer += `\n‚ùå Error flashing version [${i + 1}]: ${error.message}`;
                endBuffer += '\n========================\n';
                console.error(`Error flashing version [${i + 1}]:`, error);
            }
        }

        await delay(1_500);
        console.log('All versions flashed.');
        addLog('‚úÖ All versions have been flashed.', 'success');
        console.log(endBuffer);

        await safeDisconnect();
    }

    // New function for checking readiness for flashing
    function checkFlashReadiness() {
        if (!connected) {
            flashReady = false;
            updateFlashButton();
            return;
        }

        const enabledFiles = [1, 2, 3].filter(i => document.getElementById(`fileEnable${i}`).checked);

        // Check if file 1 is merged
        const file1Input = document.getElementById('file1');
        const isMerged = file1Input.files[0] && file1Input.files[0].name.includes('.merged.bin');

        let isReady = false;

        if (isMerged && enabledFiles.length === 1 && enabledFiles[0] === 1) {
            // Merged mode: only file 1 needs to be valid
            isReady = fileValidation[1].valid;
            addLog('üìã Mode: Merged firmware (1 file)', 'info');
        } else if (!isMerged && enabledFiles.length === 3) {
            // Three-file mode: all three files need to be valid
            isReady = fileValidation[1].valid && fileValidation[2].valid && fileValidation[3].valid;
            addLog('üìã Mode: Standard firmware (3 files)', 'info');
        } else {
            isReady = false;
            if (enabledFiles.length > 0) {
                if (isMerged) {
                    addLog('‚ö†Ô∏è Merged firmware detected - disable the other files', 'warning');
                } else {
                    addLog('‚ö†Ô∏è For standard firmware you need all 3 files', 'warning');
                }
            }
        }

        flashReady = isReady;
        updateFlashButton();
    }

    // New function to update flash button
    function updateFlashButton() {
        const flashBtn = document.getElementById('flashBtn');
        const indicator = document.getElementById('flashReadyIndicator');

        if (connected && flashReady) {
            flashBtn.disabled = false;
            indicator.className = 'flash-ready-indicator ready';
            indicator.textContent = '‚úì Ready';
        } else {
            flashBtn.disabled = true;
            indicator.className = 'flash-ready-indicator not-ready';
            if (!connected) {
                indicator.textContent = '‚äó Not connected';
            } else {
                indicator.textContent = '‚äò Not ready';
            }
        }
    }

    // Initialize serial reader and writer
    async function initializeSerial() {
        if (!espTransport || !serialPort) {
            throw new Error('Port is not open');
        }

        try {
            // Get readable and writable streams
            const textDecoder = new TextDecoderStream();
            readableStreamClosed = serialPort.readable.pipeTo(textDecoder.writable);
            serialReader = textDecoder.readable.getReader();

            const textEncoder = new TextEncoderStream();
            writableStreamClosed = textEncoder.readable.pipeTo(serialPort.writable);
            serialWriter = textEncoder.writable.getWriter();

            addLog('‚úÖ Serial read/write initialized', 'success');
            return true;
        } catch (error) {
            addLog(`‚ùå Error initializing serial I/O: ${error.message}`, 'error');
            return false;
        }
    }

    // Start reading from serial port
    async function startSerialRead() {
        if (isReading) return;

        isReading = true;
        readBuffer = '';

        try {
            while (isReading && serialReader) {
                const {value, done} = await serialReader.read();
                if (done) {
                    break;
                }
                if (value) {
                    readBuffer += value;
                    // Log each line
                    const lines = readBuffer.split('\n');
                    readBuffer = lines.pop(); // Keep incomplete line in buffer

                    logReadings(lines);
                }
            }
        } catch (error) {
            if (isReading) {
                addLog(`‚ùå Error while reading: ${error.message}`, 'error');
            }
        }
    }

    async function logReadings(lines) {
        lines.forEach(line => {
            if (line.trim()) {
                if (logReader) endBuffer += line + '\n';
                addLog(`üì• RX: ${line.trim()}`, 'machineOut', 'device');
            }
        });
    }

    // Stop reading from serial port
    async function stopSerialRead() {
        isReading = false;
        if (serialReader) {
            try {
                await serialReader.cancel();
                serialReader = null;
            } catch (error) {
                console.error('Error stopping reader:', error);
            }
        }
    }

    // Helper functions for common response patterns

    // Wait for OK response
    async function waitForStr(command, string, timeout = 5_000) {
        return await sendCommandAndWait(command, timeout, string);
    }

    // Wait for specific value with regex
    async function waitForValue(command, regex, timeout = 5_000) {
        return await sendCommandAndWait(command, timeout, {regex: regex});
    }

    // Wait for multiple possible responses
    async function waitForAny(command, possibleResponses, timeout = 5_000) {
        return await sendCommandAndWait(command, timeout, possibleResponses);
    }

    // Get MAC address with various formats
    async function getMacAddress(timeout = 5_000) {
        const macPatterns = [
            {
                regex: /MAC:\s*([0-9A-Fa-f:]{17})/,
                description: 'MAC with colons'
            },
            {
                regex: /MAC:\s*([0-9A-Fa-f-]{17})/,
                description: 'MAC with dashes'
            },
            {
                regex: /([0-9A-Fa-f]{12})/,
                description: 'MAC without separators'
            }
        ];

        const result = await sendCommandAndWait('AT+CIPSTAMAC?', timeout, macPatterns);

        if (result.success && result.matched) {
            return result.groups[0];
        }

        return null;
    }

    // Get version info
    async function getVersion(timeout = 5_000) {
        const versionPatterns = [
            {
                regex: /version:\s*([0-9.]+)/i,
                description: 'Version format: version: x.x.x'
            },
            {
                regex: /v([0-9.]+)/i,
                description: 'Version format: vx.x.x'
            },
            {
                regex: /([0-9]+\.[0-9]+\.[0-9]+)/,
                description: 'Version format: x.x.x'
            }
        ];

        const result = await sendCommandAndWait('AT+GMR', timeout, versionPatterns);

        if (result.success && result.matched) {
            return result.groups[0];
        }

        return null;
    }

    async function sendMessage() {
        if (!connected) {
            addLog('‚ùå Cannot send message: Device is not connected', 'error');
            return;
        }

        const input = document.getElementById('messageInput');
        const message = input.value.toLowerCase().trim();

        if (!message) return;

        try {
            const lineEnding = document.getElementById('lineEnding').value || 'lf';
            let textToSend = message;

            // P≈ôid√°n√≠ line ending
            switch (lineEnding) {
                case 'lf':
                    textToSend += '\n';
                    break;
                case 'cr':
                    textToSend += '\r';
                    break;
                case 'crlf':
                    textToSend += '\r\n';
                    break;
                default:
                    // No line ending
                    break;
            }

            await writeSerial(textToSend, false);

        } catch (error) {
            addLog(`‚ùå Error sending message: ${error.message}`, 'error');
            console.warn('Error sending message:', error);
        }
    }

    function handleKeyPress(event) {
        if (event.key === 'Enter') {
            sendMessage();
        }
    }

    // Write data to serial port
    async function writeSerial(data, addNewline = true) {
        if (!serialWriter) {
            addLog('‚ùå Serial port is not ready for writing', 'error');
            return false;
        }

        try {
            const message = addNewline ? data + '\n' : data;
            await serialWriter.write(message);
            addLog(`üì§ TX: ${data}`, 'machineIn', 'device');
            return true;
        } catch (error) {
            addLog(`‚ùå Error while writing: ${error.message}`, 'error');
            return false;
        }
    }

    // Close serial reader and writer
    async function closeSerial() {
        await stopSerialRead();

        if (serialWriter) {
            try {
                await serialWriter.close();
                serialWriter = null;
            } catch (error) {
                console.error('Error closing writer:', error);
            }
        }

        // Wait for streams to close
        try {
            if (writableStreamClosed) {
                await writableStreamClosed.catch(() => {
                });
                writableStreamClosed = null;
            }
            if (readableStreamClosed) {
                await readableStreamClosed.catch(() => {
                });
                readableStreamClosed = null;
            }
        } catch (error) {
            console.error('Error closing streams:', error);
        }
    }

    // Send command and wait for response
    async function sendCommandAndWait(command, timeout = 5_000, expectedResponse = null) {
        if (!serialWriter || !serialReader) {
            addLog('‚ùå Serial port is not ready', 'error');
            return null;
        }

        readBuffer = ''; // Clear buffer
        const startTime = Date.now();
        const responses = [];

        try {
            // Send command
            await writeSerial(command);

            // Wait for response
            while (Date.now() - startTime < timeout) {
                const {value, done} = await Promise.race([
                    serialReader.read(),
                    new Promise(resolve => setTimeout(() => resolve({value: null, done: true}), 100))
                ]);

                if (done || !value) {
                    await delay(50);
                    continue;
                }

                readBuffer += value;
                const lines = readBuffer.split('\n');
                readBuffer = lines.pop();

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (trimmedLine) {
                        responses.push(trimmedLine);
                        addLog(`üì• RX: ${trimmedLine}`, 'machineOut', 'device');

                        // Check if we got expected response
                        if (expectedResponse && trimmedLine.includes(expectedResponse)) {
                            return responses;
                        }
                    }
                }

                // If no expected response specified, return after short delay
                if (!expectedResponse && responses.length > 0) {
                    await delay(100);
                    return responses;
                }
            }

            if (expectedResponse) {
                addLog(`‚ö†Ô∏è Timeout while waiting for response: ${expectedResponse}`, 'warning');
            }

            return responses.length > 0 ? responses : null;

        } catch (error) {
            addLog(`‚ùå Communication error: ${error.message}`, 'error');
            return null;
        }
    }

    async function executePreFlashCommands() {
        addLog('üìã Running pre-flash commands...', 'info');
        currentPhase = 'pre-flash';

        const commands = [
            {cmd: () => performHardReset(), desc: 'Hard reset'},
            {cmd: () => initializeSerial(), desc: 'Init serial'},
            {cmd: () => startSerialRead(), desc: 'Start reading'},
            {cmd: () => writeSerial('misc get name'), desc: 'Get name'},
            {cmd: () => writeSerial('misc get machine_id'), desc: 'Get ID'},
            {cmd: () => writeSerial('mc get speed'), desc: 'Get speed'},
            {cmd: () => writeSerial('mc get acceleration'), desc: 'Get acceleration'}
        ];

        let status = false;
        try {
            if (inBootMode) {
                addLog('‚ö†Ô∏è ESP is in boot mode - hard reset...', 'warning');
                updatePreFlashProgress(0, commands.length);
                await performHardReset();
                await delay(2_000);
                updateBootModeStatus(false);
                addLog('‚úÖ ESP in normal mode', 'success');
            }

            for (let i = 0; i < commands.length; i++) {
                updatePreFlashProgress(i, commands.length);
                await commands[i].cmd();
                await delay(i < 3 ? 500 : 1_500);
            }

            updatePreFlashProgress(commands.length, commands.length);
            addLog('‚úÖ Pre-flash commands completed', 'success');
            status = true;

        } catch (error) {
            addLog(`‚ùå Error in pre-flash commands: ${error.message}`, 'error');
            status = false;
        } finally {
            await stopSerialRead();
            await closeSerial();
        }
        return status;
    }


    // Post-flash commands with pattern matching
    async function executePostFlashCommands() {
        addLog('üìã Running post-flash commands...', 'info');
        currentPhase = 'post-flash';

        const commands = [
            {cmd: () => performHardReset(), desc: 'Hard reset'},
            {cmd: () => initializeSerial(), desc: 'Init serial'},
            {cmd: () => startSerialRead(), desc: 'Start reading'},
            {cmd: () => writeSerial('memory reset'), desc: 'Memory reset'},
            {cmd: () => writeSerial('misc get libinfo'), desc: 'Get libinfo'},
            {cmd: () => writeSerial('mc get iscalibrated'), desc: 'Get calibrated'},
            {cmd: () => writeSerial('misc get name'), desc: 'Get name'},
            {cmd: () => writeSerial('misc get machine_id'), desc: 'Get ID'}
        ];

        try {
            await delay(500);

            if (inBootMode) {
                addLog('‚ö†Ô∏è ESP is in boot mode - hard reset...', 'warning');
                await performHardReset();
                await delay(2_000);
                updateBootModeStatus(false);
            }

            for (let i = 0; i < commands.length; i++) {
                updatePostFlashProgress(i, commands.length);
                await commands[i].cmd();
                await delay(i < 3 ? 500 : (i === 3 ? 3_000 : 1_000));
            }

            updatePostFlashProgress(commands.length, commands.length);
            logReader = false;
            endBuffer += '\n========================\n';

            await stopSerialRead();
            await closeSerial();

            addLog('‚úÖ Post-flash commands completed', 'success');
            return true;

        } catch (error) {
            addLog(`‚ùå Error in post-flash commands: ${error.message}`, 'error');
            await stopSerialRead();
            await closeSerial();
            return false;
        }
    }

    // Pre-flash commands with advanced pattern matching
    async function executePreFlashCommands1() {
        addLog('üìã Running pre-flash commands...', 'info');

        let status = false;
        try {
            // Check if ESP is in boot mode
            if (inBootMode) {
                addLog('‚ö†Ô∏è ESP is in boot mode - first perform a hard reset for normal communication', 'warning');
                addLog('üîÑ Performing hard reset...', 'valid');

                await performHardReset();
                await delay(2_000); // Wait for ESP to boot

                updateBootModeStatus(false);
                addLog('‚úÖ ESP is now in normal mode', 'success');
            }

            // Now we can initialize serial communication
            if (!await initializeSerial()) {
                return false;
            }

            // Start reading in background
            startSerialRead();
            await delay(3_000);

            // const response_name = await sendCommandAndWait('misc get name', 5_000);
            // const response_id = await sendCommandAndWait('misc get machine_id', 5_000);
            // const response_speed = await sendCommandAndWait('mc get speed', 5_000);
            // const response_accel = await sendCommandAndWait('mc get acceleration', 5_000);
            // console.log('Machine Name:', response_name);
            // if (response_name && response_name.length > 0) {
            //     machineInfo.name = response_name[0];
            // }
            // console.log('Machine ID:', response_id);
            // if (response_id && response_id.length > 0) {
            //     machineInfo.id = response_id[id];
            // }
            // console.log('Machine Info:', machineInfo);
            // if (response_speed && response_speed.length > 0) {
            //     machineInfo.speed = response_speed[0];
            // }
            // console.log('Machine Speed:', machineInfo.speed);
            // if (response_accel && response_accel.length > 0) {
            //     machineInfo.acceleration = response_accel[0];
            // }

            await writeSerial('misc get name');
            await delay(1_500);
            await writeSerial('misc get machine_id');
            await delay(1_500);
            await writeSerial('mc get speed');
            await delay(1_500);
            await writeSerial('mc get acceleration');
            await delay(1_500);

            // Your custom commands here
            // const result = await sendCommandAndWait('misc get name', 3_000, {
            //     regex: /\s*(.+):\s*(.+)/,
            //     position: 'any',
            //     description: 'Machine name'
            // });

            await delay(3_000);

            addLog('‚úÖ Pre-flash commands completed', 'success');
            status = true;

        } catch (error) {
            addLog(`‚ùå Error in pre-flash commands: ${error.message}`, 'error');
            await stopSerialRead();
            await closeSerial();
            status = false;

        } finally {

            await stopSerialRead();
            await closeSerial();
        }
        return status;
    }


    // Post-flash commands with pattern matching
    async function executePostFlashCommands1() {
        addLog('üìã Running post-flash commands...', 'info');

        try {
            await delay(500); // Wait

            // Check if ESP is in boot mode
            if (inBootMode) {
                addLog('‚ö†Ô∏è ESP is in boot mode - first perform a hard reset for normal communication', 'warning');
                addLog('üîÑ Performing hard reset...', 'valid');

                await performHardReset();
                await delay(2_000); // Wait for ESP to boot

                updateBootModeStatus(false);
                addLog('‚úÖ ESP is now in normal mode', 'success');
            }

            // Now we can initialize serial communication
            if (!await initializeSerial()) {
                return false;
            }

            // Start reading in background
            startSerialRead();
            await delay(3_000);
            logReader = true;
            await delay(100);

            // Your post-flash commands here
            await writeSerial('memory reset');
            await delay(3_000);
            await writeSerial('misc get libinfo');
            await delay(2_000);
            await writeSerial('mc get iscalibrated');
            await delay(1_000);
            await writeSerial('misc get name');
            await delay(1_000);
            await writeSerial('misc get machine_id');
            await delay(1_000);

            // Example: Restore machine info
            // if (machineInfo.name) {
            //     await writeSerial(`misc set name ${machineInfo.name}`);
            //     await delay(50);
            // }

            await delay(500);
            logReader = false;
            endBuffer += '\n========================\n';
            await delay(100);

            await stopSerialRead();
            await closeSerial();

            addLog('‚úÖ Post-flash commands completed', 'success');
            return true;

        } catch (error) {
            addLog(`‚ùå Error in post-flash commands: ${error.message}`, 'error');
            await stopSerialRead();
            await closeSerial();
            return false;
        }
    }

    // // 1. Simple string
    // await sendCommandAndWait('AT', 1_000, 'OK');
    //
    // // 2. RegExp
    // await sendCommandAndWait('AT+GMR', 2_000, /version:\s*([0-9.]+)/);
    //
    // // 3. Multiple options (string)
    // await sendCommandAndWait('AT', 1_000, ['OK', 'ok', 'OK\r\n']);
    //
    // // 4. Multiple options (regex)
    // await sendCommandAndWait('AT+MAC?', 2_000, [
    //     /MAC:\s*([0-9A-Fa-f:]{17})/,
    //     /MAC:\s*([0-9A-Fa-f-]{17})/,
    //     /([0-9A-Fa-f]{12})/
    // ]);
    //
    // // 5. With position
    // await sendCommandAndWait('AT+GMR', 2_000, {
    //     string: 'OK',
    //     position: 'last'  // Or 'first', or 0, 1, 2...
    // });
    //
    // // 6. Regex with position and description
    // await sendCommandAndWait('AT+STATUS', 2_000, {
    //     regex: /STATUS:(\d+)/,
    //     position: 'any',
    //     description: 'Device status code'
    // });
    //
    // // 7. Combination of multiple conditions
    // await sendCommandAndWait('AT+INFO', 3_000, [
    //     {regex: /version:\s*([0-9.]+)/, position: 0},
    //     {string: 'OK', position: 'last'},
    //     {regex: /ERROR/i, description: 'Error response'}
    // ]);
    //
    // // 8. Using returned data
    // const result = await sendCommandAndWait('AT+MAC?', 2_000, {
    //     regex: /MAC:\s*([0-9A-Fa-f:]{17})/
    // });
    //
    // if (result.success) {
    //     console.info('MAC:', result.groups[0]);
    //     console.info('Matched:', result.matched);
    //     console.info('All responses:', result.responses);
    // }


    // Pre-flash commands
    async function executePreFlashCommands2() {
        addLog('üìã Running pre-flash commands...', 'info');

        try {
            // Initialize serial communication
            if (!await initializeSerial()) {
                return false;
            }

            // Start reading in background
            startSerialRead();
            await delay(3_000);

            // // Example commands - customize as needed
            // await writeSerial('AT'); // Test command
            // await delay(200);
            //
            // await writeSerial('AT+GMR'); // Get version
            // await delay(500);
            //
            // // Or use sendCommandAndWait for specific responses
            // const response = await sendCommandAndWait('AT+GMR', 2_000, 'OK');

            // Test basic communication
            // await writeSerial('AT');
            // await delay(2_000);
            // let result = await waitForStr('AT', 2_000);
            // if (!result.success) {
            //     addLog('‚ö†Ô∏è Device does not respond to AT commands', 'warning');
            // }
            //
            // Get MAC address with multiple format support
            // const mac = await getMacAddress(3_000);
            // if (mac) {
            //     addLog(`üìå MAC address: ${mac}`, 'success');
            // }
            //
            // // Get version with multiple format support
            // const version = await getVersion(3_000);
            // if (version) {
            //     addLog(`üìå Firmware version: ${version}`, 'success');
            // }

            // Custom command with regex
            // result = await sendCommandAndWait(
            //     'AT+CIPSTATUS',
            //     3_000,
            //     [
            //         {regex: /STATUS:(\d+)/, description: 'Connection status'},
            //         {string: 'OK', position: 'last'}
            //     ]
            // );
            //
            // if (result.success) {
            //     addLog(`üìä Status: ${result.groups ? result.groups[0] : 'OK'}`, 'info');
            // }
            //
            // // Wait for specific response at specific position
            // result = await sendCommandAndWait(
            //     'AT+GMR',
            //     3_000,
            //     {
            //         regex: /SDK version:([0-9.]+)/,
            //         position: 'any',
            //         description: 'SDK version'
            //     }
            // );
            //
            // if (result.success && result.groups) {
            //     addLog(`üìå SDK version: ${result.groups[0]}`, 'success');
            // }


            const response_name = await sendCommandAndWait('misc get name', 2_000);
            const response_id = await sendCommandAndWait('misc get machine_id', 2_000);
            const response_speed = await sendCommandAndWait('mc get speed', 2_000);
            const response_accel = await sendCommandAndWait('mc get acceleration', 2_000);

            if (response_name && response_name.length > 0) {
                machineInfo.name = response_name[0];
                console.log('Machine name:', machineInfo.name);
            }
            if (response_id && response_id.length > 0) {
                machineInfo.id = response_id[id];
                console.log('Machine ID:', machineInfo.id);
            }
            if (response_speed && response_speed.length > 0) {
                machineInfo.speed = response_speed[0];
                console.log('Machine speed:', machineInfo.speed);
            }
            if (response_accel && response_accel.length > 0) {
                machineInfo.acceleration = response_accel[0];
                console.log('Machine acceleration:', machineInfo.acceleration);
            }

            await stopSerialRead();
            await closeSerial();

            addLog('‚úÖ Pre-flash commands completed', 'success');
            return true;

        } catch (error) {
            addLog(`‚ùå Error in pre-flash commands: ${error.message}`, 'error');
            await stopSerialRead();
            await closeSerial();
            return false;
        }
    }

    // Post-flash commands
    async function executePostFlashCommands2() {
        addLog('üìã Running post-flash commands...', 'info');

        try {
            // Wait for device to boot
            await delay(2_000);

            // Initialize serial communication
            if (!await initializeSerial()) {
                return false;
            }

            // Start reading
            startSerialRead();
            await delay(500);

            // // Example commands - customize as needed
            // await writeSerial('AT'); // Test command
            // await delay(200);
            //
            // await writeSerial('AT+RST'); // Reset device
            // await delay(500);

            // // Wait for boot message with multiple patterns
            // let result = await sendCommandAndWait(
            //     '', // No command, just wait for boot message
            //     5_000,
            //     [
            //         {regex: /ready/i, description: 'Boot ready'},
            //         {regex: /boot.*success/i, description: 'Boot success'},
            //         {regex: /started/i, description: 'Started'}
            //     ]
            // );
            //
            // if (result.success) {
            //     addLog('‚úÖ Device booted successfully', 'success');
            // }
            //
            // // Test communication
            // result = await waitForStr('AT', 2_000);
            // if (result.success) {
            //     addLog('‚úÖ Communication after flash is working', 'success');
            // }
            //
            // // Verify new version
            // const version = await getVersion(3_000);
            // if (version) {
            //     addLog(`üìå New firmware version: ${version}`, 'success');
            // }
            //
            // // Save configuration (example)
            // result = await sendCommandAndWait(
            //     'AT+SYSSTORE=1',
            //     2_000,
            //     [
            //         'OK',
            //         {regex: /STORE.*OK/i}
            //     ]
            // );

            await writeSerial('memory reset'); // Reset memory
            await delay(500);

            if (machineInfo.name) {
                await writeSerial(`misc set name ${machineInfo.name}`);
                await delay(50);
            }
            if (machineInfo.id) {
                await writeSerial(`misc set machine_id ${machineInfo.id}`);
                await delay(50);
            }
            if (machineInfo.speed) {
                await writeSerial(`mc set speedmm ${machineInfo.speed}`);
                await delay(50);
            }
            if (machineInfo.acceleration) {
                await writeSerial(`mc set acceleration ${machineInfo.acceleration}`);
                await delay(50);
            }

            await delay(300);

            await stopSerialRead();
            await closeSerial();

            addLog('‚úÖ Post-flash commands completed', 'success');
            return true;

        } catch (error) {
            addLog(`‚ùå Error in post-flash commands: ${error.message}`, 'error');
            await stopSerialRead();
            await closeSerial();
            return false;
        }
    }

    // Load manifest on startup
    loadManifest();

    // Load manifest.json
    async function loadManifest() {
        try {
            const response = await fetch('./firmwareFiles/manifest.json');
            if (!response.ok) {
                throw new Error('Manifest not found');
            }
            manifestData = await response.json();
            addLog('‚úÖ Manifest loaded successfully', 'success');
        } catch (error) {
            addLog('‚ö†Ô∏è Manifest not found, using Custom mode only', 'warning');
            console.warn('Manifest load error:', error);
        } finally {
            populateVersionSelector();
        }
    }

    function compareVersions(a, b) {
        const pa = a.version.split('.').map(Number);
        const pb = b.version.split('.').map(Number);

        for (let i = 0; i < Math.max(pa.length, pb.length); i++) {
            const na = pa[i] || 0;
            const nb = pb[i] || 0;
            if (na < nb) return -1;
            if (na > nb) return 1;
        }
        return 0;
    }

    function getPriority(label) {
        const l = label.toLowerCase(); // so it is not case-sensitive

        if (l.startsWith("default")) return 0; // 1. Default
        if (l.startsWith("stable")) return 1; // 2. Stable
        if (l.startsWith("current")) return 2; // 3. Current
        if (l.startsWith("latest")) return 3; // 4. Latest
        return 4;                               // 5. others
    }

    // Populate version selector
    function populateVersionSelector() {
        const versionSelect = document.getElementById('versionSelect');

        const createDivider = (symbol = '‚Äî', count = 20) => {
            const divider = document.createElement('option');
            divider.disabled = true;
            divider.textContent = symbol.repeat(count);
            return divider;
        };

        const createSpacer = () => {
            const spacer = document.createElement('option');
            spacer.disabled = true;
            spacer.textContent = '';
            return spacer;
        };

        if (manifestData) {
            versionSelect.appendChild(createSpacer());

            // Add set versions first
            const loadedSet = manifestData?.set?.slice()?.sort((a, b) => {
                const pa = getPriority(a.label);
                const pb = getPriority(b.label);

                // first compare priorities
                if (pa !== pb) return pa - pb;

                // items with the same priority are then sorted alphabetically
                return a.label.localeCompare(b.label);
            });


            if (loadedSet && Array.isArray(loadedSet)) {
                loadedSet.forEach((item, index) => {
                    if (!item.version) return; // Skip invalid entries
                    if (!item.name) item.name = `Unnamed Build`;
                    const option = document.createElement('option');
                    option.value = `set_${index}`; // Use index instead of version
                    option.textContent = `${item.label} (${item.version})`;
                    option.dataset.version = item.version; // Store version in data attribute
                    versionSelect.appendChild(option);
                });
                versionSelect.appendChild(createDivider());
            }

            // Add divider
            const loadedBuilds = manifestData?.builds?.slice()?.sort(compareVersions);

            if (loadedBuilds && Array.isArray(loadedBuilds)) {
                // Add all builds
                loadedBuilds.forEach((build, index) => {
                    if (!build.version) build.version = `?.?.?`;
                    if (!build.name) build.name = `Build`;
                    const option = document.createElement('option');
                    option.value = `build_${index}`; // Use index instead of version
                    option.textContent = `${build.name} (${build.version})`;
                    option.dataset.version = build.version; // Store version in data attribute
                    versionSelect.appendChild(option);
                });

                versionSelect.appendChild(createDivider('‚îÄ', 28));
            }
        } else {
            // No manifest, only custom option
            document.getElementById('versionSelectWrapper').style.display = 'none';
        }

        // Add custom option
        const customOption = document.createElement('option');
        customOption.value = 'custom';
        customOption.textContent = 'Custom (custom files)';
        versionSelect.appendChild(customOption);


        if (manifestData) {
            versionSelect.appendChild(createSpacer());
        }

        // Set default selection
        setDefaultVersion();
    }

    // Set default version
    function setDefaultVersion() {
        const versionSelect = document.getElementById('versionSelect');
        let defaultIndex;

        // Priority: default > current > last > first
        const defaultItem = manifestData?.set?.findIndex(item => item.label.toLowerCase().startsWith('default')) || -1;
        const stableItem = manifestData?.set?.findIndex(item => item.label.toLowerCase().startsWith('stable')) || -1;
        const currentItem = manifestData?.set?.findIndex(item => item.label.toLowerCase().startsWith('current')) || -1;
        const lastestItem = manifestData?.set?.findIndex(item => item.label.toLowerCase().startsWith('lastest')) || -1;

        if (defaultItem !== -1) {
            defaultIndex = defaultItem;
        } else if (stableItem !== -1) {
            defaultIndex = stableItem;
        } else if (currentItem !== -1) {
            defaultIndex = currentItem;
        } else if (lastestItem !== -1) {
            defaultIndex = lastestItem;
        } else {
            defaultIndex = 0;
        }

        if (defaultIndex && defaultIndex !== -1) {
            versionSelect.value = `set_${defaultIndex}`;
        }

        handleVersionChange();
    }

    // Handle version change
    const versionSelect = document.getElementById('versionSelect');
    const statusBadge = document.getElementById('statusBadgeFiles');
    const customFileActions = document.getElementById('customFileActions');

    async function handleVersionChange() {

        const selectedValue = versionSelect.value;


        setButtonsEnabled(false);

        // hide all file items
        for (let i = 1; i <= 3; i++) {
            showManifestFileItem(i, '', false, false);
        }

        try {
            // Clear current files
            clearAllFiles();
            // remove all classes
            statusBadge.classList.remove('status-success', 'status-warning', 'status-error', 'status-unknown');
            versionSelect.classList.remove('status-success', 'status-warning', 'status-error', 'status-unknown');


            if (selectedValue === 'custom') {
                // Custom mode
                currentMode = 'custom';
                customFileActions.classList.remove('hidden');
                statusBadge.innerText = 'Unknown';
                statusBadge.classList.add('status-unknown');
                versionSelect.classList.add('status-unknown');
                showFileItems(true);
                addLog('üìù Switched to Custom mode', 'info');
            } else {
                // Manifest mode
                currentMode = 'manifest';
                customFileActions.classList.add('hidden');
                showFileItems(false);

                const version = versionSelect.options[versionSelect.selectedIndex].dataset.version;
                const buildData = manifestData?.builds.find(build => build.version === version);

                const versionText = versionSelect.options[versionSelect.selectedIndex].text.trim().split(' ');
                const versionLabel = versionText[1].replace('(', '').replace(')', '');
                const name = versionText[0];

                addLog('_'.repeat(40));
                addLog(`üìë Selected version: ${name} (${versionLabel})`, 'info');
                addLog(`üì¶ Loading version: ${buildData?.name || 'Unknown'} (${buildData?.version})`, 'info');

                if (buildData) {
                    await loadBuildFiles(buildData);

                    if (connected) setButtonsEnabled(true);

                } else {
                    addLog('‚ùå Version not found in manifest', 'error');
                    statusBadge.innerText = 'Invalid';
                    statusBadge.classList.add('status-error');
                    versionSelect.classList.add('status-error');
                }
            }
        } catch (error) {
            console.error('Delay error:', error);
        } finally {
            if (!connected) {
                document.getElementById('connectBtn').disabled = false;
            }
        }
    }

    // Load build files from manifest
    const fileMapping = {
        'bootloader': 1,
        'partitions': 2,
        'application': 3,
        'merged': 1
    };

    const validFiles = [null, null, null];
    // null = not loaded (empty)
    // undefined = ???
    // true = loaded valid
    // false = loaded invalid

    async function loadBuildFiles(buildData) {
        if (!buildData.parts || !Array.isArray(buildData.parts)) {
            addLog('‚ùå Invalid build data structure', 'error');
            return;
        }

        validFiles.fill(null);

        // try to sort parts by offset
        buildData.parts.sort((a, b) => {
            return a.offset - b.offset;
        });

        const getType = (part) => {
            if (part.type) return String(part.type).trim().toLowerCase();
            if (part.path.includes('bootloader')) return 'bootloader';
            if (part.path.includes('partitions')) return 'partitions';
            if (part.path.includes('merged')) return 'merged';
            return 'Application';
        };

        const tryLoad = async (part, fileIndex) => {
            try {
                const response = await fetch(`./firmwareFiles/${part.path}`);
                if (!response.ok) {
                    console.warn(`file ${fileIndex} [${part.type}]: \n\tHTTP ${response.status} - ${response.statusText}`);
                    if (response.status === 404) {
                        addLog(`‚ùå File ${fileIndex} not found`, 'error');
                        return null;
                    } else {
                        addLog(`‚ùå Error loading file ${fileIndex}: HTTP ${response.status}`, 'error');
                    }
                    return null;
                }

                const blob = await response.blob();
                const fileName = part.path.split('/').pop();
                const file = new File([blob], fileName, {type: 'application/octet-stream'});

                const fileInput = document.getElementById(`file${fileIndex}`);
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                fileInput.files = dataTransfer.files;

                const addressInput = document.getElementById(`address${fileIndex}`);
                addressInput.value = `0x${part.offset.toString(16).toUpperCase()}`;

                const checkbox = document.getElementById(`fileEnable${fileIndex}`);
                checkbox.checked = true;
                toggleFileItem(fileIndex);

                addLog(`File ${fileIndex} loaded: ${fileName}`, 'taken');
                return true;

            } catch (error) {
                console.warn(`file ${fileIndex} [${part.type}]: \n\t${error.message}`);
                if (error.message.includes('HTTP 404')) {
                    addLog(`‚ùå File ${fileIndex} not found`, 'error');
                    return null;
                } else {
                    addLog(`‚ùå Error loading file ${fileIndex}: ${error.message}`, 'error');
                    return false;
                }
            }
        };

        const isMergedBuild = buildData.parts.some(part => getType(part) === 'merged');

        if (isMergedBuild) {
            const part = buildData.parts.find(part => getType(part) === 'merged');
            validFiles.fill(await tryLoad(part, fileMapping['merged'] || 1));

            showManifestFileItem(1, 'Merged', validFiles[0]);
            showManifestFileItem(2, 'Partitions', false, false);
            showManifestFileItem(3, 'Application', false, false);


        } else {
            for (const part of buildData.parts) {
                const type = getType(part);
                const fileIndex = fileMapping[type];
                if (fileIndex) {
                    validFiles[fileIndex - 1] = await tryLoad(part, fileIndex);
                } else {
                    addLog(`‚ö†Ô∏è Unknown part type: ${type}`, 'warning');
                }
            }

            for (let i = 0; i < 3; i++) {
                const typeName = Object.keys(fileMapping).find(key => fileMapping[key] === (i + 1));
                const label = typeName ? typeName.charAt(0).toUpperCase() + typeName.slice(1) : `File ${i + 1}`;
                showManifestFileItem(i + 1, label, validFiles[i]);
            }
        }

        statusBadge.classList.remove('status-success', 'status-warning', 'status-error', 'status-unknown');
        versionSelect.classList.remove('status-success', 'status-warning', 'status-error', 'status-unknown');

        await delay(50); // Small delay to ensure validation states are updated

        if (validFiles.every(v => v === true)) {
            addLog('‚úÖ All files successfully loaded from manifest', 'success');
            statusBadge.innerText = 'Valid';
            statusBadge.classList.add('status-success');
            versionSelect.classList.add('status-success');
        } else if (validFiles.some(v => v === true)) {
            addLog('‚ö†Ô∏è Some files were loaded with issues', 'warning');
            statusBadge.innerText = 'Error';
            statusBadge.classList.add('status-warning');
            versionSelect.classList.add('status-warning');
        } else {
            addLog('‚ùå No files could be loaded from manifest', 'error');
            statusBadge.innerText = 'Invalid';
            statusBadge.classList.add('status-error');
            versionSelect.classList.add('status-error');
        }

        checkFlashReadiness();
    }

    function showManifestFileItem(fileIndex, label, isValid, visible = true) {
        const fileItem = document.getElementById(`fileItem${fileIndex}`);
        const fileLabel = fileItem.querySelector(`label[for="fileEnable${fileIndex}"]`)

        fileItem.classList.remove('manifest-hidden', 'hidden');
        fileItem.classList.add('manifest-mode', isValid === true ? 'valid' : isValid === false ? 'invalid' : isValid === null ? 'empty' : isValid === undefined ? 'empty' : isValid === 0 ? 'empty' : 'invalid');

        if (!visible) {
            fileItem.classList.add('hidden');
        }

        if (fileLabel) fileLabel.textContent = label;

        fileItem.querySelector('.file-info')?.classList.remove('show');
        fileItem.querySelector('.file-controls').style.display = 'none';
    }

    // Show/hide file items
    function showFileItems(show) {
        for (let i = 1; i <= 3; i++) {
            const fileItem = document.getElementById(`fileItem${i}`);
            const fileLabel = fileItem.querySelector(`label[for="fileEnable${i}"]`);

            if (show) {
                fileItem.classList.remove('hidden', 'manifest-mode', 'manifest-hidden');
                const labels = {1: 'Bootloader / Merged', 2: 'Partitions', 3: 'Application'};
                if (fileLabel) fileLabel.textContent = labels[i];
            } else {
                fileItem.classList.add('manifest-hidden');
            }
        }
    }

    async function selectFile(slot) {
        validFiles[slot - 1] = null;
        await validateFile(slot);
        await delay(50); // Small delay to ensure validation states are updated

        if (currentMode === 'custom') {
            statusBadge.classList.remove('status-success', 'status-warning', 'status-error', 'status-unknown');
            versionSelect.classList.remove('status-success', 'status-warning', 'status-error', 'status-unknown');

            if (validFiles.every(v => v === true)) {
                addLog('‚úÖ All files successfully loaded', 'success');
                statusBadge.innerText = 'Valid';
                statusBadge.classList.add('status-success');
                versionSelect.classList.add('status-success');
            } else if (validFiles.some(v => v === true)) {
                addLog('‚ö†Ô∏è Some files were loaded with issues', 'warning');
                statusBadge.innerText = 'Error';
                statusBadge.classList.add('status-warning');
                versionSelect.classList.add('status-warning');
            } else {
                statusBadge.innerText = 'Unknown';
                statusBadge.classList.add('status-unknown');
                versionSelect.classList.add('status-unknown');
            }
        }
        updateIgnoredState();
    }

    // Select folder
    function selectFolder() {
        document.getElementById('folderInput').click();
    }

    // Handle folder selection
    async function handleFolderSelect() {
        validFiles.fill(null);

        const folderInput = document.getElementById('folderInput');
        const files = Array.from(folderInput.files);

        if (files.length === 0) {
            addLog('‚ö†Ô∏è No folder selected', 'warning');
            return;
        }

        addLog(`üìÅ Loading files from folder (${files.length} files)...`, 'info');

        clearAllFiles();

        const mergedFile = files.find(f => f.name.includes('.merged.bin'));

        if (mergedFile) {
            addLog('üì¶ Merged firmware detected, other files will be ignored', 'info');
            const accepted = await loadFileToSlot(mergedFile, 1, 0x0000);
            validFiles.fill(accepted);
        } else {
            const bootloaderFile = files.find(f => f.name.endsWith('.bootloader.bin'));
            const partitionsFile = files.find(f => f.name.endsWith('.partitions.bin'));
            const appFile = files.find(f => f.name.endsWith('.ino.bin') && !f.name.includes('bootloader') && !f.name.includes('partitions'));

            if (appFile) validFiles[2] = await loadFileToSlot(appFile, 3, 0x10000);
            if (partitionsFile) validFiles[1] = await loadFileToSlot(partitionsFile, 2, 0x8000);
            if (bootloaderFile) validFiles[0] = await loadFileToSlot(bootloaderFile, 1, 0x0000);

            if (!bootloaderFile && !partitionsFile && !appFile) {
                addLog('‚ö†Ô∏è No valid firmware files found in folder', 'warning');
            }
        }

        statusBadge.classList.remove('status-success', 'status-warning', 'status-error', 'status-unknown');
        versionSelect.classList.remove('status-success', 'status-warning', 'status-error', 'status-unknown');

        if (validFiles.every(v => v === true)) {
            addLog('‚úÖ All files successfully loaded', 'success');
            statusBadge.innerText = 'Valid';
            statusBadge.classList.add('status-success');
            versionSelect.classList.add('status-success');
        } else if (validFiles.some(v => v === true)) {
            addLog('‚ö†Ô∏è Some files were loaded with issues', 'warning');
            statusBadge.innerText = 'Error';
            statusBadge.classList.add('status-warning');
            versionSelect.classList.add('status-warning');
        } else {
            addLog('‚ùå File loading failed', 'error');
            statusBadge.innerText = 'Invalid';
            statusBadge.classList.add('status-error');
            versionSelect.classList.add('status-error');
        }

        checkFlashReadiness();
    }

    // Load file to specific slot
    async function loadFileToSlot(file, slot, address) {
        try {
            const fileInput = document.getElementById(`file${slot}`);
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            fileInput.files = dataTransfer.files;

            const addressInput = document.getElementById(`address${slot}`);
            addressInput.value = `0x${address.toString(16).toUpperCase()}`;

            const checkbox = document.getElementById(`fileEnable${slot}`);
            checkbox.checked = true;
            toggleFileItem(slot);

            addLog(`File ${slot} loaded: ${file.name}`, 'taken');
            return true;
        } catch (error) {
            addLog(`‚ùå Error loading file ${slot}: ${error.message}`, 'error');
            return false;
        }
    }

    // Clear all files
    function clearAllFiles() {
        validFiles.fill(null);
        for (let i = 1; i <= 3; i++) {
            const fileInput = document.getElementById(`file${i}`);
            fileInput.value = '';

            const checkbox = document.getElementById(`fileEnable${i}`);
            checkbox.checked = false;

            const fileItem = document.getElementById(`fileItem${i}`);
            fileItem.classList.remove('valid', 'invalid', 'empty', 'ignored', 'active');

            const controls = document.getElementById(`fileControls${i}`);
            controls.style.display = 'none';

            const validationBadge = document.getElementById(`validationBadge${i}`);
            validationBadge.classList.remove('show');

            const fileInfo = document.getElementById(`fileInfo${i}`);
            fileInfo.classList.remove('show');

            fileValidation[i] = {valid: false, info: null};
        }

        addLog('üóëÔ∏è All files cleared');
        checkFlashReadiness();
    }

    // Helper function to convert Uint8Array to binary string
    function uint8ArrayToBinaryString(uint8Array) {
        let binaryString = '';
        const len = uint8Array.byteLength;
        for (let i = 0; i < len; i++) {
            binaryString += String.fromCharCode(uint8Array[i]);
        }
        return binaryString;
    }

    // Format file size
    function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    }

    // Check if file 1 is merged firmware
    function isMergedFirmware() {
        const fileInput = document.getElementById('file1');
        if (!fileInput.files[0]) return false;
        return fileInput.files[0].name.includes('.merged.bin');
    }

    // Update ignored state for files 2 and 3
    function updateIgnoredState() {
        // Check if there is merged firmware in the first slot
        const file1Input = document.getElementById('file1');
        const checkbox1 = document.getElementById('fileEnable1');
        const hasMerged = file1Input.files[0] &&
            file1Input.files[0].name.includes('.merged.bin') &&
            checkbox1.checked;
        if (!checkbox1.checked) document.getElementById(`validationBadge${1}`).classList.remove('show');


        for (let i = 2; i <= 3; i++) {
            const fileItem = document.getElementById(`fileItem${i}`);
            const validationBadge = document.getElementById(`validationBadge${i}`);
            const checkbox = document.getElementById(`fileEnable${i}`);

            if (hasMerged) {
                // Merged detected - set ignored for files 2 and 3
                fileItem.classList.add('ignored');
                // fileItem.classList.remove('valid', 'invalid', 'empty');
                validationBadge.classList.add('show', 'ignored');
                validationBadge.classList.remove('valid', 'invalid', 'empty');
                validationBadge.textContent = '‚äò Ignored';
            } else {
                // No merged - remove ignored and restore original state
                fileItem.classList.remove('ignored');
                validationBadge.classList.remove('ignored');
                validationBadge.classList.remove('show');

                // Restore validation state from fileValidation
                if (checkbox.checked && fileValidation[i].valid !== undefined) {
                    if (!fileValidation[i].info) continue;
                    if (fileValidation[i].valid) {
                        fileItem.classList.add('valid');
                        fileItem.classList.remove('invalid', 'empty');
                        validationBadge.classList.add('show', 'valid');
                        validationBadge.classList.remove('invalid', 'empty');
                        validationBadge.textContent = '‚úÖ Valid';
                    } else {
                        fileItem.classList.add('invalid');
                        fileItem.classList.remove('valid');
                        validationBadge.classList.add('show', 'invalid');
                        validationBadge.classList.remove('valid');
                        validationBadge.textContent = '‚ùå Invalid';
                    }
                }
            }
        }
    }


    // Validate file function
    async function validateFile(index) {
        const fileInput = document.getElementById(`file${index}`);
        const file = fileInput.files[0];
        const fileItem = document.getElementById(`fileItem${index}`);
        const validationBadge = document.getElementById(`validationBadge${index}`);
        const fileInfo = document.getElementById(`fileInfo${index}`);

        if (!file) {
            fileValidation[index] = {valid: false, info: null};
            fileItem.classList.remove('valid', 'invalid', 'empty', 'ignored');
            validationBadge.classList.remove('show');
            fileInfo.classList.remove('show');
            checkFlashReadiness();
            validFiles[index - 1] = null;
            return;
        }

        addLog(`üîç Validating file ${index}: ${file.name}`, 'accepted');

        const validationResult = {
            fileName: file.name,
            fileSize: file.size,
            formattedSize: formatFileSize(file.size),
            lastModified: new Date(file.lastModified).toLocaleString('cs-CZ'),
            hasCorrectExtension: file.name.endsWith('.bin'),
            isSizeValid: file.size >= 512 && file.size <= 16 * 1024 * 1024,
            magicByte: null,
            segments: null,
            expectedExtension: null,
            hasExpectedExtension: false,
            isMerged: file.name.includes('.merged.bin')
        };

        // Check file extension
        if (!validationResult.hasCorrectExtension) {
            addLog(`‚ùå File ${index} does not have .bin extension`, 'error');
            showValidationResult(index, validationResult, false);
            updateIgnoredState();
            validFiles[index - 1] = false;
            return;
        }

        // Check file size
        if (!validationResult.isSizeValid) {
            addLog(`‚ùå File ${index} has invalid size (${validationResult.formattedSize})`, 'error');
            showValidationResult(index, validationResult, false);
            updateIgnoredState();
            validFiles[index - 1] = false;
            return;
        }

        // Read first 8 bytes to check magic byte and segments
        try {
            const reader = new FileReader();
            reader.onload = async (e) => {
                const buffer = new Uint8Array(e.target.result);

                // Check ESP magic byte (0xE9 for firmware, 0xAA for partitions)
                validationResult.magicByte = `0x${buffer[0].toString(16).toUpperCase().padStart(2, '0')}`;

                let hasValidMagic = false;

                // For file 2 (partitions), accept 0xAA or 0xE9
                if (index === 2) {
                    hasValidMagic = buffer[0] === 0xAA || buffer[0] === 0xE9;
                } else {
                    // For other files, require 0xE9
                    hasValidMagic = buffer[0] === 0xE9;
                }

                // Get segment count (byte at position 1)
                if (buffer.length > 1) {
                    validationResult.segments = buffer[1];
                }

                // Count ALL uploaded files (not just enabled)
                const uploadedFiles = [1, 2, 3].filter(i => {
                    const input = document.getElementById(`file${i}`);
                    return input.files[0] !== undefined;
                });

                // Determine expected extension based on actual uploaded files
                if (index === 1) {
                    if (validationResult.isMerged) {
                        validationResult.expectedExtension = '.ino.merged.bin';
                        validationResult.hasExpectedExtension = true;

                        // If merged, other files should be warned
                        if (uploadedFiles.length > 1) {
                            addLog('‚ö†Ô∏è Merged firmware detected - other files will be ignored', 'warning');
                        }
                    } else {
                        // Not merged - expect bootloader
                        validationResult.expectedExtension = '.ino.bootloader.bin';
                        validationResult.hasExpectedExtension = file.name.endsWith('.ino.bootloader.bin');
                    }
                } else if (index === 2) {
                    validationResult.expectedExtension = '.ino.partitions.bin';
                    validationResult.hasExpectedExtension = file.name.endsWith('.ino.partitions.bin');
                } else if (index === 3) {
                    validationResult.expectedExtension = '.ino.bin';
                    validationResult.hasExpectedExtension = file.name.endsWith('.ino.bin');
                }

                // Final validation
                const isValid = hasValidMagic && validationResult.isSizeValid;

                // Check extension match
                if (isValid && !validationResult.hasExpectedExtension && validationResult.expectedExtension) {
                    addLog(`‚ö†Ô∏è File ${index} does not have expected extension (${validationResult.expectedExtension})`, 'warning');
                    validFiles[index - 1] = false;
                } else if (isValid && hasValidMagic) {
                    addLog(`‚òëÔ∏è File ${index} is a valid ESP firmware`, 'valid');
                    validFiles[index - 1] = true;
                    if (validationResult.isMerged && index === 1) {
                        addLog(`‚ÑπÔ∏è Merged firmware detected - you only need this file to flash`, 'info');
                        validFiles.fill(true)
                    }
                } else if (!hasValidMagic) {
                    const expectedMagic = index === 2 ? '0xE9 or 0xAA' : '0xE9';
                    addLog(`‚ùå File ${index} does not have a valid ESP magic byte (${expectedMagic})`, 'error');
                    validFiles[index - 1] = false;
                }

                showValidationResult(index, validationResult, isValid && validationResult.hasExpectedExtension);

                // Only update ignored state if this is file 1
                if (index === 1) {
                    updateIgnoredState();
                }
            };

            reader.readAsArrayBuffer(file.slice(0, 8));

        } catch (error) {
            addLog(`‚ùå Error while validating file ${index}: ${error.message}`, 'error');
            showValidationResult(index, validationResult, false);
            validFiles[index - 1] = false;
        }
    }

    // Show validation result
    function showValidationResult(index, result, isValid) {
        const fileItem = document.getElementById(`fileItem${index}`);
        const validationBadge = document.getElementById(`validationBadge${index}`);
        const fileInfo = document.getElementById(`fileInfo${index}`);

        fileValidation[index] = {valid: isValid, info: result};

        const isIgnored = fileItem.classList.contains('ignored');

        // Update visual feedback
        fileItem.classList.remove('valid', 'invalid', 'empty');
        fileItem.classList.add(isValid ? 'valid' : 'invalid');

        validationBadge.classList.add('show');
        validationBadge.classList.remove('valid', 'invalid', 'empty');
        validationBadge.classList.add(isValid ? 'valid' : 'invalid');
        if (!isIgnored) validationBadge.textContent = isValid ? '‚úÖ Valid' : '‚ùå Invalid';

        // Show file info
        let infoHTML = '<div class="file-info-row"><div class="file-info-label">Name:</div><div class="file-info-value">' + result.fileName + '</div></div>';
        infoHTML += '<div class="file-info-row"><div class="file-info-label">Size:</div><div class="file-info-value">' + result.formattedSize + '</div></div>';
        infoHTML += '<div class="file-info-row"><div class="file-info-label">Modified:</div><div class="file-info-value">' + result.lastModified + '</div></div>';

        if (result.magicByte) {
            const expectedMagic = index === 2 ? '(0xE9 or 0xAA)' : '(0xE9)';
            const magicValid = index === 2 ? (result.magicByte === '0xE9' || result.magicByte === '0xAA') : result.magicByte === '0xE9';
            infoHTML += '<div class="file-info-row"><div class="file-info-label">Magic Byte:</div><div class="file-info-value">' + result.magicByte + ' ' + expectedMagic + (magicValid ? ' ‚úîÔ∏è' : ' ‚ùå') + '</div></div>';
        }

        if (result.segments !== null) {
            infoHTML += '<div class="file-info-row"><div class="file-info-label">Segments:</div><div class="file-info-value">' + result.segments + '</div></div>';
        }

        if (result.expectedExtension) {
            infoHTML += '<div class="file-info-row"><div class="file-info-label">Expected extension:</div><div class="file-info-value">' + result.expectedExtension + (result.hasExpectedExtension ? ' ‚úîÔ∏è' : ' ‚ùå') + '</div></div>';
        }

        fileInfo.innerHTML = infoHTML;
        if (document.getElementById('versionSelect').value !== 'custom') { // is from Manifest mode?
            fileInfo.classList.remove('show');
        } else {
            fileInfo.classList.add('show');
        }

        // Check flash readiness after validation
        checkFlashReadiness();
    }

    // Update boot mode status
    function updateBootModeStatus(isInBootMode) {
        inBootMode = isInBootMode;
        const bootModeBadge = document.getElementById('bootModeBadge');
        const bootModeWarning = document.getElementById('bootModeWarning');
        const bootModeBtn = document.getElementById('bootModeBtn');

        if (connected) {
            bootModeBadge.style.display = 'inline-block';

            if (isInBootMode) {
                bootModeBadge.textContent = 'Boot mode';
                bootModeBadge.className = 'boot-mode-indicator boot';
                bootModeWarning.classList.remove('active');
                bootModeBtn.disabled = true;
            } else {
                bootModeBadge.textContent = 'Normal mode';
                bootModeBadge.className = 'boot-mode-indicator normal';
                bootModeWarning.classList.add('active');
                bootModeBtn.disabled = false;
            }
        } else {
            bootModeBadge.style.display = 'none';
            bootModeWarning.classList.remove('active');
        }
    }

    // Update chip info table
    function updateChipInfo() {
        document.getElementById('infoChipType').textContent = chipInfo.chipType || '-';
        document.getElementById('infoFeatures').textContent = chipInfo.features || '-';
        document.getElementById('infoCrystal').textContent = chipInfo.crystal || '-';
        document.getElementById('infoMac').textContent = chipInfo.mac || '-';
        document.getElementById('infoFlashSize').textContent = chipInfo.flashSize || '-';
        document.getElementById('infoManufacturer').textContent = chipInfo.manufacturer || '-';
        document.getElementById('infoDevice').textContent = chipInfo.device || '-';
        document.getElementById('infoVendorId').textContent = chipInfo.vendorId || '-';
        document.getElementById('infoProductId').textContent = chipInfo.productId || '-';

        document.getElementById('chipInfoSection').classList.add('active');
    }

    // Clear chip info
    function clearChipInfo() {
        chipInfo = {};
        document.getElementById('chipInfoSection').classList.remove('active');
    }

    // Toggle file item visibility
    function toggleFileItem(index) {
        const checkbox = document.getElementById(`fileEnable${index}`);
        const controls = document.getElementById(`fileControls${index}`);
        const item = document.getElementById(`fileItem${index}`);

        if (checkbox.checked) {
            controls.style.display = 'grid';
            item.classList.add('active');
            selectFile(index);
        } else {
            controls.style.display = 'none';
            item.classList.remove('active', 'ignored');
            validFiles[index - 1] = null;
        }

        // Update ignored state when toggling checkboxes
        updateIgnoredState();

        // Check flash readiness
        checkFlashReadiness();

        if (currentMode === 'custom') {
            statusBadge.classList.remove('status-success', 'status-warning', 'status-error', 'status-unknown');
            versionSelect.classList.remove('status-success', 'status-warning', 'status-error', 'status-unknown');

            if (validFiles.every(v => v === true)) {
                addLog('‚úÖ All files successfully loaded', 'success');
                statusBadge.innerText = 'Valid';
                statusBadge.classList.add('status-success');
                versionSelect.classList.add('status-success');
            } else if (validFiles.some(v => v === true)) {
                addLog('‚ö†Ô∏è Some files were loaded with issues', 'warning');
                statusBadge.innerText = 'Error';
                statusBadge.classList.add('status-warning');
                versionSelect.classList.add('status-warning');
            } else {
                statusBadge.innerText = 'Unknown';
                statusBadge.classList.add('status-unknown');
                versionSelect.classList.add('status-unknown');
            }
        }
    }

    // Logging function
    function addLog(message, type = undefined, log = 'app') {
        log = String(log).toLowerCase().trim();
        const logContainer = document.getElementById(log === 'device' ? 'deviceLogContainer' : 'appLogContainer');
        const timestamp = new Date().toLocaleTimeString('cs-CZ');
        const logEntry = document.createElement('div');
        if (type) logEntry.className = `log-entry ${type}`;
        logEntry.textContent = `[${timestamp}] ${message}`;
        logContainer.appendChild(logEntry);
        logContainer.scrollTop = logContainer.scrollHeight;

        lineCount[log] += 1;
        document.getElementById(`lineCount-${log}`).textContent = lineCount[log];
    }

    function clearLog() {
        lineCount.app = 0;
        lineCount.device = 0;
        document.getElementById('lineCount-app').textContent = '0';
        document.getElementById('lineCount-device').textContent = '0';
        const appLogContainer = document.getElementById('appLogContainer');
        const deviceLogContainer = document.getElementById('deviceLogContainer');

        appLogContainer.innerHTML = '';
        deviceLogContainer.innerHTML = '';

        addLog('üóëÔ∏è Application log cleared', 'none', 'app');

        updateProgress({percentage: 0, state: 'None'});
        updateFileProgress(1, 0, 0);
        updateFileProgress(2, 0, 0);
        updateFileProgress(3, 0, 0);

        progressSection.classList.remove('active');
        fileProgressBars?.forEach(bar => bar?.classList.remove('active'));
    }

    // Update progress bar
    const isString = (str) => typeof str === 'string' && str.length > 0;
    const isNumber = (num) => typeof num === 'number' && !isNaN(num);
    const progressSection = document.getElementById('progressSection');
    const fileProgressBars = Array.from(document.querySelectorAll('.file-progress-bar-container'));
    const progressBar = document.getElementById('progressBar');
    const progressBarContainer = document.querySelector('.progress-bar-container');
    const textInner = document.getElementById('progressTextInner');
    const textOuter = document.getElementById('progressTextOuter');
    const textOuterWrapper = document.getElementById('progressTextOuterWrapper');
    const taskLabel = document.getElementById('taskLabel');


    function calculateOverallProgress(phaseProgress) {
        const phases = {
            'pre-flash': {start: 0, size: 12.5},
            'flashing': {start: 12.5, size: 75},
            'post-flash': {start: 87.5, size: 12.5}
        };

        if (!phases[currentPhase]) return 0;

        const phase = phases[currentPhase];
        return phase.start + (phaseProgress * phase.size / 100);
    }

    function updatePreFlashProgress(completed, total) {
        totalPreFlashCommands = total;
        completedPreFlashCommands = completed;
        const phaseProgress = (completed / total) * 100;
        const overallProgress = calculateOverallProgress(phaseProgress);
        updateProgress({
            percentage: overallProgress,
            state: `Pre-flash: command ${completed}/${total}`
        });
    }

    // Function to update progress of post-flash commands
    function updatePostFlashProgress(completed, total) {
        totalPostFlashCommands = total;
        completedPostFlashCommands = completed;
        const phaseProgress = (completed / total) * 100;
        const overallProgress = calculateOverallProgress(phaseProgress);
        updateProgress({
            percentage: overallProgress,
            state: `Post-flash: command ${completed}/${total}`
        });
    }

    // Function to update progress of individual files
    function updateFileProgress(fileIndex, written, total) {
        const fileProgress = (written / total) * 100;

        // Update file-specific progress bar in file-item
        const fileItem = document.getElementById(`fileItem${fileIndex}`);
        if (fileItem) {
            const progressBar = fileItem.querySelector('.file-progress-bar');
            if (progressBar) {
                progressBar.style.width = fileProgress + '%';
                if (fileProgress >= 100) {
                    progressBar.classList.add('complete');
                }
            }
        }

        // Calculate overall progress within flashing phase
        const filesCompleted = fileIndex - 1;
        const currentFileProgress = fileProgress / 100;
        const phaseProgress = ((filesCompleted + currentFileProgress) / (totalFilesToFlash || 1)) * 100;
        const overallProgress = calculateOverallProgress(phaseProgress);

        updateProgress({
            percentage: overallProgress,
            state: `Flashing file ${fileIndex}/${(totalFilesToFlash || 1)}: ${Math.round(fileProgress)}%`
        });
    }

    function updateProgress({percentage = undefined, state = undefined} = {}) {
        if (isNumber(percentage)) {
            progressBar.style.width = percentage + '%';

            if (textOuterWrapper) {
                textOuterWrapper.style.width = percentage + '%';
            }

            const textContent = percentage > 0 ? Math.round(percentage) + '%' : '';
            textInner.textContent = textContent;
            textOuter.textContent = textContent;

            // Use the optimized version
            checkTextFitThrottled(progressBar, progressBarContainer, textInner, textOuter, percentage);
        }

        if (isString(state)) taskLabel.textContent = state;
    }

    let measureCanvas = null;
    let measureContext = null;

    function initMeasureCanvas() {
        if (!measureCanvas) {
            measureCanvas = document.createElement('canvas');
            measureContext = measureCanvas.getContext('2d');
            measureContext.font = '600 14px "Segoe UI", Tahoma, Geneva, Verdana, sans-serif';
        }
    }

    // Cache for text widths
    const textWidthCache = new Map();
    let lastTextContent = '';
    let lastTextWidth = 0;

    function checkTextFit(progressBar, container, textInner, textOuter, percentage) {
        const textContent = textInner.textContent;

        // Quick check: If text hasn't changed, use cached width
        let textWidth;
        if (textContent === lastTextContent) {
            textWidth = lastTextWidth;
        } else {
            // Check cache first
            if (textWidthCache.has(textContent)) {
                textWidth = textWidthCache.get(textContent);
            } else {
                // Measure using Canvas (much faster than DOM)
                initMeasureCanvas();
                const metrics = measureContext.measureText(textContent);
                textWidth = metrics.width + 20; // Add padding (10px * 2)

                // Cache the result
                if (textWidthCache.size > 50) {
                    const firstKey = textWidthCache.keys().next().value;
                    textWidthCache.delete(firstKey);
                }
                textWidthCache.set(textContent, textWidth);
            }

            lastTextContent = textContent;
            lastTextWidth = textWidth;
        }

        const progressWidth = progressBar.offsetWidth;
        const buffer = 5;
        const fitsInside = (textWidth + buffer) <= progressWidth;

        // Only update DOM if state actually changed
        const isOutside = container.classList.contains('text-outside');
        const shouldBeOutside = !fitsInside || percentage <= 5;

        if (isOutside !== shouldBeOutside) {
            container.classList.toggle('text-outside', shouldBeOutside);
        }
    }

    let checkTextFitTimeout = null;
    let lastPercentage = -1;

    function checkTextFitThrottled(progressBar, container, textInner, textOuter, percentage) {
        // Immediate check on significant changes
        const percentageDiff = Math.abs(percentage - lastPercentage);

        if (percentageDiff > 10 || percentage === 0 || percentage === 100) {
            // Immediate check for big jumps or start/end
            clearTimeout(checkTextFitTimeout);
            checkTextFitImmediate(progressBar, container, textInner, textOuter, percentage);
            lastPercentage = percentage;
        } else {
            // Debounce for small changes
            clearTimeout(checkTextFitTimeout);
            checkTextFitTimeout = setTimeout(() => {
                checkTextFitImmediate(progressBar, container, textInner, textOuter, percentage);
                lastPercentage = percentage;
            }, 50);
        }
    }

    function checkTextFitImmediate(progressBar, container, textInner, textOuter, percentage) {
        const textContent = textInner.textContent;

        // Use cached measurement
        let textWidth;
        if (textWidthCache.has(textContent)) {
            textWidth = textWidthCache.get(textContent);
        } else {
            initMeasureCanvas();
            const metrics = measureContext.measureText(textContent);
            textWidth = metrics.width + 20;

            if (textWidthCache.size > 50) {
                const firstKey = textWidthCache.keys().next().value;
                textWidthCache.delete(firstKey);
            }
            textWidthCache.set(textContent, textWidth);
        }

        const progressWidth = progressBar.offsetWidth;
        const fitsInside = (textWidth + 5) <= progressWidth;
        const shouldBeOutside = !fitsInside || percentage <= 5;

        container.classList.toggle('text-outside', shouldBeOutside);
    }

    // Optional: Update on window resize to recalculate text fit
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            const progressBar = document.getElementById('progressBar');
            const progressBarContainer = document.querySelector('.progress-bar-container');
            const textInner = document.getElementById('progressTextInner');
            const textOuter = document.getElementById('progressTextOuter');

            if (progressBar && progressBarContainer && textInner && textOuter) {
                const currentWidth = parseFloat(progressBar.style.width) || 0;
                checkTextFit(progressBar, progressBarContainer, textInner, textOuter, currentWidth);
            }
        }, 100);
    });

    // Enter boot mode - reuses existing connection
    async function enterBootMode() {
        if (!connected || !serialPort) {
            addLog('Boot-mode: ‚ùå ESP is not connected!', 'error');
            return;
        }

        try {
            addLog('‚ö° Switching to boot mode...', 'info');

            // Close serial communication if active (normal mode)
            if (serialReader || serialWriter) {
                addLog('Closing normal communication...', 'info');
                await closeSerial();
                await delay(500);
            }

            // Close existing transport
            if (espTransport) {
                await espTransport.disconnect();
                await espTransport.waitForUnlock(500);
            }

            // Reuse the same serial port
            espTransport = new Transport(serialPort, true);

            const baudRate = parseInt(document.getElementById('baudRate').value);

            // Create new ESPLoader instance
            const loaderOptions = {
                transport: espTransport,
                baudrate: baudRate,
                terminal: {
                    clean: () => {
                    },
                    writeLine: (data) => {
                        addLog(data);
                        parseChipInfoFromLog(data);
                    },
                    write: (data) => {
                    }
                }
            };

            espLoader = new ESPLoader(loaderOptions);

            // Connect to chip - this will put it in boot mode
            espChip = await espLoader.main();

            addLog('‚úÖ ESP is now in boot mode!', 'success');
            updateBootModeStatus(true);

        } catch (error) {
            addLog(`‚ùå Error while switching to boot mode: ${error.message}`, 'error');
            console.error(error);
        }
    }

    // Connect to ESP
    if ('serial' in navigator) {
        navigator.serial.addEventListener('connect', async (e) => {
            if (connected) return;
            const port = e.target;
            const portInfo = await port?.getInfo();

            if (lastPortInfo &&
                portInfo.usbVendorId === lastPortInfo.usbVendorId &&
                portInfo.usbProductId === lastPortInfo.usbProductId) {

                addLog('üîå Device was reconnected, attempting to reconnect...', 'info');
                await delay(100); // Small delay before reconnect
                // espConnect(port);
            }


        });
    }

    // Global variables for retry logic
    const CONNECTION_TIMEOUT = 15_000; // 15 seconds timeout
    const MAX_RETRIES = 2; // Maximum number of attempts
    let connectionAttempt = 0;

    let lastSerialPort = null; // TODO: persist in localStorage?

    // Connect to ESP with timeout and retry
    async function espConnect(port = null) {
        connectionAttempt = 0;
        await connectESPWithRetry(port);
    }

    async function connectESPWithRetry(port = null) {
        connectionAttempt++;

        if (port) {
            serialPort = port;
        }

        try {
            const baudRate = parseInt(document.getElementById('baudRate').value);

            // Request serial port (only on first attempt)
            if ((!port && connectionAttempt === 1) || !serialPort) {
                serialPort = await navigator.serial?.requestPort({
                    filters: useFilteredPort ? [
                        ...thymosFingerprints.map(fp => {
                            const [vendorId, productId] = fp.split(":").map(id => parseInt(id, 10));
                            return {usbVendorId: vendorId, usbProductId: productId};
                        })
                    ] : []
                });
            }

            addLog(`Connection attempt ${connectionAttempt}/${MAX_RETRIES}...`, 'info');

            // Get USB info
            const portInfo = serialPort?.getInfo();
            lastSerialPort = serialPort;
            lastPortInfo = structuredClone(portInfo || {});
            chipInfo.vendorId = `0x${portInfo.usbVendorId?.toString(16).padStart(4, '0')}` || '-';
            chipInfo.productId = `0x${portInfo.usbProductId?.toString(16).padStart(4, '0')}` || '-';

            serialPort.addEventListener('disconnect', () => {
                addLog('‚ö†Ô∏è Device was disconnected!', 'warning');
                espDisconnect();
            }, {once: true});

            serialPort.addEventListener('connect', () => {
                addLog('üîå Device was connected!', 'error');
                espConnect(lastSerialPort); // TODO: verify port
            }, {once: true});


            // Close existing transport if any
            if (espTransport) {
                try {
                    await espTransport.disconnect();
                    await espTransport.waitForUnlock(500);
                } catch (e) {
                    console.warn('Error closing previous transport:', e);
                }
            }

            espTransport = new Transport(serialPort, true);

            addLog(`Opening serial port with baudrate ${baudRate}...`, 'info');

            // Create ESPLoader instance
            const loaderOptions = {
                transport: espTransport,
                baudrate: baudRate,
                terminal: {
                    clean: () => {
                    },
                    writeLine: (data) => {
                        addLog(data);
                        parseChipInfoFromLog(data);
                    },
                    write: (data) => {
                    }
                }
            };

            espLoader = new ESPLoader(loaderOptions);

            // Connect to chip WITH TIMEOUT
            addLog('Waiting for ESP response...', 'info');
            espChip = await Promise.race([
                espLoader.main(),
                new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('Connection timeout')), CONNECTION_TIMEOUT)
                )
            ]);

            chipInfo.chipType = espChip;
            addLog(`‚úÖ Connected to ${espChip}!`, 'success');

            // Check if in boot mode - if main() succeeded, we're in boot mode
            updateBootModeStatus(true);

            // Try to detect flash chip
            try {
                await espLoader.flashDetect();
            } catch (e) {
                // Flash detection might fail, but info is in logs
            }

            connected = true;
            connectionAttempt = 0; // Reset counter on success
            updateConnectionStatus(true);
            updateChipInfo();

        } catch (error) {
            await handleConnectionError(error);
        }
    }

    async function handleConnectionError(error) {
        // Check if it's a timeout
        const isTimeout = error.message === 'Connection timeout';

        if (isTimeout) {
            addLog(`‚è±Ô∏è Timeout while connecting (${CONNECTION_TIMEOUT / 1_000}s)`, 'warning');
        } else if (error.name === 'NotFoundError') {
            addLog('‚ùå No device was selected.', 'error');
            resetConnection();
            return;
        } else if (error.name === 'NotSupportedError') {
            addLog('‚ùå Your browser does not support the Web Serial API.', 'error');
            resetConnection();
            return;
        } else if (error.name === 'NetworkError') {
            addLog('‚ùå Cannot open serial port. Check that it is not used by another application.', 'error');
            resetConnection();
            return;
        } else {
            addLog(`‚ùå Connection error: ${error.message}`, 'error');
        }

        console.error('Connection error:', error);

        // Retry logic
        if (connectionAttempt < MAX_RETRIES && serialPort) {
            addLog('‚ïê'.repeat(40), 'warning');
            addLog('üîÑ Attempting hard reset and reconnect...', 'warning');
            addLog('‚ïê'.repeat(40), 'warning');

            try {
                // Try to perform hard reset if we have esploader
                if (espLoader && espTransport) {
                    addLog('Performing ESP hard reset...', 'info');
                    await performHardReset().catch(e => {
                        addLog('‚ö†Ô∏è Hard reset failed, continuing...', 'warning');
                    });

                    // Wait for ESP to reset
                    await delay(2_000);
                } else {
                    // If no esploader, try manual reset via DTR/RTS
                    addLog('Attempting manual reset via DTR/RTS...', 'info');
                    await manualReset(); // TODO: Handle failure
                    await hardReset();
                }

                // Wait a bit more before retry
                await delay(1_000);

                // Retry connection
                await connectESPWithRetry();

            } catch (resetError) {
                addLog(`‚ùå Error during reset: ${resetError.message}`, 'error');

                // Last attempt without reset
                if (connectionAttempt < MAX_RETRIES) {
                    addLog('Trying to connect without reset...', 'warning');
                    await delay(1_000);
                    await connectESPWithRetry();
                } else {
                    resetConnection();
                }
            }
        } else {
            // No more retries
            addLog('‚ïê'.repeat(40), 'error');
            addLog('‚ùå Failed to connect to ESP after all attempts.', 'error');
            addLog('üí° Try:', 'info');
            addLog('  1. Unplug and replug the USB cable', 'info');
            addLog('  2. Press the RESET button on the ESP', 'info');
            addLog('  3. Check if the ESP is powered on (LED on)', 'info');
            addLog('‚ïê'.repeat(40), 'error');
            resetConnection();
        }
    }

    // Manual reset using DTR/RTS signals
    async function manualReset() {
        if (!serialPort) return;

        try {
            // Open port if needed
            if (!serialPort.readable) {
                await serialPort.open({baudRate: 115200});
            }

            // DTR=0, RTS=1 -> Enter bootloader
            await serialPort.setSignals({dataTerminalReady: false, requestToSend: true});
            await delay(100);

            // DTR=1, RTS=0 -> Reset
            await serialPort.setSignals({dataTerminalReady: true, requestToSend: false});
            await delay(50);

            // DTR=1, RTS=1 -> Run
            await serialPort.setSignals({dataTerminalReady: true, requestToSend: true});

            addLog('‚úÖ Manual reset performed', 'success');

        } catch (error) {
            addLog(`‚ö†Ô∏è Manual reset failed: ${error.message}`, 'warning');
            throw error;
        }
    }

    // Reset connection state
    function resetConnection() {
        connected = false;
        serialPort = null;
        espTransport = null;
        espLoader = null;
        espChip = null;
        connectionAttempt = 0;
        updateConnectionStatus(false);
        updateBootModeStatus(false);
        clearChipInfo();
    }

    // Parse chip info from log messages
    function parseChipInfoFromLog(message) {
        if (message.includes('Features:')) {
            chipInfo.features = message.split('Features:')[1].trim();
        }
        if (message.includes('Crystal is')) {
            chipInfo.crystal = message.split('Crystal is')[1].trim();
        }
        if (message.includes('MAC:')) {
            chipInfo.mac = message.split('MAC:')[1].trim();
        }
        if (message.includes('Manufacturer:')) {
            const match = message.match(/Manufacturer:\s*([0-9a-fA-Fx]+)/);
            if (match) chipInfo.manufacturer = match[1];
        }
        if (message.includes('Device:')) {
            const match = message.match(/Device:\s*([0-9a-fA-Fx]+)/);
            if (match) chipInfo.device = match[1];
        }
        if (message.includes('Detected flash size:')) {
            chipInfo.flashSize = message.split('Detected flash size:')[1].trim();
        }
        if (message.includes('VendorID')) {
            const match = message.match(/VendorID\s+(0x[0-9a-fA-F]+)/);
            if (match) chipInfo.vendorId = match[1];
        }
        if (message.includes('ProductID')) {
            const match = message.match(/ProductID\s+(0x[0-9a-fA-F]+)/);
            if (match) chipInfo.productId = match[1];
        }

        // Update table in real-time
        if (connected) {
            updateChipInfo();
        }
    }


    // Flash firmware
    async function flashFirmware() {
        if (!connected) {
            addLog('Flash function: ‚ùå ESP is not connected!', 'error');
            return;
        }

        // Clear machine info
        for (const key of Object.keys(machineInfo)) {
            delete machineInfo[key];
        }

        progressSection.classList.add('active');
        fileProgressBars?.forEach(bar => bar?.classList.add('active'));

        // Reset all file progress bars
        updateProgress({percentage: 0, state: 'Initializing...'});
        updateFileProgress(1, 0, 0);
        updateFileProgress(2, 0, 0);
        updateFileProgress(3, 0, 0);

        let success = false;

        try {
            // PRE-FLASH PHASE
            if (doPreCommands) {
                currentPhase = 'pre-flash';
                const preFlashSuccess = await executePreFlashCommands();
                if (!preFlashSuccess) {
                    addLog('‚ö†Ô∏è Pre-flash commands failed', 'warning');
                }
                await delay(500);
            }

            // Prepare files
            const hasMergedFirmware = isMergedFirmware() && document.getElementById('fileEnable1').checked;
            const fileArray = [];
            let hasInvalidFiles = false;

            for (let i = 1; i <= 3; i++) {
                const checkbox = document.getElementById(`fileEnable${i}`);
                if (checkbox.checked) {
                    if (hasMergedFirmware && i > 1) continue;

                    const fileInput = document.getElementById(`file${i}`);
                    const addressInput = document.getElementById(`address${i}`);

                    if (!fileInput.files[0]) {
                        addLog(`‚ö†Ô∏è File ${i} is not selected!`, 'warning');
                        return;
                    }

                    if (!fileValidation[i].valid) {
                        addLog(`‚ùå File ${i} is not valid!`, 'error');
                        hasInvalidFiles = true;
                        continue;
                    }

                    const file = fileInput.files[0];
                    const address = addressInput.value;
                    const addressDec = parseInt(address, 16);
                    const fileData = await file.arrayBuffer();
                    const uint8Data = new Uint8Array(fileData);
                    const binaryString = uint8ArrayToBinaryString(uint8Data);

                    fileArray.push({
                        data: binaryString,
                        address: addressDec,
                        index: i
                    });
                }
            }

            if (hasInvalidFiles || fileArray.length === 0) {
                addLog('‚ùå Cannot upload firmware!', 'error');
                return;
            }

            // Check boot mode
            if (!inBootMode) {
                await enterBootMode();
                await delay(1_000);
                if (!inBootMode) {
                    addLog('‚ùå Failed to enter boot mode!', 'error');
                    return;
                }
            }

            // FLASHING PHASE
            currentPhase = 'flashing';
            totalFilesToFlash = fileArray.length;

            addLog('‚ïê'.repeat(32), 'info');
            addLog('üíæ FLASH PHASE', 'info');
            addLog('‚ïê'.repeat(32), 'info');

            setButtonsEnabled(false);

            // Flash with progress tracking
            const flashOptions = {
                fileArray: fileArray.map(f => ({data: f.data, address: f.address})),
                flashSize: 'keep',
                eraseAll: false,
                compress: true,
                reportProgress: (fileIndex, written, total) => {
                    updateFileProgress(fileIndex + 1, written, total);
                }
            };

            await espLoader.writeFlash(flashOptions);

            addLog('üéâ Upload completed successfully!', 'success');
            updateProgress({percentage: 87.5, state: 'Firmware uploaded!'});

            // POST-FLASH PHASE
            if (doPostCommands) {
                currentPhase = 'post-flash';
                const postFlashSuccess = await executePostFlashCommands();
                if (!postFlashSuccess) {
                    addLog('‚ö†Ô∏è Post-flash commands failed', 'warning');
                }
            }

            success = true;

        } catch (error) {
            addLog(`‚ùå Error while flashing: ${error.message}`, 'error');
            console.error(error);
        } finally {
            await performHardReset();
            addLog(success ? '‚úÖ END OF FLASH PROCESS' : '‚ùå FLASH FAILED', success ? 'success' : 'error');

            currentPhase = 'idle';
            updateProgress({
                percentage: success ? 100 : 0,
                state: success ? 'Done!' : 'Failed.'
            });

            setButtonsEnabled(true);
        }
    }

    async function flashFirmware1() {
        if (!connected) {
            addLog('‚ùå ESP is not connected!', 'error');
            return;
        }

        // Check if in boot mode before flashing
        if (!inBootMode) {
            addLog('‚ö†Ô∏è ESP is not in boot mode! Switching to boot mode...', 'warning');
            await enterBootMode();
            await delay(1_000);

            if (!inBootMode) {
                addLog('‚ùå Failed to enter boot mode!', 'error');
                return;
            }
        }

        try {
            // Check if file 1 is merged firmware
            const hasMergedFirmware = isMergedFirmware() && document.getElementById('fileEnable1').checked;

            // Collect enabled files and validate
            const fileArray = [];
            let hasInvalidFiles = false;
            let hasWarnings = false;
            const warnings = [];

            for (let i = 1; i <= 3; i++) {
                const checkbox = document.getElementById(`fileEnable${i}`);
                if (checkbox.checked) {
                    // Skip files 2 and 3 if file 1 is merged
                    if (hasMergedFirmware && i > 1) {
                        addLog(`‚ÑπÔ∏è File ${i} ignored (merged firmware detected)`, 'info');
                        continue;
                    }

                    const fileInput = document.getElementById(`file${i}`);
                    const addressInput = document.getElementById(`address${i}`);

                    if (!fileInput.files[0]) {
                        addLog(`‚ö†Ô∏è File ${i} is not selected!`, 'warning');
                        return;
                    }

                    // Check validation
                    if (!fileValidation[i].valid) {
                        addLog(`‚ùå File ${i} is not valid!`, 'error');
                        hasInvalidFiles = true;
                        continue;
                    }

                    // Check expected extension
                    const info = fileValidation[i].info;
                    if (!info.hasExpectedExtension && info.expectedExtension) {
                        hasWarnings = true;
                        warnings.push(`File ${i} does not have expected extension (${info.expectedExtension})`);
                    }

                    const file = fileInput.files[0];
                    const address = addressInput.value;

                    // Convert hex address to decimal
                    const addressDec = parseInt(address, 16);

                    // Read file as array buffer
                    const fileData = await file.arrayBuffer();
                    const uint8Data = new Uint8Array(fileData);

                    // Convert to binary string (esptool-js expects this format)
                    const binaryString = uint8ArrayToBinaryString(uint8Data);

                    fileArray.push({
                        data: binaryString,
                        address: addressDec
                    });

                    addLog(`üìÅ Added file: ${file.name} (${uint8Data.length} bytes) at address ${address} (${addressDec})`, 'info');
                }
            }

            // Block if invalid files
            if (hasInvalidFiles) {
                addLog('‚ùå Cannot upload invalid files!', 'error');
                return;
            }

            if (fileArray.length === 0) {
                addLog('‚ö†Ô∏è No file selected!', 'warning');
                return;
            }

            // Show confirmation if there are warnings
            if (hasWarnings) {
                const warningMessage = 'Warning:\n' + warnings.join('\n') + '\n\nDo you still want to continue?';
                if (!confirm(warningMessage)) {
                    addLog('‚ö†Ô∏è Upload cancelled by user', 'warning');
                    return;
                }
            }
            if (hasMergedFirmware) {
                addLog(`üöÄ Starting upload of merged firmware...`, 'info');
            } else {
                addLog(`üöÄ Starting upload of ${fileArray.length} file(s)...`, 'info');
            }

            // Disable buttons during flashing
            setButtonsEnabled(false);
            updateProgress(0);

            // Flash options
            const flashOptions = {
                fileArray: fileArray,
                flashSize: 'keep',
                eraseAll: false,
                compress: true,
                reportProgress: (fileIndex, written, total) => {
                    const percentage = (written / total) * 100;
                    const state = percentage === 100 ? `Wrapping up, please wait...` : '';
                    updateProgress(percentage, state);
                }
            };

            addLog('üìù Erasing and preparing flash memory...');

            // Write files to flash
            await espLoader.writeFlash(flashOptions);

            addLog('üéâ Upload completed successfully!', 'success');
            updateProgress(100, 'Done!');

            await delay(500);

        } catch (error) {
            addLog(`‚ùå Error while flashing: ${error.message}`, 'error');
            console.error(error);
        } finally {
            // Auto hard reset after flash
            addLog('üîÑ Automatic hard reset...', 'valid');

            await performHardReset();
            addLog('‚òëÔ∏è Hard reset done!', 'accepted');

            setButtonsEnabled(true);
        }
    }

    // Flash firmware
    async function flashFirmware2() {
        if (!connected) {
            addLog('‚ùå ESP is not connected!', 'error');
            return;
        }


        // clear all in 'machineInfo'
        for (const key of Object.keys(machineInfo)) {
            delete machineInfo[key];
        }

        let success = false;

        try {
            if (doPreCommands) {
                updateProgress({percentage: 0, state: 'Executing pre-flash preparations...'});
                // PRE-FLASH COMMANDS
                addLog('‚ïê'.repeat(32), 'info');
                addLog('üîß PRE-FLASH PHASE', 'info');
                addLog('‚ïê'.repeat(32), 'info');

                const preFlashSuccess = await executePreFlashCommands();
                if (!preFlashSuccess) {
                    addLog('‚ö†Ô∏è Pre-flash commands failed, continuing with flashing...', 'warning');
                }

                // Wait a bit before flashing
                await delay(500);
            }

            // Check if file 1 is merged firmware
            const hasMergedFirmware = isMergedFirmware() && document.getElementById('fileEnable1').checked;

            // Collect enabled files and validate
            const fileArray = [];
            let hasInvalidFiles = false;
            let hasWarnings = false;
            const warnings = [];

            for (let i = 1; i <= 3; i++) {
                const checkbox = document.getElementById(`fileEnable${i}`);
                if (checkbox.checked) {
                    // Skip files 2 and 3 if file 1 is merged
                    if (hasMergedFirmware && i > 1) {
                        addLog(`‚ÑπÔ∏è File ${i} ignored (merged firmware detected)`, 'info');
                        continue;
                    }

                    const fileInput = document.getElementById(`file${i}`);
                    const addressInput = document.getElementById(`address${i}`);

                    if (!fileInput.files[0]) {
                        addLog(`‚ö†Ô∏è File ${i} is not selected!`, 'warning');
                        return;
                    }

                    // Check validation
                    if (!fileValidation[i].valid) {
                        addLog(`‚ùå File ${i} is not valid!`, 'error');
                        hasInvalidFiles = true;
                        continue;
                    }

                    // Check expected extension
                    const info = fileValidation[i].info;
                    if (!info.hasExpectedExtension && info.expectedExtension) {
                        hasWarnings = true;
                        warnings.push(`File ${i} does not have expected extension (${info.expectedExtension})`);
                    }

                    const file = fileInput.files[0];
                    const address = addressInput.value;

                    // Convert hex address to decimal
                    const addressDec = parseInt(address, 16);

                    // Read file as array buffer
                    const fileData = await file.arrayBuffer();
                    const uint8Data = new Uint8Array(fileData);

                    // Convert to binary string (esptool-js expects this format)
                    const binaryString = uint8ArrayToBinaryString(uint8Data);

                    fileArray.push({
                        data: binaryString,
                        address: addressDec
                    });

                    addLog(`üìÅ Added file: ${file.name} (${uint8Data.length} bytes) at address ${address} (${addressDec})`, 'info');
                }
            }

            // Block if invalid files
            if (hasInvalidFiles) {
                addLog('‚ùå Cannot upload invalid files!', 'error');
                return;
            }

            if (fileArray.length === 0) {
                addLog('‚ö†Ô∏è No file selected!', 'warning');
                return;
            }

            // Show confirmation if there are warnings
            if (hasWarnings) {
                const warningMessage = 'Warning:\n' + warnings.join('\n') + '\n\nDo you still want to continue?';
                if (!confirm(warningMessage)) {
                    addLog('‚ö†Ô∏è Upload cancelled by user', 'warning');
                    return;
                }
            }

            // Check if in boot mode before flashing
            if (!inBootMode) {
                addLog('‚ö†Ô∏è ESP is not in boot mode! Switching to boot mode...', 'warning');
                await enterBootMode();
                await delay(1_000);

                if (!inBootMode) {
                    addLog('‚ùå Failed to enter boot mode!', 'error');
                    return;
                }
            }

            // FLASHING PHASE
            addLog('‚ïê'.repeat(32), 'info');
            addLog('üíæ FLASH PHASE', 'info');
            addLog('‚ïê'.repeat(32), 'info');

            if (hasMergedFirmware) {
                addLog(`üöÄ Starting upload of merged firmware...`, 'info');
            } else {
                addLog(`üöÄ Starting upload of ${fileArray.length} file(s)...`, 'info');
            }

            // Disable buttons during flashing
            setButtonsEnabled(false);
            updateProgress({percentage: 0, state: 'Uploading firmware...'});

            // Flash options
            const flashOptions = {
                fileArray: fileArray,
                flashSize: 'keep',
                eraseAll: false,
                compress: true,
                reportProgress: (fileIndex, written, total) => {
                    const percentage = (written / total) * 100;
                    const state = percentage === 100 ? `Wrapping up, please wait...` : null;
                    updateProgress({percentage: percentage, state: state});
                }
            };

            addLog('üìù Erasing and preparing flash memory...', 'info');

            // Write files to flash
            await espLoader.writeFlash(flashOptions);

            addLog('_'.repeat(40), 'info');
            addLog('üéâ Upload completed successfully!', 'success');
            updateProgress({percentage: 100, state: 'Firmware uploaded!'});

            await delay(500);

            if (doPostCommands) {
                updateProgress({percentage: 100, state: 'Executing post-flash procedures...'});
                // POST-FLASH COMMANDS
                addLog('‚ïê'.repeat(32), 'info');
                addLog('üîß POST-FLASH PHASE', 'info');
                addLog('‚ïê'.repeat(32), 'info');

                const postFlashSuccess = await executePostFlashCommands();
                if (!postFlashSuccess) {
                    addLog('‚ö†Ô∏è Post-flash commands failed', 'warning');
                }
            }

            success = true;

        } catch (error) {
            addLog(`‚ùå Error while flashing: ${error.message}`, 'error');
            console.error(error);
        } finally {
            // Auto hard reset after flash
            addLog('üîÑ Automatic hard reset...', 'valid');
            await performHardReset();
            addLog('‚òëÔ∏è Hard reset done!', 'accepted');


            addLog('‚ïê'.repeat(32), 'info');
            addLog(`${success ? '‚úÖ' : '‚ùé'} END OF FLASH PROCESS`, 'success');
            addLog('‚ïê'.repeat(32), 'info');

            success ? updateProgress({percentage: 100, state: 'Done!'}) : updateProgress({
                percentage: 0,
                state: 'Failed.'
            });

            setButtonsEnabled(true);
        }
    }

    // Robust wrapper for hard reset
    async function performHardReset({loader = espLoader, transport = espTransport, port = serialPort} = {}) {
        // 1) if the esploader instance has a hardReset method, use it (backwards compatibility)
        try {
            if (loader && typeof loader.hardReset === 'function') {
                console.debug('Using esploader.hardReset()');
                await loader.hardReset();
                return true;
            }
        } catch (err) {
            console.warn('esploader.hardReset() failed:', err);
            // continue to fallbacks
        }

        // 2) try to use exported HardReset (may be a class or a function)
        try {
            if (typeof HardReset !== 'undefined' && HardReset) {
                console.debug('HardReset export is present, inspecting...');

                // Log to console what it is
                console.dir(HardReset);

                // If it is a class (constructor), create instance with transport
                if (typeof HardReset === 'function') {
                    try {
                        const hrInstance = new HardReset(transport);
                        // Find suitable method on instance
                        const possibleMethods = ['reset', 'run', 'perform', 'execute', 'do', 'start'];
                        for (const m of possibleMethods) {
                            if (typeof hrInstance[m] === 'function') {
                                console.debug(`Calling hrInstance.${m}()`);
                                await hrInstance[m]();
                                return true;
                            }
                        }
                        // If instance itself is callable (function), try to call it
                        if (typeof hrInstance === 'function') {
                            const maybePromise = hrInstance();
                            if (maybePromise && typeof maybePromise.then === 'function') {
                                await maybePromise;
                                return true;
                            }
                        }
                        // If none of that exists, try if HardReset is a function, not a constructor (call)
                        if (typeof HardReset === 'function') {
                            const res = HardReset(transport);
                            if (res && typeof res.then === 'function') {
                                await res;
                                return true;
                            }
                        }
                    } catch (innerErr) {
                        console.warn('Using HardReset constructor/func failed:', innerErr);
                    }
                }
            }
        } catch (err) {
            console.warn('Error while trying HardReset export:', err);
        }

        // 3) try ClassicReset or CustomReset exports (sometimes these utilities are there)
        try {
            if (typeof ClassicReset !== 'undefined' && ClassicReset) {
                console.debug('Trying ClassicReset with transport');
                const cr = new ClassicReset(transport);
                if (typeof cr.reset === 'function') {
                    await cr.reset();
                    return true;
                } else if (typeof cr.run === 'function') {
                    await cr.run();
                    return true;
                }
            }
            if (typeof CustomReset !== 'undefined' && CustomReset) {
                console.debug('Trying CustomReset with transport');
                const cr = new CustomReset(transport /* maybe sequence */);
                if (typeof cr.reset === 'function') {
                    await cr.reset();
                    return true;
                } else if (typeof cr.run === 'function') {
                    await cr.run();
                    return true;
                }
            }
        } catch (err) {
            console.warn('Classic/Custom reset attempts failed:', err);
        }

        // 4) Fallback: manual reset via Web Serial API (if we have serialPort and setSignals)
        try {
            if (port && typeof port.setSignals === 'function') {
                console.debug('Attempting manual reset via serialPort.setSignals()');
                // Typical sequence: toggle DTR/RTS to reset
                await port.setSignals({dataTerminalReady: false, requestToSend: true});
                await delay(120);
                await port.setSignals({dataTerminalReady: true, requestToSend: false});
                await delay(50);
                await port.setSignals({dataTerminalReady: true, requestToSend: true});
                await delay(2_000); // wait for device to boot
                return true;
            }
        } catch (err) {
            console.warn('Manual serialPort.reset via setSignals failed:', err);
        }

        // 5) If nothing worked, failure
        console.error('Hard reset failed: no available method succeeded.');
        return false;
    }

    // Helper delay function
    function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Hard reset ESP
    async function hardReset() {
        if (!connected) {
            addLog('Reset: ‚ùå ESP is not connected!', 'error');
            return;
        }

        try {
            addLog('üîÑ Performing ESP hard reset...', 'valid');

            // Close serial if open
            if (serialReader || serialWriter) {
                await closeSerial();
            }

            await performHardReset();
            addLog('‚òëÔ∏è Hard reset done!', 'accepted');

            // After reset, device is no longer in boot mode
            updateBootModeStatus(false);

            // Wait for ESP to boot
            await delay(2_000);
            addLog('‚ÑπÔ∏è ESP should now be in normal mode and ready for communication', 'info');

        } catch (error) {
            addLog(`‚ùå Error while resetting: ${error.message}`, 'error');
            console.error(error);
        }
    }

    // Disconnect from ESP
    function safeDisconnect() {
        lastPortInfo = null;
        espDisconnect();
    }

    async function espDisconnect() {
        try {
            // Close serial if open
            if (serialReader || serialWriter) {
                await closeSerial();
            }

            updateProgress({percentage: 0, state: 'None'});
            updateFileProgress(1, 0, 0);
            updateFileProgress(2, 0, 0);
            updateFileProgress(3, 0, 0);

            progressSection.classList.remove('active');
            fileProgressBars?.forEach(bar => bar?.classList.remove('active'));

            // Auto hard reset before disconnect
            if (connected && espLoader) {
                try {
                    addLog('üîÑ Hard reset before disconnecting...', 'info');
                    await performHardReset();
                    await delay(500);
                } catch (e) {
                    addLog('‚ö†Ô∏è Hard reset failed', 'warning');
                }
            }

            if (espTransport) {
                addLog('‚ùé Disconnecting ESP...', 'success');
                await espTransport.disconnect();
                await espTransport.waitForUnlock(1_500);
            }

            addLog('‚úÖ Disconnected', 'success');

        } catch (error) {
            addLog(`‚ùå Error while disconnecting: ${error.message}`, 'error');
            console.error(error);
        } finally {
            connected = false;
            serialPort = null;
            serialReader = null;
            serialWriter = null;
            readableStreamClosed = null;
            writableStreamClosed = null;
            updateConnectionStatus(false);
            updateBootModeStatus(false);
            clearChipInfo();
        }
    }

    function formatDuration(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        const hh = String(hours).padStart(2, '0');
        const mm = String(minutes).padStart(2, '0');
        const ss = String(seconds).padStart(2, '0');

        return `${hh}:${mm}:${ss}`;
    }

    function startConnectionTimer() {
        const timerEl = document.getElementById('connectionTimer');
        if (!timerEl) return;

        // kdyby nƒõco u≈æ bƒõ≈æelo, zastav
        if (connectionTimerInterval) {
            clearInterval(connectionTimerInterval);
        }

        connectionStartTime = Date.now();
        timerEl.textContent = '00:00:00';

        connectionTimerInterval = setInterval(() => {
            if (!connectionStartTime) return;
            const diff = Date.now() - connectionStartTime;
            timerEl.textContent = formatDuration(diff);
        }, 1_000);
    }

    function stopConnectionTimer(reset = true) {
        const timerEl = document.getElementById('connectionTimer');
        if (connectionTimerInterval) {
            clearInterval(connectionTimerInterval);
            connectionTimerInterval = null;
        }
        connectionStartTime = null;

        if (timerEl && reset) {
            timerEl.textContent = '--:--:--';
        }
    }


    // Update connection status
    function updateConnectionStatus(isConnected) {
        const statusBadge = document.getElementById('statusBadge');
        const connectBtn = document.getElementById('connectBtn');
        const flashBtn = document.getElementById('flashBtn');
        const resetBtn = document.getElementById('resetBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const bootModeBtn = document.getElementById('bootModeBtn');

        if (isConnected) {
            statusBadge.textContent = 'P≈ôipojeno';
            statusBadge.className = 'status-badge connected';
            connectBtn.disabled = true;
            resetBtn.disabled = false;
            disconnectBtn.disabled = false;
            bootModeBtn.disabled = inBootMode;

            // ‚ûú start connection timer
            startConnectionTimer();
        } else {
            statusBadge.textContent = 'Odpojeno';
            statusBadge.className = 'status-badge disconnected';
            connectBtn.disabled = false;
            flashBtn.disabled = true;
            resetBtn.disabled = true;
            disconnectBtn.disabled = true;
            bootModeBtn.disabled = true;

            // ‚ûú stop connection timer
            stopConnectionTimer(true);
        }

        // Update flash button based on connection and readiness
        checkFlashReadiness();
    }


    // Enable/disable buttons
    function setButtonsEnabled(enabled) {
        document.getElementById('flashBtn').disabled = !enabled;
        document.getElementById('resetBtn').disabled = !enabled;
        document.getElementById('connectBtn').disabled = connected ? true : !enabled;
        document.getElementById('bootModeBtn').disabled = !enabled || inBootMode;
        document.getElementById('flashAllBtn').disabled = !enabled;
        document.getElementById('testBtn').disabled = !enabled;
        document.getElementById('messageInput').disabled = !enabled;
        document.getElementById('sendBtn').disabled = !enabled;
    }
</script>

<script>

</script>

</body>
</html>