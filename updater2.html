<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP Firmware Updater</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            max-width: 800px;
            width: 100%;
            padding: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .connection-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .chip-info-section {
            background: #f0f8ff;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid #4a90e2;
            display: none;
        }

        .chip-info-section.active {
            display: block;
        }

        .chip-info-section h3 {
            color: #2c5aa0;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .boot-mode-indicator {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }

        .boot-mode-indicator.boot {
            background: #d4edda;
            color: #155724;
        }

        .boot-mode-indicator.normal {
            background: #fff3cd;
            color: #856404;
        }

        .boot-mode-indicator.unknown {
            background: #f8d7da;
            color: #721c24;
        }

        .info-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 6px;
            overflow: hidden;
        }

        .info-table tr {
            border-bottom: 1px solid #e0e0e0;
        }

        .info-table tr:last-child {
            border-bottom: none;
        }

        .info-table td {
            padding: 10px 15px;
        }

        .info-table td:first-child {
            font-weight: 600;
            color: #555;
            width: 180px;
            background: #f8f9fa;
        }

        .info-table td:last-child {
            color: #333;
            font-family: 'Courier New', monospace;
        }

        .file-section {
            margin-bottom: 20px;
        }

        .version-selector {
            background: #fff9e6;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid #ffc107;
        }

        .version-selector h4 {
            margin-bottom: 10px;
            color: #856404;
        }

        #versionSelectWrapper {
            margin-bottom: 10px;
        }

        .custom-file-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .custom-file-actions.hidden {
            display: none;
        }

        .file-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid #e0e0e0;
            transition: all 0.3s;
        }

        .file-item:not(.active):not(.manifest-mode) {
            filter: grayscale(0.6);
        }

        .file-item.active {
            border-color: #667eea;
            background: #f0f4ff;
            filter: none;
        }

        .file-item.valid {
            border-color: #27ae60;
            background: #e8f8f0;
        }

        .file-item.invalid {
            border-color: #e74c3c;
            background: #fdecea;
        }

        .file-item.ignored {
            opacity: 0.6;
            border-color: #95a5a6;
            background: #ecf0f1;
        }

        .file-item.hidden {
            display: none;
        }

        .file-item.manifest-hidden {
            display: none;
        }

        .file-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .file-header input[type="checkbox"] {
            margin-right: 10px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .file-header label {
            font-weight: 600;
            color: #333;
            cursor: pointer;
            flex: 1;
        }

        .file-item.manifest-mode .file-header input[type="checkbox"] {
            visibility: hidden;
            width: 0;
            margin: 0;
        }

        .file-item.manifest-mode .file-header label {
            pointer-events: none;
            cursor: default;
        }

        .validation-badge {
            display: none;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 10px;
        }

        .validation-badge.show {
            display: inline-block;
        }

        .validation-badge.valid {
            background: #d4edda;
            color: #155724;
        }

        .validation-badge.invalid {
            background: #f8d7da;
            color: #721c24;
        }

        .validation-badge.ignored {
            background: #e2e3e5;
            color: #383d41;
        }

        .file-progress-bar-container {
            background: #e0e0e0;
            border-radius: 4px;
            height: 8px;
            overflow: hidden;
            width: 100%;
            margin-top: 10px;
            display: none;
        }

        .file-progress-bar-container.active {
            display: block;
        }

        .file-progress-bar {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            width: 0%;
            transition: width 0.3s;
        }

        .file-progress-bar.complete {
            background: #27ae60;
        }

        .file-info {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            font-size: 12px;
            color: #555;
        }

        .file-info.show {
            display: block;
        }

        .file-info-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .file-info-row:last-child {
            border-bottom: none;
        }

        .file-info-label {
            font-weight: 600;
            color: #666;
        }

        .file-info-value {
            font-family: 'Courier New', monospace;
            color: #333;
        }

        .file-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 500;
            color: #555;
            margin-bottom: 5px;
            font-size: 14px;
        }

        input[type="text"],
        input[type="file"],
        select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus,
        input[type="file"]:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        input[type="file"] {
            padding: 8px;
            cursor: pointer;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #229954;
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover:not(:disabled) {
            background: #e67e22;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(243, 156, 18, 0.3);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #7f8c8d;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .log-section {
            margin-top: 30px;
        }

        .log-container {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 8px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 3px 0;
            color: #d4d4d4;
        }

        .log-entry.info {
            color: #4ec9b0;
        }

        .log-entry.error {
            color: #f48771;
        }

        .log-entry.success {
            color: #89d185;
        }

        .log-entry.warning {
            color: #dcdcaa;
        }

        .progress-section {
            margin-top: 15px;
            display: none;
        }

        .progress-section.active {
            display: block;
        }

        .progress-bar-container {
            background: #e0e0e0;
            border-radius: 10px;
            height: 30px;
            position: relative;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-bar {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            width: 0;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
        }

        .progress-text {
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        .status-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }

        .status-badge.connected {
            background: #d4edda;
            color: #155724;
        }

        .status-badge.disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .status-success {
            border: 2px solid #27ae60 !important;
        }

        .status-badge.status-success {
            color: #27ae60 !important;
            font-weight: bold !important;
            background-color: #e8f8f0 !important;
        }

        .status-warning {
            border: 2px solid #f39c12 !important;
        }

        .status-badge.status-warning {
            color: #f39c12 !important;
            font-weight: bold !important;
            background-color: #fef5e7 !important;
        }

        .status-error {
            border: 2px solid #e74c3c !important;
        }

        .status-badge.status-error {
            color: #e74c3c !important;
            font-weight: bold !important;
            background-color: #fdecea !important;
        }

        .status-unknown {
            border: 2px solid #95a5a6 !important;
        }

        .status-badge.status-unknown {
            color: #95a5a6 !important;
            font-weight: bold !important;
            background-color: #ecf0f1 !important;
        }

        .flash-ready-indicator {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 10px;
        }

        .flash-ready-indicator.ready {
            background: #d4edda;
            color: #155724;
        }

        .flash-ready-indicator.not-ready {
            background: #f8d7da;
            color: #721c24;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #1565c0;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #856404;
            display: none;
        }

        .warning-box.active {
            display: block;
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }

            .file-controls {
                grid-template-columns: 1fr;
            }

            .action-buttons {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            .info-table td:first-child {
                width: 120px;
                font-size: 13px;
            }
        }

        select {
            cursor: pointer;
            font-weight: bold;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>üîß ESP Firmware Updater</h1>
    <p class="subtitle">Web interface for uploading firmware to ESP devices</p>

    <div class="info-box">
        ‚ÑπÔ∏è Connect your ESP device via USB and click "Connect ESP". Select a firmware version or upload custom files.
    </div>

    <div class="warning-box" id="bootModeWarning">
        ‚ö†Ô∏è ESP is not in bootloader mode! Click "Enter Boot Mode" before flashing firmware.
    </div>

    <div class="connection-section">
        <h3 style="margin-bottom: 15px;">Device Connection
            <span class="status-badge disconnected" id="statusBadge">Disconnected</span>
            <span class="boot-mode-indicator unknown" id="bootModeBadge" style="display: none;">Unknown Mode</span>
        </h3>
        <div class="form-group">
            <label for="baudRate">Baud Rate:</label>
            <select id="baudRate">
                <option value="115200" selected>115200</option>
                <option value="230400">230400</option>
                <option value="460800">460800</option>
                <option value="921600">921600</option>
            </select>
        </div>
    </div>

    <div class="chip-info-section" id="chipInfoSection">
        <h3>üìü Chip Information</h3>
        <table class="info-table">
            <tr><td>Chip Type</td><td id="infoChipType">-</td></tr>
            <tr><td>Features</td><td id="infoFeatures">-</td></tr>
            <tr><td>Crystal</td><td id="infoCrystal">-</td></tr>
            <tr><td>MAC Address</td><td id="infoMac">-</td></tr>
            <tr><td>Flash Size</td><td id="infoFlashSize">-</td></tr>
            <tr><td>Manufacturer</td><td id="infoManufacturer">-</td></tr>
            <tr><td>Device ID</td><td id="infoDevice">-</td></tr>
        </table>
    </div>

    <div class="file-section">
        <h3 style="margin-bottom: 15px;">Firmware Files</h3>

        <div class="version-selector">
            <div id="versionSelectWrapper">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h4>üì¶ Firmware Version</h4>
                    <h5>Files:
                        <span class="status-badge status-unknown" id="statusBadgeFiles">Unknown</span>
                    </h5>
                </div>
                <div class="form-group">
                    <label for="versionSelect">Version:</label>
                    <select id="versionSelect" onchange="handleVersionChange()"></select>
                </div>
            </div>

            <div class="custom-file-actions" id="customFileActions">
                <button class="btn btn-secondary btn-small" onclick="selectFolder()">üìÅ Select Folder</button>
                <button class="btn btn-secondary btn-small" onclick="clearAllFiles()">üóëÔ∏è Clear All</button>
            </div>
        </div>

        <div class="file-item" id="fileItem1">
            <div class="file-header">
                <input type="checkbox" id="fileEnable1" onchange="toggleFileItem(1)">
                <label for="fileEnable1">Bootloader / Merged</label>
                <span class="validation-badge" id="validationBadge1"></span>
            </div>
            <div class="file-progress-bar-container">
                <div class="file-progress-bar"></div>
            </div>
            <div class="file-controls" id="fileControls1" style="display: none;">
                <div class="form-group">
                    <label for="file1">Select File:</label>
                    <input type="file" id="file1" accept=".bin" onchange="validateFile(1)">
                </div>
                <div class="form-group">
                    <label for="address1">Address (hex):</label>
                    <input type="text" id="address1" placeholder="0x0000" value="0x0000">
                </div>
            </div>
            <div class="file-info" id="fileInfo1"></div>
        </div>

        <div class="file-item" id="fileItem2">
            <div class="file-header">
                <input type="checkbox" id="fileEnable2" onchange="toggleFileItem(2)">
                <label for="fileEnable2">Partitions</label>
                <span class="validation-badge" id="validationBadge2"></span>
            </div>
            <div class="file-progress-bar-container">
                <div class="file-progress-bar"></div>
            </div>
            <div class="file-controls" id="fileControls2" style="display: none;">
                <div class="form-group">
                    <label for="file2">Select File:</label>
                    <input type="file" id="file2" accept=".bin" onchange="validateFile(2)">
                </div>
                <div class="form-group">
                    <label for="address2">Address (hex):</label>
                    <input type="text" id="address2" placeholder="0x8000" value="0x8000">
                </div>
            </div>
            <div class="file-info" id="fileInfo2"></div>
        </div>

        <div class="file-item" id="fileItem3">
            <div class="file-header">
                <input type="checkbox" id="fileEnable3" onchange="toggleFileItem(3)">
                <label for="fileEnable3">Application</label>
                <span class="validation-badge" id="validationBadge3"></span>
            </div>
            <div class="file-progress-bar-container">
                <div class="file-progress-bar"></div>
            </div>
            <div class="file-controls" id="fileControls3" style="display: none;">
                <div class="form-group">
                    <label for="file3">Select File:</label>
                    <input type="file" id="file3" accept=".bin" onchange="validateFile(3)">
                </div>
                <div class="form-group">
                    <label for="address3">Address (hex):</label>
                    <input type="text" id="address3" placeholder="0x10000" value="0x10000">
                </div>
            </div>
            <div class="file-info" id="fileInfo3"></div>
        </div>
    </div>

    <div class="progress-section" id="progressSection">
        <h3 style="margin-bottom: 10px;">Upload Progress</h3>
        <div class="progress-bar-container">
            <div class="progress-bar" id="progressBar">
                <span class="progress-text" id="progressText">0%</span>
            </div>
        </div>
        <h5 style="margin-bottom: 10px; margin-top: 10px;">Task: <span id="taskLabel">None</span></h5>
    </div>

    <div class="action-buttons">
        <button class="btn btn-primary" id="connectBtn" onclick="connectESP()">üì° Connect ESP</button>
        <button class="btn btn-warning" id="bootModeBtn" onclick="enterBootMode()" disabled>‚ö° Enter Boot Mode</button>
        <button class="btn btn-success" id="flashBtn" onclick="flashFirmware()" disabled>
            üíæ Flash Firmware
            <span class="flash-ready-indicator not-ready" id="flashReadyIndicator">Not Ready</span>
        </button>
        <button class="btn btn-danger" id="resetBtn" onclick="hardReset()" disabled>üîÑ Hard Reset</button>
        <button class="btn btn-secondary" id="disconnectBtn" onclick="disconnect()" disabled>‚ùå Disconnect</button>
        <button class="btn btn-secondary" onclick="clearLog()">üóëÔ∏è Clear Log</button>
    </div>

    <div class="log-section">
        <h3 style="margin-bottom: 10px;">Console Log</h3>
        <div class="log-container" id="logContainer">
            <div class="log-entry success" style="font-weight: bold">Ready to connect ESP device...</div>
        </div>
    </div>
</div>

<input type="file" id="folderInput" webkitdirectory directory multiple onchange="handleFolderSelect()" style="display: none;">

<script type="importmap">
{
  "imports": {
    "buffer": "./packages/external/node/buffer/buffer.esm.js",
    "esptool": "./packages/external/esp/esptool.min.js"
  }
}
</script>

<script type="module">
import {Buffer} from 'buffer';

window.Buffer = Buffer;


import * as esptool from 'esptool';

const ESPLoader = esptool.ESPLoader;
const Transport = esptool.Transport;

if (!ESPLoader || !Transport) {
    alert('‚ùå Failed to load ESPTool.js library. Check your internet connection and reload the page.');
    throw new Error('ESPLoader or Transport not loaded');
}

// Configuration
const DO_PRE_COMMANDS = false;
const DO_POST_COMMANDS = true;
const CONNECTION_TIMEOUT = 15000;
const MAX_RETRIES = 2;

// State variables
let espLoader, espTransport, espChip = null;
let connected = false;
let inBootMode = false;
let serialPort = null;
let chipInfo = {};
let manifestData = null;
let currentMode = 'custom';
let flashReady = false;
let connectionAttempt = 0;
let currentPhase = 'idle';

const fileValidation = {
    1: {valid: false, info: null},
    2: {valid: false, info: null},
    3: {valid: false, info: null}
};

// Initialize
loadManifest();

// Load manifest
async function loadManifest() {
    try {
        const response = await fetch('./firmwareFiles/manifest.json');
        if (!response.ok) throw new Error('Manifest not found');
        manifestData = await response.json();
        addLog('‚úÖ Manifest loaded successfully', 'success');
    } catch (error) {
        addLog('‚ö†Ô∏è Manifest not found, using custom mode only', 'warning');
    } finally {
        populateVersionSelector();
    }
}

// Populate version selector
function populateVersionSelector() {
    const versionSelect = document.getElementById('versionSelect');

    if (manifestData?.builds) {
        manifestData.builds.sort((a, b) => compareVersions(a.version, b.version)).forEach((build, index) => {
            const option = document.createElement('option');
            option.value = `build_${index}`;
            option.textContent = `${build.name || 'Build'} (${build.version || '?.?.?'})`;
            versionSelect.appendChild(option);
        });

        const divider = document.createElement('option');
        divider.disabled = true;
        divider.textContent = '‚îÄ'.repeat(20);
        versionSelect.appendChild(divider);
    }

    const customOption = document.createElement('option');
    customOption.value = 'custom';
    customOption.textContent = 'Custom (manual files)';
    customOption.selected = true;
    versionSelect.appendChild(customOption);
}

function compareVersions(a, b) {
    const pa = a.split('.').map(Number);
    const pb = b.split('.').map(Number);
    for (let i = 0; i < Math.max(pa.length, pb.length); i++) {
        const na = pa[i] || 0;
        const nb = pb[i] || 0;
        if (na !== nb) return na - nb;
    }
    return 0;
}

// Handle version change
window.handleVersionChange = async function() {
    const selectedValue = document.getElementById('versionSelect').value;

    clearAllFiles();
    updateStatusBadge('unknown');

    if (selectedValue === 'custom') {
        currentMode = 'custom';
        document.getElementById('customFileActions').classList.remove('hidden');
        showFileItems(true);
        addLog('üìù Switched to custom mode', 'info');
    } else {
        currentMode = 'manifest';
        document.getElementById('customFileActions').classList.add('hidden');
        showFileItems(false);

        const [, indexStr] = selectedValue.split('_');
        const buildData = manifestData?.builds[parseInt(indexStr)];

        if (buildData) {
            addLog(`üì¶ Loading: ${buildData.name} (${buildData.version})`, 'info');
            await loadBuildFiles(buildData);
        } else {
            addLog('‚ùå Version not found', 'error');
            updateStatusBadge('error');
        }
    }
}

// Load build files
async function loadBuildFiles(buildData) {
    if (!buildData.parts?.length) {
        addLog('‚ùå Invalid build data', 'error');
        return;
    }

    const fileMapping = {bootloader: 1, partitions: 2, application: 3, merged: 1};
    const loadedFiles = [];

    for (const part of buildData.parts) {
        const type = getPartType(part);
        const fileIndex = fileMapping[type];

        if (!fileIndex) continue;

        try {
            const response = await fetch(`./firmwareFiles/${part.path}`);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);

            const blob = await response.blob();
            const file = new File([blob], part.path.split('/').pop(), {type: 'application/octet-stream'});

            document.getElementById(`file${fileIndex}`).files = createFileList(file);
            document.getElementById(`address${fileIndex}`).value = `0x${part.offset.toString(16).toUpperCase()}`;
            document.getElementById(`fileEnable${fileIndex}`).checked = true;

            await validateFile(fileIndex);

            loadedFiles.push({
                fileIndex,
                label: getLabelForType(type),
                valid: fileValidation[fileIndex].valid
            });

            addLog(`File ${fileIndex} loaded: ${file.name}`, 'success');
        } catch (error) {
            addLog(`‚ùå File ${fileIndex} failed to load`, 'error');
            loadedFiles.push({fileIndex, label: getLabelForType(getPartType(part)), valid: false});
        }
    }

    loadedFiles.forEach(f => showManifestFileItem(f.fileIndex, f.label, f.valid));

    const allValid = loadedFiles.every(f => f.valid);
    updateStatusBadge(allValid ? 'success' : 'error');
    checkFlashReadiness();
}

function getPartType(part) {
    if (part.type) return part.type.trim().toLowerCase();
    if (part.path.includes('bootloader')) return 'bootloader';
    if (part.path.includes('partitions')) return 'partitions';
    if (part.path.includes('merged')) return 'merged';
    return 'application';
}

function getLabelForType(type) {
    const labels = {bootloader: 'Bootloader', partitions: 'Partitions', application: 'Application', merged: 'Merged Firmware'};
    return labels[type] || `File ${type}`;
}

function showManifestFileItem(fileIndex, label, isValid) {
    const fileItem = document.getElementById(`fileItem${fileIndex}`);
    const fileLabel = fileItem.querySelector('.file-header label');
    const progressContainer = fileItem.querySelector('.file-progress-bar-container');

    fileItem.classList.remove('manifest-hidden', 'hidden');
    fileItem.classList.add('manifest-mode', isValid ? 'valid' : 'invalid');

    if (fileLabel) fileLabel.textContent = label;
    if (progressContainer) progressContainer.classList.add('active');

    fileItem.querySelector('.file-info')?.classList.remove('show');
    fileItem.querySelector('.file-controls').style.display = 'none';
}

function showFileItems(show) {
    for (let i = 1; i <= 3; i++) {
        const fileItem = document.getElementById(`fileItem${i}`);
        const fileLabel = fileItem.querySelector('.file-header label');

        if (show) {
            fileItem.classList.remove('hidden', 'manifest-mode', 'manifest-hidden');
            const labels = {1: 'Bootloader / Merged', 2: 'Partitions', 3: 'Application'};
            if (fileLabel) fileLabel.textContent = labels[i];
        } else {
            fileItem.classList.add('manifest-hidden');
        }
    }
}

// File validation
window.validateFile = async function(index) {
    const fileInput = document.getElementById(`file${index}`);
    const file = fileInput.files[0];

    if (!file) {
        fileValidation[index] = {valid: false, info: null};
        resetFileItem(index);
        updateIgnoredState();
        checkFlashReadiness();
        updateCustomFilesStatus();
        return;
    }

    addLog(`üîç Validating file ${index}: ${file.name}`, 'info');

    const result = {
        fileName: file.name,
        fileSize: file.size,
        formattedSize: formatFileSize(file.size),
        isMerged: file.name.includes('.merged.bin')
    };

    try {
        const buffer = await file.slice(0, 8).arrayBuffer();
        const data = new Uint8Array(buffer);

        result.magicByte = `0x${data[0].toString(16).toUpperCase().padStart(2, '0')}`;
        result.segments = data[1];

        const hasValidMagic = index === 2 ? (data[0] === 0xAA || data[0] === 0xE9) : data[0] === 0xE9;
        const isSizeValid = file.size >= 512 && file.size <= 16 * 1024 * 1024;
        const isValid = hasValidMagic && isSizeValid;

        fileValidation[index] = {valid: isValid, info: result};
        showValidationResult(index, isValid);

        updateIgnoredState();
        updateCustomFilesStatus();
        checkFlashReadiness();

        if (isValid) {
            addLog(`‚òëÔ∏è File ${index} is valid`, 'success');
        } else {
            addLog(`‚ùå File ${index} is invalid`, 'error');
        }
    } catch (error) {
        addLog(`‚ùå Validation error for file ${index}`, 'error');
        fileValidation[index] = {valid: false, info: result};
        showValidationResult(index, false);
    }
}

function showValidationResult(index, isValid) {
    const fileItem = document.getElementById(`fileItem${index}`);
    const badge = document.getElementById(`validationBadge${index}`);

    fileItem.classList.remove('valid', 'invalid');
    fileItem.classList.add(isValid ? 'valid' : 'invalid');

    badge.classList.add('show');
    badge.classList.remove('valid', 'invalid');
    badge.classList.add(isValid ? 'valid' : 'invalid');
    badge.textContent = isValid ? '‚úÖ Valid' : '‚ùå Invalid';
}

function resetFileItem(index) {
    const fileItem = document.getElementById(`fileItem${index}`);
    fileItem.classList.remove('valid', 'invalid', 'ignored');
    document.getElementById(`validationBadge${index}`).classList.remove('show');
    document.getElementById(`fileInfo${index}`).classList.remove('show');
}

// Toggle file item
window.toggleFileItem = function(index) {
    const checkbox = document.getElementById(`fileEnable${index}`);
    const controls = document.getElementById(`fileControls${index}`);
    const item = document.getElementById(`fileItem${index}`);
    const progressContainer = item.querySelector('.file-progress-bar-container');

    if (checkbox.checked) {
        controls.style.display = 'grid';
        item.classList.add('active');
        if (currentMode === 'custom' && progressContainer) {
            progressContainer.classList.add('active');
        }
    } else {
        controls.style.display = 'none';
        item.classList.remove('active', 'ignored');
        if (progressContainer) {
            progressContainer.classList.remove('active');
            progressContainer.querySelector('.file-progress-bar').style.width = '0%';
        }
    }

    updateIgnoredState();
    checkFlashReadiness();
    updateCustomFilesStatus();
}

function updateIgnoredState() {
    const file1Input = document.getElementById('file1');
    const hasMerged = file1Input.files[0]?.name.includes('.merged.bin') && document.getElementById('fileEnable1').checked;

    for (let i = 2; i <= 3; i++) {
        const fileItem = document.getElementById(`fileItem${i}`);
        const badge = document.getElementById(`validationBadge${i}`);

        if (hasMerged) {
            fileItem.classList.add('ignored');
            fileItem.classList.remove('valid', 'invalid');
            badge.classList.add('show', 'ignored');
            badge.textContent = '‚äò Ignored';
        } else {
            fileItem.classList.remove('ignored');
            badge.classList.remove('ignored');
        }
    }
}

function updateCustomFilesStatus() {
    if (currentMode !== 'custom') return;

    const enabledFiles = [1, 2, 3].filter(i => document.getElementById(`fileEnable${i}`).checked);
    const validFiles = enabledFiles.filter(i => fileValidation[i].valid);
    const file1Input = document.getElementById('file1');
    const isMerged = file1Input.files[0]?.name.includes('.merged.bin');

    let status = 'unknown';
    if (enabledFiles.length === 0) {
        status = 'unknown';
    } else if (isMerged && validFiles.length === 1) {
        status = 'success';
    } else if (validFiles.length === 3) {
        status = 'success';
    } else if (validFiles.length > 0) {
        status = 'warning';
    } else {
        status = 'error';
    }

    updateStatusBadge(status);
}

function updateStatusBadge(status) {
    const badge = document.getElementById('statusBadgeFiles');
    const versionSelect = document.getElementById('versionSelect');
    const statuses = {
        success: {text: 'Valid', class: 'status-success'},
        error: {text: 'Invalid', class: 'status-error'},
        warning: {text: 'Warning', class: 'status-warning'},
        unknown: {text: 'Unknown', class: 'status-unknown'}
    };

    badge.className = 'status-badge';
    versionSelect.className = '';
    badge.classList.add(statuses[status].class);
    versionSelect.classList.add(statuses[status].class);
    badge.textContent = statuses[status].text;
}

// Clear all files
window.clearAllFiles = function() {
    for (let i = 1; i <= 3; i++) {
        document.getElementById(`file${i}`).value = '';
        document.getElementById(`fileEnable${i}`).checked = false;
        resetFileItem(i);
        document.getElementById(`fileControls${i}`).style.display = 'none';
        const progressContainer = document.getElementById(`fileItem${i}`).querySelector('.file-progress-bar-container');
        if (progressContainer) {
            progressContainer.classList.remove('active');
            progressContainer.querySelector('.file-progress-bar').style.width = '0%';
        }
        fileValidation[i] = {valid: false, info: null};
    }

    updateIgnoredState();
    updateCustomFilesStatus();
    checkFlashReadiness();
    addLog('üóëÔ∏è All files cleared', 'info');
}

// Folder selection
window.selectFolder = function() {
    document.getElementById('folderInput').click();
}

window.handleFolderSelect = async function() {
    const files = Array.from(document.getElementById('folderInput').files);
    if (files.length === 0) return;

    addLog(`üìÅ Loading files from folder (${files.length} files)...`, 'info');
    clearAllFiles();

    const mergedFile = files.find(f => f.name.includes('.merged.bin'));
    if (mergedFile) {
        await loadFileToSlot(mergedFile, 1, 0x0000);
    } else {
        const bootloader = files.find(f => f.name.endsWith('.bootloader.bin'));
        const partitions = files.find(f => f.name.endsWith('.partitions.bin'));
        const application = files.find(f => f.name.endsWith('.ino.bin') && !f.name.includes('bootloader') && !f.name.includes('partitions'));

        if (application) await loadFileToSlot(application, 3, 0x10000);
        if (partitions) await loadFileToSlot(partitions, 2, 0x8000);
        if (bootloader) await loadFileToSlot(bootloader, 1, 0x0000);
    }
}

async function loadFileToSlot(file, slot, address) {
    try {
        document.getElementById(`file${slot}`).files = createFileList(file);
        document.getElementById(`address${slot}`).value = `0x${address.toString(16).toUpperCase()}`;
        document.getElementById(`fileEnable${slot}`).checked = true;
        toggleFileItem(slot);
        await validateFile(slot);
        return true;
    } catch (error) {
        addLog(`‚ùå Error loading file ${slot}`, 'error');
        return false;
    }
}

// Connect to ESP
window.connectESP = async function() {
    connectionAttempt = 0;
    await connectESPWithRetry();
}

async function connectESPWithRetry() {
    connectionAttempt++;

    try {
        const baudRate = parseInt(document.getElementById('baudRate').value);

        if (connectionAttempt === 1) {
            serialPort = await navigator.serial.requestPort();
        }

        addLog(`Connection attempt ${connectionAttempt}/${MAX_RETRIES}...`, 'info');

        if (espTransport) {
            await espTransport.disconnect();
            await espTransport.waitForUnlock(500);
        }

        espTransport = new Transport(serialPort, true);
        espLoader = new ESPLoader({
            transport: espTransport,
            baudrate: baudRate,
            terminal: {
                clean: () => {},
                writeLine: (data) => addLog(data, 'info'),
                write: () => {}
            }
        });

        addLog('Waiting for ESP response...', 'info');
        espChip = await Promise.race([
            espLoader.main(),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Connection timeout')), CONNECTION_TIMEOUT))
        ]);

        chipInfo.chipType = espChip;
        addLog(`‚úÖ Connected to ${espChip}!`, 'success');

        updateBootModeStatus(true);

        try {
            await espLoader.flashDetect();
        } catch (e) {}

        connected = true;
        connectionAttempt = 0;
        updateConnectionStatus(true);
        updateChipInfo();
    } catch (error) {
        if (error.message === 'Connection timeout') {
            addLog(`‚è±Ô∏è Connection timeout (${CONNECTION_TIMEOUT / 1000}s)`, 'warning');
        } else {
            addLog(`‚ùå Connection error: ${error.message}`, 'error');
        }

        if (connectionAttempt < MAX_RETRIES) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            await connectESPWithRetry();
        } else {
            addLog('‚ùå Failed to connect after all attempts', 'error');
            resetConnection();
        }
    }
}

// Boot mode
window.enterBootMode = async function() {
    if (!connected || !serialPort) {
        addLog('‚ùå ESP not connected!', 'error');
        return;
    }

    try {
        addLog('‚ö° Entering boot mode...', 'info');

        if (espTransport) {
            await espTransport.disconnect();
            await espTransport.waitForUnlock(500);
        }

        espTransport = new Transport(serialPort, true);
        const baudRate = parseInt(document.getElementById('baudRate').value);

        espLoader = new ESPLoader({
            transport: espTransport,
            baudrate: baudRate,
            terminal: {
                clean: () => {},
                writeLine: (data) => addLog(data, 'info'),
                write: () => {}
            }
        });

        espChip = await espLoader.main();
        addLog('‚úÖ ESP is now in boot mode!', 'success');
        updateBootModeStatus(true);
    } catch (error) {
        addLog(`‚ùå Boot mode error: ${error.message}`, 'error');
    }
}

// Flash firmware
window.flashFirmware = async function() {
    if (!connected) {
        addLog('‚ùå ESP not connected!', 'error');
        return;
    }

    if (!inBootMode) {
        await enterBootMode();
        await new Promise(resolve => setTimeout(resolve, 1000));
        if (!inBootMode) return;
    }

    const fileArray = [];
    for (let i = 1; i <= 3; i++) {
        const checkbox = document.getElementById(`fileEnable${i}`);
        if (!checkbox.checked) continue;

        const fileInput = document.getElementById(`file${i}`);
        const file = fileInput.files[0];
        if (!file || !fileValidation[i].valid) continue;

        const address = parseInt(document.getElementById(`address${i}`).value, 16);
        const data = await file.arrayBuffer();
        fileArray.push({data: uint8ArrayToBinaryString(new Uint8Array(data)), address});
    }

    if (fileArray.length === 0) {
        addLog('‚ùå No valid files to flash!', 'error');
        return;
    }

    try {
        addLog('üöÄ Starting flash...', 'info');
        currentPhase = 'flashing';

        document.getElementById('progressSection').classList.add('active');

        await espLoader.writeFlash({
            fileArray,
            flashSize: 'keep',
            eraseAll: false,
            compress: true,
            reportProgress: (fileIndex, written, total) => {
                const progress = Math.round((written / total) * 100);
                updateProgress(progress, `Flashing file ${fileIndex + 1}: ${progress}%`);
            }
        });

        addLog('üéâ Flash completed successfully!', 'success');
        updateProgress(100, 'Done!');

        await performHardReset();
    } catch (error) {
        addLog(`‚ùå Flash error: ${error.message}`, 'error');
    } finally {
        currentPhase = 'idle';
    }
}

// Hard reset
window.hardReset = async function() {
    if (!connected) {
        addLog('‚ùå ESP not connected!', 'error');
        return;
    }

    try {
        addLog('üîÑ Performing hard reset...', 'info');
        await performHardReset();
        addLog('‚òëÔ∏è Hard reset done!', 'success');
        updateBootModeStatus(false);
    } catch (error) {
        addLog(`‚ùå Reset error: ${error.message}`, 'error');
    }
}

async function performHardReset() {
    if (espLoader?.hardReset) {
        await espLoader.hardReset();
        return;
    }

    if (serialPort?.setSignals) {
        await serialPort.setSignals({dataTerminalReady: false, requestToSend: true});
        await delay(120);
        await serialPort.setSignals({dataTerminalReady: true, requestToSend: false});
        await delay(50);
        await serialPort.setSignals({dataTerminalReady: true, requestToSend: true});
        await delay(2000);
    }
}

// Disconnect
window.disconnect = async function() {
    try {
        if (connected && espLoader) {
            await performHardReset();
        }

        if (espTransport) {
            await espTransport.disconnect();
            await espTransport.waitForUnlock(1500);
        }

        addLog('‚úÖ Disconnected', 'success');
    } catch (error) {
        addLog(`‚ùå Disconnect error: ${error.message}`, 'error');
    } finally {
        connected = false;
        serialPort = null;
        updateConnectionStatus(false);
        updateBootModeStatus(false);
    }
}

// Helper functions
function updateBootModeStatus(isInBootMode) {
    inBootMode = isInBootMode;
    const badge = document.getElementById('bootModeBadge');
    const warning = document.getElementById('bootModeWarning');

    if (connected) {
        badge.style.display = 'inline-block';
        badge.className = 'boot-mode-indicator ' + (isInBootMode ? 'boot' : 'normal');
        badge.textContent = isInBootMode ? 'Boot Mode' : 'Normal Mode';
        warning.classList.toggle('active', !isInBootMode);
    } else {
        badge.style.display = 'none';
        warning.classList.remove('active');
    }
}

function updateConnectionStatus(isConnected) {
    const statusBadge = document.getElementById('statusBadge');
    statusBadge.className = 'status-badge ' + (isConnected ? 'connected' : 'disconnected');
    statusBadge.textContent = isConnected ? 'Connected' : 'Disconnected';

    document.getElementById('connectBtn').disabled = isConnected;
    document.getElementById('disconnectBtn').disabled = !isConnected;
    document.getElementById('resetBtn').disabled = !isConnected;
    document.getElementById('bootModeBtn').disabled = !isConnected || inBootMode;

    checkFlashReadiness();
}

function checkFlashReadiness() {
    if (!connected) {
        flashReady = false;
        updateFlashButton();
        return;
    }

    const enabledFiles = [1, 2, 3].filter(i => document.getElementById(`fileEnable${i}`).checked);
    const file1Input = document.getElementById('file1');
    const isMerged = file1Input.files[0]?.name.includes('.merged.bin');

    flashReady = isMerged ?
        (enabledFiles.length === 1 && fileValidation[1].valid) :
        (enabledFiles.length === 3 && fileValidation[1].valid && fileValidation[2].valid && fileValidation[3].valid);

    updateFlashButton();
}

function updateFlashButton() {
    const btn = document.getElementById('flashBtn');
    const indicator = document.getElementById('flashReadyIndicator');

    btn.disabled = !(connected && flashReady);
    indicator.className = 'flash-ready-indicator ' + (flashReady ? 'ready' : 'not-ready');
    indicator.textContent = flashReady ? '‚úì Ready' : (connected ? '‚äó Not Ready' : '‚äó Disconnected');
}

function updateChipInfo() {
    document.getElementById('infoChipType').textContent = chipInfo.chipType || '-';
    document.getElementById('infoFeatures').textContent = chipInfo.features || '-';
    document.getElementById('infoCrystal').textContent = chipInfo.crystal || '-';
    document.getElementById('infoMac').textContent = chipInfo.mac || '-';
    document.getElementById('infoFlashSize').textContent = chipInfo.flashSize || '-';
    document.getElementById('infoManufacturer').textContent = chipInfo.manufacturer || '-';
    document.getElementById('infoDevice').textContent = chipInfo.device || '-';
    document.getElementById('chipInfoSection').classList.add('active');
}

function resetConnection() {
    connected = false;
    serialPort = null;
    espTransport = null;
    espLoader = null;
    connectionAttempt = 0;
    updateConnectionStatus(false);
    updateBootModeStatus(false);
}

function updateProgress(percentage, state) {
    const bar = document.getElementById('progressBar');
    const text = document.getElementById('progressText');
    const label = document.getElementById('taskLabel');

    bar.style.width = percentage + '%';
    text.textContent = Math.round(percentage) + '%';
    if (state) label.textContent = state;
}

window.addLog = function(message, type = 'info') {
    const container = document.getElementById('logContainer');
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    container.appendChild(entry);
    container.scrollTop = container.scrollHeight;
}

window.clearLog = function() {
    document.getElementById('logContainer').innerHTML = '';
}

function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
}

function uint8ArrayToBinaryString(arr) {
    let str = '';
    for (let i = 0; i < arr.length; i++) {
        str += String.fromCharCode(arr[i]);
    }
    return str;
}

function createFileList(file) {
    const dt = new DataTransfer();
    dt.items.add(file);
    return dt.files;
}

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Check browser support
if (!('serial' in navigator)) {
    addLog('‚ùå Web Serial API not supported in this browser!', 'error');
    addLog('‚ö†Ô∏è Please use Chrome, Edge, or Opera.', 'warning');
    document.getElementById('connectBtn').disabled = true;
}
</script>
</body>
</html>