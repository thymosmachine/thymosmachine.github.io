<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP Firmware Update</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            max-width: 800px;
            width: 100%;
            padding: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .connection-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .chip-info-section {
            background: #f0f8ff;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid #4a90e2;
            display: none;
        }

        .chip-info-section.active {
            display: block;
        }

        .chip-info-section h3 {
            color: #2c5aa0;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .boot-mode-indicator {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }

        .boot-mode-indicator.boot {
            background: #d4edda;
            color: #155724;
        }

        .boot-mode-indicator.normal {
            background: #fff3cd;
            color: #856404;
        }

        .boot-mode-indicator.unknown {
            background: #f8d7da;
            color: #721c24;
        }

        .info-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 6px;
            overflow: hidden;
        }

        .info-table tr {
            border-bottom: 1px solid #e0e0e0;
        }

        .info-table tr:last-child {
            border-bottom: none;
        }

        .info-table td {
            padding: 10px 15px;
        }

        .info-table td:first-child {
            font-weight: 600;
            color: #555;
            width: 180px;
            background: #f8f9fa;
        }

        .info-table td:last-child {
            color: #333;
            font-family: 'Courier New', monospace;
        }

        .file-section {
            margin-bottom: 20px;
        }

        .version-selector {
            background: #fff9e6;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid #ffc107;
        }

        .version-selector h4 {
            margin-bottom: 10px;
            color: #856404;
        }

        #versionSelectWrapper {
            margin-bottom: 10px;
        }

        .custom-file-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .custom-file-actions.hidden {
            display: none;
        }

        .file-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid #e0e0e0;
            transition: all 0.3s;
        }

        .file-item.active {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .file-item.valid {
            border-color: #27ae60;
            background: #e8f8f0;
        }

        .file-item.invalid {
            border-color: #e74c3c;
            background: #fdecea;
        }

        .file-item.ignored {
            opacity: 0.6;
            border-color: #95a5a6;
            background: #ecf0f1;
        }

        .file-item.hidden {
            display: none;
        }

        .file-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .file-header input[type="checkbox"] {
            margin-right: 10px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .file-header label {
            font-weight: 600;
            color: #333;
            cursor: pointer;
            flex: 1;
        }

        .validation-badge {
            display: none;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 10px;
        }

        .validation-badge.show {
            display: inline-block;
        }

        .validation-badge.valid {
            background: #d4edda;
            color: #155724;
        }

        .validation-badge.invalid {
            background: #f8d7da;
            color: #721c24;
        }

        .validation-badge.ignored {
            background: #e2e3e5;
            color: #383d41;
        }

        .file-info {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            font-size: 12px;
            color: #555;
        }

        .file-info.show {
            display: block;
        }

        .file-info-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .file-info-row:last-child {
            border-bottom: none;
        }

        .file-info-label {
            font-weight: 600;
            color: #666;
        }

        .file-info-value {
            font-family: 'Courier New', monospace;
            color: #333;
        }

        .file-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 500;
            color: #555;
            margin-bottom: 5px;
            font-size: 14px;
        }

        input[type="text"],
        input[type="file"],
        select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus,
        input[type="file"]:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        input[type="file"] {
            padding: 8px;
            cursor: pointer;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #229954;
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover:not(:disabled) {
            background: #e67e22;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(243, 156, 18, 0.3);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #7f8c8d;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .log-section {
            margin-top: 30px;
        }

        .log-container {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 8px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 3px 0;
        }

        .log-entry.info {
            color: #4ec9b0;
        }

        .log-entry.error {
            color: #f48771;
        }

        .log-entry.success {
            color: #89d185;
        }

        .log-entry.warning {
            color: #dcdcaa;
        }

        .progress-section {
            margin-top: 15px;
            display: none;
        }

        .progress-section.active {
            display: block;
        }

        .progress-bar-container {
            background: #e0e0e0;
            border-radius: 10px;
            height: 30px;
            overflow: hidden;
            position: relative;
            margin-top: 10px;
        }

        .progress-bar {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 14px;
        }

        .status-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
        }

        .status-badge.connected {
            background: #d4edda;
            color: #155724;
        }

        .status-badge.disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #1565c0;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #856404;
            display: none;
        }

        .warning-box.active {
            display: block;
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }

            .file-controls {
                grid-template-columns: 1fr;
            }

            .action-buttons {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            .info-table td:first-child {
                width: 120px;
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>üîß ESP Firmware Update Tool</h1>
    <p class="subtitle">Webov√© rozhran√≠ pro nahr√°v√°n√≠ firmware do ESP za≈ô√≠zen√≠</p>

    <div class="info-box">
        ‚ÑπÔ∏è P≈ôipojte ESP za≈ô√≠zen√≠ p≈ôes USB a kliknƒõte na "P≈ôipojit ESP". Vyberte verzi firmware nebo nahrajte vlastn√≠
        soubory.
    </div>

    <div class="warning-box" id="bootModeWarning">
        ‚ö†Ô∏è ESP nen√≠ v bootloader m√≥du! P≈ôed nahr√°v√°n√≠m firmware kliknƒõte na "P≈ôej√≠t do Boot M√≥du".
    </div>

    <!-- Connection Section -->
    <div class="connection-section">
        <h3 style="margin-bottom: 15px;">P≈ôipojen√≠ k za≈ô√≠zen√≠
            <span class="status-badge disconnected" id="statusBadge">Odpojeno</span>
            <span class="boot-mode-indicator unknown" id="bootModeBadge" style="display: none;">Nezn√°m√Ω m√≥d</span>
        </h3>
        <div class="form-group">
            <label for="baudRate">Baudrate:</label>
            <select id="baudRate">
                <option value="115200" selected>115200</option>
                <option value="230400">230400</option>
                <option value="460800">460800</option>
                <option value="921600">921600</option>
            </select>
        </div>
    </div>

    <!-- Chip Info Section -->
    <div class="chip-info-section" id="chipInfoSection">
        <h3>üìü Informace o ƒçipu</h3>
        <table class="info-table" id="chipInfoTable">
            <tr>
                <td>Typ ƒçipu</td>
                <td id="infoChipType">-</td>
            </tr>
            <tr>
                <td>Funkce</td>
                <td id="infoFeatures">-</td>
            </tr>
            <tr>
                <td>Krystal</td>
                <td id="infoCrystal">-</td>
            </tr>
            <tr>
                <td>MAC adresa</td>
                <td id="infoMac">-</td>
            </tr>
            <tr>
                <td>Flash velikost</td>
                <td id="infoFlashSize">-</td>
            </tr>
            <tr>
                <td>V√Ωrobce</td>
                <td id="infoManufacturer">-</td>
            </tr>
            <tr>
                <td>Device ID</td>
                <td id="infoDevice">-</td>
            </tr>
            <tr>
                <td>Vendor ID</td>
                <td id="infoVendorId">-</td>
            </tr>
            <tr>
                <td>Product ID</td>
                <td id="infoProductId">-</td>
            </tr>
        </table>
    </div>

    <!-- File Upload Section -->
    <div class="file-section">
        <h3 style="margin-bottom: 15px;">Soubory firmware</h3>

        <!-- Version Selector -->
        <div class="version-selector">
            <div id="versionSelectWrapper">
                <h4>üì¶ V√Ωbƒõr verze firmware</h4>
                <div class="form-group">
                    <label for="versionSelect">Verze:</label>
                    <select id="versionSelect" onchange="handleVersionChange()">
                    </select>
                </div>
            </div>

            <!-- Custom file actions -->
            <div class="custom-file-actions" id="customFileActions">
                <button class="btn btn-secondary btn-small" onclick="selectFolder()">
                    üìÅ Vybrat slo≈æku
                </button>
                <button class="btn btn-secondary btn-small" onclick="clearAllFiles()">
                    üóëÔ∏è Vymazat v≈°e
                </button>
            </div>
        </div>

        <!-- File 1 -->
        <div class="file-item" id="fileItem1">
            <div class="file-header">
                <input type="checkbox" id="fileEnable1" onchange="toggleFileItem(1)">
                <label for="fileEnable1">Soubor 1 (Bootloader / Merged)</label>
                <span class="validation-badge" id="validationBadge1"></span>
            </div>
            <div class="file-controls" id="fileControls1" style="display: none;">
                <div class="form-group">
                    <label for="file1">Vybrat soubor:</label>
                    <input type="file" id="file1" accept=".bin" onchange="validateFile(1)">
                </div>
                <div class="form-group">
                    <label for="address1">Adresa (hex):</label>
                    <input type="text" id="address1" placeholder="0x0000" value="0x0000">
                </div>
            </div>
            <div class="file-info" id="fileInfo1"></div>
        </div>

        <!-- File 2 -->
        <div class="file-item" id="fileItem2">
            <div class="file-header">
                <input type="checkbox" id="fileEnable2" onchange="toggleFileItem(2)">
                <label for="fileEnable2">Soubor 2 (Partitions)</label>
                <span class="validation-badge" id="validationBadge2"></span>
            </div>
            <div class="file-controls" id="fileControls2" style="display: none;">
                <div class="form-group">
                    <label for="file2">Vybrat soubor:</label>
                    <input type="file" id="file2" accept=".bin" onchange="validateFile(2)">
                </div>
                <div class="form-group">
                    <label for="address2">Adresa (hex):</label>
                    <input type="text" id="address2" placeholder="0x8000" value="0x8000">
                </div>
            </div>
            <div class="file-info" id="fileInfo2"></div>
        </div>

        <!-- File 3 -->
        <div class="file-item" id="fileItem3">
            <div class="file-header">
                <input type="checkbox" id="fileEnable3" onchange="toggleFileItem(3)">
                <label for="fileEnable3">Soubor 3 (Application)</label>
                <span class="validation-badge" id="validationBadge3"></span>
            </div>
            <div class="file-controls" id="fileControls3" style="display: none;">
                <div class="form-group">
                    <label for="file3">Vybrat soubor:</label>
                    <input type="file" id="file3" accept=".bin" onchange="validateFile(3)">
                </div>
                <div class="form-group">
                    <label for="address3">Adresa (hex):</label>
                    <input type="text" id="address3" placeholder="0x10000" value="0x10000">
                </div>
            </div>
            <div class="file-info" id="fileInfo3"></div>
        </div>
    </div>

    <!-- Progress Section -->
    <div class="progress-section" id="progressSection">
        <h3 style="margin-bottom: 10px;">Pr≈Øbƒõh nahr√°v√°n√≠</h3>
        <div class="progress-bar-container">
            <div class="progress-bar" id="progressBar">0%</div>
        </div>
    </div>

    <!-- Action Buttons -->
    <div class="action-buttons">
        <button class="btn btn-primary" id="connectBtn" onclick="connectESP()">
            üì° P≈ôipojit ESP
        </button>
        <button class="btn btn-warning" id="bootModeBtn" onclick="enterBootMode()" disabled>
            ‚ö° P≈ôej√≠t do Boot M√≥du
        </button>
        <button class="btn btn-success" id="flashBtn" onclick="flashFirmware()" disabled>
            üíæ Nahr√°t Firmware
        </button>
        <button class="btn btn-danger" id="resetBtn" onclick="hardReset()" disabled>
            üîÑ Hard Reset
        </button>
        <button class="btn btn-secondary" id="disconnectBtn" onclick="disconnect()" disabled>
            ‚ùå Odpojit
        </button>
        <button class="btn btn-secondary" onclick="clearLog()">
            üóëÔ∏è Vymazat Log
        </button>
    </div>

    <!-- Log Section -->
    <div class="log-section">
        <h3 style="margin-bottom: 10px;">Log konzole</h3>
        <div class="log-container" id="logContainer">
            <div class="log-entry info">P≈ôipraveno k p≈ôipojen√≠ ESP za≈ô√≠zen√≠...</div>
        </div>
    </div>
</div>

<!-- Hidden file input for folder selection -->
<input type="file" id="folderInput" webkitdirectory directory multiple style="display: none;"
       onchange="handleFolderSelect()">

<!-- Import maps for better module support -->
<script type="importmap">
    {
      "imports": {
        "buffer": "https://cdn.jsdelivr.net/npm/buffer@6.0.3/+esm",
        "esptool": "https://unpkg.com/esptool-js@0.4.0/bundle.js"
      }
    }
</script>

<!-- ESPTool.js Library as Module -->
<script type="module">
    import {Buffer} from 'buffer';
    import {ESPLoader, Transport} from 'esptool';

    // Make Buffer globally available
    window.Buffer = Buffer;

    let esploader;
    let transport;
    let chip = null;
    let connected = false;
    let inBootMode = false;
    let chipInfo = {};
    let serialPort = null;
    let manifestData = null;
    let currentMode = 'custom'; // 'custom' or 'manifest'

    // File validation state
    const fileValidation = {
        1: {valid: false, info: null},
        2: {valid: false, info: null},
        3: {valid: false, info: null}
    };

    // Make functions globally accessible
    window.toggleFileItem = toggleFileItem;
    window.validateFile = validateFile;
    window.handleVersionChange = handleVersionChange;
    window.selectFolder = selectFolder;
    window.handleFolderSelect = handleFolderSelect;
    window.clearAllFiles = clearAllFiles;
    window.connectESP = connectESP;
    window.enterBootMode = enterBootMode;
    window.flashFirmware = flashFirmware;
    window.hardReset = hardReset;
    window.disconnect = disconnect;
    window.clearLog = clearLog;

    // Load manifest on startup
    loadManifest();

    // Load manifest.json
    async function loadManifest() {
        try {
            const response = await fetch('./firmwareFiles/manifest.json');
            if (!response.ok) {
                throw new Error('Manifest not found');
            }
            manifestData = await response.json();
            addLog('‚úÖ Manifest naƒçten √∫spƒõ≈°nƒõ', 'success');
        } catch (error) {
            addLog('‚ö†Ô∏è Manifest nenalezen, pou≈æ√≠v√°m pouze Custom m√≥d', 'warning');
            console.warn('Manifest load error:', error);
        } finally {
            populateVersionSelector();
        }
    }

    // Populate version selector
    // Populate version selector
    function populateVersionSelector() {
        const versionSelect = document.getElementById('versionSelect');

        const createDivider = () => {
            const divider = document.createElement('option');
            divider.disabled = true;
            divider.textContent = '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ';
            return divider;
        };

        if (manifestData) {
            // Add set versions first
            if (manifestData.set && Array.isArray(manifestData.set)) {
                manifestData.set.forEach((item, index) => {
                    const option = document.createElement('option');
                    option.value = `set_${index}`; // Use index instead of version
                    option.textContent = `${item.label} (${item.version})`;
                    option.dataset.version = item.version; // Store version in data attribute
                    versionSelect.appendChild(option);
                });
            }

            // Add divider
            if (manifestData.builds && Array.isArray(manifestData.builds)) {
                versionSelect.appendChild(createDivider());

                // Add all builds
                manifestData.builds.forEach((build, index) => {
                    const option = document.createElement('option');
                    option.value = `build_${index}`; // Use index instead of version
                    option.textContent = `${build.name} (${build.version})`;
                    option.dataset.version = build.version; // Store version in data attribute
                    versionSelect.appendChild(option);
                });

                versionSelect.appendChild(createDivider());
            }
        } else {
            // No manifest, only custom option
            document.getElementById('versionSelectWrapper').style.display = 'none';
        }

        // Add custom option
        const customOption = document.createElement('option');
        customOption.value = 'custom';
        customOption.textContent = 'Custom (vlastn√≠ soubory)';
        versionSelect.appendChild(customOption);

        // Set default selection
        setDefaultVersion();
    }

    // Set default version
    function setDefaultVersion() {
        if (!manifestData || !manifestData.set) return;

        const versionSelect = document.getElementById('versionSelect');
        let defaultIndex = -1;

        // Priority: default > current > last > first
        const defaultItem = manifestData.set.findIndex(item => item.label.toLowerCase() === 'default');
        const currentItem = manifestData.set.findIndex(item => item.label.toLowerCase() === 'current');
        const lastItem = manifestData.set.findIndex(item => item.label.toLowerCase() === 'last');

        if (defaultItem !== -1) {
            defaultIndex = defaultItem;
        } else if (currentItem !== -1) {
            defaultIndex = currentItem;
        } else if (lastItem !== -1) {
            defaultIndex = lastItem;
        } else if (manifestData.set.length > 0) {
            defaultIndex = 0;
        }

        if (defaultIndex !== -1) {
            versionSelect.value = `set_${defaultIndex}`;
            handleVersionChange();
        }
    }

    // Handle version change
    async function handleVersionChange() {
        const versionSelect = document.getElementById('versionSelect');
        const selectedValue = versionSelect.value;
        const customFileActions = document.getElementById('customFileActions');

        // Clear current files
        clearAllFiles();

        if (selectedValue === 'custom') {
            // Custom mode
            currentMode = 'custom';
            customFileActions.classList.remove('hidden');
            showFileItems(true);
            addLog('üìù P≈ôepnuto na Custom m√≥d', 'info');
        } else {
            // Manifest mode
            currentMode = 'manifest';
            customFileActions.classList.add('hidden');

            const [type, indexStr] = selectedValue.split('_');
            const index = parseInt(indexStr);
            let buildData = null;

            if (type === 'set') {
                // Find build by version from set
                const setItem = manifestData.set[index];
                if (setItem) {
                    buildData = manifestData.builds.find(build => build.version === setItem.version);
                }
            } else if (type === 'build') {
                // Direct build selection by index
                buildData = manifestData.builds[index];
            }

            if (buildData) {
                addLog(`üì¶ Naƒç√≠t√°m verzi: ${buildData.name} (${buildData.version})`, 'info');
                await loadBuildFiles(buildData);
            } else {
                addLog('‚ùå Verze nenalezena v manifestu', 'error');
            }
        }
    }

    // Load build files from manifest
    async function loadBuildFiles(buildData) {
        if (!buildData.parts || !Array.isArray(buildData.parts)) {
            addLog('‚ùå Neplatn√° struktura build dat', 'error');
            return;
        }

        showFileItems(false);

        for (let i = 0; i < buildData.parts.length && i < 3; i++) {
            const part = buildData.parts[i];
            const fileIndex = i + 1;

            try {
                // Fetch file from server
                const response = await fetch(`./firmwareFiles/${part.path}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const blob = await response.blob();
                const fileName = part.path.split('/').pop();
                const file = new File([blob], fileName, {type: 'application/octet-stream'});

                // Create a fake file input
                const fileInput = document.getElementById(`file${fileIndex}`);
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                fileInput.files = dataTransfer.files;

                // Set address
                const addressInput = document.getElementById(`address${fileIndex}`);
                addressInput.value = `0x${part.offset.toString(16).toUpperCase()}`;

                // Enable and show
                const checkbox = document.getElementById(`fileEnable${fileIndex}`);
                checkbox.checked = true;
                toggleFileItem(fileIndex);

                // Validate
                await validateFile(fileIndex);

                addLog(`‚úÖ Soubor ${fileIndex} naƒçten: ${fileName}`, 'success');

            } catch (error) {
                addLog(`‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ souboru ${fileIndex}: ${error.message}`, 'error');
            }
        }
    }

    // Show/hide file items
    function showFileItems(show) {
        for (let i = 1; i <= 3; i++) {
            const fileItem = document.getElementById(`fileItem${i}`);
            if (show) {
                fileItem.classList.remove('hidden');
            } else {
                fileItem.classList.add('hidden');
            }
        }
    }

    // Select folder
    function selectFolder() {
        document.getElementById('folderInput').click();
    }

    // Handle folder selection
    async function handleFolderSelect() {
        const folderInput = document.getElementById('folderInput');
        const files = Array.from(folderInput.files);

        if (files.length === 0) {
            addLog('‚ö†Ô∏è Nebyla vybr√°na ≈æ√°dn√° slo≈æka', 'warning');
            return;
        }

        addLog(`üìÅ Naƒç√≠t√°m soubory ze slo≈æky (${files.length} soubor≈Ø)...`, 'info');

        // Clear current files
        clearAllFiles();

        // Check for merged file first
        const mergedFile = files.find(f => f.name.includes('.merged.bin'));

        if (mergedFile) {
            addLog('üì¶ Detekov√°n merged firmware, ostatn√≠ soubory budou ignorov√°ny', 'info');
            await loadFileToSlot(mergedFile, 1, 0x0000);
            return;
        }

        // Load individual files
        const bootloaderFile = files.find(f => f.name.endsWith('.bootloader.bin'));
        const partitionsFile = files.find(f => f.name.endsWith('.partitions.bin'));
        const appFile = files.find(f => f.name.endsWith('.ino.bin') && !f.name.includes('bootloader') && !f.name.includes('partitions'));

        if (bootloaderFile) await loadFileToSlot(bootloaderFile, 1, 0x0000);
        if (partitionsFile) await loadFileToSlot(partitionsFile, 2, 0x8000);
        if (appFile) await loadFileToSlot(appFile, 3, 0x10000);

        if (!bootloaderFile && !partitionsFile && !appFile) {
            addLog('‚ö†Ô∏è Ve slo≈æce nebyly nalezeny platn√© firmware soubory', 'warning');
        }
    }

    // Load file to specific slot
    async function loadFileToSlot(file, slot, address) {
        try {
            const fileInput = document.getElementById(`file${slot}`);
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            fileInput.files = dataTransfer.files;

            const addressInput = document.getElementById(`address${slot}`);
            addressInput.value = `0x${address.toString(16).toUpperCase()}`;

            const checkbox = document.getElementById(`fileEnable${slot}`);
            checkbox.checked = true;
            toggleFileItem(slot);

            await validateFile(slot);

            addLog(`‚úÖ Soubor ${slot} naƒçten: ${file.name}`, 'success');
        } catch (error) {
            addLog(`‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ souboru ${slot}: ${error.message}`, 'error');
        }
    }

    // Clear all files
    function clearAllFiles() {
        for (let i = 1; i <= 3; i++) {
            const fileInput = document.getElementById(`file${i}`);
            fileInput.value = '';

            const checkbox = document.getElementById(`fileEnable${i}`);
            checkbox.checked = false;

            const fileItem = document.getElementById(`fileItem${i}`);
            fileItem.classList.remove('valid', 'invalid', 'ignored', 'active');

            const controls = document.getElementById(`fileControls${i}`);
            controls.style.display = 'none';

            const validationBadge = document.getElementById(`validationBadge${i}`);
            validationBadge.classList.remove('show');

            const fileInfo = document.getElementById(`fileInfo${i}`);
            fileInfo.classList.remove('show');

            fileValidation[i] = {valid: false, info: null};
        }

        addLog('üóëÔ∏è V≈°echny soubory vymaz√°ny', 'info');
    }

    // Helper function to convert Uint8Array to binary string
    function uint8ArrayToBinaryString(uint8Array) {
        let binaryString = '';
        const len = uint8Array.byteLength;
        for (let i = 0; i < len; i++) {
            binaryString += String.fromCharCode(uint8Array[i]);
        }
        return binaryString;
    }

    // Format file size
    function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    }

    // Check if file 1 is merged firmware
    function isMergedFirmware() {
        const fileInput = document.getElementById('file1');
        if (!fileInput.files[0]) return false;
        return fileInput.files[0].name.includes('.merged.bin');
    }

    // Update ignored state for files 2 and 3
    function updateIgnoredState() {
        const hasMerged = isMergedFirmware() && document.getElementById('fileEnable1').checked;

        for (let i = 2; i <= 3; i++) {
            const fileItem = document.getElementById(`fileItem${i}`);
            const validationBadge = document.getElementById(`validationBadge${i}`);
            const checkbox = document.getElementById(`fileEnable${i}`);

            if (hasMerged && checkbox.checked) {
                fileItem.classList.add('ignored');
                fileItem.classList.remove('valid', 'invalid');
                validationBadge.classList.add('show', 'ignored');
                validationBadge.classList.remove('valid', 'invalid');
                validationBadge.textContent = '‚äò Ignorov√°no';
            } else {
                fileItem.classList.remove('ignored');
            }
        }
    }

    // Validate file function
    async function validateFile(index) {
        const fileInput = document.getElementById(`file${index}`);
        const file = fileInput.files[0];
        const fileItem = document.getElementById(`fileItem${index}`);
        const validationBadge = document.getElementById(`validationBadge${index}`);
        const fileInfo = document.getElementById(`fileInfo${index}`);

        if (!file) {
            fileValidation[index] = {valid: false, info: null};
            fileItem.classList.remove('valid', 'invalid', 'ignored');
            validationBadge.classList.remove('show');
            fileInfo.classList.remove('show');
            return;
        }

        addLog(`üîç Validuji soubor ${index}: ${file.name}`, 'info');

        const validationResult = {
            fileName: file.name,
            fileSize: file.size,
            formattedSize: formatFileSize(file.size),
            lastModified: new Date(file.lastModified).toLocaleString('cs-CZ'),
            hasCorrectExtension: file.name.endsWith('.bin'),
            isSizeValid: file.size >= 512 && file.size <= 16 * 1024 * 1024,
            magicByte: null,
            segments: null,
            expectedExtension: null,
            hasExpectedExtension: false,
            isMerged: file.name.includes('.merged.bin')
        };

        // Check file extension
        if (!validationResult.hasCorrectExtension) {
            addLog(`‚ùå Soubor ${index} nem√° p≈ô√≠ponu .bin`, 'error');
            showValidationResult(index, validationResult, false);
            updateIgnoredState();
            return;
        }

        // Check file size
        if (!validationResult.isSizeValid) {
            addLog(`‚ùå Soubor ${index} m√° neplatnou velikost (${validationResult.formattedSize})`, 'error');
            showValidationResult(index, validationResult, false);
            updateIgnoredState();
            return;
        }

        // Read first 8 bytes to check magic byte and segments
        try {
            const reader = new FileReader();
            reader.onload = async (e) => {
                const buffer = new Uint8Array(e.target.result);

                // Check ESP magic byte (0xE9 for firmware, 0xAA for partitions)
                validationResult.magicByte = `0x${buffer[0].toString(16).toUpperCase().padStart(2, '0')}`;

                let hasValidMagic = false;

                // For file 2 (partitions), accept 0xAA or 0xE9
                if (index === 2) {
                    hasValidMagic = buffer[0] === 0xAA || buffer[0] === 0xE9;
                } else {
                    // For other files, require 0xE9
                    hasValidMagic = buffer[0] === 0xE9;
                }

                // Get segment count (byte at position 1)
                if (buffer.length > 1) {
                    validationResult.segments = buffer[1];
                }

                // Count enabled files
                const enabledFiles = [1, 2, 3].filter(i => document.getElementById(`fileEnable${i}`).checked).length;

                // Determine expected extension based on file position and count
                if (enabledFiles === 1 && index === 1) {
                    // Only one file - must be merged
                    validationResult.expectedExtension = '.ino.merged.bin';
                    validationResult.hasExpectedExtension = validationResult.isMerged;
                } else {
                    // Multiple files
                    if (index === 1) {
                        if (validationResult.isMerged) {
                            validationResult.expectedExtension = '.ino.merged.bin (ostatn√≠ soubory budou ignorov√°ny)';
                            validationResult.hasExpectedExtension = true;
                        } else {
                            validationResult.expectedExtension = '.ino.bootloader.bin';
                            validationResult.hasExpectedExtension = file.name.endsWith('.ino.bootloader.bin');
                        }
                    } else if (index === 2) {
                        validationResult.expectedExtension = '.ino.partitions.bin';
                        validationResult.hasExpectedExtension = file.name.endsWith('.ino.partitions.bin');
                    } else if (index === 3) {
                        validationResult.expectedExtension = '.ino.bin';
                        validationResult.hasExpectedExtension = file.name.endsWith('.ino.bin');
                    }
                }

                // Final validation
                const isValid = hasValidMagic && validationResult.isSizeValid;

                // Check extension match
                if (isValid && !validationResult.hasExpectedExtension && validationResult.expectedExtension) {
                    addLog(`‚ö†Ô∏è Soubor ${index} nem√° oƒçek√°vanou p≈ô√≠ponu (${validationResult.expectedExtension})`, 'warning');
                } else if (isValid && hasValidMagic) {
                    addLog(`‚úÖ Soubor ${index} je platn√Ω ESP firmware`, 'success');
                    if (validationResult.isMerged && index === 1) {
                        addLog(`‚ÑπÔ∏è Detekov√°n merged firmware - ostatn√≠ soubory budou ignorov√°ny`, 'info');
                    }
                } else if (!hasValidMagic) {
                    const expectedMagic = index === 2 ? '0xE9 nebo 0xAA' : '0xE9';
                    addLog(`‚ùå Soubor ${index} nem√° platn√Ω ESP magic byte (${expectedMagic})`, 'error');
                }

                showValidationResult(index, validationResult, isValid);

                // Only update ignored state if this is file 1
                if (index === 1) {
                    updateIgnoredState();
                }
            };

            reader.readAsArrayBuffer(file.slice(0, 8));

        } catch (error) {
            addLog(`‚ùå Chyba p≈ôi validaci souboru ${index}: ${error.message}`, 'error');
            showValidationResult(index, validationResult, false);
        }
    }

    // Show validation result
    function showValidationResult(index, result, isValid) {
        const fileItem = document.getElementById(`fileItem${index}`);
        const validationBadge = document.getElementById(`validationBadge${index}`);
        const fileInfo = document.getElementById(`fileInfo${index}`);

        fileValidation[index] = {valid: isValid, info: result};

        // Update visual feedback
        fileItem.classList.remove('valid', 'invalid');
        fileItem.classList.add(isValid ? 'valid' : 'invalid');

        validationBadge.classList.add('show');
        validationBadge.classList.remove('valid', 'invalid');
        validationBadge.classList.add(isValid ? 'valid' : 'invalid');
        validationBadge.textContent = isValid ? '‚úÖ Platn√Ω' : '‚ùå Neplatn√Ω';

        // Show file info
        let infoHTML = '<div class="file-info-row"><div class="file-info-label">N√°zev:</div><div class="file-info-value">' + result.fileName + '</div></div>';
        infoHTML += '<div class="file-info-row"><div class="file-info-label">Velikost:</div><div class="file-info-value">' + result.formattedSize + '</div></div>';
        infoHTML += '<div class="file-info-row"><div class="file-info-label">Upraveno:</div><div class="file-info-value">' + result.lastModified + '</div></div>';

        if (result.magicByte) {
            const expectedMagic = index === 2 ? '(0xE9 nebo 0xAA)' : '(0xE9)';
            const magicValid = index === 2 ? (result.magicByte === '0xE9' || result.magicByte === '0xAA') : result.magicByte === '0xE9';
            infoHTML += '<div class="file-info-row"><div class="file-info-label">Magic Byte:</div><div class="file-info-value">' + result.magicByte + ' ' + expectedMagic + (magicValid ? ' ‚úÖ' : ' ‚ùå') + '</div></div>';
        }

        if (result.segments !== null) {
            infoHTML += '<div class="file-info-row"><div class="file-info-label">Segmenty:</div><div class="file-info-value">' + result.segments + '</div></div>';
        }

        if (result.expectedExtension) {
            infoHTML += '<div class="file-info-row"><div class="file-info-label">Oƒçek√°van√° p≈ô√≠pona:</div><div class="file-info-value">' + result.expectedExtension + (result.hasExpectedExtension ? ' ‚úÖ' : ' ‚ùå') + '</div></div>';
        }

        fileInfo.innerHTML = infoHTML;
        fileInfo.classList.add('show');
    }

    // Update boot mode status
    function updateBootModeStatus(isInBootMode) {
        inBootMode = isInBootMode;
        const bootModeBadge = document.getElementById('bootModeBadge');
        const bootModeWarning = document.getElementById('bootModeWarning');
        const bootModeBtn = document.getElementById('bootModeBtn');

        if (connected) {
            bootModeBadge.style.display = 'inline-block';

            if (isInBootMode) {
                bootModeBadge.textContent = 'Boot m√≥d';
                bootModeBadge.className = 'boot-mode-indicator boot';
                bootModeWarning.classList.remove('active');
                bootModeBtn.disabled = true;
            } else {
                bootModeBadge.textContent = 'Norm√°ln√≠ m√≥d';
                bootModeBadge.className = 'boot-mode-indicator normal';
                bootModeWarning.classList.add('active');
                bootModeBtn.disabled = false;
            }
        } else {
            bootModeBadge.style.display = 'none';
            bootModeWarning.classList.remove('active');
        }
    }

    // Update chip info table
    function updateChipInfo() {
        document.getElementById('infoChipType').textContent = chipInfo.chipType || '-';
        document.getElementById('infoFeatures').textContent = chipInfo.features || '-';
        document.getElementById('infoCrystal').textContent = chipInfo.crystal || '-';
        document.getElementById('infoMac').textContent = chipInfo.mac || '-';
        document.getElementById('infoFlashSize').textContent = chipInfo.flashSize || '-';
        document.getElementById('infoManufacturer').textContent = chipInfo.manufacturer || '-';
        document.getElementById('infoDevice').textContent = chipInfo.device || '-';
        document.getElementById('infoVendorId').textContent = chipInfo.vendorId || '-';
        document.getElementById('infoProductId').textContent = chipInfo.productId || '-';

        document.getElementById('chipInfoSection').classList.add('active');
    }

    // Clear chip info
    function clearChipInfo() {
        chipInfo = {};
        document.getElementById('chipInfoSection').classList.remove('active');
    }

    // Toggle file item visibility
    function toggleFileItem(index) {
        const checkbox = document.getElementById(`fileEnable${index}`);
        const controls = document.getElementById(`fileControls${index}`);
        const item = document.getElementById(`fileItem${index}`);

        if (checkbox.checked) {
            controls.style.display = 'grid';
            item.classList.add('active');
        } else {
            controls.style.display = 'none';
            item.classList.remove('active', 'ignored');
        }

        // Update ignored state when toggling checkboxes
        updateIgnoredState();
    }

    // Logging function
    function addLog(message, type = 'info') {
        const logContainer = document.getElementById('logContainer');
        const timestamp = new Date().toLocaleTimeString('cs-CZ');
        const logEntry = document.createElement('div');
        logEntry.className = `log-entry ${type}`;
        logEntry.textContent = `[${timestamp}] ${message}`;
        logContainer.appendChild(logEntry);
        logContainer.scrollTop = logContainer.scrollHeight;
    }

    function clearLog() {
        const logContainer = document.getElementById('logContainer');
        logContainer.innerHTML = '<div class="log-entry info">Log vymaz√°n...</div>';
    }

    // Update progress bar
    function updateProgress(percentage, state = "") {
        if (!(typeof percentage === 'number' && !isNaN(percentage))) return;
        const isString = typeof state === 'string' && state.length > 0;
        const progressSection = document.getElementById('progressSection');
        const progressBar = document.getElementById('progressBar');
        progressSection.classList.add('active');
        progressBar.style.width = percentage + '%';
        progressBar.textContent = isString ? state : Math.round(percentage) + '%';
    }

    // Enter boot mode - reuses existing connection
    async function enterBootMode() {
        if (!connected || !serialPort) {
            addLog('‚ùå ESP nen√≠ p≈ôipojeno!', 'error');
            return;
        }

        try {
            addLog('‚ö° P≈ôep√≠n√°m do boot m√≥du...', 'info');

            // Close existing transport
            if (transport) {
                await transport.disconnect();
                await transport.waitForUnlock(500);
            }

            // Reuse the same serial port
            transport = new Transport(serialPort, true);

            const baudRate = parseInt(document.getElementById('baudRate').value);

            // Create new ESPLoader instance
            const loaderOptions = {
                transport: transport,
                baudrate: baudRate,
                terminal: {
                    clean: () => {
                    },
                    writeLine: (data) => {
                        addLog(data, 'info');
                        parseChipInfoFromLog(data);
                    },
                    write: (data) => {
                    }
                }
            };

            esploader = new ESPLoader(loaderOptions);

            // Connect to chip - this will put it in boot mode
            chip = await esploader.main();

            addLog('‚úÖ ESP je nyn√≠ v boot m√≥du!', 'success');
            updateBootModeStatus(true);

        } catch (error) {
            addLog(`‚ùå Chyba p≈ôi p≈ôep√≠n√°n√≠ do boot m√≥du: ${error.message}`, 'error');
            console.error(error);
        }
    }

    // Connect to ESP
    async function connectESP() {
        try {
            addLog('Po≈æadavek na p≈ôipojen√≠ k ESP za≈ô√≠zen√≠...', 'info');

            const baudRate = parseInt(document.getElementById('baudRate').value);

            // Request serial port
            serialPort = await navigator.serial.requestPort();

            // Get USB info
            const portInfo = serialPort.getInfo();
            chipInfo.vendorId = `0x${portInfo.usbVendorId?.toString(16).padStart(4, '0')}` || '-';
            chipInfo.productId = `0x${portInfo.usbProductId?.toString(16).padStart(4, '0')}` || '-';

            transport = new Transport(serialPort, true);

            addLog(`Otev√≠r√°m s√©riov√Ω port s baudrate ${baudRate}...`, 'info');

            // Create ESPLoader instance
            const loaderOptions = {
                transport: transport,
                baudrate: baudRate,
                terminal: {
                    clean: () => {
                    },
                    writeLine: (data) => {
                        addLog(data, 'info');
                        parseChipInfoFromLog(data);
                    },
                    write: (data) => {
                    }
                }
            };

            esploader = new ESPLoader(loaderOptions);

            // Connect to chip
            chip = await esploader.main();

            chipInfo.chipType = chip;
            addLog(`‚úÖ P≈ôipojeno k ${chip}!`, 'success');

            // Check if in boot mode - if main() succeeded, we're in boot mode
            updateBootModeStatus(true);

            // Try to get chip info
            try {
                const chipName = await esploader.chipName();
                chipInfo.chipType = chipName;
                addLog(`Chip: ${chipName}`, 'info');
            } catch (e) {
                addLog(`Chip: ${chip}`, 'info');
            }

            // Get MAC address
            try {
                const macAddr = await esploader.readMac();
                chipInfo.mac = macAddr;
                addLog(`MAC adresa: ${macAddr}`, 'info');
            } catch (e) {
                // MAC reading might not be supported on all chips
            }

            // Get flash size
            try {
                const flashSize = await esploader.getFlashSize();
                if (flashSize) {
                    chipInfo.flashSize = flashSize;
                    addLog(`Flash velikost: ${flashSize}`, 'info');
                }
            } catch (e) {
                // Flash size reading might not work
            }

            // Try to detect flash chip
            try {
                await esploader.flashDetect();
            } catch (e) {
                // Flash detection might fail, but info is in logs
            }

            connected = true;
            updateConnectionStatus(true);
            updateChipInfo();

        } catch (error) {
            addLog(`‚ùå Chyba p≈ôipojen√≠: ${error.message}`, 'error');
            console.error(error);
            connected = false;
            serialPort = null;
            updateConnectionStatus(false);
            updateBootModeStatus(false);
        }
    }

    // Parse chip info from log messages
    function parseChipInfoFromLog(message) {
        if (message.includes('Features:')) {
            chipInfo.features = message.split('Features:')[1].trim();
        }
        if (message.includes('Crystal is')) {
            chipInfo.crystal = message.split('Crystal is')[1].trim();
        }
        if (message.includes('MAC:')) {
            chipInfo.mac = message.split('MAC:')[1].trim();
        }
        if (message.includes('Manufacturer:')) {
            const match = message.match(/Manufacturer:\s*([0-9a-fA-Fx]+)/);
            if (match) chipInfo.manufacturer = match[1];
        }
        if (message.includes('Device:')) {
            const match = message.match(/Device:\s*([0-9a-fA-Fx]+)/);
            if (match) chipInfo.device = match[1];
        }
        if (message.includes('Detected flash size:')) {
            chipInfo.flashSize = message.split('Detected flash size:')[1].trim();
        }
        if (message.includes('VendorID')) {
            const match = message.match(/VendorID\s+(0x[0-9a-fA-F]+)/);
            if (match) chipInfo.vendorId = match[1];
        }
        if (message.includes('ProductID')) {
            const match = message.match(/ProductID\s+(0x[0-9a-fA-F]+)/);
            if (match) chipInfo.productId = match[1];
        }

        // Update table in real-time
        if (connected) {
            updateChipInfo();
        }
    }

    // Flash firmware
    async function flashFirmware() {
        if (!connected) {
            addLog('‚ùå ESP nen√≠ p≈ôipojeno!', 'error');
            return;
        }

        // Check if in boot mode before flashing
        if (!inBootMode) {
            addLog('‚ö†Ô∏è ESP nen√≠ v boot m√≥du! P≈ôep√≠n√°m do boot m√≥du...', 'warning');
            await enterBootMode();
            await new Promise(resolve => setTimeout(resolve, 1000));

            if (!inBootMode) {
                addLog('‚ùå Nepoda≈ôilo se p≈ôej√≠t do boot m√≥du!', 'error');
                return;
            }
        }

        try {
            // Check if file 1 is merged firmware
            const hasMergedFirmware = isMergedFirmware() && document.getElementById('fileEnable1').checked;

            // Collect enabled files and validate
            const fileArray = [];
            let hasInvalidFiles = false;
            let hasWarnings = false;
            const warnings = [];

            for (let i = 1; i <= 3; i++) {
                const checkbox = document.getElementById(`fileEnable${i}`);
                if (checkbox.checked) {
                    // Skip files 2 and 3 if file 1 is merged
                    if (hasMergedFirmware && i > 1) {
                        addLog(`‚ÑπÔ∏è Soubor ${i} ignorov√°n (merged firmware detekov√°n)`, 'info');
                        continue;
                    }

                    const fileInput = document.getElementById(`file${i}`);
                    const addressInput = document.getElementById(`address${i}`);

                    if (!fileInput.files[0]) {
                        addLog(`‚ö†Ô∏è Soubor ${i} nen√≠ vybr√°n!`, 'warning');
                        return;
                    }

                    // Check validation
                    if (!fileValidation[i].valid) {
                        addLog(`‚ùå Soubor ${i} nen√≠ platn√Ω!`, 'error');
                        hasInvalidFiles = true;
                        continue;
                    }

                    // Check expected extension
                    const info = fileValidation[i].info;
                    if (!info.hasExpectedExtension && info.expectedExtension) {
                        hasWarnings = true;
                        warnings.push(`Soubor ${i} nem√° oƒçek√°vanou p≈ô√≠ponu (${info.expectedExtension})`);
                    }

                    const file = fileInput.files[0];
                    const address = addressInput.value;

                    // Convert hex address to decimal
                    const addressDec = parseInt(address, 16);

                    // Read file as array buffer
                    const fileData = await file.arrayBuffer();
                    const uint8Data = new Uint8Array(fileData);

                    // Convert to binary string (esptool-js expects this format)
                    const binaryString = uint8ArrayToBinaryString(uint8Data);

                    fileArray.push({
                        data: binaryString,
                        address: addressDec
                    });

                    addLog(`üìÅ P≈ôid√°n soubor: ${file.name} (${uint8Data.length} bajt≈Ø) na adresu ${address} (${addressDec})`, 'info');
                }
            }

            // Block if invalid files
            if (hasInvalidFiles) {
                addLog('‚ùå Nelze nahr√°t neplatn√© soubory!', 'error');
                return;
            }

            if (fileArray.length === 0) {
                addLog('‚ö†Ô∏è Nebyl vybr√°n ≈æ√°dn√Ω soubor!', 'warning');
                return;
            }

            // Show confirmation if there are warnings
            if (hasWarnings) {
                const warningMessage = 'Varov√°n√≠:\n' + warnings.join('\n') + '\n\nChcete p≈ôesto pokraƒçovat?';
                if (!confirm(warningMessage)) {
                    addLog('‚ö†Ô∏è Nahr√°v√°n√≠ zru≈°eno u≈æivatelem', 'warning');
                    return;
                }
            }
            if (hasMergedFirmware) {
                addLog(`üöÄ Zahajuji nahr√°v√°n√≠ merged firmware...`, 'info');
            } else {
                addLog(`üöÄ Zahajuji nahr√°v√°n√≠ ${fileArray.length} soubor(≈Ø)...`, 'info');
            }

            // Disable buttons during flashing
            setButtonsEnabled(false);
            updateProgress(0);

            // Flash options
            const flashOptions = {
                fileArray: fileArray,
                flashSize: 'keep',
                eraseAll: false,
                compress: true,
                reportProgress: (fileIndex, written, total) => {
                    const percentage = (written / total) * 100;
                    const state = percentage === 100 ? `Wrapping up, please wait...` : '';
                    updateProgress(percentage, state);
                }
            };

            addLog('üìù Maz√°n√≠ a p≈ô√≠prava flash pamƒõti...', 'info');

            // Write files to flash
            await esploader.writeFlash(flashOptions);

            addLog('üéâ Nahr√°v√°n√≠ dokonƒçeno √∫spƒõ≈°nƒõ!', 'success');
            updateProgress(100, 'Done!');

            await new Promise(resolve => setTimeout(resolve, 500));

        } catch (error) {
            addLog(`‚ùå Chyba p≈ôi nahr√°v√°n√≠: ${error.message}`, 'error');
            console.error(error);
        } finally {
            // Auto hard reset after flash
            addLog('üîÑ Automatick√Ω hard reset...', 'info');

            await esploader.hardReset();
            addLog('‚úÖ Hard reset proveden!', 'success');

            setButtonsEnabled(true);
        }
    }

    // Hard reset ESP
    async function hardReset() {
        if (!connected) {
            addLog('‚ùå ESP nen√≠ p≈ôipojeno!', 'error');
            return;
        }

        try {
            addLog('üîÑ Prov√°d√≠m hard reset ESP...', 'info');
            await esploader.hardReset();
            addLog('‚úÖ Hard reset proveden!', 'success');

            // After reset, device is no longer in boot mode
            updateBootModeStatus(false);
        } catch (error) {
            addLog(`‚ùå Chyba p≈ôi resetu: ${error.message}`, 'error');
            console.error(error);
        }
    }

    // Disconnect
    async function disconnect() {
        try {
            // Auto hard reset before disconnect
            if (connected && esploader) {
                try {
                    addLog('üîÑ Hard reset p≈ôed odpojen√≠m...', 'info');
                    await esploader.hardReset();
                    await new Promise(resolve => setTimeout(resolve, 500));
                } catch (e) {
                    addLog('‚ö†Ô∏è Hard reset se nezda≈ôil', 'warning');
                }
            }

            if (transport) {
                addLog('Odpojuji ESP...', 'info');
                await transport.disconnect();
                await transport.waitForUnlock(1500);
            }

            connected = false;
            serialPort = null;
            updateConnectionStatus(false);
            updateBootModeStatus(false);
            clearChipInfo();
            addLog('‚úÖ Odpojeno', 'success');

        } catch (error) {
            addLog(`‚ùå Chyba p≈ôi odpojov√°n√≠: ${error.message}`, 'error');
            console.error(error);
        }
    }

    // Update connection status
    function updateConnectionStatus(isConnected) {
        const statusBadge = document.getElementById('statusBadge');
        const connectBtn = document.getElementById('connectBtn');
        const flashBtn = document.getElementById('flashBtn');
        const resetBtn = document.getElementById('resetBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const bootModeBtn = document.getElementById('bootModeBtn');

        if (isConnected) {
            statusBadge.textContent = 'P≈ôipojeno';
            statusBadge.className = 'status-badge connected';
            connectBtn.disabled = true;
            flashBtn.disabled = false;
            resetBtn.disabled = false;
            disconnectBtn.disabled = false;
            bootModeBtn.disabled = inBootMode;
        } else {
            statusBadge.textContent = 'Odpojeno';
            statusBadge.className = 'status-badge disconnected';
            connectBtn.disabled = false;
            flashBtn.disabled = true;
            resetBtn.disabled = true;
            disconnectBtn.disabled = true;
            bootModeBtn.disabled = true;
        }
    }

    // Enable/disable buttons
    function setButtonsEnabled(enabled) {
        document.getElementById('flashBtn').disabled = !enabled;
        document.getElementById('resetBtn').disabled = !enabled;
        document.getElementById('connectBtn').disabled = !enabled;
        document.getElementById('bootModeBtn').disabled = !enabled || inBootMode;
    }

    // Check Web Serial API support
    if (!("serial" in navigator)) {
        addLog('‚ùå Web Serial API nen√≠ podporov√°no v tomto prohl√≠≈æeƒçi!', 'error');
        addLog('‚ÑπÔ∏è Pou≈æijte Chrome, Edge nebo Opera.', 'warning');
        document.getElementById('connectBtn').disabled = true;
    }
</script>
</body>
</html>